"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkchurchroad"] = self["webpackChunkchurchroad"] || []).push([["vendors-node_modules_yowasp_yosys_gen_resources-yosys_js"],{

/***/ "./node_modules/@yowasp/yosys/gen/share/ice40/cells_sim.v":
/*!****************************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/share/ice40/cells_sim.v ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"fc1568d0a72c3ba1154b.v\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/share/ice40/cells_sim.v?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/share/nexus/cells_xtra.v":
/*!*****************************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/share/nexus/cells_xtra.v ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"37bf908f560b789ee528.v\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/share/nexus/cells_xtra.v?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/share/quicklogic/qlf_k6n10f/bram_types_sim.v":
/*!*************************************************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/share/quicklogic/qlf_k6n10f/bram_types_sim.v ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"eebd31ec03d57f5190d5.v\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/share/quicklogic/qlf_k6n10f/bram_types_sim.v?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/share/quicklogic/qlf_k6n10f/brams_sim.v":
/*!********************************************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/share/quicklogic/qlf_k6n10f/brams_sim.v ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"54131eb187f34bef5774.v\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/share/quicklogic/qlf_k6n10f/brams_sim.v?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/share/xilinx/cells_sim.v":
/*!*****************************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/share/xilinx/cells_sim.v ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"f6e940a9c14925bfa503.v\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/share/xilinx/cells_sim.v?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/share/xilinx/cells_xtra.v":
/*!******************************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/share/xilinx/cells_xtra.v ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"b16e683fb4ef9cafc9e2.v\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/share/xilinx/cells_xtra.v?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/yosys.core.wasm":
/*!********************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/yosys.core.wasm ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"81568c75f331310d69e7.wasm\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/yosys.core.wasm?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/yosys.core2.wasm":
/*!*********************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/yosys.core2.wasm ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"3e3fe2fb4fd6ccda9e25.wasm\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/yosys.core2.wasm?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/yosys.core3.wasm":
/*!*********************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/yosys.core3.wasm ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"9c1bc2a75f84dfea5b04.wasm\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/yosys.core3.wasm?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/yosys.core4.wasm":
/*!*********************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/yosys.core4.wasm ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"828f79ca7cdb9e431da9.wasm\";\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/yosys.core4.wasm?");

/***/ }),

/***/ "./node_modules/@yowasp/yosys/gen/resources-yosys.js":
/*!***********************************************************!*\
  !*** ./node_modules/@yowasp/yosys/gen/resources-yosys.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filesystem: () => (/* binding */ filesystem),\n/* harmony export */   modules: () => (/* binding */ modules)\n/* harmony export */ });\nconst modules = {\n    \"yosys.core.wasm\": new URL(/* asset import */ __webpack_require__(/*! ./yosys.core.wasm */ \"./node_modules/@yowasp/yosys/gen/yosys.core.wasm\"), __webpack_require__.b),\n    \"yosys.core2.wasm\": new URL(/* asset import */ __webpack_require__(/*! ./yosys.core2.wasm */ \"./node_modules/@yowasp/yosys/gen/yosys.core2.wasm\"), __webpack_require__.b),\n    \"yosys.core3.wasm\": new URL(/* asset import */ __webpack_require__(/*! ./yosys.core3.wasm */ \"./node_modules/@yowasp/yosys/gen/yosys.core3.wasm\"), __webpack_require__.b),\n    \"yosys.core4.wasm\": new URL(/* asset import */ __webpack_require__(/*! ./yosys.core4.wasm */ \"./node_modules/@yowasp/yosys/gen/yosys.core4.wasm\"), __webpack_require__.b),\n};\nconst filesystem = {\n    share: {\n        \"abc9_map.v\": \"`ifdef DFF\\n(* techmap_celltype = \\\"$_DFF_[PN]_\\\" *)\\nmodule $_DFF_x_(input C, D, output Q);\\n  parameter [0:0] _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  parameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n  wire D_;\\n  generate if (_TECHMAP_CELLTYPE_ == \\\"$_DFF_N_\\\") begin\\n    if (_TECHMAP_WIREINIT_Q_ === 1'b0) begin\\n      $__DFF_N__$abc9_flop _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q), .n1(D_));\\n      $_DFF_N_ ff (.C(C), .D(D_), .Q(Q));\\n    end\\n    else\\n      (* abc9_keep *) $_DFF_N_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));\\n  end\\n  else if (_TECHMAP_CELLTYPE_ == \\\"$_DFF_P_\\\") begin\\n    if (_TECHMAP_WIREINIT_Q_ === 1'b0) begin\\n      $__DFF_P__$abc9_flop _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q), .n1(D_));\\n      $_DFF_P_ ff (.C(C), .D(D_), .Q(Q));\\n    end\\n    else\\n      (* abc9_keep *) $_DFF_P_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));\\n  end\\n  else if (_TECHMAP_CELLTYPE_ != \\\"\\\")\\n    $error(\\\"Unrecognised _TECHMAP_CELLTYPE_\\\");\\n  endgenerate\\nendmodule\\n`endif\\n\",\n        \"abc9_model.v\": \"(* abc9_box *)\\nmodule $__ABC9_DELAY (input I, output O);\\n  parameter DELAY = 0;\\n  specify\\n    (I => O) = DELAY;\\n  endspecify\\nendmodule\\n\\nmodule $__ABC9_SCC_BREAKER (input [WIDTH-1:0] I, output [WIDTH-1:0] O);\\nparameter WIDTH = 0;\\nendmodule\\n\\n(* abc9_flop, abc9_box, lib_whitebox *)\\nmodule $__DFF_N__$abc9_flop (input C, D, Q, output n1);\\n  assign n1 = D;\\n  specify\\n    $setup(D, posedge C, 0);\\n    (posedge C => (n1:D)) = 0;\\n  endspecify\\nendmodule\\n\\n(* abc9_flop, abc9_box, lib_whitebox *)\\nmodule $__DFF_P__$abc9_flop (input C, D, Q, output n1);\\n  assign n1 = D;\\n  specify\\n    $setup(D, posedge C, 0);\\n    (posedge C => (n1:D)) = 0;\\n  endspecify\\nendmodule\\n\",\n        \"abc9_unmap.v\": \"(* techmap_celltype = \\\"$__DFF_N__$abc9_flop $__DFF_P__$abc9_flop\\\" *)\\nmodule $__DFF_x__$abc9_flop (input C, D, (* init = 1'b0 *) input Q, output n1);\\n  parameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n  generate if (_TECHMAP_CELLTYPE_ == \\\"$__DFF_N__$abc9_flop\\\")\\n    $_DFF_N_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));\\n  else if (_TECHMAP_CELLTYPE_ == \\\"$__DFF_P__$abc9_flop\\\")\\n    $_DFF_P_ _TECHMAP_REPLACE_ (.C(C), .D(D), .Q(Q));\\n  else if (_TECHMAP_CELLTYPE_ != \\\"\\\")\\n    $error(\\\"Unrecognised _TECHMAP_CELLTYPE_\\\");\\n  endgenerate\\nendmodule\\n\\nmodule $__ABC9_SCC_BREAKER (input [WIDTH-1:0] I, output [WIDTH-1:0] O);\\nparameter WIDTH = 0;\\nassign O = I;\\nendmodule\\n\",\n        \"achronix\": {\n            \"speedster22i\": {\n                \"cells_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n// > c60k28 (Viacheslav, VT) [at] yandex [dot] com\\n// > Achronix eFPGA technology mapping. User must first simulate the generated \\\\\\n// > netlist before going to test it on board/custom chip.\\n\\n// > Input/Output buffers <\\n// Input buffer map\\nmodule \\\\$__inpad (input I, output O);\\n    PADIN _TECHMAP_REPLACE_ (.padout(O), .padin(I));\\nendmodule\\n// Output buffer map\\nmodule \\\\$__outpad (input I, output O);\\n    PADOUT _TECHMAP_REPLACE_ (.padout(O), .padin(I), .oe(1'b1));\\nendmodule\\n// > end buffers <\\n\\n// > Look-Up table <\\n// > VT: I still think Achronix folks would have chosen a better \\\\\\n// >     logic architecture.\\n// LUT Map\\nmodule \\\\$lut (A, Y);\\n   parameter WIDTH  = 0;\\n   parameter LUT    = 0;\\n   (* force_downto *)\\n   input [WIDTH-1:0] A;\\n   output \\t     Y;\\n   generate\\n      if (WIDTH == 1) begin\\n\\t   // VT: This is not consistent and ACE will complain: assign Y = ~A[0];\\n         LUT4 #(.lut_function({4{LUT}})) _TECHMAP_REPLACE_\\n           (.dout(Y), .din0(A[0]), .din1(1'b0), .din2(1'b0), .din3(1'b0));\\n      end else\\n      if (WIDTH == 2) begin\\n              LUT4 #(.lut_function({4{LUT}})) _TECHMAP_REPLACE_\\n                (.dout(Y), .din0(A[0]), .din1(A[1]), .din2(1'b0), .din3(1'b0));\\n      end else\\n      if(WIDTH == 3) begin\\n\\t      LUT4 #(.lut_function({2{LUT}})) _TECHMAP_REPLACE_\\n                (.dout(Y), .din0(A[0]), .din1(A[1]), .din2(A[2]), .din3(1'b0));\\n      end else\\n      if(WIDTH == 4) begin\\n             LUT4 #(.lut_function(LUT)) _TECHMAP_REPLACE_\\n               (.dout(Y), .din0(A[0]), .din1(A[1]), .din2(A[2]), .din3(A[3]));\\n      end else\\n\\t   wire _TECHMAP_FAIL_ = 1;\\n   endgenerate\\nendmodule\\n// > end LUT <\\n\\n// > Flops <\\n// DFF flop\\nmodule  \\\\$_DFF_P_ (input D, C, output Q);\\n   DFF _TECHMAP_REPLACE_\\n     (.q(Q), .d(D), .ck(C));\\nendmodule\\n\\n\",\n                \"cells_sim.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n// > c60k28 (Viacheslav, VT) [at] yandex [dot] com\\n// > Achronix eFPGA technology sim models. User must first simulate the generated \\\\\\n// > netlist before going to test it on board/custom chip.\\n// > Changelog: 1) Removed unused VCC/GND modules\\n// >            2) Altera comments here (?). Removed.\\n// >            3) Reusing LUT sim model, removed wrong wires and parameters.\\n\\nmodule PADIN (output padout, input padin);\\n   assign padout = padin;\\nendmodule\\n\\nmodule PADOUT (output padout, input padin, input oe);\\n   assign padout  = padin;\\n   assign oe = oe;\\nendmodule\\n\\nmodule LUT4 (output dout,\\n             input  din0, din1, din2, din3);\\n\\nparameter [15:0] lut_function = 16'hFFFF;\\nreg combout_rt;\\nwire dataa_w;\\nwire datab_w;\\nwire datac_w;\\nwire datad_w;\\n\\nassign dataa_w = din0;\\nassign datab_w = din1;\\nassign datac_w = din2;\\nassign datad_w = din3;\\n\\nfunction lut_data;\\ninput [15:0] mask;\\ninput        dataa, datab, datac, datad;\\nreg [7:0]   s3;\\nreg [3:0]   s2;\\nreg [1:0]   s1;\\n  begin\\n       s3 = datad ? mask[15:8] : mask[7:0];\\n       s2 = datac ?   s3[7:4]  :   s3[3:0];\\n       s1 = datab ?   s2[3:2]  :   s2[1:0];\\n       lut_data = dataa ? s1[1] : s1[0];\\n  end\\nendfunction\\n\\nalways @(dataa_w or datab_w or datac_w or datad_w) begin\\n   combout_rt = lut_data(lut_function, dataa_w, datab_w,\\n                         datac_w, datad_w);\\nend\\nassign dout = combout_rt & 1'b1;\\nendmodule\\n\\nmodule DFF (output reg q,\\n            input  d, ck);\\n   always @(posedge ck)\\n     q <= d;\\n\\nendmodule\\n\\n\\n\\n\",\n            },\n        },\n        \"adff2dff.v\": \"(* techmap_celltype = \\\"$adff\\\" *)\\nmodule adff2dff (CLK, ARST, D, Q);\\n\\tparameter WIDTH = 1;\\n\\tparameter CLK_POLARITY = 1;\\n\\tparameter ARST_POLARITY = 1;\\n\\tparameter ARST_VALUE = 0;\\n\\n\\tinput CLK, ARST;\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] D;\\n\\t(* force_downto *)\\n\\toutput reg [WIDTH-1:0] Q;\\n\\t(* force_downto *)\\n\\treg [WIDTH-1:0] NEXT_Q;\\n\\n\\twire [1023:0] _TECHMAP_DO_ = \\\"proc;;\\\";\\n\\n\\talways @*\\n\\t\\tif (ARST == ARST_POLARITY)\\n\\t\\t\\tNEXT_Q <= ARST_VALUE;\\n\\t\\telse\\n\\t\\t\\tNEXT_Q <= D;\\n\\n\\tif (CLK_POLARITY)\\n\\t\\talways @(posedge CLK)\\n\\t\\t\\tQ <= NEXT_Q;\\n\\telse\\n\\t\\talways @(negedge CLK)\\n\\t\\t\\tQ <= NEXT_Q;\\nendmodule\\n\",\n        \"anlogic\": {\n            \"arith_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2018  Miodrag Milanovic <micko@yosyshq.com>\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_anlogic_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH  = 1;\\n\\tparameter B_WIDTH  = 1;\\n\\tparameter Y_WIDTH  = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n   \\n\\twire CIx;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] COx;\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 2;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] C = { COx, CIx };\\n\\n    wire dummy;\\n    AL_MAP_ADDER #(\\n    \\t.ALUTYPE(\\\"ADD_CARRY\\\"))\\n    adder_cin  (\\n        .a(CI),\\n\\t\\t.b(1'b0),\\n\\t\\t.c(1'b0),\\n        .o({CIx, dummy})\\n\\t);\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < Y_WIDTH; i = i + 1) begin: slice\\n\\t    AL_MAP_ADDER #(\\n            .ALUTYPE(\\\"ADD\\\")\\n        ) adder_i (\\n            .a(AA[i]),\\n            .b(BB[i]),\\n            .c(C[i]),\\n            .o({COx[i],Y[i]})\\n        );\\n\\n\\t\\twire cout;\\n\\t\\tAL_MAP_ADDER #(\\n\\t\\t\\t.ALUTYPE(\\\"ADD\\\"))\\n\\t\\tadder_cout  (\\n\\t\\t\\t.a(1'b0),\\n\\t\\t\\t.b(1'b0),\\n\\t\\t\\t.c(COx[i]),\\n\\t\\t\\t.o({cout, CO[i]})\\n\\t\\t);\\n\\t  end: slice\\t  \\n\\tendgenerate\\n\\n   /* End implementation */\\n   assign X = AA ^ BB;\\nendmodule\\n\",\n            \"brams.txt\": \"ram block $__ANLOGIC_BRAM_TDP_ {\\n\\tabits 13;\\n\\twidths 1 2 4 9 per_port;\\n\\tcost 64;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"NORMAL\\\" {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"WRITETHROUGH\\\" {\\n\\t\\t\\trdwr new;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"READBEFOREWRITE\\\" {\\n\\t\\t\\trdwr old;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated block_wr;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n}\\n\\nram block $__ANLOGIC_BRAM_SDP_ {\\n\\tabits 13;\\n\\twidths 1 2 4 9 18 per_port;\\n\\tbyte 9;\\n\\tcost 64;\\n\\tinit no_undef;\\n\\tport sr \\\"R\\\" {\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\toption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t}\\n}\\n\\nram block $__ANLOGIC_BRAM32K_ {\\n\\tabits 12;\\n\\twidths 8 16 per_port;\\n\\tbyte 8;\\n\\tcost 192;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"NORMAL\\\" {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"WRITETHROUGH\\\" {\\n\\t\\t\\trdwr new;\\n\\t\\t}\\n\\t\\t# no reset - it doesn't really work without the pipeline\\n\\t\\t# output registers\\n\\t}\\n}\\n\",\n            \"brams_map.v\": \"module $__ANLOGIC_BRAM_TDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESETMODE = \\\"SYNC\\\";\\n\\nparameter PORT_A_WIDTH = 9;\\nparameter PORT_A_CLK_POL = 1;\\nparameter PORT_A_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput PORT_A_WR_EN;\\ninput PORT_A_RD_SRST;\\ninput PORT_A_RD_ARST;\\ninput [12:0] PORT_A_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\n\\nparameter PORT_B_WIDTH = 9;\\nparameter PORT_B_CLK_POL = 1;\\nparameter PORT_B_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput PORT_B_WR_EN;\\ninput PORT_B_RD_SRST;\\ninput PORT_B_RD_ARST;\\ninput [12:0] PORT_B_ADDR;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\n\\nfunction [255:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < 32; i = i + 1) begin\\n\\t\\tinit_slice[i*8+:8] = INIT[(idx * 32 + i) * 9 +: 8];\\n\\tend\\nendfunction\\n\\nfunction [255:0] initp_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < 256; i = i + 1) begin\\n\\t\\tinitp_slice[i] = INIT[(idx * 256 + i) * 9 + 8];\\n\\tend\\nendfunction\\n\\nwire [8:0] DOA;\\nwire [8:0] DOB;\\n// the replication is important — the BRAM behaves in... unexpected ways for\\n// width 1 and 2\\nwire [8:0] DIA = {9{PORT_A_WR_DATA}};\\nwire [8:0] DIB = {9{PORT_B_WR_DATA}};\\n\\nassign PORT_A_RD_DATA = DOA;\\nassign PORT_B_RD_DATA = DOB;\\n\\nEG_PHY_BRAM #(\\n\\t.INIT_00(init_slice('h00)),\\n\\t.INIT_01(init_slice('h01)),\\n\\t.INIT_02(init_slice('h02)),\\n\\t.INIT_03(init_slice('h03)),\\n\\t.INIT_04(init_slice('h04)),\\n\\t.INIT_05(init_slice('h05)),\\n\\t.INIT_06(init_slice('h06)),\\n\\t.INIT_07(init_slice('h07)),\\n\\t.INIT_08(init_slice('h08)),\\n\\t.INIT_09(init_slice('h09)),\\n\\t.INIT_0A(init_slice('h0a)),\\n\\t.INIT_0B(init_slice('h0b)),\\n\\t.INIT_0C(init_slice('h0c)),\\n\\t.INIT_0D(init_slice('h0d)),\\n\\t.INIT_0E(init_slice('h0e)),\\n\\t.INIT_0F(init_slice('h0f)),\\n\\t.INIT_10(init_slice('h10)),\\n\\t.INIT_11(init_slice('h11)),\\n\\t.INIT_12(init_slice('h12)),\\n\\t.INIT_13(init_slice('h13)),\\n\\t.INIT_14(init_slice('h14)),\\n\\t.INIT_15(init_slice('h15)),\\n\\t.INIT_16(init_slice('h16)),\\n\\t.INIT_17(init_slice('h17)),\\n\\t.INIT_18(init_slice('h18)),\\n\\t.INIT_19(init_slice('h19)),\\n\\t.INIT_1A(init_slice('h1a)),\\n\\t.INIT_1B(init_slice('h1b)),\\n\\t.INIT_1C(init_slice('h1c)),\\n\\t.INIT_1D(init_slice('h1d)),\\n\\t.INIT_1E(init_slice('h1e)),\\n\\t.INIT_1F(init_slice('h1f)),\\n\\t.INITP_00(initp_slice('h00)),\\n\\t.INITP_01(initp_slice('h01)),\\n\\t.INITP_02(initp_slice('h02)),\\n\\t.INITP_03(initp_slice('h03)),\\n\\t.MODE(\\\"DP8K\\\"),\\n\\t.DATA_WIDTH_A($sformatf(\\\"%d\\\", PORT_A_WIDTH)),\\n\\t.DATA_WIDTH_B($sformatf(\\\"%d\\\", PORT_B_WIDTH)),\\n\\t.REGMODE_A(\\\"NOREG\\\"),\\n\\t.REGMODE_B(\\\"NOREG\\\"),\\n\\t.RESETMODE(OPTION_RESETMODE),\\n\\t.ASYNC_RESET_RELEASE(OPTION_RESETMODE),\\n\\t.CLKAMUX(PORT_A_CLK_POL ? \\\"SIG\\\" : \\\"INV\\\"),\\n\\t.CLKBMUX(PORT_B_CLK_POL ? \\\"SIG\\\" : \\\"INV\\\"),\\n\\t.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),\\n\\t.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),\\n) _TECHMAP_REPLACE_ (\\n\\t.clka(PORT_A_CLK),\\n\\t.wea(PORT_A_WR_EN),\\n\\t.cea(PORT_A_CLK_EN),\\n\\t.ocea(1'b1),\\n\\t.rsta(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST),\\n\\t.csa(3'b111),\\n\\t.addra(PORT_A_WIDTH == 9 ? {PORT_A_ADDR[12:1], 1'b1} : PORT_A_ADDR),\\n\\t.dia(DIA),\\n\\t.doa(DOA),\\n\\n\\t.clkb(PORT_B_CLK),\\n\\t.web(PORT_B_WR_EN),\\n\\t.ceb(PORT_B_CLK_EN),\\n\\t.oceb(1'b1),\\n\\t.rstb(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_B_RD_SRST : PORT_B_RD_ARST),\\n\\t.csb(3'b111),\\n\\t.addrb(PORT_B_WIDTH == 9 ? {PORT_B_ADDR[12:1], 1'b1} : PORT_B_ADDR),\\n\\t.dib(DIB),\\n\\t.dob(DOB),\\n);\\n\\nendmodule\\n\\n\\nmodule $__ANLOGIC_BRAM_SDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESETMODE = \\\"SYNC\\\";\\n\\nparameter PORT_R_WIDTH = 18;\\nparameter PORT_R_CLK_POL = 1;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput PORT_R_RD_SRST;\\ninput PORT_R_RD_ARST;\\ninput [12:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\n\\nparameter PORT_W_WIDTH = 18;\\nparameter PORT_W_WR_EN_WIDTH = 2;\\nparameter PORT_W_CLK_POL = 1;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput [12:0] PORT_W_ADDR;\\ninput [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\n\\nfunction [255:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < 32; i = i + 1) begin\\n\\t\\tinit_slice[i*8+:8] = INIT[(idx * 32 + i) * 9 +: 8];\\n\\tend\\nendfunction\\n\\nfunction [255:0] initp_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < 256; i = i + 1) begin\\n\\t\\tinitp_slice[i] = INIT[(idx * 256 + i) * 9 + 8];\\n\\tend\\nendfunction\\n\\nwire [17:0] DI = {18{PORT_W_WR_DATA}};\\nwire [17:0] DO;\\n\\nassign PORT_R_RD_DATA = PORT_R_WIDTH == 18 ? DO : DO[17:9];\\n\\nEG_PHY_BRAM #(\\n\\t.INIT_00(init_slice('h00)),\\n\\t.INIT_01(init_slice('h01)),\\n\\t.INIT_02(init_slice('h02)),\\n\\t.INIT_03(init_slice('h03)),\\n\\t.INIT_04(init_slice('h04)),\\n\\t.INIT_05(init_slice('h05)),\\n\\t.INIT_06(init_slice('h06)),\\n\\t.INIT_07(init_slice('h07)),\\n\\t.INIT_08(init_slice('h08)),\\n\\t.INIT_09(init_slice('h09)),\\n\\t.INIT_0A(init_slice('h0a)),\\n\\t.INIT_0B(init_slice('h0b)),\\n\\t.INIT_0C(init_slice('h0c)),\\n\\t.INIT_0D(init_slice('h0d)),\\n\\t.INIT_0E(init_slice('h0e)),\\n\\t.INIT_0F(init_slice('h0f)),\\n\\t.INIT_10(init_slice('h10)),\\n\\t.INIT_11(init_slice('h11)),\\n\\t.INIT_12(init_slice('h12)),\\n\\t.INIT_13(init_slice('h13)),\\n\\t.INIT_14(init_slice('h14)),\\n\\t.INIT_15(init_slice('h15)),\\n\\t.INIT_16(init_slice('h16)),\\n\\t.INIT_17(init_slice('h17)),\\n\\t.INIT_18(init_slice('h18)),\\n\\t.INIT_19(init_slice('h19)),\\n\\t.INIT_1A(init_slice('h1a)),\\n\\t.INIT_1B(init_slice('h1b)),\\n\\t.INIT_1C(init_slice('h1c)),\\n\\t.INIT_1D(init_slice('h1d)),\\n\\t.INIT_1E(init_slice('h1e)),\\n\\t.INIT_1F(init_slice('h1f)),\\n\\t.INITP_00(initp_slice('h00)),\\n\\t.INITP_01(initp_slice('h01)),\\n\\t.INITP_02(initp_slice('h02)),\\n\\t.INITP_03(initp_slice('h03)),\\n\\t.MODE(\\\"PDPW8K\\\"),\\n\\t.DATA_WIDTH_A($sformatf(\\\"%d\\\", PORT_W_WIDTH)),\\n\\t.DATA_WIDTH_B($sformatf(\\\"%d\\\", PORT_R_WIDTH)),\\n\\t.REGMODE_A(\\\"NOREG\\\"),\\n\\t.REGMODE_B(\\\"NOREG\\\"),\\n\\t.RESETMODE(OPTION_RESETMODE),\\n\\t.ASYNC_RESET_RELEASE(OPTION_RESETMODE),\\n\\t.CLKAMUX(PORT_W_CLK_POL ? \\\"SIG\\\" : \\\"INV\\\"),\\n\\t.CLKBMUX(PORT_R_CLK_POL ? \\\"SIG\\\" : \\\"INV\\\"),\\n) _TECHMAP_REPLACE_ (\\n\\t.clka(PORT_W_CLK),\\n\\t.wea(PORT_W_WIDTH >= 9 ? 1'b1 : PORT_W_WR_EN[0]),\\n\\t.cea(PORT_W_CLK_EN),\\n\\t.ocea(1'b1),\\n\\t.rsta(1'b0),\\n\\t.csa(3'b111),\\n\\t.addra(PORT_W_WIDTH == 18 ? {PORT_W_ADDR[12:2], PORT_W_WR_EN[1:0]} : (PORT_W_WIDTH == 9 ? {PORT_W_ADDR[12:1], PORT_W_WR_EN[0]} : PORT_W_ADDR)),\\n\\t.dia(DI[8:0]),\\n\\t.doa(DO[8:0]),\\n\\n\\t.clkb(PORT_R_CLK),\\n\\t.web(1'b0),\\n\\t.ceb(PORT_R_CLK_EN),\\n\\t.oceb(1'b1),\\n\\t.rstb(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_R_RD_SRST : PORT_R_RD_ARST),\\n\\t.csb(3'b111),\\n\\t.addrb(PORT_R_ADDR),\\n\\t.dib(DI[17:9]),\\n\\t.dob(DO[17:9]),\\n);\\n\\nendmodule\\n\\n\\nmodule $__ANLOGIC_BRAM32K_ (...);\\n\\nparameter INIT = 0;\\n\\nparameter PORT_A_WIDTH = 16;\\nparameter PORT_A_WR_EN_WIDTH = 2;\\nparameter PORT_A_CLK_POL = 1;\\nparameter PORT_A_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;\\ninput [11:0] PORT_A_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\n\\nparameter PORT_B_WIDTH = 16;\\nparameter PORT_B_WR_EN_WIDTH = 2;\\nparameter PORT_B_CLK_POL = 1;\\nparameter PORT_B_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;\\ninput [11:0] PORT_B_ADDR;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\n\\nfunction [255:0] init_slice;\\n\\tinput integer idx;\\n\\tinit_slice = INIT[256 * idx +: 256];\\nendfunction\\n\\nwire [15:0] DOA;\\nwire [15:0] DOB;\\nwire [15:0] DIA = PORT_A_WR_DATA;\\nwire [15:0] DIB = PORT_B_WR_DATA;\\n\\nassign PORT_A_RD_DATA = DOA;\\nassign PORT_B_RD_DATA = DOB;\\n\\nwire BYTE_A, BYTEWE_A;\\nwire BYTE_B, BYTEWE_B;\\n\\ngenerate\\n\\nif (PORT_A_WIDTH == 8) begin\\n\\tassign BYTE_A = PORT_A_ADDR[0];\\n\\tassign BYTEWE_A = 1;\\nend else begin\\n\\tassign BYTE_A = PORT_A_WR_EN == 2;\\n\\tassign BYTEWE_A = ^PORT_A_WR_EN;\\nend\\n\\nif (PORT_B_WIDTH == 8) begin\\n\\tassign BYTE_B = PORT_B_ADDR[0];\\n\\tassign BYTEWE_B = 1;\\nend else begin\\n\\tassign BYTE_B = PORT_B_WR_EN == 2;\\n\\tassign BYTEWE_B = ^PORT_B_WR_EN;\\nend\\n\\nendgenerate\\n\\nEG_PHY_BRAM32K #(\\n\\t.INIT_00(init_slice('h00)),\\n\\t.INIT_01(init_slice('h01)),\\n\\t.INIT_02(init_slice('h02)),\\n\\t.INIT_03(init_slice('h03)),\\n\\t.INIT_04(init_slice('h04)),\\n\\t.INIT_05(init_slice('h05)),\\n\\t.INIT_06(init_slice('h06)),\\n\\t.INIT_07(init_slice('h07)),\\n\\t.INIT_08(init_slice('h08)),\\n\\t.INIT_09(init_slice('h09)),\\n\\t.INIT_0A(init_slice('h0a)),\\n\\t.INIT_0B(init_slice('h0b)),\\n\\t.INIT_0C(init_slice('h0c)),\\n\\t.INIT_0D(init_slice('h0d)),\\n\\t.INIT_0E(init_slice('h0e)),\\n\\t.INIT_0F(init_slice('h0f)),\\n\\t.INIT_10(init_slice('h10)),\\n\\t.INIT_11(init_slice('h11)),\\n\\t.INIT_12(init_slice('h12)),\\n\\t.INIT_13(init_slice('h13)),\\n\\t.INIT_14(init_slice('h14)),\\n\\t.INIT_15(init_slice('h15)),\\n\\t.INIT_16(init_slice('h16)),\\n\\t.INIT_17(init_slice('h17)),\\n\\t.INIT_18(init_slice('h18)),\\n\\t.INIT_19(init_slice('h19)),\\n\\t.INIT_1A(init_slice('h1a)),\\n\\t.INIT_1B(init_slice('h1b)),\\n\\t.INIT_1C(init_slice('h1c)),\\n\\t.INIT_1D(init_slice('h1d)),\\n\\t.INIT_1E(init_slice('h1e)),\\n\\t.INIT_1F(init_slice('h1f)),\\n\\t.INIT_20(init_slice('h20)),\\n\\t.INIT_21(init_slice('h21)),\\n\\t.INIT_22(init_slice('h22)),\\n\\t.INIT_23(init_slice('h23)),\\n\\t.INIT_24(init_slice('h24)),\\n\\t.INIT_25(init_slice('h25)),\\n\\t.INIT_26(init_slice('h26)),\\n\\t.INIT_27(init_slice('h27)),\\n\\t.INIT_28(init_slice('h28)),\\n\\t.INIT_29(init_slice('h29)),\\n\\t.INIT_2A(init_slice('h2a)),\\n\\t.INIT_2B(init_slice('h2b)),\\n\\t.INIT_2C(init_slice('h2c)),\\n\\t.INIT_2D(init_slice('h2d)),\\n\\t.INIT_2E(init_slice('h2e)),\\n\\t.INIT_2F(init_slice('h2f)),\\n\\t.INIT_30(init_slice('h30)),\\n\\t.INIT_31(init_slice('h31)),\\n\\t.INIT_32(init_slice('h32)),\\n\\t.INIT_33(init_slice('h33)),\\n\\t.INIT_34(init_slice('h34)),\\n\\t.INIT_35(init_slice('h35)),\\n\\t.INIT_36(init_slice('h36)),\\n\\t.INIT_37(init_slice('h37)),\\n\\t.INIT_38(init_slice('h38)),\\n\\t.INIT_39(init_slice('h39)),\\n\\t.INIT_3A(init_slice('h3a)),\\n\\t.INIT_3B(init_slice('h3b)),\\n\\t.INIT_3C(init_slice('h3c)),\\n\\t.INIT_3D(init_slice('h3d)),\\n\\t.INIT_3E(init_slice('h3e)),\\n\\t.INIT_3F(init_slice('h3f)),\\n\\t.INIT_40(init_slice('h40)),\\n\\t.INIT_41(init_slice('h41)),\\n\\t.INIT_42(init_slice('h42)),\\n\\t.INIT_43(init_slice('h43)),\\n\\t.INIT_44(init_slice('h44)),\\n\\t.INIT_45(init_slice('h45)),\\n\\t.INIT_46(init_slice('h46)),\\n\\t.INIT_47(init_slice('h47)),\\n\\t.INIT_48(init_slice('h48)),\\n\\t.INIT_49(init_slice('h49)),\\n\\t.INIT_4A(init_slice('h4a)),\\n\\t.INIT_4B(init_slice('h4b)),\\n\\t.INIT_4C(init_slice('h4c)),\\n\\t.INIT_4D(init_slice('h4d)),\\n\\t.INIT_4E(init_slice('h4e)),\\n\\t.INIT_4F(init_slice('h4f)),\\n\\t.INIT_50(init_slice('h50)),\\n\\t.INIT_51(init_slice('h51)),\\n\\t.INIT_52(init_slice('h52)),\\n\\t.INIT_53(init_slice('h53)),\\n\\t.INIT_54(init_slice('h54)),\\n\\t.INIT_55(init_slice('h55)),\\n\\t.INIT_56(init_slice('h56)),\\n\\t.INIT_57(init_slice('h57)),\\n\\t.INIT_58(init_slice('h58)),\\n\\t.INIT_59(init_slice('h59)),\\n\\t.INIT_5A(init_slice('h5a)),\\n\\t.INIT_5B(init_slice('h5b)),\\n\\t.INIT_5C(init_slice('h5c)),\\n\\t.INIT_5D(init_slice('h5d)),\\n\\t.INIT_5E(init_slice('h5e)),\\n\\t.INIT_5F(init_slice('h5f)),\\n\\t.INIT_60(init_slice('h60)),\\n\\t.INIT_61(init_slice('h61)),\\n\\t.INIT_62(init_slice('h62)),\\n\\t.INIT_63(init_slice('h63)),\\n\\t.INIT_64(init_slice('h64)),\\n\\t.INIT_65(init_slice('h65)),\\n\\t.INIT_66(init_slice('h66)),\\n\\t.INIT_67(init_slice('h67)),\\n\\t.INIT_68(init_slice('h68)),\\n\\t.INIT_69(init_slice('h69)),\\n\\t.INIT_6A(init_slice('h6a)),\\n\\t.INIT_6B(init_slice('h6b)),\\n\\t.INIT_6C(init_slice('h6c)),\\n\\t.INIT_6D(init_slice('h6d)),\\n\\t.INIT_6E(init_slice('h6e)),\\n\\t.INIT_6F(init_slice('h6f)),\\n\\t.INIT_70(init_slice('h70)),\\n\\t.INIT_71(init_slice('h71)),\\n\\t.INIT_72(init_slice('h72)),\\n\\t.INIT_73(init_slice('h73)),\\n\\t.INIT_74(init_slice('h74)),\\n\\t.INIT_75(init_slice('h75)),\\n\\t.INIT_76(init_slice('h76)),\\n\\t.INIT_77(init_slice('h77)),\\n\\t.INIT_78(init_slice('h78)),\\n\\t.INIT_79(init_slice('h79)),\\n\\t.INIT_7A(init_slice('h7a)),\\n\\t.INIT_7B(init_slice('h7b)),\\n\\t.INIT_7C(init_slice('h7c)),\\n\\t.INIT_7D(init_slice('h7d)),\\n\\t.INIT_7E(init_slice('h7e)),\\n\\t.INIT_7F(init_slice('h7f)),\\n\\t.MODE(\\\"DP16K\\\"),\\n\\t.DATA_WIDTH_A($sformatf(\\\"%d\\\", PORT_A_WIDTH)),\\n\\t.DATA_WIDTH_B($sformatf(\\\"%d\\\", PORT_B_WIDTH)),\\n\\t.REGMODE_A(\\\"NOREG\\\"),\\n\\t.REGMODE_B(\\\"NOREG\\\"),\\n\\t.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),\\n\\t.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),\\n\\t.CLKAMUX(PORT_A_CLK_POL ? \\\"SIG\\\" : \\\"INV\\\"),\\n\\t.CLKBMUX(PORT_B_CLK_POL ? \\\"SIG\\\" : \\\"INV\\\"),\\n) _TECHMAP_REPLACE_ (\\n\\t.clka(PORT_A_CLK),\\n\\t.csa(PORT_A_CLK_EN),\\n\\t.wea(|PORT_A_WR_EN),\\n\\t.ocea(1'b1),\\n\\t.rsta(1'b0),\\n\\t.addra(PORT_A_ADDR[11:1]),\\n\\t.bytea(BYTE_A),\\n\\t.bytewea(BYTEWE_A),\\n\\t.dia(DIA),\\n\\t.doa(DOA),\\n\\n\\t.clkb(PORT_B_CLK),\\n\\t.csb(PORT_B_CLK_EN),\\n\\t.web(|PORT_B_WR_EN),\\n\\t.ocea(1'b1),\\n\\t.rsta(1'b0),\\n\\t.addrb(PORT_B_ADDR[11:1]),\\n\\t.byteb(BYTE_B),\\n\\t.byteweb(BYTEWE_B),\\n\\t.dib(DIB),\\n\\t.dob(DOB),\\n);\\n\\nendmodule\\n\",\n            \"cells_map.v\": \"module  \\\\$_DFFE_PN0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"FF\\\"), .REGSET(\\\"RESET\\\"), .SRMUX(\\\"INV\\\"), .SRMODE(\\\"ASYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C) ,.ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PN1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"FF\\\"), .REGSET(\\\"SET\\\"), .SRMUX(\\\"INV\\\"), .SRMODE(\\\"ASYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"FF\\\"), .REGSET(\\\"RESET\\\"), .SRMUX(\\\"SR\\\"),  .SRMODE(\\\"ASYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"FF\\\"), .REGSET(\\\"SET\\\"), .SRMUX(\\\"SR\\\"), . SRMODE(\\\"ASYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_SDFFE_PN0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"FF\\\"), .REGSET(\\\"RESET\\\"), .SRMUX(\\\"INV\\\"), .SRMODE(\\\"SYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C) ,.ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PN1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"FF\\\"), .REGSET(\\\"SET\\\"), .SRMUX(\\\"INV\\\"), .SRMODE(\\\"SYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP0P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"FF\\\"), .REGSET(\\\"RESET\\\"), .SRMUX(\\\"SR\\\"),  .SRMODE(\\\"SYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP1P_ (input D, C, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"FF\\\"), .REGSET(\\\"SET\\\"), .SRMUX(\\\"SR\\\"), . SRMODE(\\\"SYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .ce(E), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_DLATCH_NN0_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"LATCH\\\"), .REGSET(\\\"RESET\\\"), .SRMUX(\\\"INV\\\"), .SRMODE(\\\"ASYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E) ,.ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DLATCH_NN1_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"LATCH\\\"), .REGSET(\\\"SET\\\"), .SRMUX(\\\"INV\\\"), .SRMODE(\\\"ASYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E), .ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DLATCH_NP0_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"LATCH\\\"), .REGSET(\\\"RESET\\\"), .SRMUX(\\\"SR\\\"),  .SRMODE(\\\"ASYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E), .ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DLATCH_NP1_ (input D, R, E, output Q); AL_MAP_SEQ #(.DFFMODE(\\\"LATCH\\\"), .REGSET(\\\"SET\\\"), .SRMUX(\\\"SR\\\"), . SRMODE(\\\"ASYNC\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(E), .ce(1'b1), .sr(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\n`ifndef NO_LUT\\nmodule \\\\$lut (A, Y);\\n  parameter WIDTH = 0;\\n  parameter LUT = 0;\\n\\n  (* force_downto *)\\n  input [WIDTH-1:0] A;\\n  output Y;\\n\\n  generate\\n    if (WIDTH == 1) begin\\n      AL_MAP_LUT1 #(.EQN(\\\"\\\"),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]));\\n    end else\\n    if (WIDTH == 2) begin\\n      AL_MAP_LUT2 #(.EQN(\\\"\\\"),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]));\\n    end else\\n    if (WIDTH == 3) begin\\n      AL_MAP_LUT3 #(.EQN(\\\"\\\"),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]));\\n    end else\\n    if (WIDTH == 4) begin\\n      AL_MAP_LUT4 #(.EQN(\\\"\\\"),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]), .d(A[3]));\\n    end else\\n    if (WIDTH == 5) begin\\n      AL_MAP_LUT5 #(.EQN(\\\"\\\"),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]), .d(A[3]), .e(A[4]));\\n    end else\\n    if (WIDTH == 6) begin\\n      AL_MAP_LUT6 #(.EQN(\\\"\\\"),.INIT(LUT)) _TECHMAP_REPLACE_ (.o(Y), .a(A[0]), .b(A[1]), .c(A[2]), .d(A[3]), .e(A[4]), .f(A[5]));\\n    end else begin\\n      wire _TECHMAP_FAIL_ = 1;\\n    end\\n  endgenerate\\nendmodule\\n`endif\\n\",\n            \"cells_sim.v\": \"module AL_MAP_SEQ (\\n\\toutput reg q,\\n\\tinput ce,\\n\\tinput clk,\\n\\tinput sr,\\n\\tinput d\\n);\\n\\tparameter DFFMODE = \\\"FF\\\"; //FF,LATCH\\n\\tparameter REGSET = \\\"RESET\\\"; //RESET/SET\\n\\tparameter SRMUX = \\\"SR\\\"; //SR/INV\\n\\tparameter SRMODE = \\\"SYNC\\\"; //SYNC/ASYNC\\n\\n\\twire srmux;\\n\\tgenerate\\n\\t\\tcase (SRMUX)\\n\\t\\t\\t\\\"SR\\\": assign srmux = sr;\\n\\t\\t\\t\\\"INV\\\": assign srmux = ~sr;\\n\\t\\t\\tdefault: assign srmux = sr;\\n\\t\\tendcase\\n\\tendgenerate\\n\\n\\twire regset;\\n\\tgenerate\\n\\t\\tcase (REGSET)\\n\\t\\t\\t\\\"RESET\\\": assign regset = 1'b0;\\n\\t\\t\\t\\\"SET\\\": assign regset = 1'b1;\\n\\t\\t\\tdefault: assign regset = 1'b0;\\n\\t\\tendcase\\n\\tendgenerate\\n\\n\\tinitial q = regset;\\n\\n\\tgenerate\\n\\t\\tif (DFFMODE == \\\"FF\\\")\\n\\t\\tbegin\\n\\t\\t\\tif (SRMODE == \\\"ASYNC\\\")\\n\\t\\t\\tbegin\\n\\t\\t\\t\\talways @(posedge clk, posedge srmux)\\n\\t\\t\\t\\t\\tif (srmux)\\n\\t\\t\\t\\t\\t\\tq <= regset;\\n\\t\\t\\t\\t\\telse if (ce)\\n\\t\\t\\t\\t\\t\\tq <= d;\\n\\t\\t\\tend\\n\\t\\t\\telse\\n\\t\\t\\tbegin\\n\\t\\t\\t\\talways @(posedge clk)\\n\\t\\t\\t\\t\\tif (srmux)\\n\\t\\t\\t\\t\\t\\tq <= regset;\\n\\t\\t\\t\\t\\telse if (ce)\\n\\t\\t\\t\\t\\t\\tq <= d;\\n\\t\\t\\tend\\n\\t\\tend\\n\\t\\telse\\n\\t\\tbegin\\n\\t\\t\\t// DFFMODE == \\\"LATCH\\\"\\n\\t\\t\\tif (SRMODE == \\\"ASYNC\\\")\\n\\t\\t\\tbegin\\n\\t\\t\\t\\talways @*\\n\\t\\t\\t\\t\\tif (srmux)\\n\\t\\t\\t\\t\\t\\tq <= regset;\\n\\t\\t\\t\\t\\telse if (~clk & ce)\\n\\t\\t\\t\\t\\t\\tq <= d;\\n\\t\\t\\tend\\n\\t\\t\\telse\\n\\t\\t\\tbegin\\n\\t\\t\\t\\talways @*\\n\\t\\t\\t\\t\\tif (~clk) begin\\n\\t\\t\\t\\t\\t\\tif (srmux)\\n\\t\\t\\t\\t\\t\\t\\tq <= regset;\\n\\t\\t\\t\\t\\t\\telse if (ce)\\n\\t\\t\\t\\t\\t\\t\\tq <= d;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\t\\tend\\n    endgenerate\\nendmodule\\n\\nmodule AL_MAP_LUT1 (\\n\\toutput o,\\n\\tinput a\\n);\\n\\tparameter [1:0] INIT = 2'h0;\\n\\tparameter EQN = \\\"(A)\\\";\\n\\n\\tassign o = a ? INIT[1] : INIT[0];\\t\\nendmodule\\n\\nmodule AL_MAP_LUT2 (\\n\\toutput o,\\n\\tinput a,\\n\\tinput b\\n);\\n\\tparameter [3:0] INIT = 4'h0;\\n\\tparameter EQN = \\\"(A)\\\";\\n\\n\\twire [1:0] s1 = b ? INIT[ 3:2] : INIT[1:0];\\n\\tassign o = a ? s1[1] : s1[0];\\t\\nendmodule\\n\\nmodule AL_MAP_LUT3 (\\n\\toutput o,\\n\\tinput a,\\n\\tinput b,\\n\\tinput c\\n);\\n\\tparameter [7:0] INIT = 8'h0;\\n\\tparameter EQN = \\\"(A)\\\";\\n\\n\\twire [3:0] s2 = c ? INIT[ 7:4] : INIT[3:0];\\n\\twire [1:0] s1 = b ?   s2[ 3:2] :   s2[1:0];\\n\\tassign o = a ? s1[1] : s1[0];\\t\\nendmodule\\n\\nmodule AL_MAP_LUT4 (\\n\\toutput o,\\n\\tinput a,\\n\\tinput b,\\n\\tinput c,\\n\\tinput d\\n);\\n\\tparameter [15:0] INIT = 16'h0;\\n\\tparameter EQN = \\\"(A)\\\";\\n\\n\\twire [7:0] s3 = d ? INIT[15:8] : INIT[7:0];\\n\\twire [3:0] s2 = c ?   s3[ 7:4] :   s3[3:0];\\n\\twire [1:0] s1 = b ?   s2[ 3:2] :   s2[1:0];\\n\\tassign o = a ? s1[1] : s1[0];\\t\\nendmodule\\n\\nmodule AL_MAP_LUT5 (\\n\\toutput o,\\n\\tinput a,\\n\\tinput b,\\n\\tinput c,\\n\\tinput d,\\n\\tinput e\\n);\\n\\tparameter [31:0] INIT = 32'h0;\\n\\tparameter EQN = \\\"(A)\\\";\\n\\tassign o = INIT >> {e, d, c, b, a};\\nendmodule\\n\\n\\nmodule AL_MAP_LUT6 (\\n\\toutput o,\\n\\tinput a,\\n\\tinput b,\\n\\tinput c,\\n\\tinput d,\\n\\tinput e,\\n\\tinput f\\n);\\n\\tparameter [63:0] INIT = 64'h0;\\n\\tparameter EQN = \\\"(A)\\\";\\n\\tassign o = INIT >> {f, e, d, c, b, a};\\nendmodule\\n\\nmodule AL_MAP_ALU2B (\\n   input cin,\\n   input a0, b0, c0, d0,\\n   input a1, b1, c1, d1,\\n   output s0, s1, cout\\n);\\n\\tparameter [15:0] INIT0 = 16'h0000;\\n\\tparameter [15:0] INIT1 = 16'h0000;\\n\\tparameter FUNC0 = \\\"NO\\\";\\n\\tparameter FUNC1 = \\\"NO\\\";\\nendmodule\\n\\nmodule AL_MAP_ADDER (\\n  input a,\\n  input b,\\n  input c,\\n  output [1:0] o\\n);\\n\\tparameter ALUTYPE = \\\"ADD\\\";\\n\\n\\tgenerate\\n\\t\\tcase (ALUTYPE)\\n\\t\\t\\t\\\"ADD\\\": \\t\\t assign o = a + b + c;\\n\\t\\t\\t\\\"SUB\\\": \\t\\t assign o = a - b - c;\\n\\t\\t\\t\\\"A_LE_B\\\":    assign o = a - b - c;\\n\\n\\t\\t\\t\\\"ADD_CARRY\\\":    assign o = {  a, 1'b0 };\\n\\t\\t\\t\\\"SUB_CARRY\\\":    assign o = { ~a, 1'b0 };\\n\\t\\t\\t\\\"A_LE_B_CARRY\\\": assign o = {  a, 1'b0 };\\n\\t\\t\\tdefault: assign o = a + b + c;\\n\\t\\tendcase\\n\\tendgenerate\\t\\n\\nendmodule\\n\",\n            \"eagle_bb.v\": \"// Anlogic Eagle - Blackbox cells\\n// FIXME: Create sim models\\n\\n(* blackbox *)\\nmodule EG_LOGIC_BUF(\\n  output o,\\n  input i\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_BUFG(\\n  output o,\\n  input i\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_BUFIO(\\n  input clki,\\n  input rst,\\n  input coe,\\n  output clko,\\n  output clkdiv1,\\n  output clkdivx\\n);\\n  parameter GSR = \\\"DISABLE\\\";\\n  parameter DIV = 2;\\n  parameter STOPCLK = \\\"DISABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_BUFGMUX(\\n  output o,\\n  input i0,\\n  input i1,\\n  input s\\n);\\n  parameter INIT_OUT = \\\"0\\\";\\n  parameter PRESELECT_I0 = \\\"TRUE\\\";\\n  parameter PRESELECT_I1 = \\\"FALSE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_MBOOT(\\n  input rebootn,\\n  input [7:0] dynamic_addr  \\n);\\n  parameter ADDR_SOURCE_SEL = \\\"STATIC\\\";\\n  parameter STATIC_ADDR = 8'b00000000;\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_DNA(\\n  output dout,\\n  input  clk,\\n  input  din,\\n  input  shift_en\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_GCTRL(\\n  output done,\\n  output highz\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_GSRN(\\n  input gsrn,\\n  input sync_clk\\n);\\n  parameter GSRN_SYNC_SEL = \\\"DISABLE\\\";\\n  parameter USR_GSRN_EN = \\\"DISABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_CCLK(\\n  output cclk,\\n  input  en\\n);\\n  parameter FREQ = \\\"4.5\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_IDELAY(\\n  output o,\\n  input i\\n);\\n  parameter INDEL = 0;\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_IDDR(\\n  output q1,\\n  output q0,\\n  input clk,\\n  input d,\\n  input rst\\n);\\n  parameter ASYNCRST = \\\"ENABLE\\\";\\n  parameter PIPEMODE = \\\"PIPED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_ODDR(\\n  output q,\\n  input clk,\\n  input d1,\\n  input d0,\\n  input rst\\n);\\n  parameter ASYNCRST = \\\"ENABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_IDDRx2(\\n  output q3,\\n  output q2,\\n  output q1,\\n  output q0,\\n  input pclk,\\n  input sclk,\\n  input d,\\n  input rst\\n);\\n  parameter ASYNCRST = \\\"ENABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_ODELAY(\\n  output o,\\n  input i\\n);\\n  parameter OUTDEL = 0;\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_ODDRx2(\\n  output q,\\n  input pclk,\\n  input sclk,\\n  input d3,\\n  input d2,\\n  input d1,\\n  input d0,\\n  input rst\\n);\\n  parameter ASYNCRST = \\\"ENABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_ODDRx2l(\\n  output q,\\n  input sclk,\\n  input d3,\\n  input d2,\\n  input d1,\\n  input d0,\\n  input rst\\n);\\n  parameter ASYNCRST = \\\"ENABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_FIFO(\\n  input rst,\\n  input [DATA_WIDTH_W-1:0] di,\\n  output [DATA_WIDTH_R-1:0] do,\\n  input clkw,\\n  input we,\\n  input clkr,\\n  input re,\\n  input ore,\\n  input [2:0] csw,\\n  input [2:0] csr,\\n  output empty_flag,\\n  output aempty_flag,\\n  output full_flag,\\n  output afull_flag\\n);\\n  parameter DATA_WIDTH_W = 9;\\n  parameter DATA_WIDTH_R = DATA_WIDTH_W;\\n  parameter DATA_DEPTH_W = 1024;\\n  parameter DATA_DEPTH_R = DATA_WIDTH_W * DATA_DEPTH_W / DATA_WIDTH_R;\\n  parameter MODE = \\\"FIFO8K\\\";\\n  parameter REGMODE_W = \\\"NOREG\\\";\\n  parameter REGMODE_R = \\\"NOREG\\\";\\n  parameter E = 0;\\n  parameter AE = 6;\\n  parameter AF = DATA_DEPTH_W - 6;\\n  parameter F = DATA_DEPTH_W;\\n  parameter GSR = \\\"DISABLE\\\";\\n  parameter RESETMODE = \\\"ASYNC\\\";\\n  parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n  parameter ENDIAN = \\\"LITTLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_DRAM(\\n  input [DATA_WIDTH_W-1:0] di,\\n  input [ADDR_WIDTH_W-1:0] waddr,\\n  input wclk,\\n  input we,\\n  output [DATA_WIDTH_R-1:0] do,\\n  input [ADDR_WIDTH_R-1:0] raddr\\n);\\n  parameter DATA_WIDTH_W = 9;\\n  parameter ADDR_WIDTH_W = 10;\\n  parameter DATA_DEPTH_W = 2 ** ADDR_WIDTH_W;\\n  parameter DATA_WIDTH_R = 9;\\n  parameter ADDR_WIDTH_R = 10;\\n  parameter DATA_DEPTH_R = 2 ** ADDR_WIDTH_R;\\n  parameter INIT_FILE = \\\"NONE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_DRAM16X4(\\n  input [3:0] di,\\n  input [3:0] waddr,\\n  input wclk,\\n  input we,\\n  input [3:0]raddr,\\n  output [3:0]do\\n);\\n  parameter INIT_D0=16'h0000;\\n  parameter INIT_D1=16'h0000;\\n  parameter INIT_D2=16'h0000;\\n  parameter INIT_D3=16'h0000;\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_MULT(\\n  output [OUTPUT_WIDTH-1:0] p,\\n  input [INPUT_WIDTH_A-1:0] a,\\n  input [INPUT_WIDTH_B-1:0] b,\\n  input cea,\\n  input ceb,\\n  input cepd,\\n  input clk,\\n  input rstan,\\n  input rstbn,\\n  input rstpdn\\n); \\n  parameter INPUT_WIDTH_A = 18;\\n  parameter INPUT_WIDTH_B = 18;\\n  parameter OUTPUT_WIDTH = 36;\\n  parameter INPUTFORMAT = \\\"SIGNED\\\";\\n  parameter INPUTREGA = \\\"ENABLE\\\";\\n  parameter INPUTREGB = \\\"ENABLE\\\";\\n  parameter OUTPUTREG = \\\"ENABLE\\\";\\n  parameter SRMODE = \\\"ASYNC\\\";\\n  parameter IMPLEMENT = \\\"AUTO\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_SEQ_DIV(\\n  input clk,\\n  input rst,\\n  input start,\\n  input [NUMER_WIDTH-1:0] numer,\\n  input [DENOM_WIDTH-1:0] denom,\\n  output [NUMER_WIDTH-1:0] quotient,\\n  output [DENOM_WIDTH-1:0] remain,\\n  output done\\n);\\n\\tparameter NUMER_WIDTH = 16;\\n  parameter DENOM_WIDTH = 16;\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_BRAM(\\n  output [8:0] doa,\\n  output [8:0] dob,\\n  input [8:0] dia,\\n  input [8:0] dib,\\n  input [2:0] csa,\\n  input [2:0] csb,\\n  input cea,\\n  input ocea,\\n  input clka,\\n  input wea,\\n  input rsta,\\n  input ceb,\\n  input oceb,\\n  input clkb,\\n  input web,\\n  input rstb,\\n  input [12:0] addra,\\n  input [12:0] addrb\\n);\\n  parameter MODE = \\\"DP8K\\\";\\n  parameter DATA_WIDTH_A = \\\"9\\\";\\n  parameter DATA_WIDTH_B = \\\"9\\\";\\n  parameter READBACK = \\\"OFF\\\";\\n  parameter REGMODE_A = \\\"NOREG\\\";\\n  parameter REGMODE_B = \\\"NOREG\\\";\\n  parameter WRITEMODE_A = \\\"NORMAL\\\";\\n  parameter WRITEMODE_B = \\\"NORMAL\\\";\\n  parameter GSR = \\\"ENABLE\\\";\\n  parameter RESETMODE = \\\"SYNC\\\";\\n  parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n  parameter CEAMUX = \\\"SIG\\\";\\n  parameter CEBMUX = \\\"SIG\\\";\\n  parameter OCEAMUX = \\\"SIG\\\";\\n  parameter OCEBMUX = \\\"SIG\\\";\\n  parameter RSTAMUX = \\\"SIG\\\";\\n  parameter RSTBMUX = \\\"SIG\\\";\\n  parameter CLKAMUX = \\\"SIG\\\";\\n  parameter CLKBMUX = \\\"SIG\\\";\\n  parameter WEAMUX = \\\"SIG\\\";\\n  parameter WEBMUX = \\\"SIG\\\";\\n  parameter CSA0 = \\\"SIG\\\" ;\\n  parameter CSA1 = \\\"SIG\\\" ;\\n  parameter CSA2 = \\\"SIG\\\" ;\\n  parameter CSB0 = \\\"SIG\\\" ;\\n  parameter CSB1 = \\\"SIG\\\" ;\\n  parameter CSB2 = \\\"SIG\\\" ;\\n  parameter INIT_FILE = \\\"NONE\\\";\\n  parameter INITP_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INITP_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INITP_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INITP_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_BRAM32K(\\n  output [15:0] doa,\\n  output [15:0] dob,\\n  input [15:0] dia,\\n  input [15:0] dib,\\n  input [10:0] addra,\\n  input [10:0] addrb,\\n  input bytea,\\n  input bytewea,\\n  input byteb,\\n  input byteweb,\\n  input csa,\\n  input wea,\\n  input csb,\\n  input web,\\n  input clka,\\n  input rsta,\\n  input clkb,\\n  input rstb,\\n  input ocea,\\n  input oceb\\n);\\n  parameter MODE = \\\"DP16K\\\";\\n  parameter DATA_WIDTH_A = \\\"16\\\";\\n  parameter DATA_WIDTH_B = \\\"16\\\";\\n  parameter REGMODE_A = \\\"NOREG\\\";\\n  parameter REGMODE_B = \\\"NOREG\\\";\\n  parameter WRITEMODE_A = \\\"NORMAL\\\";\\n  parameter WRITEMODE_B = \\\"NORMAL\\\";\\n  parameter SRMODE = \\\"SYNC\\\";\\n  parameter CSAMUX = \\\"SIG\\\";\\n  parameter CSBMUX = \\\"SIG\\\";\\n  parameter OCEAMUX = \\\"SIG\\\";\\n  parameter OCEBMUX = \\\"SIG\\\";\\n  parameter RSTAMUX = \\\"SIG\\\";\\n  parameter RSTBMUX = \\\"SIG\\\";\\n  parameter CLKAMUX = \\\"SIG\\\";\\n  parameter CLKBMUX = \\\"SIG\\\";\\n  parameter WEAMUX = \\\"SIG\\\";\\n  parameter WEBMUX = \\\"SIG\\\";\\n  parameter READBACK = \\\"OFF\\\";\\n  parameter INIT_FILE = \\\"\\\";\\n  parameter INIT_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_40 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_41 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_42 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_43 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_44 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_45 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_46 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_47 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_48 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_49 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_4A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_4B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_4C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_4D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_4E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_4F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_50 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_51 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_52 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_53 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_54 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_55 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_56 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_57 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_58 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_59 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_5A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_5B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_5C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_5D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_5E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_5F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_60 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_61 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_62 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_63 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_64 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_65 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_66 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_67 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_68 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_69 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_6A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_6B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_6C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_6D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_6E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_6F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_70 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_71 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_72 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_73 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_74 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_75 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_76 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_77 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_78 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_79 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_7A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_7B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_7C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_7D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_7E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n  parameter INIT_7F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_FIFO(\\n  input [8:0] dia,\\n  input [8:0] dib,\\n  input [2:0] csr,\\n  input [2:0] csw,\\n  input we,\\n  input re,\\n  input clkw,\\n  input clkr,\\n  input rst,\\n  input rprst,\\n  input orea,\\n  input oreb,\\n  output [8:0] dob,\\n  output [8:0] doa,\\n  output empty_flag,\\n  output aempty_flag,\\n  output afull_flag,\\n  output full_flag\\n);\\n  parameter MODE = \\\"FIFO8K\\\";\\n  parameter DATA_WIDTH_A = \\\"18\\\";\\n  parameter DATA_WIDTH_B = \\\"18\\\";\\n  parameter READBACK = \\\"OFF\\\";\\n  parameter REGMODE_A = \\\"NOREG\\\";\\n  parameter REGMODE_B = \\\"NOREG\\\";\\n  parameter [13:0] AE = 14'b00000001100000;\\n  parameter [13:0] AF = 14'b01111110010000;\\n  parameter [13:0] F = 14'b01111111110000;\\n  parameter [13:0] AEP1 = 14'b00000001110000;\\n  parameter [13:0] AFM1 = 14'b01111110000000;\\n  parameter [13:0] FM1  = 14'b01111111100000;   \\n  parameter [4:0] E = 5'b00000;\\n  parameter [5:0] EP1 = 6'b010000;\\n  parameter GSR = \\\"ENABLE\\\";\\n  parameter RESETMODE = \\\"ASYNC\\\";\\n  parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n  parameter CEA = \\\"SIG\\\";\\n  parameter CEB = \\\"SIG\\\";\\n  parameter OCEA = \\\"SIG\\\";\\n  parameter OCEB = \\\"SIG\\\";\\n  parameter RSTA = \\\"SIG\\\";\\n  parameter RSTB = \\\"SIG\\\";\\n  parameter CLKA = \\\"SIG\\\";\\n  parameter CLKB = \\\"SIG\\\";\\n  parameter WEA = \\\"SIG\\\";\\n  parameter WEB = \\\"SIG\\\";\\n  parameter CSA0 = \\\"SIG\\\";\\n  parameter CSA1 = \\\"SIG\\\";\\n  parameter CSA2 = \\\"SIG\\\";\\n  parameter CSB0 = \\\"SIG\\\";\\n  parameter CSB1 = \\\"SIG\\\";\\n  parameter CSB2 = \\\"SIG\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_MULT18(\\n  output [17:0] acout,\\n  output [17:0] bcout,\\n  output [35:0] p,\\n  input signeda,\\n  input signedb,\\n  input [17:0] a,\\n  input [17:0] b,\\n  input [17:0] acin,\\n  input [17:0] bcin,\\n  input cea,\\n  input ceb,\\n  input cepd,\\n  input clk,\\n  input rstan,\\n  input rstbn,\\n  input rstpdn,\\n  input sourcea,\\n  input sourceb  \\n); \\n  parameter INPUTREGA = \\\"ENABLE\\\";\\n  parameter INPUTREGB = \\\"ENABLE\\\";\\n  parameter OUTPUTREG = \\\"ENABLE\\\";\\n  parameter SRMODE = \\\"ASYNC\\\";\\n  parameter MODE = \\\"MULT18X18C\\\";\\n  parameter CEAMUX = \\\"SIG\\\";\\n  parameter CEBMUX = \\\"SIG\\\";\\n  parameter CEPDMUX = \\\"SIG\\\";\\n  parameter RSTANMUX = \\\"SIG\\\";\\n  parameter RSTBNMUX = \\\"SIG\\\";\\n  parameter RSTPDNMUX = \\\"SIG\\\";\\n  parameter CLKMUX = \\\"SIG\\\";\\n  parameter SIGNEDAMUX = \\\"SIG\\\";\\n  parameter SIGNEDBMUX = \\\"SIG\\\";\\n  parameter SOURCEAMUX = \\\"SIG\\\";\\n  parameter SOURCEBMUX = \\\"SIG\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_GCLK(\\n  input clki,\\n  output clko\\n);    \\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_IOCLK(\\n  input clki,\\n  input stop,\\n  output clko\\n);\\n  parameter STOPCLK = \\\"DISABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_CLKDIV(\\n  output clkdiv1,\\n  output clkdivx,\\n  input clki,\\n  input rst,\\n  input rls\\n);    \\n  parameter GSR = \\\"DISABLE\\\";\\n  parameter DIV = 2;\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_CONFIG(\\n  output jrstn,\\n  output [1:0] jrti,\\n  output jshift,\\n  output jtck,\\n  output jtdi,\\n  output jupdate,\\n  output [1:0] jscanen,\\n  output jtms,\\n  input [1:0] jtdo,\\n  input [7:0] jtag8_ipa,\\n  input [7:0] jtag8_ipb,\\n  output done,\\n  output highz,\\n  output cclk,\\n  input\\tcclk_en,\\n  input gsrn_sync_clk,\\n  input usr_gsrn,\\n  output dna_dout,\\n  input\\tdna_clk,\\n  input\\tdna_din,\\n  input\\tdna_shift_en,\\n  input\\tmboot_rebootn,\\n  input [7:0]\\tmboot_dynamic_addr\\n);  \\n  parameter MBOOT_AUTO_SEL = \\\"DISABLE\\\";\\n  parameter ADDR_SOURCE_SEL = \\\"STATIC\\\";\\n  parameter STATIC_ADDR = 8'b0;\\n  parameter DONE_PERSISTN = \\\"ENABLE\\\";\\n  parameter INIT_PERSISTN = \\\"ENABLE\\\";\\n  parameter PROGRAMN_PERSISTN = \\\"DISABLE\\\";\\n  parameter JTAG_PERSISTN = \\\"DISABLE\\\";\\n  parameter GSRN_SYNC_SEL = \\\"DISABLE\\\";\\n  parameter FREQ = \\\"2.5\\\";\\n  parameter USR_GSRN_EN = \\\"DISABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_OSC(\\n  input osc_dis,\\n  output osc_clk\\n);    \\n  parameter STDBY = \\\"DISABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_PWRMNT(\\n    output pwr_dwn_n,\\n    input sel_pwr,\\n    input pwr_mnt_pd\\n);\\n  parameter MNT_LVL = 0;\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_DDR_8M_16(\\n  input clk,\\n  input clk_n,\\n  input ras_n,\\n  input cas_n,\\n  input we_n,\\n  input cs_n,\\n  input [11:0] addr,\\n  input [1:0] ba,\\n  inout [15:0] dq,\\n  input ldqs,\\n  input udqs,\\n  input ldm,\\n  input udm,\\n  input cke\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_SDRAM_2M_32(\\n  input clk,\\n  input ras_n,\\n  input cas_n,\\n  input we_n,\\n  input [10:0] addr,\\n  input [1:0] ba,\\n  inout [31:0] dq,\\n  input cs_n,\\n  input dm0,\\n  input dm1,\\n  input dm2,\\n  input dm3,\\n  input cke\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_PAD(\\n  input ipad,\\n  output opad,\\n  inout bpad,\\n  input rst,\\n  input ce,\\n  input isclk,\\n  input ipclk,\\n  input osclk,\\n  input opclk,\\n  input ts,\\n  input [3:0] do,\\n  output di,\\n  output [3:0] diq\\n);\\n  parameter DEDCLK = \\\"DISABLE\\\";\\n  parameter GSR = \\\"ENABLE\\\";\\n  parameter SRMODE = \\\"SYNC\\\";\\n  parameter TSMUX = \\\"1\\\";\\n  parameter INSCLKMUX = \\\"0\\\";\\n  parameter INPCLKMUX = \\\"CLK\\\";\\n  parameter INCEMUX = \\\"CE\\\";\\n  parameter INRSTMUX = \\\"0\\\";\\n  parameter IN_REGSET = \\\"RESET\\\";\\n  parameter IN_DFFMODE = \\\"NONE\\\";\\n  parameter IDDRMODE = \\\"OFF\\\";\\n  parameter IDDRPIPEMODE = \\\"NONE\\\";\\n  parameter INDELMUX = \\\"NODEL\\\";\\n  parameter INDEL = 0;\\n  parameter OUTSCLKMUX = \\\"0\\\";\\n  parameter OUTPCLKMUX = \\\"CLK\\\";\\n  parameter OUTCEMUX = \\\"CE\\\";\\n  parameter OUTRSTMUX = \\\"0\\\";\\n  parameter DO_REGSET = \\\"RESET\\\";\\n  parameter DO_DFFMODE = \\\"NONE\\\";\\n  parameter ODDRMODE = \\\"OFF\\\";\\n  parameter OUTDELMUX = \\\"NODEL\\\";\\n  parameter OUTDEL = 0;\\n  parameter TO_REGSET = \\\"RESET\\\";\\n  parameter TO_DFFMODE = \\\"NONE\\\";\\n  parameter MODE = \\\"IN\\\";\\n  parameter DRIVE = \\\"NONE\\\";\\n  parameter IOTYPE = \\\"LVCMOS25\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_MSLICE(\\n  input [1:0] a,\\n  input [1:0] b,\\n  input [1:0] c,\\n  input [1:0] d,\\n  input [1:0] mi,\\n  input clk,\\n  input ce,\\n  input sr,\\n  input fci,\\n  output [1:0] f,\\n  output [1:0] fx,\\n  output [1:0] q,\\n  output fco,\\n  input dpram_mode,\\n  input [1:0] dpram_di,\\n  input dpram_we,\\n  input dpram_wclk,\\n  input [3:0] dpram_waddr\\n);\\n  parameter INIT_LUT0 = 16'h0000;\\n  parameter INIT_LUT1 = 16'h0000;\\n  parameter MODE = \\\"LOGIC\\\";\\n  parameter ALUTYPE = \\\"ADD\\\";\\n  parameter MSFXMUX = \\\"OFF\\\";\\n  parameter GSR = \\\"ENABLE\\\";\\n  parameter TESTMODE = \\\"OFF\\\";\\n  parameter CEMUX = \\\"CE\\\";\\n  parameter SRMUX = \\\"SR\\\";\\n  parameter CLKMUX = \\\"CLK\\\";\\n  parameter SRMODE = \\\"ASYNC\\\";\\n  parameter DFFMODE = \\\"FF\\\";\\n  parameter REG0_SD = \\\"MI\\\";\\n  parameter REG1_SD = \\\"MI\\\";\\n  parameter REG0_REGSET = \\\"SET\\\";\\n  parameter REG1_REGSET = \\\"SET\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_LSLICE(\\n  input [1:0] a,\\n  input [1:0] b,\\n  input [1:0] c,\\n  input [1:0] d,\\n  input [1:0] e,\\n  input [1:0] mi,\\n  input clk,\\n  input ce,\\n  input sr,\\n  input fci,\\n  output [1:0] f,\\n  output [1:0] fx,\\n  output [1:0] q,\\n  output fco,\\n  output [3:0] dpram_di,\\n  output [3:0] dpram_waddr,\\n  output dpram_wclk,\\n  output dpram_we,\\n  output dpram_mode\\n);\\n  parameter INIT_LUTF0 = 16'h0000;\\n  parameter INIT_LUTG0 = 16'h0000;\\n  parameter INIT_LUTF1 = 16'h0000;\\n  parameter INIT_LUTG1 = 16'h0000;\\n  parameter MODE = \\\"LOGIC\\\";\\n  parameter GSR = \\\"ENABLE\\\";\\n  parameter TESTMODE = \\\"OFF\\\";\\n  parameter CEMUX = \\\"1\\\";\\n  parameter SRMUX = \\\"SR\\\";\\n  parameter CLKMUX = \\\"CLK\\\";\\n  parameter SRMODE = \\\"ASYNC\\\";\\n  parameter DFFMODE = \\\"FF\\\";\\n  parameter REG0_SD = \\\"MI\\\";\\n  parameter REG1_SD = \\\"MI\\\";\\n  parameter REG0_REGSET = \\\"SET\\\";\\n  parameter REG1_REGSET = \\\"SET\\\";\\n  parameter DEMUX0 = \\\"D\\\";\\n  parameter DEMUX1 = \\\"D\\\";\\n  parameter CMIMUX0 = \\\"C\\\";\\n  parameter CMIMUX1 = \\\"C\\\";\\n  parameter LSFMUX0 = \\\"LUTF\\\";\\n  parameter LSFXMUX0 = \\\"LUTG\\\";\\n  parameter LSFMUX1 = \\\"LUTF\\\";\\n  parameter LSFXMUX1 = \\\"LUTG\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_PHY_PLL(\\n  output [4:0] clkc,\\n  output extlock,\\n  input stdby,\\n  input refclk,\\n  input fbclk,\\n  input reset,\\n  output psdone,\\n  input psclk,\\n  input psdown,\\n  input psstep,\\n  input [2:0] psclksel,\\n  output [7:0] do,\\n  input dclk,\\n  input dcs,\\n  input dwe,\\n  input [7:0] di,\\n  input [5:0] daddr\\n);\\n  parameter DYNCFG = \\\"DISABLE\\\";\\n  parameter IF_ESCLKSTSW = \\\"DISABLE\\\";\\n  parameter REFCLK_SEL = \\\"INTERNAL\\\";\\n  parameter FIN = \\\"100.0000\\\";\\n  parameter REFCLK_DIV = 1;\\n  parameter FBCLK_DIV = 1;\\n  parameter CLKC0_DIV = 1;\\n  parameter CLKC1_DIV = 1;\\n  parameter CLKC2_DIV = 1;\\n  parameter CLKC3_DIV = 1;\\n  parameter CLKC4_DIV = 1;\\n  parameter CLKC0_ENABLE = \\\"DISABLE\\\";\\n  parameter CLKC1_ENABLE = \\\"DISABLE\\\";\\n  parameter CLKC2_ENABLE = \\\"DISABLE\\\";\\n  parameter CLKC3_ENABLE = \\\"DISABLE\\\";\\n  parameter CLKC4_ENABLE = \\\"DISABLE\\\";\\n  parameter CLKC0_DIV2_ENABLE = \\\"DISABLE\\\";\\n  parameter CLKC1_DIV2_ENABLE = \\\"DISABLE\\\";\\n  parameter CLKC2_DIV2_ENABLE = \\\"DISABLE\\\";\\n  parameter CLKC3_DIV2_ENABLE = \\\"DISABLE\\\";\\n  parameter CLKC4_DIV2_ENABLE = \\\"DISABLE\\\";\\n  parameter FEEDBK_MODE = \\\"NORMAL\\\";\\n  parameter FEEDBK_PATH = \\\"VCO_PHASE_0\\\";  \\n  parameter STDBY_ENABLE = \\\"ENABLE\\\";\\n  parameter CLKC0_FPHASE = 0;\\n  parameter CLKC1_FPHASE = 0;\\n  parameter CLKC2_FPHASE = 0;\\n  parameter CLKC3_FPHASE = 0;\\n  parameter CLKC4_FPHASE = 0;\\n  parameter CLKC0_CPHASE = 1;\\n  parameter CLKC1_CPHASE = 1;\\n  parameter CLKC2_CPHASE = 1;\\n  parameter CLKC3_CPHASE = 1;\\n  parameter CLKC4_CPHASE = 1;\\n  parameter GMC_GAIN = 7;\\n  parameter GMC_TEST = 14;\\n  parameter ICP_CURRENT = 14;\\n  parameter KVCO = 7;\\n  parameter LPF_CAPACITOR = 3;\\n  parameter LPF_RESISTOR = 1;\\n  parameter PLLRST_ENA = \\\"ENABLE\\\";\\n  parameter PLLMRST_ENA = \\\"DISABLE\\\";\\n  parameter PLLC2RST_ENA = \\\"DISABLE\\\";\\n  parameter PLLC34RST_ENA = \\\"DISABLE\\\";\\n  parameter PREDIV_MUXC0 = \\\"VCO\\\";\\n  parameter PREDIV_MUXC1 = \\\"VCO\\\";\\n  parameter PREDIV_MUXC2 = \\\"VCO\\\";\\n  parameter PREDIV_MUXC3 = \\\"VCO\\\";\\n  parameter PREDIV_MUXC4 = \\\"VCO\\\";\\n  parameter ODIV_MUXC0 = \\\"DIV\\\";\\n  parameter ODIV_MUXC1 = \\\"DIV\\\";\\n  parameter ODIV_MUXC2 = \\\"DIV\\\";\\n  parameter ODIV_MUXC3 = \\\"DIV\\\";\\n  parameter ODIV_MUXC4 = \\\"DIV\\\";\\n  parameter FREQ_LOCK_ACCURACY = 2;\\n  parameter PLL_LOCK_MODE = 0;\\n  parameter INTFB_WAKE = \\\"DISABLE\\\";\\n  parameter DPHASE_SOURCE = \\\"DISABLE\\\";\\n  parameter VCO_NORESET = \\\"DISABLE\\\";\\n  parameter STDBY_VCO_ENA = \\\"DISABLE\\\";\\n  parameter NORESET = \\\"DISABLE\\\";\\n  parameter SYNC_ENABLE = \\\"ENABLE\\\";\\n  parameter DERIVE_PLL_CLOCKS = \\\"DISABLE\\\";\\n  parameter GEN_BASIC_CLOCK = \\\"DISABLE\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EG_LOGIC_BRAM(\\n  output [DATA_WIDTH_A-1:0] doa,\\n  output [DATA_WIDTH_B-1:0] dob,\\n  input [DATA_WIDTH_A-1:0] dia,\\n  input [DATA_WIDTH_B-1:0] dib,\\n  input cea,\\n  input ocea,\\n  input clka,\\n  input wea,\\n  input rsta,\\n  input ceb,\\n  input oceb,\\n  input clkb,\\n  input web,\\n  input rstb,\\n  input [BYTE_A - 1 : 0] bea,\\n  input [BYTE_B - 1 : 0] beb,\\n  input [ADDR_WIDTH_A-1:0] addra,\\n  input [ADDR_WIDTH_B-1:0] addrb\\n);\\n  parameter DATA_WIDTH_A = 9;\\n  parameter DATA_WIDTH_B = DATA_WIDTH_A;\\n  parameter ADDR_WIDTH_A = 10;\\n  parameter ADDR_WIDTH_B = ADDR_WIDTH_A;\\n  parameter DATA_DEPTH_A = 2 ** ADDR_WIDTH_A;\\n  parameter DATA_DEPTH_B = 2 ** ADDR_WIDTH_B;\\n  parameter BYTE_ENABLE = 0;\\n  parameter BYTE_A = BYTE_ENABLE == 0 ? 1 : DATA_WIDTH_A / BYTE_ENABLE;\\n  parameter BYTE_B = BYTE_ENABLE == 0 ? 1 : DATA_WIDTH_B / BYTE_ENABLE;  \\n  parameter MODE = \\\"DP\\\";\\n  parameter REGMODE_A = \\\"NOREG\\\";\\n  parameter REGMODE_B = \\\"NOREG\\\";\\n  parameter WRITEMODE_A = \\\"NORMAL\\\";\\n  parameter WRITEMODE_B = \\\"NORMAL\\\";\\n  parameter RESETMODE = \\\"SYNC\\\";\\n  parameter DEBUGGABLE = \\\"NO\\\";\\n  parameter PACKABLE = \\\"NO\\\";\\n  parameter FORCE_KEEP = \\\"OFF\\\";\\n  parameter INIT_FILE = \\\"NONE\\\";\\n  parameter FILL_ALL = \\\"NONE\\\";\\n  parameter IMPLEMENT = \\\"9K\\\";\\nendmodule     \\n\\n(* blackbox *)\\nmodule EG_PHY_ADC(\\n  input clk,\\n  input pd,\\n  input [2:0] s,\\n  input soc,\\n  output eoc,\\n  output [11:0] dout\\n);\\n  parameter CH0 = \\\"DISABLE\\\";\\n  parameter CH1 = \\\"DISABLE\\\";\\n  parameter CH2 = \\\"DISABLE\\\";\\n  parameter CH3 = \\\"DISABLE\\\";\\n  parameter CH4 = \\\"DISABLE\\\";\\n  parameter CH5 = \\\"DISABLE\\\";\\n  parameter CH6 = \\\"DISABLE\\\";\\n  parameter CH7 = \\\"DISABLE\\\";\\n  parameter VREF = \\\"DISABLE\\\";\\nendmodule\\n\",\n            \"lutrams.txt\": \"ram distributed $__ANLOGIC_DRAM16X4_ {\\n\\tabits 4;\\n\\twidth 4;\\n\\tcost 4;\\n\\tinit no_undef;\\n\\tprune_rom;\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\",\n            \"lutrams_map.v\": \"module $__ANLOGIC_DRAM16X4_ (...);\\n\\tparameter INIT = 64'b0;\\n\\n\\tinput PORT_W_CLK;\\n\\tinput [3:0] PORT_W_ADDR;\\n\\tinput [3:0] PORT_W_WR_DATA;\\n\\tinput PORT_W_WR_EN;\\n\\n\\tinput [3:0] PORT_R_ADDR;\\n\\toutput [3:0] PORT_R_RD_DATA;\\n\\n\\tfunction [15:0] init_slice;\\n\\t\\tinput integer idx;\\n\\t\\tinteger i;\\n\\t\\tfor (i = 0; i < 16; i = i + 1)\\n\\t\\t\\tinit_slice[i] = INIT[i * 4 + idx];\\n\\tendfunction\\n\\n\\tEG_LOGIC_DRAM16X4 #(\\n\\t\\t.INIT_D0(init_slice(0)),\\n\\t\\t.INIT_D1(init_slice(1)),\\n\\t\\t.INIT_D2(init_slice(2)),\\n\\t\\t.INIT_D3(init_slice(3))\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.di(PORT_W_WR_DATA),\\n\\t\\t.waddr(PORT_W_ADDR),\\n\\t\\t.wclk(PORT_W_CLK),\\n\\t\\t.we(PORT_W_WR_EN),\\n\\t\\t.raddr(PORT_R_ADDR),\\n\\t\\t.do(PORT_R_RD_DATA)\\n\\t);\\nendmodule\\n\",\n        },\n        \"cells.lib\": \"library(yosys_cells) {\\n\\tcell(DFF_N) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"!C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n\\tcell(DFF_P) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n\\tcell(DFF_NN0) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"!C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t\\tclear: \\\"!R\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(R) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n\\tcell(DFF_NN1) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"!C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t\\tpreset: \\\"!R\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(R) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n\\tcell(DFF_NP0) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"!C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t\\tclear: \\\"R\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(R) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n\\tcell(DFF_NP1) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"!C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t\\tpreset: \\\"R\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(R) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n\\tcell(DFF_PN0) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t\\tclear: \\\"!R\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(R) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n\\tcell(DFF_PN1) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t\\tpreset: \\\"!R\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(R) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n\\tcell(DFF_PP0) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t\\tclear: \\\"R\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(R) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n\\tcell(DFF_PP1) {\\n\\t\\tff(IQ, IQN) {\\n\\t\\t\\tclocked_on: \\\"C\\\";\\n\\t\\t\\tnext_state: \\\"D\\\";\\n\\t\\t\\tpreset: \\\"R\\\";\\n\\t\\t}\\n\\t\\tpin(D) { direction: input; }\\n\\t\\tpin(R) { direction: input; }\\n\\t\\tpin(C) { direction: input; clock: true; }\\n\\t\\tpin(Q) { direction: output; function: \\\"IQ\\\"; }\\n\\t}\\n}\\n\",\n        \"choices\": {\n            \"kogge-stone.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2024  Martin Povišer <povik@cutebit.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$lcu\\\" *)\\nmodule _80_lcu_kogge_stone (P, G, CI, CO);\\n\\tparameter WIDTH = 2;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] P, G;\\n\\tinput CI;\\n\\n\\t(* force_downto *)\\n\\toutput [WIDTH-1:0] CO;\\n\\n\\tinteger i, j;\\n\\t(* force_downto *)\\n\\treg [WIDTH-1:0] p, g;\\n\\n\\twire [1023:0] _TECHMAP_DO_ = \\\"proc; opt -fast\\\";\\n\\n\\talways @* begin\\n\\t\\tp = P;\\n\\t\\tg = G;\\n\\n\\t\\t// in almost all cases CI will be constant zero\\n\\t\\tg[0] = g[0] | (p[0] & CI);\\n\\n\\t\\tfor (i = 0; i < $clog2(WIDTH); i = i + 1) begin\\n\\t\\t\\t// iterate in reverse so we don't confuse a result from this stage and the previous\\n\\t\\t\\tfor (j = WIDTH - 1; j >= 2**i; j = j - 1) begin\\n\\t\\t\\t\\tg[j] = g[j] | p[j] & g[j - 2**i];\\n\\t\\t\\t\\tp[j] = p[j] & p[j - 2**i];\\n\\t\\t\\tend\\n\\t\\tend\\n\\tend\\n\\n\\tassign CO = g;\\nendmodule\\n\",\n        },\n        \"cmp2lcu.v\": \"// This pass performs an optimisation that decomposes wide arithmetic\\n//   comparisons into LUT-size chunks (as guided by the `LUT_WIDTH\\n//   macro) connected to a single lookahead-carry-unit $lcu cell,\\n//   which is typically mapped to dedicated (and fast) FPGA\\n//   carry-chains.\\n(* techmap_celltype = \\\"$lt $le $gt $ge\\\" *)\\nmodule _80_lcu_cmp_ (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\n(* force_downto *)\\ninput [A_WIDTH-1:0] A;\\n(* force_downto *)\\ninput [B_WIDTH-1:0] B;\\n(* force_downto *)\\noutput [Y_WIDTH-1:0] Y;\\n\\nparameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n\\ngenerate\\n    if (_TECHMAP_CELLTYPE_ == \\\"\\\" || `LUT_WIDTH < 2)\\n        wire _TECHMAP_FAIL_ = 1;\\n    else if (_TECHMAP_CELLTYPE_ == \\\"$lt\\\") begin\\n        // Transform $lt into $gt by swapping A and B\\n        $gt #(.A_SIGNED(B_SIGNED), .B_SIGNED(A_SIGNED), .A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(B), .B(A), .Y(Y));\\n    end\\n    else if (_TECHMAP_CELLTYPE_ == \\\"$le\\\") begin\\n        // Transform $le into $ge by swapping A and B\\n        $ge #(.A_SIGNED(B_SIGNED), .B_SIGNED(A_SIGNED), .A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(B), .B(A), .Y(Y));\\n    end\\n    else begin\\n        // Perform sign extension on A and B\\n        localparam WIDTH = A_WIDTH > B_WIDTH ? A_WIDTH : B_WIDTH;\\n        (* force_downto *)\\n        wire [WIDTH-1:0] AA = {{(WIDTH-A_WIDTH){A_SIGNED ? A[A_WIDTH-1] : 1'b0}}, A};\\n        (* force_downto *)\\n        wire [WIDTH-1:0] BB = {{(WIDTH-B_WIDTH){B_SIGNED ? B[B_WIDTH-1] : 1'b0}}, B};\\n        // For $ge operation, start with the assumption that A and B are\\n        //   equal (propagating this equality if A and B turn out to be so)\\n        localparam CI = _TECHMAP_CELLTYPE_ == \\\"$ge\\\";\\n        $__CMP2LCU #(.AB_WIDTH(WIDTH), .AB_SIGNED(A_SIGNED && B_SIGNED), .LCU_WIDTH(1), .BUDGET(`LUT_WIDTH), .CI(CI))\\n            _TECHMAP_REPLACE_ (.A(AA), .B(BB), .P(1'b1), .G(1'b0), .Y(Y));\\n    end\\nendgenerate\\nendmodule\\n\\nmodule $__CMP2LCU (A, B, P, G, Y);\\n\\nparameter AB_WIDTH = 0;\\nparameter AB_SIGNED = 0;\\nparameter LCU_WIDTH = 1;\\nparameter BUDGET = 0;\\nparameter CI = 0;\\n\\n(* force_downto *)\\ninput [AB_WIDTH-1:0] A; // A from original $gt/$ge\\n(* force_downto *)\\ninput [AB_WIDTH-1:0] B; // B from original $gt/$ge\\n(* force_downto *)\\ninput [LCU_WIDTH-1:0] P; // P of $lcu\\n(* force_downto *)\\ninput [LCU_WIDTH-1:0] G; // G of $lcu\\noutput Y;\\n\\nparameter [AB_WIDTH-1:0] _TECHMAP_CONSTMSK_A_ = 0;\\nparameter [AB_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;\\nparameter [LCU_WIDTH-1:0] _TECHMAP_CONSTMSK_P_ = 0;\\n\\ngenerate\\n    if (AB_WIDTH == 0) begin\\n        (* force_downto *)\\n        wire [LCU_WIDTH-1:0] CO;\\n        $lcu #(.WIDTH(LCU_WIDTH)) _TECHMAP_REPLACE_ (.P(P), .G(G), .CI(CI), .CO(CO));\\n        assign Y = CO[LCU_WIDTH-1];\\n    end\\n    else begin\\n        localparam COST =\\n            _TECHMAP_CONSTMSK_A_[AB_WIDTH-1:0] && _TECHMAP_CONSTMSK_B_[AB_WIDTH-1:0]\\n            ? 0\\n            : (_TECHMAP_CONSTMSK_A_[AB_WIDTH-1:0] || _TECHMAP_CONSTMSK_B_[AB_WIDTH-1:0]\\n                ? 1\\n                : 2);\\n\\n        if (BUDGET < COST)\\n             $__CMP2LCU #(.AB_WIDTH(AB_WIDTH), .AB_SIGNED(AB_SIGNED), .LCU_WIDTH(LCU_WIDTH+1), .BUDGET(`LUT_WIDTH), .CI(CI))\\n                _TECHMAP_REPLACE_ (.A(A), .B(B), .P({P, 1'b1}), .G({G, 1'b0}), .Y(Y));\\n        else begin\\n            wire PP, GG;\\n            // Bit-wise equality (xnor) of A and B\\n            assign PP = A[AB_WIDTH-1] ^~ B[AB_WIDTH-1];\\n            if (AB_SIGNED)\\n                assign GG = ~A[AB_WIDTH-1] & B[AB_WIDTH-1];\\n            else if (_TECHMAP_CONSTMSK_P_[LCU_WIDTH-1]) // First compare for LUT if P (and G) is constant\\n                assign GG = A[AB_WIDTH-1] & ~B[AB_WIDTH-1];\\n            else\\n                // Priority \\\"encoder\\\" that checks A[i] == 1'b1 && B[i] == 1'b0\\n                //   from MSB down, deferring to less significant bits if the\\n                //   MSBs are equal\\n                assign GG = P[0] & (A[AB_WIDTH-1] & ~B[AB_WIDTH-1]);\\n            (* force_downto *)\\n            wire [LCU_WIDTH-1:0] P_, G_;\\n            if (LCU_WIDTH == 1) begin\\n                // Propagate only if all pairs are equal\\n                //   (inconclusive evidence to say A >= B)\\n                assign P_ = P[0] & PP;\\n                // Generate if any comparisons call for it\\n                assign G_ = G[0] | GG;\\n            end\\n            else begin\\n                // Propagate only if all pairs are equal\\n                //   (inconclusive evidence to say A >= B)\\n                assign P_ = {P[LCU_WIDTH-1:1], P[0] & PP};\\n                // Generate if any comparisons call for it\\n                assign G_ = {G[LCU_WIDTH-1:1], G[0] | GG};\\n            end\\n            if (AB_WIDTH == 1)\\n               $__CMP2LCU #(.AB_WIDTH(AB_WIDTH-1), .AB_SIGNED(1'b0), .LCU_WIDTH(LCU_WIDTH), .BUDGET(BUDGET-COST), .CI(CI))\\n                    _TECHMAP_REPLACE_ (.A(), .B(), .P(P_), .G(G_), .Y(Y));\\n            else\\n               $__CMP2LCU #(.AB_WIDTH(AB_WIDTH-1), .AB_SIGNED(1'b0), .LCU_WIDTH(LCU_WIDTH), .BUDGET(BUDGET-COST), .CI(CI))\\n                    _TECHMAP_REPLACE_ (.A(A[AB_WIDTH-2:0]), .B(B[AB_WIDTH-2:0]), .P(P_), .G(G_), .Y(Y));\\n        end\\n    end\\nendgenerate\\nendmodule\\n\",\n        \"cmp2lut.v\": \"// Certain arithmetic operations between a signal of width n and a constant can be directly mapped\\n// to a single k-LUT (where n <= k). This is preferable to normal alumacc techmapping process\\n// because for many targets, arithmetic techmapping creates hard logic (such as carry cells) which often\\n// cannot be optimized further.\\n//\\n// TODO: Currently, only comparisons with 1-bit output are mapped. Potentially, all arithmetic cells\\n// with n <= k inputs should be techmapped in this way, because this shortens the critical path\\n// from n to 1 by avoiding carry chains.\\n\\n(* techmap_celltype = \\\"$lt $le $gt $ge\\\" *)\\nmodule _90_lut_cmp_ (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\n(* force_downto *)\\ninput [A_WIDTH-1:0] A;\\n(* force_downto *)\\ninput [B_WIDTH-1:0] B;\\n(* force_downto *)\\noutput [Y_WIDTH-1:0] Y;\\n\\nparameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n\\nparameter _TECHMAP_CONSTMSK_A_ = 0;\\nparameter _TECHMAP_CONSTVAL_A_ = 0;\\nparameter _TECHMAP_CONSTMSK_B_ = 0;\\nparameter _TECHMAP_CONSTVAL_B_ = 0;\\n\\nfunction automatic [(1 << `LUT_WIDTH)-1:0] gen_lut;\\n\\tinput integer width;\\n\\tinput integer operation;\\n\\tinput integer swap;\\n\\tinput integer sign;\\n\\tinput integer operand;\\n\\tinteger n, i_var, i_cst, lhs, rhs, o_bit;\\n\\tbegin\\n\\t\\tgen_lut = width'b0;\\n\\t\\tfor (n = 0; n < (1 << width); n++) begin\\n\\t\\t\\tif (sign)\\n\\t\\t\\t\\ti_var = n[width-1:0];\\n\\t\\t\\telse\\n\\t\\t\\t\\ti_var = n;\\n\\t\\t\\ti_cst = operand;\\n\\t\\t\\tif (swap) begin\\n\\t\\t\\t\\tlhs = i_cst;\\n\\t\\t\\t\\trhs = i_var;\\n\\t\\t\\tend else begin\\n\\t\\t\\t\\tlhs = i_var;\\n\\t\\t\\t\\trhs = i_cst;\\n\\t\\t\\tend\\n\\t\\t\\tif (operation == 0)\\n\\t\\t\\t\\to_bit = (lhs <  rhs);\\n\\t\\t\\tif (operation == 1)\\n\\t\\t\\t\\to_bit = (lhs <= rhs);\\n\\t\\t\\tif (operation == 2)\\n\\t\\t\\t\\to_bit = (lhs >  rhs);\\n\\t\\t\\tif (operation == 3)\\n\\t\\t\\t\\to_bit = (lhs >= rhs);\\n\\t\\t\\tgen_lut = gen_lut | (o_bit << n);\\n\\t\\tend\\n\\tend\\nendfunction\\n\\ngenerate\\n\\tlocalparam operation =\\n\\t\\t_TECHMAP_CELLTYPE_ == \\\"$lt\\\" ? 0 :\\n\\t\\t_TECHMAP_CELLTYPE_ == \\\"$le\\\" ? 1 :\\n\\t\\t_TECHMAP_CELLTYPE_ == \\\"$gt\\\" ? 2 :\\n\\t\\t_TECHMAP_CELLTYPE_ == \\\"$ge\\\" ? 3 :\\n\\t\\t-1;\\n\\n\\tif (A_WIDTH > `LUT_WIDTH || B_WIDTH > `LUT_WIDTH || Y_WIDTH != 1)\\n\\t\\twire _TECHMAP_FAIL_ = 1;\\n\\telse if (&_TECHMAP_CONSTMSK_B_)\\n\\t\\t\\\\$lut #(\\n\\t\\t\\t.WIDTH(A_WIDTH),\\n\\t\\t\\t.LUT({ gen_lut(A_WIDTH, operation, 0, A_SIGNED && B_SIGNED, _TECHMAP_CONSTVAL_B_) })\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t.A(A),\\n\\t\\t\\t.Y(Y)\\n\\t\\t);\\n\\telse if (&_TECHMAP_CONSTMSK_A_)\\n\\t\\t\\\\$lut #(\\n\\t\\t\\t.WIDTH(B_WIDTH),\\n\\t\\t\\t.LUT({ gen_lut(B_WIDTH, operation, 1, A_SIGNED && B_SIGNED, _TECHMAP_CONSTVAL_A_) })\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t.A(B),\\n\\t\\t\\t.Y(Y)\\n\\t\\t);\\n\\telse\\n\\t\\twire _TECHMAP_FAIL_ = 1;\\nendgenerate\\n\\nendmodule\\n\",\n        \"cmp2softlogic.v\": \"module constgtge(C, A, B, Y);\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\n\\n(* force_downto *)\\ninput [A_WIDTH-1:0] A;\\n(* force_downto *)\\ninput [B_WIDTH-1:0] B;\\noutput Y;\\ninput C;\\n\\nwire [A_WIDTH:0] ch;\\ngenvar n;\\ngenerate\\n\\tif (B_WIDTH > A_WIDTH) begin\\n\\t\\t// Fail\\n\\tend else begin\\n\\t\\tassign ch[0] = C;\\n\\t\\tfor (n = 0; n < A_WIDTH; n = n + 1) begin\\n\\t\\t\\tif (n < B_WIDTH) begin\\n\\t\\t\\t\\tassign ch[n + 1] = B[n] ? (ch[n] && A[n]) : (ch[n] || A[n]);\\n\\t\\t\\tend else begin\\n\\t\\t\\t\\tassign ch[n + 1] = ch[n] || A[n];\\n\\t\\t\\tend\\n\\t\\tend\\n\\t\\tassign Y = ch[A_WIDTH];\\n\\tend\\nendgenerate\\nendmodule\\n\\nmodule constltle(C, A, B, Y);\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\n\\n(* force_downto *)\\ninput [A_WIDTH-1:0] A;\\n(* force_downto *)\\ninput [B_WIDTH-1:0] B;\\noutput Y;\\ninput C;\\n\\nwire [A_WIDTH:0] ch;\\ngenvar n;\\ngenerate\\n\\tif (B_WIDTH > A_WIDTH) begin\\n\\t\\t// Fail\\n\\tend else begin\\n\\t\\tassign ch[0] = C;\\n\\t\\tfor (n = 0; n < A_WIDTH; n = n + 1) begin\\n\\t\\t\\tif (n < B_WIDTH) begin\\n\\t\\t\\t\\tassign ch[n + 1] = !B[n] ? (ch[n] && !A[n]) : (ch[n] || !A[n]);\\n\\t\\t\\tend else begin\\n\\t\\t\\t\\tassign ch[n + 1] = ch[n] && !A[n];\\n\\t\\t\\tend\\n\\t\\tend\\n\\t\\tassign Y = ch[A_WIDTH];\\n\\tend\\nendgenerate\\nendmodule\\n\\n(* techmap_celltype = \\\"$ge $gt $le $lt\\\" *)\\nmodule _map_const_cmp_(A, B, Y);\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\n\\n(* force_downto *)\\ninput [A_WIDTH-1:0] A;\\n(* force_downto *)\\ninput [B_WIDTH-1:0] B;\\n(* force_downto *)\\noutput [Y_WIDTH-1:0] Y;\\n\\nparameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n\\nparameter _TECHMAP_CONSTMSK_A_ = 0;\\nparameter _TECHMAP_CONSTVAL_A_ = 0;\\nparameter _TECHMAP_CONSTMSK_B_ = 0;\\nparameter _TECHMAP_CONSTVAL_B_ = 0;\\n\\nwire [1023:0] _TECHMAP_DO_ = \\\"opt -fast;\\\";\\n\\nwire [A_WIDTH:0] ch;\\n\\ngenvar n;\\ngenerate\\n\\tif (Y_WIDTH != 1 || A_SIGNED || B_SIGNED)\\n\\t\\twire _TECHMAP_FAIL_ = 1;\\n\\telse if (&_TECHMAP_CONSTMSK_A_) begin\\n\\t\\tif (A_WIDTH > B_WIDTH)\\n\\t\\t\\twire _TECHMAP_FAIL_ = 1;\\n\\t\\telse if (_TECHMAP_CELLTYPE_ == \\\"$lt\\\" || _TECHMAP_CELLTYPE_ == \\\"$le\\\")\\n\\t\\t\\tconstgtge #(.A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH))\\n\\t\\t\\t\\t_TECHMAP_REPLACE_(.A(B), .B(A), .Y(Y),\\n\\t\\t\\t\\t\\t.C(_TECHMAP_CELLTYPE_ == \\\"$lt\\\"));\\n\\t\\telse\\n\\t\\t\\tconstltle #(.A_WIDTH(B_WIDTH), .B_WIDTH(A_WIDTH))\\n\\t\\t\\t\\t_TECHMAP_REPLACE_(.A(B), .B(A), .Y(Y),\\n\\t\\t\\t\\t\\t.C(_TECHMAP_CELLTYPE_ == \\\"$gt\\\"));\\n\\tend else if (&_TECHMAP_CONSTMSK_B_) begin\\n\\t\\tif (B_WIDTH > A_WIDTH)\\n\\t\\t\\twire _TECHMAP_FAIL_ = 1;\\n\\t\\telse if (_TECHMAP_CELLTYPE_ == \\\"$lt\\\" || _TECHMAP_CELLTYPE_ == \\\"$le\\\")\\n\\t\\t\\tconstltle #(.A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH))\\n\\t\\t\\t\\t_TECHMAP_REPLACE_(.A(A), .B(B), .Y(Y),\\n\\t\\t\\t\\t\\t.C(_TECHMAP_CELLTYPE_ == \\\"$le\\\"));\\n\\t\\telse\\n\\t\\t\\tconstgtge #(.A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH))\\n\\t\\t\\t\\t_TECHMAP_REPLACE_(.A(A), .B(B), .Y(Y),\\n\\t\\t\\t\\t\\t.C(_TECHMAP_CELLTYPE_ == \\\"$ge\\\"));\\n\\tend else\\n\\t\\twire _TECHMAP_FAIL_ = 1;\\nendgenerate\\n\\nendmodule\\n\",\n        \"coolrunner2\": {\n            \"cells_counter_map.v\": \"module \\\\$__COUNT_ (CE, CLK, OUT, POUT, RST, UP);\\n\\n    input wire CE;\\n    input wire CLK;\\n    output wire OUT;\\n    (* force_downto *)\\n    output wire[WIDTH-1:0] POUT;\\n    input wire RST;\\n    input wire UP;\\n\\n    parameter COUNT_TO = 1;\\n    parameter RESET_MODE = \\\"RISING\\\";\\n    parameter RESET_TO_MAX = 0;\\n    parameter HAS_POUT = 0;\\n    parameter HAS_CE = 0;\\n    parameter WIDTH = 8;\\n    parameter DIRECTION = \\\"DOWN\\\";\\n\\n    if (DIRECTION == \\\"UP\\\") begin\\n        if (WIDTH < 2) begin\\n            initial begin\\n                $display(\\\"ERROR: \\\\$__COUNT_ must be at least 2 bits wide (bug in extract_counter pass?).\\\");\\n                $finish;\\n            end\\n        end\\n\\n        // FIXME: Max width?\\n\\n        assign OUT = POUT == COUNT_TO;\\n\\n        if (HAS_CE) begin\\n            genvar i;\\n            for (i = 0; i < WIDTH; i++) begin: countbits\\n                // each bit = (cur & !reset) ^ (all prev & !reset)\\n                wire xor_to_mc_bitn;\\n                FDCP #(\\n                    .INIT(0)\\n                ) bitn_ff (\\n                    .C(CLK),\\n                    .CLR(0),\\n                    .D(xor_to_mc_bitn),\\n                    .PRE(0),\\n                    .Q(POUT[i])\\n                );\\n                wire orterm_to_xor_bitn;\\n                wire pterm0_to_or_bitn;\\n                wire pterm1_to_or_bitn;\\n                MACROCELL_XOR #(\\n                    .INVERT_OUT(0)\\n                ) bitn_xor (\\n                    .IN_ORTERM(orterm_to_xor_bitn),\\n                    .IN_PTC(pterm1_to_or_bitn),\\n                    .OUT(xor_to_mc_bitn)\\n                );\\n                ORTERM #(\\n                    .WIDTH(1)\\n                ) bitn_or (\\n                    .IN(pterm0_to_or_bitn),\\n                    .OUT(orterm_to_xor_bitn)\\n                );\\n                ANDTERM #(\\n                    .COMP_INP(1),\\n                    .TRUE_INP(1)\\n                ) bitn_pterm0 (\\n                    .IN(POUT[i]),\\n                    .IN_B(OUT),\\n                    .OUT(pterm0_to_or_bitn)\\n                );\\n                ANDTERM #(\\n                    .COMP_INP(1),\\n                    .TRUE_INP(i + 1)\\n                ) bitn_pterm1 (\\n                    .IN({POUT[i-1:0], CE}),\\n                    .IN_B(OUT),\\n                    .OUT(pterm1_to_or_bitn)\\n                );\\n            end\\n        end else begin\\n            // Bit0 is special; toggle unless reset\\n            // cur  reset           out\\n            // 0    0               1\\n            // 0    1               0\\n            // 1    0               0\\n            // 1    1               0\\n            wire xor_to_mc_bit0;\\n            FDCP #(\\n                .INIT(0)\\n            ) bit0_ff (\\n                .C(CLK),\\n                .CLR(0),\\n                .D(xor_to_mc_bit0),\\n                .PRE(0),\\n                .Q(POUT[0])\\n            );\\n            wire pterm_to_xor_bit0;\\n            MACROCELL_XOR #(\\n                .INVERT_OUT(0)\\n            ) bit0_xor (\\n                .IN_PTC(pterm_to_xor_bit0),\\n                .OUT(xor_to_mc_bit0)\\n            );\\n            ANDTERM #(\\n                .COMP_INP(2),\\n                .TRUE_INP(0)\\n            ) bit0_pterm (\\n                .IN(),\\n                .IN_B({POUT[0], OUT}),\\n                .OUT(pterm_to_xor_bit0)\\n            );\\n\\n            genvar i;\\n            for (i = 1; i < WIDTH; i++) begin: countbits\\n                // each bit = (cur & !reset) ^ (all prev & !reset)\\n                wire xor_to_mc_bitn;\\n                FDCP #(\\n                    .INIT(0)\\n                ) bitn_ff (\\n                    .C(CLK),\\n                    .CLR(0),\\n                    .D(xor_to_mc_bitn),\\n                    .PRE(0),\\n                    .Q(POUT[i])\\n                );\\n                wire orterm_to_xor_bitn;\\n                wire pterm0_to_or_bitn;\\n                wire pterm1_to_or_bitn;\\n                MACROCELL_XOR #(\\n                    .INVERT_OUT(0)\\n                ) bitn_xor (\\n                    .IN_ORTERM(orterm_to_xor_bitn),\\n                    .IN_PTC(pterm1_to_or_bitn),\\n                    .OUT(xor_to_mc_bitn)\\n                );\\n                ORTERM #(\\n                    .WIDTH(1)\\n                ) bitn_or (\\n                    .IN(pterm0_to_or_bitn),\\n                    .OUT(orterm_to_xor_bitn)\\n                );\\n                ANDTERM #(\\n                    .COMP_INP(1),\\n                    .TRUE_INP(1)\\n                ) bitn_pterm0 (\\n                    .IN(POUT[i]),\\n                    .IN_B(OUT),\\n                    .OUT(pterm0_to_or_bitn)\\n                );\\n                ANDTERM #(\\n                    .COMP_INP(1),\\n                    .TRUE_INP(i)\\n                ) bitn_pterm1 (\\n                    .IN(POUT[i-1:0]),\\n                    .IN_B(OUT),\\n                    .OUT(pterm1_to_or_bitn)\\n                );\\n            end\\n        end\\n    end\\n\\n    // FIXME: down counters\\n\\nendmodule\\n\",\n            \"cells_latch.v\": \"module $_DLATCH_P_(input E, input D, output Q);\\n    LDCP _TECHMAP_REPLACE_ (\\n        .D(D),\\n        .G(E),\\n        .Q(Q),\\n        .PRE(1'b0),\\n        .CLR(1'b0)\\n        );\\nendmodule\\n\\nmodule $_DLATCH_N_(input E, input D, output Q);\\n    LDCP_N _TECHMAP_REPLACE_ (\\n        .D(D),\\n        .G(E),\\n        .Q(Q),\\n        .PRE(1'b0),\\n        .CLR(1'b0)\\n        );\\nendmodule\\n\",\n            \"cells_sim.v\": \"module IBUF(input I, output O);\\n    assign O = I;\\nendmodule\\n\\nmodule IOBUFE(input I, input E, output O, inout IO);\\n    assign O = IO;\\n    assign IO = E ? I : 1'bz;\\nendmodule\\n\\nmodule ANDTERM(IN, IN_B, OUT);\\n    parameter TRUE_INP = 0;\\n    parameter COMP_INP = 0;\\n\\n    input [TRUE_INP-1:0] IN;\\n    input [COMP_INP-1:0] IN_B;\\n    output reg OUT;\\n\\n    integer i;\\n\\n    always @(*) begin\\n        OUT = 1;\\n        for (i = 0; i < TRUE_INP; i=i+1)\\n            OUT = OUT & IN[i];\\n        for (i = 0; i < COMP_INP; i=i+1)\\n            OUT = OUT & ~IN_B[i];\\n    end\\nendmodule\\n\\nmodule ORTERM(IN, OUT);\\n    parameter WIDTH = 0;\\n\\n    input [WIDTH-1:0] IN;\\n    output reg OUT;\\n\\n    integer i;\\n\\n    always @(*) begin\\n        OUT = 0;\\n        for (i = 0; i < WIDTH; i=i+1) begin\\n            OUT = OUT | IN[i];\\n        end\\n    end\\nendmodule\\n\\nmodule MACROCELL_XOR(IN_PTC, IN_ORTERM, OUT);\\n    parameter INVERT_OUT = 0;\\n\\n    input IN_PTC;\\n    input IN_ORTERM;\\n    output wire OUT;\\n\\n    wire xor_intermed;\\n\\n    assign OUT = INVERT_OUT ? ~xor_intermed : xor_intermed;\\n    assign xor_intermed = IN_ORTERM ^ IN_PTC;\\nendmodule\\n\\nmodule FDCP (C, PRE, CLR, D, Q);\\n    parameter INIT = 0;\\n\\n    input C, PRE, CLR, D;\\n    output reg Q;\\n\\n    initial begin\\n        Q <= INIT;\\n    end\\n\\n    always @(posedge C, posedge PRE, posedge CLR) begin\\n        if (CLR == 1)\\n            Q <= 0;\\n        else if (PRE == 1)\\n            Q <= 1;\\n        else\\n            Q <= D;\\n    end\\nendmodule\\n\\nmodule FDCP_N (C, PRE, CLR, D, Q);\\n    parameter INIT = 0;\\n\\n    input C, PRE, CLR, D;\\n    output reg Q;\\n\\n    initial begin\\n        Q <= INIT;\\n    end\\n\\n    always @(negedge C, posedge PRE, posedge CLR) begin\\n        if (CLR == 1)\\n            Q <= 0;\\n        else if (PRE == 1)\\n            Q <= 1;\\n        else\\n            Q <= D;\\n    end\\nendmodule\\n\\nmodule LDCP (G, PRE, CLR, D, Q);\\n    parameter INIT = 0;\\n\\n    input G, PRE, CLR, D;\\n    output reg Q;\\n\\n    initial begin\\n        Q <= INIT;\\n    end\\n\\n    always @* begin\\n        if (CLR == 1)\\n            Q <= 0;\\n        else if (G == 1)\\n            Q <= D;\\n        else if (PRE == 1)\\n            Q <= 1;\\n    end\\nendmodule\\n\\nmodule LDCP_N (G, PRE, CLR, D, Q);\\n    parameter INIT = 0;\\n\\n    input G, PRE, CLR, D;\\n    output reg Q;\\n\\n    initial begin\\n        Q <= INIT;\\n    end\\n\\n    always @* begin\\n        if (CLR == 1)\\n            Q <= 0;\\n        else if (G == 0)\\n            Q <= D;\\n        else if (PRE == 1)\\n            Q <= 1;\\n    end\\nendmodule\\n\\nmodule BUFG(I, O);\\n    input I;\\n    output O;\\n\\n    assign O = I;\\nendmodule\\n\\nmodule BUFGSR(I, O);\\n    parameter INVERT = 0;\\n\\n    input I;\\n    output O;\\n\\n    assign O = INVERT ? ~I : I;\\nendmodule\\n\\nmodule BUFGTS(I, O);\\n    parameter INVERT = 0;\\n\\n    input I;\\n    output O;\\n\\n    assign O = INVERT ? ~I : I;\\nendmodule\\n\\nmodule FDDCP (C, PRE, CLR, D, Q);\\n    parameter INIT = 0;\\n\\n    input C, PRE, CLR, D;\\n    output reg Q;\\n\\n    initial begin\\n        Q <= INIT;\\n    end\\n\\n    always @(posedge C, negedge C, posedge PRE, posedge CLR) begin\\n        if (CLR == 1)\\n            Q <= 0;\\n        else if (PRE == 1)\\n            Q <= 1;\\n        else\\n            Q <= D;\\n    end\\nendmodule\\n\\nmodule FTCP (C, PRE, CLR, T, Q);\\n    parameter INIT = 0;\\n\\n    input C, PRE, CLR, T;\\n    output wire Q;\\n    reg Q_;\\n\\n    initial begin\\n        Q_ <= INIT;\\n    end\\n\\n    always @(posedge C, posedge PRE, posedge CLR) begin\\n        if (CLR == 1)\\n            Q_ <= 0;\\n        else if (PRE == 1)\\n            Q_ <= 1;\\n        else if (T == 1)\\n            Q_ <= ~Q_;\\n    end\\n\\n    assign Q = Q_;\\nendmodule\\n\\nmodule FTCP_N (C, PRE, CLR, T, Q);\\n    parameter INIT = 0;\\n\\n    input C, PRE, CLR, T;\\n    output wire Q;\\n    reg Q_;\\n\\n    initial begin\\n        Q_ <= INIT;\\n    end\\n\\n    always @(negedge C, posedge PRE, posedge CLR) begin\\n        if (CLR == 1)\\n            Q_ <= 0;\\n        else if (PRE == 1)\\n            Q_ <= 1;\\n        else if (T == 1)\\n            Q_ <= ~Q_;\\n    end\\n\\n    assign Q = Q_;\\nendmodule\\n\\nmodule FTDCP (C, PRE, CLR, T, Q);\\n    parameter INIT = 0;\\n\\n    input C, PRE, CLR, T;\\n    output wire Q;\\n    reg Q_;\\n\\n    initial begin\\n        Q_ <= INIT;\\n    end\\n\\n    always @(posedge C, negedge C, posedge PRE, posedge CLR) begin\\n        if (CLR == 1)\\n            Q_ <= 0;\\n        else if (PRE == 1)\\n            Q_ <= 1;\\n        else if (T == 1)\\n            Q_ <= ~Q_;\\n    end\\n\\n    assign Q = Q_;\\nendmodule\\n\\nmodule FDCPE (C, PRE, CLR, D, Q, CE);\\n    parameter INIT = 0;\\n\\n    input C, PRE, CLR, D, CE;\\n    output reg Q;\\n\\n    initial begin\\n        Q <= INIT;\\n    end\\n\\n    always @(posedge C, posedge PRE, posedge CLR) begin\\n        if (CLR == 1)\\n            Q <= 0;\\n        else if (PRE == 1)\\n            Q <= 1;\\n        else if (CE == 1)\\n            Q <= D;\\n    end\\nendmodule\\n\\nmodule FDCPE_N (C, PRE, CLR, D, Q, CE);\\n    parameter INIT = 0;\\n\\n    input C, PRE, CLR, D, CE;\\n    output reg Q;\\n\\n    initial begin\\n        Q <= INIT;\\n    end\\n\\n    always @(negedge C, posedge PRE, posedge CLR) begin\\n        if (CLR == 1)\\n            Q <= 0;\\n        else if (PRE == 1)\\n            Q <= 1;\\n        else if (CE == 1)\\n            Q <= D;\\n    end\\nendmodule\\n\\nmodule FDDCPE (C, PRE, CLR, D, Q, CE);\\n    parameter INIT = 0;\\n\\n    input C, PRE, CLR, D, CE;\\n    output reg Q;\\n\\n    initial begin\\n        Q <= INIT;\\n    end\\n\\n    always @(posedge C, negedge C, posedge PRE, posedge CLR) begin\\n        if (CLR == 1)\\n            Q <= 0;\\n        else if (PRE == 1)\\n            Q <= 1;\\n        else if (CE == 1)\\n            Q <= D;\\n    end\\nendmodule\\n\",\n            \"tff_extract.v\": \"module FTCP (C, PRE, CLR, T, Q);\\n\\tinput C, PRE, CLR, T;\\n\\toutput wire Q;\\n\\n\\twire xorout;\\n\\n\\t$_XOR_ xorgate (\\n\\t\\t.A(T),\\n\\t\\t.B(Q),\\n\\t\\t.Y(xorout),\\n\\t);\\n\\n\\t$_DFFSR_PPP_ dff (\\n\\t\\t.C(C),\\n\\t\\t.D(xorout),\\n\\t\\t.Q(Q),\\n\\t\\t.S(PRE),\\n\\t\\t.R(CLR),\\n\\t);\\nendmodule\\n\\nmodule FTCP_N (C, PRE, CLR, T, Q);\\n\\tinput C, PRE, CLR, T;\\n\\toutput wire Q;\\n\\n\\twire xorout;\\n\\n\\t$_XOR_ xorgate (\\n\\t\\t.A(T),\\n\\t\\t.B(Q),\\n\\t\\t.Y(xorout),\\n\\t);\\n\\n\\t$_DFFSR_NPP_ dff (\\n\\t\\t.C(C),\\n\\t\\t.D(xorout),\\n\\t\\t.Q(Q),\\n\\t\\t.S(PRE),\\n\\t\\t.R(CLR),\\n\\t);\\nendmodule\\n\",\n            \"xc2_dff.lib\": \"library(xc2_dff) {\\n  cell(FDCP) {\\n    area: 1;\\n    ff(\\\"IQ\\\", \\\"IQN\\\") { clocked_on: C;\\n                      next_state: D;\\n                      clear: \\\"CLR\\\";\\n                      preset: \\\"PRE\\\"; }\\n    pin(C) { direction: input;\\n             clock: true; }\\n    pin(D) { direction: input; }\\n    pin(Q) { direction: output;\\n             function: \\\"IQ\\\"; }\\n    pin(CLR) { direction: input; }\\n    pin(PRE) { direction: input; }\\n  }\\n\\n  cell(FDCP_N) {\\n    area: 1;\\n    ff(\\\"IQ\\\", \\\"IQN\\\") { clocked_on: \\\"!C\\\";\\n                      next_state: D;\\n                      clear: \\\"CLR\\\";\\n                      preset: \\\"PRE\\\"; }\\n    pin(C) { direction: input;\\n             clock: true; }\\n    pin(D) { direction: input; }\\n    pin(Q) { direction: output;\\n             function: \\\"IQ\\\"; }\\n    pin(CLR) { direction: input; }\\n    pin(PRE) { direction: input; }\\n  }\\n}\\n\",\n        },\n        \"dff2ff.v\": \"(* techmap_celltype = \\\"$dff\\\" *)\\nmodule dff2ff (CLK, D, Q);\\n\\tparameter WIDTH = 1;\\n\\tparameter CLK_POLARITY = 1;\\n\\n\\tinput CLK;\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] D;\\n\\t(* force_downto *)\\n\\toutput reg [WIDTH-1:0] Q;\\n\\n\\twire [1023:0] _TECHMAP_DO_ = \\\"proc;;\\\";\\n\\n\\talways @($global_clock)\\n\\t\\tQ <= D;\\nendmodule\\n\",\n        \"ecp5\": {\n            \"arith_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *  Copyright (C) 2018  gatecat <gatecat@ds0.me>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_ecp5_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 4;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\tfunction integer round_up2;\\n\\t\\tinput integer N;\\n\\t\\tbegin\\n\\t\\t\\tround_up2 = ((N + 1) / 2) * 2;\\n\\t\\tend\\n\\tendfunction\\n\\n\\tlocalparam Y_WIDTH2 = round_up2(Y_WIDTH);\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] BX = B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] C = {CO, CI};\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] FCO, Y1;\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice\\n\\t\\tCCU2C #(\\n\\t\\t\\t.INIT0(16'b1001011010101010),\\n\\t\\t\\t.INIT1(16'b1001011010101010),\\n\\t\\t\\t.INJECT1_0(\\\"NO\\\"),\\n\\t\\t\\t.INJECT1_1(\\\"NO\\\")\\n\\t   ) ccu2c_i (\\n\\t\\t\\t.CIN(C[i]),\\n\\t\\t\\t.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b1),\\n\\t\\t\\t.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b1),\\n\\t\\t\\t.S0(Y[i]), .S1(Y1[i]),\\n\\t\\t\\t.COUT(FCO[i])\\n\\t\\t);\\n\\n\\t\\tassign CO[i] = (AA[i] && BB[i]) || (C[i] && (AA[i] || BB[i]));\\n\\t\\tif (i+1 < Y_WIDTH) begin\\n\\t\\t\\tassign CO[i+1] = FCO[i];\\n\\t\\t\\tassign Y[i+1] = Y1[i];\\n\\t\\tend\\n\\tend endgenerate\\n\\n\\tassign X = AA ^ BB;\\nendmodule\\n\",\n            \"brams.txt\": \"ram block $__ECP5_DP16KD_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 per_port;\\n\\tbyte 9;\\n\\tcost 128;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\twrbe_separate;\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"NORMAL\\\" {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"WRITETHROUGH\\\" {\\n\\t\\t\\trdwr new;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"READBEFOREWRITE\\\" {\\n\\t\\t\\trdwr old;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated block_wr;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n}\\n\\nram block $__ECP5_PDPW16KD_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 36 per_port;\\n\\tbyte 9;\\n\\tcost 128;\\n\\tinit no_undef;\\n\\tport sr \\\"R\\\" {\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\toption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n\\tport sw \\\"W\\\" {\\n\\t\\twidth 36;\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t}\\n}\\n\",\n            \"brams_map.v\": \"module $__ECP5_DP16KD_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESETMODE = \\\"SYNC\\\";\\n\\nparameter PORT_A_WIDTH = 18;\\nparameter PORT_A_WR_BE_WIDTH = 2;\\nparameter PORT_A_CLK_POL = 1;\\nparameter PORT_A_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput PORT_A_WR_EN;\\ninput PORT_A_RD_SRST;\\ninput PORT_A_RD_ARST;\\ninput [13:0] PORT_A_ADDR;\\ninput [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\n\\nparameter PORT_B_WIDTH = 18;\\nparameter PORT_B_WR_BE_WIDTH = 2;\\nparameter PORT_B_CLK_POL = 1;\\nparameter PORT_B_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput PORT_B_WR_EN;\\ninput PORT_B_RD_SRST;\\ninput PORT_B_RD_ARST;\\ninput [13:0] PORT_B_ADDR;\\ninput [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\n\\nfunction [319:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i, j;\\n\\tinit_slice = 0;\\n\\tfor (i = 0; i < 16; i = i + 1) begin\\n\\t\\tinit_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];\\n\\tend\\nendfunction\\n\\nwire [17:0] DOA;\\nwire [17:0] DOB;\\nwire [17:0] DIA = PORT_A_WR_DATA;\\nwire [17:0] DIB = PORT_B_WR_DATA;\\n\\nassign PORT_A_RD_DATA = DOA;\\nassign PORT_B_RD_DATA = DOB;\\n\\nDP16KD #(\\n\\t.INITVAL_00(init_slice('h00)),\\n\\t.INITVAL_01(init_slice('h01)),\\n\\t.INITVAL_02(init_slice('h02)),\\n\\t.INITVAL_03(init_slice('h03)),\\n\\t.INITVAL_04(init_slice('h04)),\\n\\t.INITVAL_05(init_slice('h05)),\\n\\t.INITVAL_06(init_slice('h06)),\\n\\t.INITVAL_07(init_slice('h07)),\\n\\t.INITVAL_08(init_slice('h08)),\\n\\t.INITVAL_09(init_slice('h09)),\\n\\t.INITVAL_0A(init_slice('h0a)),\\n\\t.INITVAL_0B(init_slice('h0b)),\\n\\t.INITVAL_0C(init_slice('h0c)),\\n\\t.INITVAL_0D(init_slice('h0d)),\\n\\t.INITVAL_0E(init_slice('h0e)),\\n\\t.INITVAL_0F(init_slice('h0f)),\\n\\t.INITVAL_10(init_slice('h10)),\\n\\t.INITVAL_11(init_slice('h11)),\\n\\t.INITVAL_12(init_slice('h12)),\\n\\t.INITVAL_13(init_slice('h13)),\\n\\t.INITVAL_14(init_slice('h14)),\\n\\t.INITVAL_15(init_slice('h15)),\\n\\t.INITVAL_16(init_slice('h16)),\\n\\t.INITVAL_17(init_slice('h17)),\\n\\t.INITVAL_18(init_slice('h18)),\\n\\t.INITVAL_19(init_slice('h19)),\\n\\t.INITVAL_1A(init_slice('h1a)),\\n\\t.INITVAL_1B(init_slice('h1b)),\\n\\t.INITVAL_1C(init_slice('h1c)),\\n\\t.INITVAL_1D(init_slice('h1d)),\\n\\t.INITVAL_1E(init_slice('h1e)),\\n\\t.INITVAL_1F(init_slice('h1f)),\\n\\t.INITVAL_20(init_slice('h20)),\\n\\t.INITVAL_21(init_slice('h21)),\\n\\t.INITVAL_22(init_slice('h22)),\\n\\t.INITVAL_23(init_slice('h23)),\\n\\t.INITVAL_24(init_slice('h24)),\\n\\t.INITVAL_25(init_slice('h25)),\\n\\t.INITVAL_26(init_slice('h26)),\\n\\t.INITVAL_27(init_slice('h27)),\\n\\t.INITVAL_28(init_slice('h28)),\\n\\t.INITVAL_29(init_slice('h29)),\\n\\t.INITVAL_2A(init_slice('h2a)),\\n\\t.INITVAL_2B(init_slice('h2b)),\\n\\t.INITVAL_2C(init_slice('h2c)),\\n\\t.INITVAL_2D(init_slice('h2d)),\\n\\t.INITVAL_2E(init_slice('h2e)),\\n\\t.INITVAL_2F(init_slice('h2f)),\\n\\t.INITVAL_30(init_slice('h30)),\\n\\t.INITVAL_31(init_slice('h31)),\\n\\t.INITVAL_32(init_slice('h32)),\\n\\t.INITVAL_33(init_slice('h33)),\\n\\t.INITVAL_34(init_slice('h34)),\\n\\t.INITVAL_35(init_slice('h35)),\\n\\t.INITVAL_36(init_slice('h36)),\\n\\t.INITVAL_37(init_slice('h37)),\\n\\t.INITVAL_38(init_slice('h38)),\\n\\t.INITVAL_39(init_slice('h39)),\\n\\t.INITVAL_3A(init_slice('h3a)),\\n\\t.INITVAL_3B(init_slice('h3b)),\\n\\t.INITVAL_3C(init_slice('h3c)),\\n\\t.INITVAL_3D(init_slice('h3d)),\\n\\t.INITVAL_3E(init_slice('h3e)),\\n\\t.INITVAL_3F(init_slice('h3f)),\\n\\t.DATA_WIDTH_A(PORT_A_WIDTH),\\n\\t.DATA_WIDTH_B(PORT_B_WIDTH),\\n\\t.REGMODE_A(\\\"NOREG\\\"),\\n\\t.REGMODE_B(\\\"NOREG\\\"),\\n\\t.RESETMODE(OPTION_RESETMODE),\\n\\t.ASYNC_RESET_RELEASE(OPTION_RESETMODE),\\n\\t.CSDECODE_A(\\\"0b000\\\"),\\n\\t.CSDECODE_B(\\\"0b000\\\"),\\n\\t.CLKAMUX(PORT_A_CLK_POL ? \\\"CLKA\\\" : \\\"INV\\\"),\\n\\t.CLKBMUX(PORT_B_CLK_POL ? \\\"CLKB\\\" : \\\"INV\\\"),\\n\\t.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),\\n\\t.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),\\n\\t.GSR(\\\"AUTO\\\")\\n) _TECHMAP_REPLACE_ (\\n\\t.CLKA(PORT_A_CLK),\\n\\t.WEA(PORT_A_WIDTH == 18 ? PORT_A_WR_EN : (PORT_A_WR_EN | PORT_A_WR_BE[0])),\\n\\t.CEA(PORT_A_CLK_EN),\\n\\t.OCEA(1'b1),\\n\\t.RSTA(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST),\\n\\t.CSA0(1'b0),\\n\\t.CSA1(1'b0),\\n\\t.CSA2(1'b0),\\n\\t.ADA0(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[0] : PORT_A_ADDR[0]),\\n\\t.ADA1(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[1] : PORT_A_ADDR[1]),\\n\\t.ADA2(PORT_A_ADDR[2]),\\n\\t.ADA3(PORT_A_ADDR[3]),\\n\\t.ADA4(PORT_A_ADDR[4]),\\n\\t.ADA5(PORT_A_ADDR[5]),\\n\\t.ADA6(PORT_A_ADDR[6]),\\n\\t.ADA7(PORT_A_ADDR[7]),\\n\\t.ADA8(PORT_A_ADDR[8]),\\n\\t.ADA9(PORT_A_ADDR[9]),\\n\\t.ADA10(PORT_A_ADDR[10]),\\n\\t.ADA11(PORT_A_ADDR[11]),\\n\\t.ADA12(PORT_A_ADDR[12]),\\n\\t.ADA13(PORT_A_ADDR[13]),\\n\\t.DIA0(DIA[0]),\\n\\t.DIA1(DIA[1]),\\n\\t.DIA2(DIA[2]),\\n\\t.DIA3(DIA[3]),\\n\\t.DIA4(DIA[4]),\\n\\t.DIA5(DIA[5]),\\n\\t.DIA6(DIA[6]),\\n\\t.DIA7(DIA[7]),\\n\\t.DIA8(DIA[8]),\\n\\t.DIA9(DIA[9]),\\n\\t.DIA10(DIA[10]),\\n\\t.DIA11(DIA[11]),\\n\\t.DIA12(DIA[12]),\\n\\t.DIA13(DIA[13]),\\n\\t.DIA14(DIA[14]),\\n\\t.DIA15(DIA[15]),\\n\\t.DIA16(DIA[16]),\\n\\t.DIA17(DIA[17]),\\n\\t.DOA0(DOA[0]),\\n\\t.DOA1(DOA[1]),\\n\\t.DOA2(DOA[2]),\\n\\t.DOA3(DOA[3]),\\n\\t.DOA4(DOA[4]),\\n\\t.DOA5(DOA[5]),\\n\\t.DOA6(DOA[6]),\\n\\t.DOA7(DOA[7]),\\n\\t.DOA8(DOA[8]),\\n\\t.DOA9(DOA[9]),\\n\\t.DOA10(DOA[10]),\\n\\t.DOA11(DOA[11]),\\n\\t.DOA12(DOA[12]),\\n\\t.DOA13(DOA[13]),\\n\\t.DOA14(DOA[14]),\\n\\t.DOA15(DOA[15]),\\n\\t.DOA16(DOA[16]),\\n\\t.DOA17(DOA[17]),\\n\\n\\t.CLKB(PORT_B_CLK),\\n\\t.WEB(PORT_B_WIDTH == 18 ? PORT_B_WR_EN : (PORT_B_WR_EN | PORT_B_WR_BE[0])),\\n\\t.CEB(PORT_B_CLK_EN),\\n\\t.OCEB(1'b1),\\n\\t.RSTB(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_B_RD_SRST : PORT_B_RD_ARST),\\n\\t.CSB0(1'b0),\\n\\t.CSB1(1'b0),\\n\\t.CSB2(1'b0),\\n\\t.ADB0(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[0] : PORT_B_ADDR[0]),\\n\\t.ADB1(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[1] : PORT_B_ADDR[1]),\\n\\t.ADB2(PORT_B_ADDR[2]),\\n\\t.ADB3(PORT_B_ADDR[3]),\\n\\t.ADB4(PORT_B_ADDR[4]),\\n\\t.ADB5(PORT_B_ADDR[5]),\\n\\t.ADB6(PORT_B_ADDR[6]),\\n\\t.ADB7(PORT_B_ADDR[7]),\\n\\t.ADB8(PORT_B_ADDR[8]),\\n\\t.ADB9(PORT_B_ADDR[9]),\\n\\t.ADB10(PORT_B_ADDR[10]),\\n\\t.ADB11(PORT_B_ADDR[11]),\\n\\t.ADB12(PORT_B_ADDR[12]),\\n\\t.ADB13(PORT_B_ADDR[13]),\\n\\t.DIB0(DIB[0]),\\n\\t.DIB1(DIB[1]),\\n\\t.DIB2(DIB[2]),\\n\\t.DIB3(DIB[3]),\\n\\t.DIB4(DIB[4]),\\n\\t.DIB5(DIB[5]),\\n\\t.DIB6(DIB[6]),\\n\\t.DIB7(DIB[7]),\\n\\t.DIB8(DIB[8]),\\n\\t.DIB9(DIB[9]),\\n\\t.DIB10(DIB[10]),\\n\\t.DIB11(DIB[11]),\\n\\t.DIB12(DIB[12]),\\n\\t.DIB13(DIB[13]),\\n\\t.DIB14(DIB[14]),\\n\\t.DIB15(DIB[15]),\\n\\t.DIB16(DIB[16]),\\n\\t.DIB17(DIB[17]),\\n\\t.DOB0(DOB[0]),\\n\\t.DOB1(DOB[1]),\\n\\t.DOB2(DOB[2]),\\n\\t.DOB3(DOB[3]),\\n\\t.DOB4(DOB[4]),\\n\\t.DOB5(DOB[5]),\\n\\t.DOB6(DOB[6]),\\n\\t.DOB7(DOB[7]),\\n\\t.DOB8(DOB[8]),\\n\\t.DOB9(DOB[9]),\\n\\t.DOB10(DOB[10]),\\n\\t.DOB11(DOB[11]),\\n\\t.DOB12(DOB[12]),\\n\\t.DOB13(DOB[13]),\\n\\t.DOB14(DOB[14]),\\n\\t.DOB15(DOB[15]),\\n\\t.DOB16(DOB[16]),\\n\\t.DOB17(DOB[17]),\\n);\\n\\nendmodule\\n\\n\\nmodule $__ECP5_PDPW16KD_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESETMODE = \\\"SYNC\\\";\\n\\nparameter PORT_R_WIDTH = 36;\\nparameter PORT_R_CLK_POL = 1;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput PORT_R_RD_SRST;\\ninput PORT_R_RD_ARST;\\ninput [13:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\n\\nparameter PORT_W_WIDTH = 36;\\nparameter PORT_W_WR_EN_WIDTH = 4;\\nparameter PORT_W_CLK_POL = 1;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput [13:0] PORT_W_ADDR;\\ninput [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\n\\nfunction [319:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i, j;\\n\\tinit_slice = 0;\\n\\tfor (i = 0; i < 16; i = i + 1) begin\\n\\t\\tinit_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];\\n\\tend\\nendfunction\\n\\nwire [35:0] DI = PORT_W_WR_DATA;\\nwire [35:0] DO;\\n\\nassign PORT_R_RD_DATA = PORT_R_WIDTH == 36 ? DO : DO[35:18];\\n\\nDP16KD #(\\n\\t.INITVAL_00(init_slice('h00)),\\n\\t.INITVAL_01(init_slice('h01)),\\n\\t.INITVAL_02(init_slice('h02)),\\n\\t.INITVAL_03(init_slice('h03)),\\n\\t.INITVAL_04(init_slice('h04)),\\n\\t.INITVAL_05(init_slice('h05)),\\n\\t.INITVAL_06(init_slice('h06)),\\n\\t.INITVAL_07(init_slice('h07)),\\n\\t.INITVAL_08(init_slice('h08)),\\n\\t.INITVAL_09(init_slice('h09)),\\n\\t.INITVAL_0A(init_slice('h0a)),\\n\\t.INITVAL_0B(init_slice('h0b)),\\n\\t.INITVAL_0C(init_slice('h0c)),\\n\\t.INITVAL_0D(init_slice('h0d)),\\n\\t.INITVAL_0E(init_slice('h0e)),\\n\\t.INITVAL_0F(init_slice('h0f)),\\n\\t.INITVAL_10(init_slice('h10)),\\n\\t.INITVAL_11(init_slice('h11)),\\n\\t.INITVAL_12(init_slice('h12)),\\n\\t.INITVAL_13(init_slice('h13)),\\n\\t.INITVAL_14(init_slice('h14)),\\n\\t.INITVAL_15(init_slice('h15)),\\n\\t.INITVAL_16(init_slice('h16)),\\n\\t.INITVAL_17(init_slice('h17)),\\n\\t.INITVAL_18(init_slice('h18)),\\n\\t.INITVAL_19(init_slice('h19)),\\n\\t.INITVAL_1A(init_slice('h1a)),\\n\\t.INITVAL_1B(init_slice('h1b)),\\n\\t.INITVAL_1C(init_slice('h1c)),\\n\\t.INITVAL_1D(init_slice('h1d)),\\n\\t.INITVAL_1E(init_slice('h1e)),\\n\\t.INITVAL_1F(init_slice('h1f)),\\n\\t.INITVAL_20(init_slice('h20)),\\n\\t.INITVAL_21(init_slice('h21)),\\n\\t.INITVAL_22(init_slice('h22)),\\n\\t.INITVAL_23(init_slice('h23)),\\n\\t.INITVAL_24(init_slice('h24)),\\n\\t.INITVAL_25(init_slice('h25)),\\n\\t.INITVAL_26(init_slice('h26)),\\n\\t.INITVAL_27(init_slice('h27)),\\n\\t.INITVAL_28(init_slice('h28)),\\n\\t.INITVAL_29(init_slice('h29)),\\n\\t.INITVAL_2A(init_slice('h2a)),\\n\\t.INITVAL_2B(init_slice('h2b)),\\n\\t.INITVAL_2C(init_slice('h2c)),\\n\\t.INITVAL_2D(init_slice('h2d)),\\n\\t.INITVAL_2E(init_slice('h2e)),\\n\\t.INITVAL_2F(init_slice('h2f)),\\n\\t.INITVAL_30(init_slice('h30)),\\n\\t.INITVAL_31(init_slice('h31)),\\n\\t.INITVAL_32(init_slice('h32)),\\n\\t.INITVAL_33(init_slice('h33)),\\n\\t.INITVAL_34(init_slice('h34)),\\n\\t.INITVAL_35(init_slice('h35)),\\n\\t.INITVAL_36(init_slice('h36)),\\n\\t.INITVAL_37(init_slice('h37)),\\n\\t.INITVAL_38(init_slice('h38)),\\n\\t.INITVAL_39(init_slice('h39)),\\n\\t.INITVAL_3A(init_slice('h3a)),\\n\\t.INITVAL_3B(init_slice('h3b)),\\n\\t.INITVAL_3C(init_slice('h3c)),\\n\\t.INITVAL_3D(init_slice('h3d)),\\n\\t.INITVAL_3E(init_slice('h3e)),\\n\\t.INITVAL_3F(init_slice('h3f)),\\n\\t.DATA_WIDTH_A(PORT_W_WIDTH),\\n\\t.DATA_WIDTH_B(PORT_R_WIDTH),\\n\\t.REGMODE_A(\\\"NOREG\\\"),\\n\\t.REGMODE_B(\\\"NOREG\\\"),\\n\\t.RESETMODE(OPTION_RESETMODE),\\n\\t.ASYNC_RESET_RELEASE(OPTION_RESETMODE),\\n\\t.CSDECODE_A(\\\"0b000\\\"),\\n\\t.CSDECODE_B(\\\"0b000\\\"),\\n\\t.CLKAMUX(PORT_W_CLK_POL ? \\\"CLKA\\\" : \\\"INV\\\"),\\n\\t.CLKBMUX(PORT_R_CLK_POL ? \\\"CLKB\\\" : \\\"INV\\\"),\\n\\t.GSR(\\\"AUTO\\\")\\n) _TECHMAP_REPLACE_ (\\n\\t.CLKA(PORT_W_CLK),\\n\\t.WEA(PORT_W_WIDTH >= 18 ? 1'b1 : PORT_W_WR_EN[0]),\\n\\t.CEA(PORT_W_CLK_EN),\\n\\t.OCEA(1'b0),\\n\\t.RSTA(1'b0),\\n\\t.CSA0(1'b0),\\n\\t.CSA1(1'b0),\\n\\t.CSA2(1'b0),\\n\\t.ADA0(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[0] : PORT_W_ADDR[0]),\\n\\t.ADA1(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[1] : PORT_W_ADDR[1]),\\n\\t.ADA2(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[2] : PORT_W_ADDR[2]),\\n\\t.ADA3(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[3] : PORT_W_ADDR[3]),\\n\\t.ADA4(PORT_W_ADDR[4]),\\n\\t.ADA5(PORT_W_ADDR[5]),\\n\\t.ADA6(PORT_W_ADDR[6]),\\n\\t.ADA7(PORT_W_ADDR[7]),\\n\\t.ADA8(PORT_W_ADDR[8]),\\n\\t.ADA9(PORT_W_ADDR[9]),\\n\\t.ADA10(PORT_W_ADDR[10]),\\n\\t.ADA11(PORT_W_ADDR[11]),\\n\\t.ADA12(PORT_W_ADDR[12]),\\n\\t.ADA13(PORT_W_ADDR[13]),\\n\\t.DIA0(DI[0]),\\n\\t.DIA1(DI[1]),\\n\\t.DIA2(DI[2]),\\n\\t.DIA3(DI[3]),\\n\\t.DIA4(DI[4]),\\n\\t.DIA5(DI[5]),\\n\\t.DIA6(DI[6]),\\n\\t.DIA7(DI[7]),\\n\\t.DIA8(DI[8]),\\n\\t.DIA9(DI[9]),\\n\\t.DIA10(DI[10]),\\n\\t.DIA11(DI[11]),\\n\\t.DIA12(DI[12]),\\n\\t.DIA13(DI[13]),\\n\\t.DIA14(DI[14]),\\n\\t.DIA15(DI[15]),\\n\\t.DIA16(DI[16]),\\n\\t.DIA17(DI[17]),\\n\\t.DIB0(DI[18]),\\n\\t.DIB1(DI[19]),\\n\\t.DIB2(DI[20]),\\n\\t.DIB3(DI[21]),\\n\\t.DIB4(DI[22]),\\n\\t.DIB5(DI[23]),\\n\\t.DIB6(DI[24]),\\n\\t.DIB7(DI[25]),\\n\\t.DIB8(DI[26]),\\n\\t.DIB9(DI[27]),\\n\\t.DIB10(DI[28]),\\n\\t.DIB11(DI[29]),\\n\\t.DIB12(DI[30]),\\n\\t.DIB13(DI[31]),\\n\\t.DIB14(DI[32]),\\n\\t.DIB15(DI[33]),\\n\\t.DIB16(DI[34]),\\n\\t.DIB17(DI[35]),\\n\\n\\t.CLKB(PORT_R_CLK),\\n\\t.WEB(1'b0),\\n\\t.CEB(PORT_R_CLK_EN),\\n\\t.OCEB(1'b1),\\n\\t.RSTB(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_R_RD_SRST : PORT_R_RD_ARST),\\n\\t.CSB0(1'b0),\\n\\t.CSB1(1'b0),\\n\\t.CSB2(1'b0),\\n\\t.ADB0(PORT_R_ADDR[0]),\\n\\t.ADB1(PORT_R_ADDR[1]),\\n\\t.ADB2(PORT_R_ADDR[2]),\\n\\t.ADB3(PORT_R_ADDR[3]),\\n\\t.ADB4(PORT_R_ADDR[4]),\\n\\t.ADB5(PORT_R_ADDR[5]),\\n\\t.ADB6(PORT_R_ADDR[6]),\\n\\t.ADB7(PORT_R_ADDR[7]),\\n\\t.ADB8(PORT_R_ADDR[8]),\\n\\t.ADB9(PORT_R_ADDR[9]),\\n\\t.ADB10(PORT_R_ADDR[10]),\\n\\t.ADB11(PORT_R_ADDR[11]),\\n\\t.ADB12(PORT_R_ADDR[12]),\\n\\t.ADB13(PORT_R_ADDR[13]),\\n\\t.DOA0(DO[0]),\\n\\t.DOA1(DO[1]),\\n\\t.DOA2(DO[2]),\\n\\t.DOA3(DO[3]),\\n\\t.DOA4(DO[4]),\\n\\t.DOA5(DO[5]),\\n\\t.DOA6(DO[6]),\\n\\t.DOA7(DO[7]),\\n\\t.DOA8(DO[8]),\\n\\t.DOA9(DO[9]),\\n\\t.DOA10(DO[10]),\\n\\t.DOA11(DO[11]),\\n\\t.DOA12(DO[12]),\\n\\t.DOA13(DO[13]),\\n\\t.DOA14(DO[14]),\\n\\t.DOA15(DO[15]),\\n\\t.DOA16(DO[16]),\\n\\t.DOA17(DO[17]),\\n\\t.DOB0(DO[18]),\\n\\t.DOB1(DO[19]),\\n\\t.DOB2(DO[20]),\\n\\t.DOB3(DO[21]),\\n\\t.DOB4(DO[22]),\\n\\t.DOB5(DO[23]),\\n\\t.DOB6(DO[24]),\\n\\t.DOB7(DO[25]),\\n\\t.DOB8(DO[26]),\\n\\t.DOB9(DO[27]),\\n\\t.DOB10(DO[28]),\\n\\t.DOB11(DO[29]),\\n\\t.DOB12(DO[30]),\\n\\t.DOB13(DO[31]),\\n\\t.DOB14(DO[32]),\\n\\t.DOB15(DO[33]),\\n\\t.DOB16(DO[34]),\\n\\t.DOB17(DO[35]),\\n);\\n\\nendmodule\\n\",\n            \"cells_bb.v\": \"// ECP5 Blackbox cells\\n// FIXME: Create sim models\\n\\n(* blackbox *)\\nmodule MULT18X18D(\\n\\tinput A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17,\\n\\tinput B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17,\\n\\tinput C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17,\\n\\tinput SIGNEDA, SIGNEDB, SOURCEA, SOURCEB,\\n\\tinput CLK0, CLK1, CLK2, CLK3,\\n\\tinput CE0, CE1, CE2, CE3,\\n\\tinput RST0, RST1, RST2, RST3,\\n\\tinput SRIA0, SRIA1, SRIA2, SRIA3, SRIA4, SRIA5, SRIA6, SRIA7, SRIA8, SRIA9, SRIA10, SRIA11, SRIA12, SRIA13, SRIA14, SRIA15, SRIA16, SRIA17,\\n\\tinput SRIB0, SRIB1, SRIB2, SRIB3, SRIB4, SRIB5, SRIB6, SRIB7, SRIB8, SRIB9, SRIB10, SRIB11, SRIB12, SRIB13, SRIB14, SRIB15, SRIB16, SRIB17,\\n\\toutput SROA0, SROA1, SROA2, SROA3, SROA4, SROA5, SROA6, SROA7, SROA8, SROA9, SROA10, SROA11, SROA12, SROA13, SROA14, SROA15, SROA16, SROA17,\\n\\toutput SROB0, SROB1, SROB2, SROB3, SROB4, SROB5, SROB6, SROB7, SROB8, SROB9, SROB10, SROB11, SROB12, SROB13, SROB14, SROB15, SROB16, SROB17,\\n\\toutput ROA0, ROA1, ROA2, ROA3, ROA4, ROA5, ROA6, ROA7, ROA8, ROA9, ROA10, ROA11, ROA12, ROA13, ROA14, ROA15, ROA16, ROA17,\\n\\toutput ROB0, ROB1, ROB2, ROB3, ROB4, ROB5, ROB6, ROB7, ROB8, ROB9, ROB10, ROB11, ROB12, ROB13, ROB14, ROB15, ROB16, ROB17,\\n\\toutput ROC0, ROC1, ROC2, ROC3, ROC4, ROC5, ROC6, ROC7, ROC8, ROC9, ROC10, ROC11, ROC12, ROC13, ROC14, ROC15, ROC16, ROC17,\\n\\toutput P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22, P23, P24, P25, P26, P27, P28, P29, P30, P31, P32, P33, P34, P35,\\n\\toutput SIGNEDP\\n);\\n\\tparameter REG_INPUTA_CLK = \\\"NONE\\\";\\n\\tparameter REG_INPUTA_CE = \\\"CE0\\\";\\n\\tparameter REG_INPUTA_RST = \\\"RST0\\\";\\n\\tparameter REG_INPUTB_CLK = \\\"NONE\\\";\\n\\tparameter REG_INPUTB_CE = \\\"CE0\\\";\\n\\tparameter REG_INPUTB_RST = \\\"RST0\\\";\\n\\tparameter REG_INPUTC_CLK = \\\"NONE\\\";\\n\\tparameter REG_INPUTC_CE = \\\"CE0\\\";\\n\\tparameter REG_INPUTC_RST = \\\"RST0\\\";\\n\\tparameter REG_PIPELINE_CLK = \\\"NONE\\\";\\n\\tparameter REG_PIPELINE_CE = \\\"CE0\\\";\\n\\tparameter REG_PIPELINE_RST = \\\"RST0\\\";\\n\\tparameter REG_OUTPUT_CLK = \\\"NONE\\\";\\n\\tparameter REG_OUTPUT_CE = \\\"CE0\\\";\\n\\tparameter REG_OUTPUT_RST = \\\"RST0\\\";\\n\\tparameter [127:0] CLK0_DIV = \\\"ENABLED\\\";\\n\\tparameter [127:0] CLK1_DIV = \\\"ENABLED\\\";\\n\\tparameter [127:0] CLK2_DIV = \\\"ENABLED\\\";\\n\\tparameter [127:0] CLK3_DIV = \\\"ENABLED\\\";\\n\\tparameter HIGHSPEED_CLK = \\\"NONE\\\";\\n\\tparameter [127:0] GSR = \\\"ENABLED\\\";\\n\\tparameter CAS_MATCH_REG = \\\"FALSE\\\";\\n\\tparameter [127:0] SOURCEB_MODE = \\\"B_SHIFT\\\";\\n\\tparameter [127:0] MULT_BYPASS = \\\"DISABLED\\\";\\n\\tparameter [127:0] RESETMODE = \\\"SYNC\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule ALU54B(\\n\\tinput CLK0, CLK1, CLK2, CLK3,\\n\\tinput CE0, CE1, CE2, CE3,\\n\\tinput RST0, RST1, RST2, RST3,\\n\\tinput SIGNEDIA, SIGNEDIB, SIGNEDCIN,\\n\\tinput A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34, A35,\\n\\tinput B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17, B18, B19, B20, B21, B22, B23, B24, B25, B26, B27, B28, B29, B30, B31, B32, B33, B34, B35,\\n\\tinput C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19, C20, C21, C22, C23, C24, C25, C26, C27, C28, C29, C30, C31, C32, C33, C34, C35, C36, C37, C38, C39, C40, C41, C42, C43, C44, C45, C46, C47, C48, C49, C50, C51, C52, C53,\\n\\tinput CFB0, CFB1, CFB2, CFB3, CFB4, CFB5, CFB6, CFB7, CFB8, CFB9, CFB10, CFB11, CFB12, CFB13, CFB14, CFB15, CFB16, CFB17, CFB18, CFB19, CFB20, CFB21, CFB22, CFB23, CFB24, CFB25, CFB26, CFB27, CFB28, CFB29, CFB30, CFB31, CFB32, CFB33, CFB34, CFB35, CFB36, CFB37, CFB38, CFB39, CFB40, CFB41, CFB42, CFB43, CFB44, CFB45, CFB46, CFB47, CFB48, CFB49, CFB50, CFB51, CFB52, CFB53,\\n\\tinput MA0, MA1, MA2, MA3, MA4, MA5, MA6, MA7, MA8, MA9, MA10, MA11, MA12, MA13, MA14, MA15, MA16, MA17, MA18, MA19, MA20, MA21, MA22, MA23, MA24, MA25, MA26, MA27, MA28, MA29, MA30, MA31, MA32, MA33, MA34, MA35,\\n\\tinput MB0, MB1, MB2, MB3, MB4, MB5, MB6, MB7, MB8, MB9, MB10, MB11, MB12, MB13, MB14, MB15, MB16, MB17, MB18, MB19, MB20, MB21, MB22, MB23, MB24, MB25, MB26, MB27, MB28, MB29, MB30, MB31, MB32, MB33, MB34, MB35,\\n\\tinput CIN0, CIN1, CIN2, CIN3, CIN4, CIN5, CIN6, CIN7, CIN8, CIN9, CIN10, CIN11, CIN12, CIN13, CIN14, CIN15, CIN16, CIN17, CIN18, CIN19, CIN20, CIN21, CIN22, CIN23, CIN24, CIN25, CIN26, CIN27, CIN28, CIN29, CIN30, CIN31, CIN32, CIN33, CIN34, CIN35, CIN36, CIN37, CIN38, CIN39, CIN40, CIN41, CIN42, CIN43, CIN44, CIN45, CIN46, CIN47, CIN48, CIN49, CIN50, CIN51, CIN52, CIN53,\\n\\tinput OP0, OP1, OP2, OP3, OP4, OP5, OP6, OP7, OP8, OP9, OP10,\\n\\toutput R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15, R16, R17, R18, R19, R20, R21, R22, R23, R24, R25, R26, R27, R28, R29, R30, R31, R32, R33, R34, R35, R36, R37, R38, R39, R40, R41, R42, R43, R44, R45, R46, R47, R48, R49, R50, R51, R52, R53,\\n\\toutput CO0, CO1, CO2, CO3, CO4, CO5, CO6, CO7, CO8, CO9, CO10, CO11, CO12, CO13, CO14, CO15, CO16, CO17, CO18, CO19, CO20, CO21, CO22, CO23, CO24, CO25, CO26, CO27, CO28, CO29, CO30, CO31, CO32, CO33, CO34, CO35, CO36, CO37, CO38, CO39, CO40, CO41, CO42, CO43, CO44, CO45, CO46, CO47, CO48, CO49, CO50, CO51, CO52, CO53,\\n\\toutput EQZ, EQZM, EQOM, EQPAT, EQPATB,\\n\\toutput OVER, UNDER, OVERUNDER,\\n\\toutput SIGNEDR\\n);\\n\\tparameter REG_INPUTC0_CLK = \\\"NONE\\\";\\n\\tparameter REG_INPUTC0_CE = \\\"CE0\\\";\\n\\tparameter REG_INPUTC0_RST = \\\"RST0\\\";\\n\\tparameter REG_INPUTC1_CLK = \\\"NONE\\\";\\n\\tparameter REG_INPUTC1_CE = \\\"CE0\\\";\\n\\tparameter REG_INPUTC1_RST = \\\"RST0\\\";\\n\\tparameter REG_OPCODEOP0_0_CLK = \\\"NONE\\\";\\n\\tparameter REG_OPCODEOP0_0_CE = \\\"CE0\\\";\\n\\tparameter REG_OPCODEOP0_0_RST = \\\"RST0\\\";\\n\\tparameter REG_OPCODEOP1_0_CLK = \\\"NONE\\\";\\n\\tparameter REG_OPCODEOP0_1_CLK = \\\"NONE\\\";\\n\\tparameter REG_OPCODEOP0_1_CE = \\\"CE0\\\";\\n\\tparameter REG_OPCODEOP0_1_RST = \\\"RST0\\\";\\n\\tparameter REG_OPCODEOP1_1_CLK = \\\"NONE\\\";\\n\\tparameter REG_OPCODEIN_0_CLK = \\\"NONE\\\";\\n\\tparameter REG_OPCODEIN_0_CE = \\\"CE0\\\";\\n\\tparameter REG_OPCODEIN_0_RST = \\\"RST0\\\";\\n\\tparameter REG_OPCODEIN_1_CLK = \\\"NONE\\\";\\n\\tparameter REG_OPCODEIN_1_CE = \\\"CE0\\\";\\n\\tparameter REG_OPCODEIN_1_RST = \\\"RST0\\\";\\n\\tparameter REG_OUTPUT0_CLK = \\\"NONE\\\";\\n\\tparameter REG_OUTPUT0_CE = \\\"CE0\\\";\\n\\tparameter REG_OUTPUT0_RST = \\\"RST0\\\";\\n\\tparameter REG_OUTPUT1_CLK = \\\"NONE\\\";\\n\\tparameter REG_OUTPUT1_CE = \\\"CE0\\\";\\n\\tparameter REG_OUTPUT1_RST = \\\"RST0\\\";\\n\\tparameter REG_FLAG_CLK = \\\"NONE\\\";\\n\\tparameter REG_FLAG_CE = \\\"CE0\\\";\\n\\tparameter REG_FLAG_RST = \\\"RST0\\\";\\n\\tparameter REG_INPUTCFB_CLK = \\\"NONE\\\";\\n\\tparameter REG_INPUTCFB_CE = \\\"CE0\\\";\\n\\tparameter REG_INPUTCFB_RST = \\\"RST0\\\";\\n\\tparameter [127:0] MCPAT_SOURCE = \\\"STATIC\\\";\\n\\tparameter [127:0] MASKPAT_SOURCE = \\\"STATIC\\\";\\n\\tparameter MASK01 = \\\"0x00000000000000\\\";\\n\\tparameter [127:0] CLK0_DIV = \\\"ENABLED\\\";\\n\\tparameter [127:0] CLK1_DIV = \\\"ENABLED\\\";\\n\\tparameter [127:0] CLK2_DIV = \\\"ENABLED\\\";\\n\\tparameter [127:0] CLK3_DIV = \\\"ENABLED\\\";\\n\\tparameter MCPAT = \\\"0x00000000000000\\\";\\n\\tparameter MASKPAT = \\\"0x00000000000000\\\";\\n\\tparameter RNDPAT = \\\"0x00000000000000\\\";\\n\\tparameter [127:0] GSR = \\\"ENABLED\\\";\\n\\tparameter [127:0] RESETMODE = \\\"SYNC\\\";\\n\\tparameter MULT9_MODE = \\\"DISABLED\\\";\\n\\tparameter FORCE_ZERO_BARREL_SHIFT = \\\"DISABLED\\\";\\n\\tparameter LEGACY = \\\"DISABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EHXPLLL (\\n\\tinput CLKI, CLKFB,\\n\\tinput PHASESEL1, PHASESEL0, PHASEDIR, PHASESTEP, PHASELOADREG,\\n\\tinput STDBY, PLLWAKESYNC,\\n\\tinput RST, ENCLKOP, ENCLKOS, ENCLKOS2, ENCLKOS3,\\n\\toutput CLKOP, CLKOS, CLKOS2, CLKOS3,\\n\\toutput LOCK, INTLOCK,\\n\\toutput REFCLK, CLKINTFB\\n);\\n\\tparameter CLKI_DIV = 1;\\n\\tparameter CLKFB_DIV = 1;\\n\\tparameter CLKOP_DIV = 8;\\n\\tparameter CLKOS_DIV = 8;\\n\\tparameter CLKOS2_DIV = 8;\\n\\tparameter CLKOS3_DIV = 8;\\n\\tparameter CLKOP_ENABLE = \\\"ENABLED\\\";\\n\\tparameter CLKOS_ENABLE = \\\"DISABLED\\\";\\n\\tparameter CLKOS2_ENABLE = \\\"DISABLED\\\";\\n\\tparameter CLKOS3_ENABLE = \\\"DISABLED\\\";\\n\\tparameter CLKOP_CPHASE = 0;\\n\\tparameter CLKOS_CPHASE = 0;\\n\\tparameter CLKOS2_CPHASE = 0;\\n\\tparameter CLKOS3_CPHASE = 0;\\n\\tparameter CLKOP_FPHASE = 0;\\n\\tparameter CLKOS_FPHASE = 0;\\n\\tparameter CLKOS2_FPHASE = 0;\\n\\tparameter CLKOS3_FPHASE = 0;\\n\\tparameter FEEDBK_PATH = \\\"CLKOP\\\";\\n\\tparameter CLKOP_TRIM_POL = \\\"RISING\\\";\\n\\tparameter CLKOP_TRIM_DELAY = 0;\\n\\tparameter CLKOS_TRIM_POL = \\\"RISING\\\";\\n\\tparameter CLKOS_TRIM_DELAY = 0;\\n\\tparameter OUTDIVIDER_MUXA = \\\"DIVA\\\";\\n\\tparameter OUTDIVIDER_MUXB = \\\"DIVB\\\";\\n\\tparameter OUTDIVIDER_MUXC = \\\"DIVC\\\";\\n\\tparameter OUTDIVIDER_MUXD = \\\"DIVD\\\";\\n\\tparameter PLL_LOCK_MODE = 0;\\n\\tparameter PLL_LOCK_DELAY = 200;\\n\\tparameter STDBY_ENABLE = \\\"DISABLED\\\";\\n\\tparameter REFIN_RESET = \\\"DISABLED\\\";\\n\\tparameter SYNC_ENABLE = \\\"DISABLED\\\";\\n\\tparameter INT_LOCK_STICKY = \\\"ENABLED\\\";\\n\\tparameter DPHASE_SOURCE = \\\"DISABLED\\\";\\n\\tparameter PLLRST_ENA = \\\"DISABLED\\\";\\n\\tparameter INTFB_WAKE = \\\"DISABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule DTR(\\n\\tinput STARTPULSE,\\n\\toutput DTROUT7, DTROUT6, DTROUT5, DTROUT4, DTROUT3, DTROUT2, DTROUT1, DTROUT0\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCG(\\n\\toutput OSC\\n);\\nparameter DIV = 128;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule USRMCLK(\\n\\tinput USRMCLKI, USRMCLKTS,\\n\\toutput USRMCLKO\\n);\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule JTAGG(\\n\\t(* iopad_external_pin *)\\n\\tinput TCK, \\n\\t(* iopad_external_pin *)\\n\\tinput TMS, \\n\\t(* iopad_external_pin *)\\n\\tinput TDI,\\n\\tinput JTDO2, JTDO1,\\n\\t(* iopad_external_pin *)\\n\\toutput TDO,\\n\\toutput JTDI, JTCK, JRTI2, JRTI1,\\n\\toutput JSHIFT, JUPDATE, JRSTN, JCE2, JCE1\\n);\\nparameter ER1 = \\\"ENABLED\\\";\\nparameter ER2 = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule DELAYF(\\n\\tinput A, LOADN, MOVE, DIRECTION,\\n\\toutput Z, CFLAG\\n);\\n\\tparameter DEL_MODE = \\\"USER_DEFINED\\\";\\n\\tparameter DEL_VALUE = 0;\\nendmodule\\n\\n(* blackbox *)\\nmodule DELAYG(\\n\\tinput A,\\n\\toutput Z\\n);\\n\\tparameter DEL_MODE = \\\"USER_DEFINED\\\";\\n\\tparameter DEL_VALUE = 0;\\nendmodule\\n\\n(* blackbox *)\\nmodule IDDRX1F(\\n\\tinput D, SCLK, RST,\\n\\toutput Q0, Q1\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule IDDRX2F(\\n\\tinput D, SCLK, ECLK, RST, ALIGNWD,\\n\\toutput Q0, Q1, Q2, Q3\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule IDDR71B(\\n\\tinput D, SCLK, ECLK, RST, ALIGNWD,\\n\\toutput Q0, Q1, Q2, Q3, Q4, Q5, Q6\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule IDDRX2DQA(\\n\\tinput D, DQSR90, ECLK, SCLK, RST,\\n\\tinput RDPNTR2, RDPNTR1, RDPNTR0, WRPNTR2, WRPNTR1, WRPNTR0,\\n\\toutput Q0, Q1, Q2, Q3, QWL\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDRX1F(\\n\\tinput SCLK, RST, D0, D1,\\n\\toutput Q\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDRX2F(\\n\\tinput SCLK, ECLK, RST, D0, D1, D2, D3,\\n\\toutput Q\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDR71B(\\n\\tinput SCLK, ECLK, RST, D0, D1, D2, D3, D4, D5, D6,\\n\\toutput Q\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule OSHX2A(\\n\\tinput D0, D1, RST, ECLK, SCLK,\\n\\toutput Q\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDRX2DQA(\\n\\tinput D0, D1, D2, D3, RST, ECLK, SCLK, DQSW270,\\n\\toutput Q\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDRX2DQSB(\\n\\tinput D0, D1, D2, D3, RST, ECLK, SCLK, DQSW,\\n\\toutput Q\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule TSHX2DQA(\\n\\tinput T0, T1, SCLK, ECLK, DQSW270, RST,\\n\\toutput Q\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\n\\tparameter REGSET = \\\"SET\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule TSHX2DQSA(\\n\\tinput T0, T1, SCLK, ECLK, DQSW, RST,\\n\\toutput Q\\n);\\n\\tparameter GSR = \\\"ENABLED\\\";\\n\\tparameter REGSET = \\\"SET\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule DQSBUFM(\\n\\tinput DQSI, READ1, READ0, READCLKSEL2, READCLKSEL1, READCLKSEL0, DDRDEL,\\n\\tinput ECLK, SCLK,\\n\\tinput DYNDELAY7, DYNDELAY6, DYNDELAY5, DYNDELAY4,\\n\\tinput DYNDELAY3, DYNDELAY2, DYNDELAY1, DYNDELAY0, \\n\\tinput RST, RDLOADN, RDMOVE, RDDIRECTION, WRLOADN, WRMOVE, WRDIRECTION, PAUSE,\\n\\toutput DQSR90, DQSW, DQSW270,\\n\\toutput RDPNTR2, RDPNTR1, RDPNTR0, WRPNTR2, WRPNTR1, WRPNTR0,\\n\\toutput DATAVALID, BURSTDET, RDCFLAG, WRCFLAG\\n);\\n\\tparameter DQS_LI_DEL_ADJ = \\\"FACTORYONLY\\\";\\n\\tparameter DQS_LI_DEL_VAL = 0;\\n\\tparameter DQS_LO_DEL_ADJ = \\\"FACTORYONLY\\\";\\n\\tparameter DQS_LO_DEL_VAL = 0;\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule DDRDLLA(\\n\\tinput CLK, RST, UDDCNTLN, FREEZE,\\n\\toutput LOCK, DDRDEL, DCNTL7, DCNTL6, DCNTL5, DCNTL4, DCNTL3, DCNTL2, DCNTL1, DCNTL0\\n);\\n\\tparameter FORCE_MAX_DELAY = \\\"NO\\\";\\n\\tparameter GSR = \\\"ENABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule DLLDELD(\\n\\tinput A, DDRDEL, LOADN, MOVE, DIRECTION,\\n\\toutput Z, CFLAG\\n);\\n\\tparameter DEL_ADJ = \\\"PLUS\\\";\\n\\tparameter DEL_VAL = 0;\\nendmodule\\n\\n(* blackbox *)\\nmodule CLKDIVF(\\n\\tinput CLKI, RST, ALIGNWD,\\n\\toutput CDIVX\\n);\\n\\tparameter GSR = \\\"DISABLED\\\";\\n\\tparameter DIV = \\\"2.0\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKSYNCB(\\n\\tinput ECLKI, STOP,\\n\\toutput ECLKO\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKBRIDGECS(\\n\\tinput CLK0, CLK1, SEL,\\n\\toutput ECSOUT\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule DCCA(\\n\\tinput CLKI, CE,\\n\\toutput CLKO\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule DCSC(\\n\\tinput CLK1, CLK0,\\n\\tinput SEL1, SEL0,\\n\\tinput MODESEL,\\n\\toutput DCSOUT\\n);\\n\\tparameter DCSMODE = \\\"POS\\\";\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule DCUA(\\n\\t(* iopad_external_pin *)\\n\\tinput CH0_HDINP,\\n\\t(* iopad_external_pin *)\\n\\tinput CH1_HDINP,\\n\\t(* iopad_external_pin *)\\n\\tinput CH0_HDINN,\\n\\t(* iopad_external_pin *)\\n\\tinput CH1_HDINN,\\n\\tinput D_TXBIT_CLKP_FROM_ND, D_TXBIT_CLKN_FROM_ND, D_SYNC_ND, D_TXPLL_LOL_FROM_ND,\\n\\tinput CH0_RX_REFCLK, CH1_RX_REFCLK, CH0_FF_RXI_CLK, CH1_FF_RXI_CLK, CH0_FF_TXI_CLK, CH1_FF_TXI_CLK, CH0_FF_EBRD_CLK, CH1_FF_EBRD_CLK,\\n\\tinput CH0_FF_TX_D_0, CH1_FF_TX_D_0, CH0_FF_TX_D_1, CH1_FF_TX_D_1, CH0_FF_TX_D_2, CH1_FF_TX_D_2, CH0_FF_TX_D_3, CH1_FF_TX_D_3,\\n\\tinput CH0_FF_TX_D_4, CH1_FF_TX_D_4, CH0_FF_TX_D_5, CH1_FF_TX_D_5, CH0_FF_TX_D_6, CH1_FF_TX_D_6, CH0_FF_TX_D_7, CH1_FF_TX_D_7,\\n\\tinput CH0_FF_TX_D_8, CH1_FF_TX_D_8, CH0_FF_TX_D_9, CH1_FF_TX_D_9, CH0_FF_TX_D_10, CH1_FF_TX_D_10, CH0_FF_TX_D_11, CH1_FF_TX_D_11,\\n\\tinput CH0_FF_TX_D_12, CH1_FF_TX_D_12, CH0_FF_TX_D_13, CH1_FF_TX_D_13, CH0_FF_TX_D_14, CH1_FF_TX_D_14, CH0_FF_TX_D_15, CH1_FF_TX_D_15,\\n\\tinput CH0_FF_TX_D_16, CH1_FF_TX_D_16, CH0_FF_TX_D_17, CH1_FF_TX_D_17, CH0_FF_TX_D_18, CH1_FF_TX_D_18, CH0_FF_TX_D_19, CH1_FF_TX_D_19,\\n\\tinput CH0_FF_TX_D_20, CH1_FF_TX_D_20, CH0_FF_TX_D_21, CH1_FF_TX_D_21, CH0_FF_TX_D_22, CH1_FF_TX_D_22, CH0_FF_TX_D_23, CH1_FF_TX_D_23,\\n\\tinput CH0_FFC_EI_EN, CH1_FFC_EI_EN, CH0_FFC_PCIE_DET_EN, CH1_FFC_PCIE_DET_EN, CH0_FFC_PCIE_CT, CH1_FFC_PCIE_CT, CH0_FFC_SB_INV_RX, CH1_FFC_SB_INV_RX,\\n\\tinput CH0_FFC_ENABLE_CGALIGN, CH1_FFC_ENABLE_CGALIGN, CH0_FFC_SIGNAL_DETECT, CH1_FFC_SIGNAL_DETECT, CH0_FFC_FB_LOOPBACK, CH1_FFC_FB_LOOPBACK, CH0_FFC_SB_PFIFO_LP, CH1_FFC_SB_PFIFO_LP,\\n\\tinput CH0_FFC_PFIFO_CLR, CH1_FFC_PFIFO_CLR, CH0_FFC_RATE_MODE_RX, CH1_FFC_RATE_MODE_RX, CH0_FFC_RATE_MODE_TX, CH1_FFC_RATE_MODE_TX, CH0_FFC_DIV11_MODE_RX, CH1_FFC_DIV11_MODE_RX, CH0_FFC_RX_GEAR_MODE, CH1_FFC_RX_GEAR_MODE, CH0_FFC_TX_GEAR_MODE, CH1_FFC_TX_GEAR_MODE,\\n\\tinput CH0_FFC_DIV11_MODE_TX, CH1_FFC_DIV11_MODE_TX, CH0_FFC_LDR_CORE2TX_EN, CH1_FFC_LDR_CORE2TX_EN, CH0_FFC_LANE_TX_RST, CH1_FFC_LANE_TX_RST, CH0_FFC_LANE_RX_RST, CH1_FFC_LANE_RX_RST,\\n\\tinput CH0_FFC_RRST, CH1_FFC_RRST, CH0_FFC_TXPWDNB, CH1_FFC_TXPWDNB, CH0_FFC_RXPWDNB, CH1_FFC_RXPWDNB, CH0_LDR_CORE2TX, CH1_LDR_CORE2TX,\\n\\tinput D_SCIWDATA0, D_SCIWDATA1, D_SCIWDATA2, D_SCIWDATA3, D_SCIWDATA4, D_SCIWDATA5, D_SCIWDATA6, D_SCIWDATA7,\\n\\tinput D_SCIADDR0, D_SCIADDR1, D_SCIADDR2, D_SCIADDR3, D_SCIADDR4, D_SCIADDR5, D_SCIENAUX, D_SCISELAUX,\\n\\tinput CH0_SCIEN, CH1_SCIEN, CH0_SCISEL, CH1_SCISEL, D_SCIRD, D_SCIWSTN, D_CYAWSTN, D_FFC_SYNC_TOGGLE,\\n\\tinput D_FFC_DUAL_RST, D_FFC_MACRO_RST, D_FFC_MACROPDB, D_FFC_TRST, CH0_FFC_CDR_EN_BITSLIP, CH1_FFC_CDR_EN_BITSLIP, D_SCAN_ENABLE, D_SCAN_IN_0,\\n\\tinput D_SCAN_IN_1, D_SCAN_IN_2, D_SCAN_IN_3, D_SCAN_IN_4, D_SCAN_IN_5, D_SCAN_IN_6, D_SCAN_IN_7, D_SCAN_MODE,\\n\\tinput D_SCAN_RESET, D_CIN0, D_CIN1, D_CIN2, D_CIN3, D_CIN4, D_CIN5, D_CIN6,D_CIN7, D_CIN8, D_CIN9, D_CIN10, D_CIN11,\\n\\toutput CH0_HDOUTP, CH1_HDOUTP, CH0_HDOUTN, CH1_HDOUTN, D_TXBIT_CLKP_TO_ND, D_TXBIT_CLKN_TO_ND, D_SYNC_PULSE2ND, D_TXPLL_LOL_TO_ND,\\n\\toutput CH0_FF_RX_F_CLK, CH1_FF_RX_F_CLK, CH0_FF_RX_H_CLK, CH1_FF_RX_H_CLK, CH0_FF_TX_F_CLK, CH1_FF_TX_F_CLK, CH0_FF_TX_H_CLK, CH1_FF_TX_H_CLK,\\n\\toutput CH0_FF_RX_PCLK, CH1_FF_RX_PCLK, CH0_FF_TX_PCLK, CH1_FF_TX_PCLK, CH0_FF_RX_D_0, CH1_FF_RX_D_0, CH0_FF_RX_D_1, CH1_FF_RX_D_1,\\n\\toutput CH0_FF_RX_D_2, CH1_FF_RX_D_2, CH0_FF_RX_D_3, CH1_FF_RX_D_3, CH0_FF_RX_D_4, CH1_FF_RX_D_4, CH0_FF_RX_D_5, CH1_FF_RX_D_5,\\n\\toutput CH0_FF_RX_D_6, CH1_FF_RX_D_6, CH0_FF_RX_D_7, CH1_FF_RX_D_7, CH0_FF_RX_D_8, CH1_FF_RX_D_8, CH0_FF_RX_D_9, CH1_FF_RX_D_9,\\n\\toutput CH0_FF_RX_D_10, CH1_FF_RX_D_10, CH0_FF_RX_D_11, CH1_FF_RX_D_11, CH0_FF_RX_D_12, CH1_FF_RX_D_12, CH0_FF_RX_D_13, CH1_FF_RX_D_13,\\n\\toutput CH0_FF_RX_D_14, CH1_FF_RX_D_14, CH0_FF_RX_D_15, CH1_FF_RX_D_15, CH0_FF_RX_D_16, CH1_FF_RX_D_16, CH0_FF_RX_D_17, CH1_FF_RX_D_17,\\n\\toutput CH0_FF_RX_D_18, CH1_FF_RX_D_18, CH0_FF_RX_D_19, CH1_FF_RX_D_19, CH0_FF_RX_D_20, CH1_FF_RX_D_20, CH0_FF_RX_D_21, CH1_FF_RX_D_21,\\n\\toutput CH0_FF_RX_D_22, CH1_FF_RX_D_22, CH0_FF_RX_D_23, CH1_FF_RX_D_23, CH0_FFS_PCIE_DONE, CH1_FFS_PCIE_DONE, CH0_FFS_PCIE_CON, CH1_FFS_PCIE_CON,\\n\\toutput CH0_FFS_RLOS, CH1_FFS_RLOS, CH0_FFS_LS_SYNC_STATUS, CH1_FFS_LS_SYNC_STATUS, CH0_FFS_CC_UNDERRUN, CH1_FFS_CC_UNDERRUN, CH0_FFS_CC_OVERRUN, CH1_FFS_CC_OVERRUN,\\n\\toutput CH0_FFS_RXFBFIFO_ERROR, CH1_FFS_RXFBFIFO_ERROR, CH0_FFS_TXFBFIFO_ERROR, CH1_FFS_TXFBFIFO_ERROR, CH0_FFS_RLOL, CH1_FFS_RLOL, CH0_FFS_SKP_ADDED, CH1_FFS_SKP_ADDED,\\n\\toutput CH0_FFS_SKP_DELETED, CH1_FFS_SKP_DELETED, CH0_LDR_RX2CORE, CH1_LDR_RX2CORE, D_SCIRDATA0, D_SCIRDATA1, D_SCIRDATA2, D_SCIRDATA3,\\n\\toutput D_SCIRDATA4, D_SCIRDATA5, D_SCIRDATA6, D_SCIRDATA7, D_SCIINT, D_SCAN_OUT_0, D_SCAN_OUT_1, D_SCAN_OUT_2, D_SCAN_OUT_3, D_SCAN_OUT_4, D_SCAN_OUT_5, D_SCAN_OUT_6, D_SCAN_OUT_7,\\n\\toutput D_COUT0, D_COUT1, D_COUT2, D_COUT3, D_COUT4, D_COUT5, D_COUT6, D_COUT7, D_COUT8, D_COUT9, D_COUT10, D_COUT11, D_COUT12, D_COUT13, D_COUT14, D_COUT15, D_COUT16, D_COUT17, D_COUT18, D_COUT19,\\n\\n\\tinput  D_REFCLKI,\\n\\toutput D_FFS_PLOL\\n);\\n\\tparameter CH0_AUTO_CALIB_EN = \\\"0b0\\\";\\n\\tparameter CH0_AUTO_FACQ_EN = \\\"0b0\\\";\\n\\tparameter CH0_BAND_THRESHOLD = \\\"0b000000\\\";\\n\\tparameter CH0_CALIB_CK_MODE = \\\"0b0\\\";\\n\\tparameter CH0_CC_MATCH_1 = \\\"0b0000000000\\\";\\n\\tparameter CH0_CC_MATCH_2 = \\\"0b0000000000\\\";\\n\\tparameter CH0_CC_MATCH_3 = \\\"0b0000000000\\\";\\n\\tparameter CH0_CC_MATCH_4 = \\\"0b0000000000\\\";\\n\\tparameter CH0_CDR_CNT4SEL = \\\"0b00\\\";\\n\\tparameter CH0_CDR_CNT8SEL = \\\"0b00\\\";\\n\\tparameter CH0_CTC_BYPASS = \\\"0b0\\\";\\n\\tparameter CH0_DCOATDCFG = \\\"0b00\\\";\\n\\tparameter CH0_DCOATDDLY = \\\"0b00\\\";\\n\\tparameter CH0_DCOBYPSATD = \\\"0b0\\\";\\n\\tparameter CH0_DCOCALDIV = \\\"0b000\\\";\\n\\tparameter CH0_DCOCTLGI = \\\"0b000\\\";\\n\\tparameter CH0_DCODISBDAVOID = \\\"0b0\\\";\\n\\tparameter CH0_DCOFLTDAC = \\\"0b00\\\";\\n\\tparameter CH0_DCOFTNRG = \\\"0b000\\\";\\n\\tparameter CH0_DCOIOSTUNE = \\\"0b000\\\";\\n\\tparameter CH0_DCOITUNE = \\\"0b00\\\";\\n\\tparameter CH0_DCOITUNE4LSB = \\\"0b000\\\";\\n\\tparameter CH0_DCOIUPDNX2 = \\\"0b0\\\";\\n\\tparameter CH0_DCONUOFLSB = \\\"0b000\\\";\\n\\tparameter CH0_DCOSCALEI = \\\"0b00\\\";\\n\\tparameter CH0_DCOSTARTVAL = \\\"0b000\\\";\\n\\tparameter CH0_DCOSTEP = \\\"0b00\\\";\\n\\tparameter CH0_DEC_BYPASS = \\\"0b0\\\";\\n\\tparameter CH0_ENABLE_CG_ALIGN = \\\"0b0\\\";\\n\\tparameter CH0_ENC_BYPASS = \\\"0b0\\\";\\n\\tparameter CH0_FF_RX_F_CLK_DIS = \\\"0b0\\\";\\n\\tparameter CH0_FF_RX_H_CLK_EN = \\\"0b0\\\";\\n\\tparameter CH0_FF_TX_F_CLK_DIS = \\\"0b0\\\";\\n\\tparameter CH0_FF_TX_H_CLK_EN = \\\"0b0\\\";\\n\\tparameter CH0_GE_AN_ENABLE = \\\"0b0\\\";\\n\\tparameter CH0_INVERT_RX = \\\"0b0\\\";\\n\\tparameter CH0_INVERT_TX = \\\"0b0\\\";\\n\\tparameter CH0_LDR_CORE2TX_SEL = \\\"0b0\\\";\\n\\tparameter CH0_LDR_RX2CORE_SEL = \\\"0b0\\\";\\n\\tparameter CH0_LEQ_OFFSET_SEL = \\\"0b0\\\";\\n\\tparameter CH0_LEQ_OFFSET_TRIM = \\\"0b000\\\";\\n\\tparameter CH0_LSM_DISABLE = \\\"0b0\\\";\\n\\tparameter CH0_MATCH_2_ENABLE = \\\"0b0\\\";\\n\\tparameter CH0_MATCH_4_ENABLE = \\\"0b0\\\";\\n\\tparameter CH0_MIN_IPG_CNT = \\\"0b00\\\";\\n\\tparameter CH0_PCIE_EI_EN = \\\"0b0\\\";\\n\\tparameter CH0_PCIE_MODE = \\\"0b0\\\";\\n\\tparameter CH0_PCS_DET_TIME_SEL = \\\"0b00\\\";\\n\\tparameter CH0_PDEN_SEL = \\\"0b0\\\";\\n\\tparameter CH0_PRBS_ENABLE = \\\"0b0\\\";\\n\\tparameter CH0_PRBS_LOCK = \\\"0b0\\\";\\n\\tparameter CH0_PRBS_SELECTION = \\\"0b0\\\";\\n\\tparameter CH0_RATE_MODE_RX = \\\"0b0\\\";\\n\\tparameter CH0_RATE_MODE_TX = \\\"0b0\\\";\\n\\tparameter CH0_RCV_DCC_EN = \\\"0b0\\\";\\n\\tparameter CH0_REG_BAND_OFFSET = \\\"0b0000\\\";\\n\\tparameter CH0_REG_BAND_SEL = \\\"0b000000\\\";\\n\\tparameter CH0_REG_IDAC_EN = \\\"0b0\\\";\\n\\tparameter CH0_REG_IDAC_SEL = \\\"0b0000000000\\\";\\n\\tparameter CH0_REQ_EN = \\\"0b0\\\";\\n\\tparameter CH0_REQ_LVL_SET = \\\"0b00\\\";\\n\\tparameter CH0_RIO_MODE = \\\"0b0\\\";\\n\\tparameter CH0_RLOS_SEL = \\\"0b0\\\";\\n\\tparameter CH0_RPWDNB = \\\"0b0\\\";\\n\\tparameter CH0_RTERM_RX = \\\"0b00000\\\";\\n\\tparameter CH0_RTERM_TX = \\\"0b00000\\\";\\n\\tparameter CH0_RXIN_CM = \\\"0b00\\\";\\n\\tparameter CH0_RXTERM_CM = \\\"0b00\\\";\\n\\tparameter CH0_RX_DCO_CK_DIV = \\\"0b000\\\";\\n\\tparameter CH0_RX_DIV11_SEL = \\\"0b0\\\";\\n\\tparameter CH0_RX_GEAR_BYPASS = \\\"0b0\\\";\\n\\tparameter CH0_RX_GEAR_MODE = \\\"0b0\\\";\\n\\tparameter CH0_RX_LOS_CEQ = \\\"0b00\\\";\\n\\tparameter CH0_RX_LOS_EN = \\\"0b0\\\";\\n\\tparameter CH0_RX_LOS_HYST_EN = \\\"0b0\\\";\\n\\tparameter CH0_RX_LOS_LVL = \\\"0b000\\\";\\n\\tparameter CH0_RX_RATE_SEL = \\\"0b0000\\\";\\n\\tparameter CH0_RX_SB_BYPASS = \\\"0b0\\\";\\n\\tparameter CH0_SB_BYPASS = \\\"0b0\\\";\\n\\tparameter CH0_SEL_SD_RX_CLK = \\\"0b0\\\";\\n\\tparameter CH0_TDRV_DAT_SEL = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_POST_EN = \\\"0b0\\\";\\n\\tparameter CH0_TDRV_PRE_EN = \\\"0b0\\\";\\n\\tparameter CH0_TDRV_SLICE0_CUR = \\\"0b000\\\";\\n\\tparameter CH0_TDRV_SLICE0_SEL = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_SLICE1_CUR = \\\"0b000\\\";\\n\\tparameter CH0_TDRV_SLICE1_SEL = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_SLICE2_CUR = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_SLICE2_SEL = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_SLICE3_CUR = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_SLICE3_SEL = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_SLICE4_CUR = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_SLICE4_SEL = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_SLICE5_CUR = \\\"0b00\\\";\\n\\tparameter CH0_TDRV_SLICE5_SEL = \\\"0b00\\\";\\n\\tparameter CH0_TPWDNB = \\\"0b0\\\";\\n\\tparameter CH0_TX_CM_SEL = \\\"0b00\\\";\\n\\tparameter CH0_TX_DIV11_SEL = \\\"0b0\\\";\\n\\tparameter CH0_TX_GEAR_BYPASS = \\\"0b0\\\";\\n\\tparameter CH0_TX_GEAR_MODE = \\\"0b0\\\";\\n\\tparameter CH0_TX_POST_SIGN = \\\"0b0\\\";\\n\\tparameter CH0_TX_PRE_SIGN = \\\"0b0\\\";\\n\\tparameter CH0_UC_MODE = \\\"0b0\\\";\\n\\tparameter CH0_UDF_COMMA_A = \\\"0b0000000000\\\";\\n\\tparameter CH0_UDF_COMMA_B = \\\"0b0000000000\\\";\\n\\tparameter CH0_UDF_COMMA_MASK = \\\"0b0000000000\\\";\\n\\tparameter CH0_WA_BYPASS = \\\"0b0\\\";\\n\\tparameter CH0_WA_MODE = \\\"0b0\\\";\\n\\tparameter CH1_AUTO_CALIB_EN = \\\"0b0\\\";\\n\\tparameter CH1_AUTO_FACQ_EN = \\\"0b0\\\";\\n\\tparameter CH1_BAND_THRESHOLD = \\\"0b000000\\\";\\n\\tparameter CH1_CALIB_CK_MODE = \\\"0b0\\\";\\n\\tparameter CH1_CC_MATCH_1 = \\\"0b0000000000\\\";\\n\\tparameter CH1_CC_MATCH_2 = \\\"0b0000000000\\\";\\n\\tparameter CH1_CC_MATCH_3 = \\\"0b0000000000\\\";\\n\\tparameter CH1_CC_MATCH_4 = \\\"0b0000000000\\\";\\n\\tparameter CH1_CDR_CNT4SEL = \\\"0b00\\\";\\n\\tparameter CH1_CDR_CNT8SEL = \\\"0b00\\\";\\n\\tparameter CH1_CTC_BYPASS = \\\"0b0\\\";\\n\\tparameter CH1_DCOATDCFG = \\\"0b00\\\";\\n\\tparameter CH1_DCOATDDLY = \\\"0b00\\\";\\n\\tparameter CH1_DCOBYPSATD = \\\"0b0\\\";\\n\\tparameter CH1_DCOCALDIV = \\\"0b000\\\";\\n\\tparameter CH1_DCOCTLGI = \\\"0b000\\\";\\n\\tparameter CH1_DCODISBDAVOID = \\\"0b0\\\";\\n\\tparameter CH1_DCOFLTDAC = \\\"0b00\\\";\\n\\tparameter CH1_DCOFTNRG = \\\"0b000\\\";\\n\\tparameter CH1_DCOIOSTUNE = \\\"0b000\\\";\\n\\tparameter CH1_DCOITUNE = \\\"0b00\\\";\\n\\tparameter CH1_DCOITUNE4LSB = \\\"0b000\\\";\\n\\tparameter CH1_DCOIUPDNX2 = \\\"0b0\\\";\\n\\tparameter CH1_DCONUOFLSB = \\\"0b000\\\";\\n\\tparameter CH1_DCOSCALEI = \\\"0b00\\\";\\n\\tparameter CH1_DCOSTARTVAL = \\\"0b000\\\";\\n\\tparameter CH1_DCOSTEP = \\\"0b00\\\";\\n\\tparameter CH1_DEC_BYPASS = \\\"0b0\\\";\\n\\tparameter CH1_ENABLE_CG_ALIGN = \\\"0b0\\\";\\n\\tparameter CH1_ENC_BYPASS = \\\"0b0\\\";\\n\\tparameter CH1_FF_RX_F_CLK_DIS = \\\"0b0\\\";\\n\\tparameter CH1_FF_RX_H_CLK_EN = \\\"0b0\\\";\\n\\tparameter CH1_FF_TX_F_CLK_DIS = \\\"0b0\\\";\\n\\tparameter CH1_FF_TX_H_CLK_EN = \\\"0b0\\\";\\n\\tparameter CH1_GE_AN_ENABLE = \\\"0b0\\\";\\n\\tparameter CH1_INVERT_RX = \\\"0b0\\\";\\n\\tparameter CH1_INVERT_TX = \\\"0b0\\\";\\n\\tparameter CH1_LDR_CORE2TX_SEL = \\\"0b0\\\";\\n\\tparameter CH1_LDR_RX2CORE_SEL = \\\"0b0\\\";\\n\\tparameter CH1_LEQ_OFFSET_SEL = \\\"0b0\\\";\\n\\tparameter CH1_LEQ_OFFSET_TRIM = \\\"0b000\\\";\\n\\tparameter CH1_LSM_DISABLE = \\\"0b0\\\";\\n\\tparameter CH1_MATCH_2_ENABLE = \\\"0b0\\\";\\n\\tparameter CH1_MATCH_4_ENABLE = \\\"0b0\\\";\\n\\tparameter CH1_MIN_IPG_CNT = \\\"0b00\\\";\\n\\tparameter CH1_PCIE_EI_EN = \\\"0b0\\\";\\n\\tparameter CH1_PCIE_MODE = \\\"0b0\\\";\\n\\tparameter CH1_PCS_DET_TIME_SEL = \\\"0b00\\\";\\n\\tparameter CH1_PDEN_SEL = \\\"0b0\\\";\\n\\tparameter CH1_PRBS_ENABLE = \\\"0b0\\\";\\n\\tparameter CH1_PRBS_LOCK = \\\"0b0\\\";\\n\\tparameter CH1_PRBS_SELECTION = \\\"0b0\\\";\\n\\tparameter CH1_RATE_MODE_RX = \\\"0b0\\\";\\n\\tparameter CH1_RATE_MODE_TX = \\\"0b0\\\";\\n\\tparameter CH1_RCV_DCC_EN = \\\"0b0\\\";\\n\\tparameter CH1_REG_BAND_OFFSET = \\\"0b0000\\\";\\n\\tparameter CH1_REG_BAND_SEL = \\\"0b000000\\\";\\n\\tparameter CH1_REG_IDAC_EN = \\\"0b0\\\";\\n\\tparameter CH1_REG_IDAC_SEL = \\\"0b0000000000\\\";\\n\\tparameter CH1_REQ_EN = \\\"0b0\\\";\\n\\tparameter CH1_REQ_LVL_SET = \\\"0b00\\\";\\n\\tparameter CH1_RIO_MODE = \\\"0b0\\\";\\n\\tparameter CH1_RLOS_SEL = \\\"0b0\\\";\\n\\tparameter CH1_RPWDNB = \\\"0b0\\\";\\n\\tparameter CH1_RTERM_RX = \\\"0b00000\\\";\\n\\tparameter CH1_RTERM_TX = \\\"0b00000\\\";\\n\\tparameter CH1_RXIN_CM = \\\"0b00\\\";\\n\\tparameter CH1_RXTERM_CM = \\\"0b00\\\";\\n\\tparameter CH1_RX_DCO_CK_DIV = \\\"0b000\\\";\\n\\tparameter CH1_RX_DIV11_SEL = \\\"0b0\\\";\\n\\tparameter CH1_RX_GEAR_BYPASS = \\\"0b0\\\";\\n\\tparameter CH1_RX_GEAR_MODE = \\\"0b0\\\";\\n\\tparameter CH1_RX_LOS_CEQ = \\\"0b00\\\";\\n\\tparameter CH1_RX_LOS_EN = \\\"0b0\\\";\\n\\tparameter CH1_RX_LOS_HYST_EN = \\\"0b0\\\";\\n\\tparameter CH1_RX_LOS_LVL = \\\"0b000\\\";\\n\\tparameter CH1_RX_RATE_SEL = \\\"0b0000\\\";\\n\\tparameter CH1_RX_SB_BYPASS = \\\"0b0\\\";\\n\\tparameter CH1_SB_BYPASS = \\\"0b0\\\";\\n\\tparameter CH1_SEL_SD_RX_CLK = \\\"0b0\\\";\\n\\tparameter CH1_TDRV_DAT_SEL = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_POST_EN = \\\"0b0\\\";\\n\\tparameter CH1_TDRV_PRE_EN = \\\"0b0\\\";\\n\\tparameter CH1_TDRV_SLICE0_CUR = \\\"0b000\\\";\\n\\tparameter CH1_TDRV_SLICE0_SEL = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_SLICE1_CUR = \\\"0b000\\\";\\n\\tparameter CH1_TDRV_SLICE1_SEL = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_SLICE2_CUR = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_SLICE2_SEL = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_SLICE3_CUR = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_SLICE3_SEL = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_SLICE4_CUR = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_SLICE4_SEL = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_SLICE5_CUR = \\\"0b00\\\";\\n\\tparameter CH1_TDRV_SLICE5_SEL = \\\"0b00\\\";\\n\\tparameter CH1_TPWDNB = \\\"0b0\\\";\\n\\tparameter CH1_TX_CM_SEL = \\\"0b00\\\";\\n\\tparameter CH1_TX_DIV11_SEL = \\\"0b0\\\";\\n\\tparameter CH1_TX_GEAR_BYPASS = \\\"0b0\\\";\\n\\tparameter CH1_TX_GEAR_MODE = \\\"0b0\\\";\\n\\tparameter CH1_TX_POST_SIGN = \\\"0b0\\\";\\n\\tparameter CH1_TX_PRE_SIGN = \\\"0b0\\\";\\n\\tparameter CH1_UC_MODE = \\\"0b0\\\";\\n\\tparameter CH1_UDF_COMMA_A = \\\"0b0000000000\\\";\\n\\tparameter CH1_UDF_COMMA_B = \\\"0b0000000000\\\";\\n\\tparameter CH1_UDF_COMMA_MASK = \\\"0b0000000000\\\";\\n\\tparameter CH1_WA_BYPASS = \\\"0b0\\\";\\n\\tparameter CH1_WA_MODE = \\\"0b0\\\";\\n\\tparameter D_BITCLK_FROM_ND_EN = \\\"0b0\\\";\\n\\tparameter D_BITCLK_LOCAL_EN = \\\"0b0\\\";\\n\\tparameter D_BITCLK_ND_EN = \\\"0b0\\\";\\n\\tparameter D_BUS8BIT_SEL = \\\"0b0\\\";\\n\\tparameter D_CDR_LOL_SET = \\\"0b00\\\";\\n\\tparameter D_CMUSETBIASI = \\\"0b00\\\";\\n\\tparameter D_CMUSETI4CPP = \\\"0b0000\\\";\\n\\tparameter D_CMUSETI4CPZ = \\\"0b0000\\\";\\n\\tparameter D_CMUSETI4VCO = \\\"0b00\\\";\\n\\tparameter D_CMUSETICP4P = \\\"0b00\\\";\\n\\tparameter D_CMUSETICP4Z = \\\"0b000\\\";\\n\\tparameter D_CMUSETINITVCT = \\\"0b00\\\";\\n\\tparameter D_CMUSETISCL4VCO = \\\"0b000\\\";\\n\\tparameter D_CMUSETP1GM = \\\"0b000\\\";\\n\\tparameter D_CMUSETP2AGM = \\\"0b000\\\";\\n\\tparameter D_CMUSETZGM = \\\"0b000\\\";\\n\\tparameter D_DCO_CALIB_TIME_SEL = \\\"0b00\\\";\\n\\tparameter D_HIGH_MARK = \\\"0b0000\\\";\\n\\tparameter D_IB_PWDNB = \\\"0b0\\\";\\n\\tparameter D_ISETLOS = \\\"0b00000000\\\";\\n\\tparameter D_LOW_MARK = \\\"0b0000\\\";\\n\\tparameter D_MACROPDB = \\\"0b0\\\";\\n\\tparameter D_PD_ISET = \\\"0b00\\\";\\n\\tparameter D_PLL_LOL_SET = \\\"0b00\\\";\\n\\tparameter D_REFCK_MODE = \\\"0b000\\\";\\n\\tparameter D_REQ_ISET = \\\"0b000\\\";\\n\\tparameter D_RG_EN = \\\"0b0\\\";\\n\\tparameter D_RG_SET = \\\"0b00\\\";\\n\\tparameter D_SETICONST_AUX = \\\"0b00\\\";\\n\\tparameter D_SETICONST_CH = \\\"0b00\\\";\\n\\tparameter D_SETIRPOLY_AUX = \\\"0b00\\\";\\n\\tparameter D_SETIRPOLY_CH = \\\"0b00\\\";\\n\\tparameter D_SETPLLRC = \\\"0b000000\\\";\\n\\tparameter D_SYNC_LOCAL_EN = \\\"0b0\\\";\\n\\tparameter D_SYNC_ND_EN = \\\"0b0\\\";\\n\\tparameter D_TXPLL_PWDNB = \\\"0b0\\\";\\n\\tparameter D_TX_VCO_CK_DIV = \\\"0b000\\\";\\n\\tparameter D_XGE_MODE = \\\"0b0\\\";\\n\\n// These parameters don't do anything but are\\n// needed for compatibility with Diamond\\n\\tparameter D_TX_MAX_RATE = \\\"2.5\\\";\\n\\tparameter D_RX_MAX_RATE = \\\"2.5\\\";\\n\\tparameter CH0_TXAMPLITUDE = \\\"0d1300\\\";\\n\\tparameter CH1_TXAMPLITUDE = \\\"0d1300\\\";\\n\\tparameter CH0_PROTOCOL = \\\"8B10B\\\";\\n\\tparameter CH1_PROTOCOL = \\\"8B10B\\\";\\n\\tparameter CH0_CDR_MAX_RATE = \\\"2.5\\\";\\n\\tparameter CH1_CDR_MAX_RATE = \\\"2.5\\\";\\n\\tparameter CH0_TXDEPRE = \\\"DISABLED\\\";\\n\\tparameter CH1_TXDEPRE = \\\"DISABLED\\\";\\n\\tparameter CH0_TXDEPOST = \\\"DISABLED\\\";\\n\\tparameter CH1_TXDEPOST = \\\"DISABLED\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule EXTREFB (\\n\\t(* iopad_external_pin *)\\n\\tinput REFCLKP,\\n\\t(* iopad_external_pin *)\\n\\tinput REFCLKN,\\n\\toutput REFCLKO\\n);\\n\\tparameter REFCK_PWDNB = \\\"0b0\\\";\\n\\tparameter REFCK_RTERM = \\\"0b0\\\";\\n\\tparameter REFCK_DCBIAS_EN = \\\"0b0\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule PCSCLKDIV (\\n\\tinput CLKI, RST, SEL2, SEL1, SEL0,\\n\\toutput CDIV1, CDIVX\\n);\\n\\tparameter GSR = \\\"DISABLED\\\";\\nendmodule\\n\\n// Note: this module is not marked keep as we want it swept away in synth (sim use only)\\n(* blackbox *)\\nmodule PUR (\\n\\tinput PUR\\n);\\n\\tparameter RST_PULSE = 1;\\nendmodule\\n\\n(* blackbox, keep *)\\nmodule GSR (\\n\\tinput GSR\\n);\\nendmodule\\n\\n(* blackbox, keep *)\\nmodule SGSR (\\n\\tinput GSR, CLK\\n);\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule PDPW16KD (\\n\\tinput DI35, DI34, DI33, DI32, DI31, DI30, DI29, DI28, DI27, DI26, DI25, DI24, DI23, DI22, DI21, DI20, DI19, DI18,\\n\\tinput DI17, DI16, DI15, DI14, DI13, DI12, DI11, DI10, DI9, DI8, DI7, DI6, DI5, DI4, DI3, DI2, DI1, DI0,\\n\\tinput ADW8, ADW7, ADW6, ADW5, ADW4, ADW3, ADW2, ADW1, ADW0,\\n\\tinput BE3,  BE2,  BE1, BE0, CEW, CLKW, CSW2, CSW1, CSW0,\\n\\tinput ADR13, ADR12, ADR11, ADR10, ADR9, ADR8, ADR7, ADR6, ADR5, ADR4, ADR3, ADR2, ADR1, ADR0,\\n\\tinput CER, OCER, CLKR, CSR2, CSR1, CSR0, RST,\\n\\toutput DO35, DO34, DO33, DO32, DO31, DO30, DO29, DO28, DO27, DO26, DO25, DO24, DO23, DO22, DO21, DO20, DO19, DO18,\\n\\toutput DO17, DO16, DO15, DO14, DO13, DO12, DO11, DO10, DO9, DO8, DO7, DO6, DO5, DO4, DO3, DO2, DO1, DO0\\n);\\n\\tparameter DATA_WIDTH_W = 36;\\n\\tparameter DATA_WIDTH_R = 36;\\n\\tparameter GSR = \\\"ENABLED\\\";\\n\\n\\tparameter REGMODE = \\\"NOREG\\\";\\n\\n\\tparameter RESETMODE = \\\"SYNC\\\";\\n\\tparameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n\\n\\tparameter CSDECODE_W = \\\"0b000\\\";\\n\\tparameter CSDECODE_R = \\\"0b000\\\";\\n\\n\\tparameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INIT_DATA = \\\"STATIC\\\";\\n\\tparameter CLKWMUX = \\\"CLKW\\\";\\n\\tparameter CLKRMUX = \\\"CLKR\\\";\\n\\nendmodule\\n\",\n            \"cells_ff.vh\": \"// Diamond flip-flops\\nmodule FD1P3AX(input     D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3AY(input     D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3BX(input PD, D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3DX(input CD, D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3IX(input CD, D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3JX(input PD, D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1S3AX(input     D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3AY(input     D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3BX(input PD, D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3DX(input CD, D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3IX(input CD, D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3JX(input PD, D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule\\n\\n// TODO: Diamond latches\\n// module FL1P3AY(); endmodule\\n// module FL1P3AZ(); endmodule\\n// module FL1P3BX(); endmodule\\n// module FL1P3DX(); endmodule\\n// module FL1P3IY(); endmodule\\n// module FL1P3JY(); endmodule\\n// module FL1S3AX(); endmodule\\n// module FL1S3AY(); endmodule\\n\\n// Diamond I/O registers\\nmodule IFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"input\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule IFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"input\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule IFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"input\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule IFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"input\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"LSR_OVER_CE\\\")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\n\\nmodule OFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"output\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule OFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"output\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule OFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"output\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule OFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"output\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"LSR_OVER_CE\\\")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\n\\n// TODO: Diamond I/O latches\\n// module IFS1S1B(input PD, D, SCLK, output Q); endmodule\\n// module IFS1S1D(input CD, D, SCLK, output Q); endmodule\\n// module IFS1S1I(input PD, D, SCLK, output Q); endmodule\\n// module IFS1S1J(input CD, D, SCLK, output Q); endmodule\\n\",\n            \"cells_io.vh\": \"// Diamond I/O buffers\\nmodule IB   ((* iopad_external_pin *) input I,     output O); (* PULLMODE=\\\"NONE\\\" *) TRELLIS_IO #(.DIR(\\\"INPUT\\\"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule\\nmodule IBPU ((* iopad_external_pin *) input I,     output O); (* PULLMODE=\\\"UP\\\"   *) TRELLIS_IO #(.DIR(\\\"INPUT\\\"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule\\nmodule IBPD ((* iopad_external_pin *) input I,     output O); (* PULLMODE=\\\"DOWN\\\" *) TRELLIS_IO #(.DIR(\\\"INPUT\\\"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule\\nmodule OB   (input I,     (* iopad_external_pin *) output O); (* PULLMODE=\\\"NONE\\\" *) TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(O), .I(I)); endmodule\\nmodule OBZ  (input I, T,  (* iopad_external_pin *) output O); (* PULLMODE=\\\"NONE\\\" *) TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule\\nmodule OBZPU(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE=\\\"UP\\\"   *) TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule\\nmodule OBZPD(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE=\\\"DOWN\\\" *) TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule\\nmodule OBCO (input I,     output OT, OC); OLVDS olvds (.A(I), .Z(OT), .ZN(OC)); endmodule\\nmodule BB   (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE=\\\"NONE\\\" *) TRELLIS_IO #(.DIR(\\\"BIDIR\\\")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule\\nmodule BBPU (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE=\\\"UP\\\"   *) TRELLIS_IO #(.DIR(\\\"BIDIR\\\")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule\\nmodule BBPD (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE=\\\"DOWN\\\" *) TRELLIS_IO #(.DIR(\\\"BIDIR\\\")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule\\nmodule ILVDS(input A, AN, (* iopad_external_pin *) output Z    ); TRELLIS_IO #(.DIR(\\\"INPUT\\\"))  _TECHMAP_REPLACE_ (.B(A), .O(Z)); endmodule\\nmodule OLVDS(input A,     (* iopad_external_pin *) output Z, output ZN); TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(Z), .I(A)); endmodule\\n\",\n            \"cells_map.v\": \"module  \\\\$_DFF_N_ (input D, C, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFF_P_ (input D, C, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFFE_NN_ (input D, C, E, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFFE_PN_ (input D, C, E, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFFE_NP_ (input D, C, E, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFFE_PP_ (input D, C, E, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_SDFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_DFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_DFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_SDFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_SDFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule \\\\$_ALDFF_NP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\nmodule \\\\$_ALDFF_PP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\n\\nmodule \\\\$_ALDFFE_NPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\nmodule \\\\$_ALDFFE_NPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\nmodule \\\\$_ALDFFE_PPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\nmodule \\\\$_ALDFFE_PPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\n\\n`include \\\"cells_ff.vh\\\"\\n`include \\\"cells_io.vh\\\"\\n\\n`ifndef NO_LUT\\nmodule \\\\$lut (A, Y);\\n    parameter WIDTH = 0;\\n    parameter LUT = 0;\\n\\n    (* force_downto *)\\n    input [WIDTH-1:0] A;\\n    output Y;\\n\\n    generate\\n        if (WIDTH == 1) begin\\n            localparam [15:0] INIT = {{8{LUT[1]}}, {8{LUT[0]}}};\\n            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),\\n                .A(1'b0), .B(1'b0), .C(1'b0), .D(A[0]));\\n        end else\\n        if (WIDTH == 2) begin\\n            localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};\\n            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),\\n                .A(1'b0), .B(1'b0), .C(A[0]), .D(A[1]));\\n        end else\\n        if (WIDTH == 3) begin\\n            localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};\\n            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),\\n                .A(1'b0), .B(A[0]), .C(A[1]), .D(A[2]));\\n        end else\\n        if (WIDTH == 4) begin\\n            LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Z(Y),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n        `ifndef NO_PFUMUX\\n        end else\\n        if (WIDTH == 5) begin\\n            wire f0, f1;\\n            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            PFUMX mux5(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(Y));\\n        end else\\n        if (WIDTH == 6) begin\\n            wire f0, f1, f2, f3, g0, g1;\\n            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));\\n            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));\\n            L6MUX21 mux6 (.D0(g0), .D1(g1), .SD(A[5]), .Z(Y));\\n        end else\\n        if (WIDTH == 7) begin\\n            wire f0, f1, f2, f3, f4, f5, f6, f7, g0, g1, g2, g3, h0, h1;\\n            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            LUT4 #(.INIT(LUT[79:64])) lut4 (.Z(f4),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[95:80])) lut5 (.Z(f5),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            LUT4 #(.INIT(LUT[111: 96])) lut6 (.Z(f6),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[127:112])) lut7 (.Z(f7),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));\\n            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));\\n            PFUMX mux52(.ALUT(f5), .BLUT(f4), .C0(A[4]), .Z(g2));\\n            PFUMX mux53(.ALUT(f7), .BLUT(f6), .C0(A[4]), .Z(g3));\\n            L6MUX21 mux60 (.D0(g0), .D1(g1), .SD(A[5]), .Z(h0));\\n            L6MUX21 mux61 (.D0(g2), .D1(g3), .SD(A[5]), .Z(h1));\\n            L6MUX21 mux7  (.D0(h0), .D1(h1), .SD(A[6]), .Z(Y));\\n        `endif\\n        end else begin\\n            wire _TECHMAP_FAIL_ = 1;\\n        end\\n    endgenerate\\nendmodule\\n`endif\\n\",\n            \"cells_sim.v\": \"// ---------------------------------------\\n\\n(* abc9_lut=1, lib_whitebox *)\\nmodule LUT4(input A, B, C, D, output Z);\\n    parameter [15:0] INIT = 16'h0000;\\n    wire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];\\n    wire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];\\n    wire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];\\n    assign Z =      A ?          s1[1] :         s1[0];\\n    specify\\n        (A => Z) = 141;\\n        (B => Z) = 275;\\n        (C => Z) = 379;\\n        (D => Z) = 379;\\n    endspecify\\nendmodule\\n\\n// This is a placeholder for ABC9 to extract the area/delay\\n//   cost of 5-input LUTs and is not intended to be instantiated\\n// LUT5 = 2x LUT4 + PFUMX\\n(* abc9_lut=2 *)\\nmodule \\\\$__ABC9_LUT5 (input M0, D, C, B, A, output Z);\\n    specify\\n        (M0 => Z) = 151;\\n        (D => Z) = 239;\\n        (C => Z) = 373;\\n        (B => Z) = 477;\\n        (A => Z) = 477;\\n    endspecify\\nendmodule\\n\\n// This is a placeholder for ABC9 to extract the area/delay\\n//   of 6-input LUTs and is not intended to be instantiated\\n// LUT6 = 2x LUT5 + MUX2\\n(* abc9_lut=4 *)\\nmodule \\\\$__ABC9_LUT6 (input M1, M0, D, C, B, A, output Z);\\n    specify\\n        (M1 => Z) = 148;\\n        (M0 => Z) = 292;\\n        (D => Z) = 380;\\n        (C => Z) = 514;\\n        (B => Z) = 618;\\n        (A => Z) = 618;\\n    endspecify\\nendmodule\\n\\n// This is a placeholder for ABC9 to extract the area/delay\\n//   of 7-input LUTs and is not intended to be instantiated\\n// LUT7 = 2x LUT6 + MUX2\\n(* abc9_lut=8 *)\\nmodule \\\\$__ABC9_LUT7 (input M2, M1, M0, D, C, B, A, output Z);\\n    specify\\n        (M2 => Z) = 148;\\n        (M1 => Z) = 289;\\n        (M0 => Z) = 433;\\n        (D => Z) = 521;\\n        (C => Z) = 655;\\n        (B => Z) = 759;\\n        (A => Z) = 759;\\n    endspecify\\nendmodule\\n\\n// ---------------------------------------\\n(* abc9_box, lib_whitebox *)\\nmodule L6MUX21 (input D0, D1, SD, output Z);\\n\\tassign Z = SD ? D1 : D0;\\n\\tspecify\\n\\t\\t(D0 => Z) = 140;\\n\\t\\t(D1 => Z) = 141;\\n\\t\\t(SD => Z) = 148;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n(* abc9_box, lib_whitebox *)\\nmodule CCU2C(\\n\\t(* abc9_carry *)\\n\\tinput  CIN,\\n\\tinput  A0, B0, C0, D0, A1, B1, C1, D1,\\n\\toutput S0, S1,\\n\\t(* abc9_carry *)\\n\\toutput COUT\\n);\\n\\tparameter [15:0] INIT0 = 16'h0000;\\n\\tparameter [15:0] INIT1 = 16'h0000;\\n\\tparameter INJECT1_0 = \\\"YES\\\";\\n\\tparameter INJECT1_1 = \\\"YES\\\";\\n\\n\\t// First half\\n\\twire LUT4_0, LUT2_0;\\n\\tLUT4 #(.INIT(INIT0)) lut4_0(.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0));\\n\\tLUT2 #(.INIT(INIT0[3:0])) lut2_0(.A(A0), .B(B0), .Z(LUT2_0));\\n\\twire gated_cin_0 = (INJECT1_0 == \\\"YES\\\") ? 1'b0 : CIN;\\n\\tassign S0 = LUT4_0 ^ gated_cin_0;\\n\\n\\twire gated_lut2_0 = (INJECT1_0 == \\\"YES\\\") ? 1'b0 : LUT2_0;\\n\\twire cout_0 = (~LUT4_0 & gated_lut2_0) | (LUT4_0 & CIN);\\n\\n\\t// Second half\\n\\twire LUT4_1, LUT2_1;\\n\\tLUT4 #(.INIT(INIT1)) lut4_1(.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1));\\n\\tLUT2 #(.INIT(INIT1[3:0])) lut2_1(.A(A1), .B(B1), .Z(LUT2_1));\\n\\twire gated_cin_1 = (INJECT1_1 == \\\"YES\\\") ? 1'b0 : cout_0;\\n\\tassign S1 = LUT4_1 ^ gated_cin_1;\\n\\n\\twire gated_lut2_1 = (INJECT1_1 == \\\"YES\\\") ? 1'b0 : LUT2_1;\\n\\tassign COUT = (~LUT4_1 & gated_lut2_1) | (LUT4_1 & cout_0);\\n\\n\\tspecify\\n\\t\\t(A0 => S0) = 379;\\n\\t\\t(B0 => S0) = 379;\\n\\t\\t(C0 => S0) = 275;\\n\\t\\t(D0 => S0) = 141;\\n\\t\\t(CIN => S0) = 257;\\n\\t\\t(A0 => S1) = 630;\\n\\t\\t(B0 => S1) = 630;\\n\\t\\t(C0 => S1) = 526;\\n\\t\\t(D0 => S1) = 392;\\n\\t\\t(A1 => S1) = 379;\\n\\t\\t(B1 => S1) = 379;\\n\\t\\t(C1 => S1) = 275;\\n\\t\\t(D1 => S1) = 141;\\n\\t\\t(CIN => S1) = 273;\\n\\t\\t(A0 => COUT) = 516;\\n\\t\\t(B0 => COUT) = 516;\\n\\t\\t(C0 => COUT) = 412;\\n\\t\\t(D0 => COUT) = 278;\\n\\t\\t(A1 => COUT) = 516;\\n\\t\\t(B1 => COUT) = 516;\\n\\t\\t(C1 => COUT) = 412;\\n\\t\\t(D1 => COUT) = 278;\\n\\t\\t(CIN => COUT) = 43;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n\\nmodule TRELLIS_RAM16X2 (\\n\\tinput DI0, DI1,\\n\\tinput WAD0, WAD1, WAD2, WAD3,\\n\\tinput WRE, WCK,\\n\\tinput RAD0, RAD1, RAD2, RAD3,\\n\\toutput DO0, DO1\\n);\\n\\tparameter WCKMUX = \\\"WCK\\\";\\n\\tparameter WREMUX = \\\"WRE\\\";\\n\\tparameter INITVAL_0 = 16'h0000;\\n\\tparameter INITVAL_1 = 16'h0000;\\n\\n\\treg [1:0] mem[15:0];\\n\\n\\tinteger i;\\n\\tinitial begin\\n\\t\\tfor (i = 0; i < 16; i = i + 1)\\n\\t\\t\\tmem[i] <= {INITVAL_1[i], INITVAL_0[i]};\\n\\tend\\n\\n\\twire muxwck = (WCKMUX == \\\"INV\\\") ? ~WCK : WCK;\\n\\n\\treg muxwre;\\n\\talways @(*)\\n\\t\\tcase (WREMUX)\\n\\t\\t\\t\\\"1\\\": muxwre = 1'b1;\\n\\t\\t\\t\\\"0\\\": muxwre = 1'b0;\\n\\t\\t\\t\\\"INV\\\": muxwre = ~WRE;\\n\\t\\t\\tdefault: muxwre = WRE;\\n\\t\\tendcase\\n\\n\\n\\talways @(posedge muxwck)\\n\\t\\tif (muxwre)\\n\\t\\t\\tmem[{WAD3, WAD2, WAD1, WAD0}] <= {DI1, DI0};\\n\\n\\tassign {DO1, DO0} = mem[{RAD3, RAD2, RAD1, RAD0}];\\nendmodule\\n\\n// ---------------------------------------\\n(* abc9_box, lib_whitebox *)\\nmodule PFUMX (input ALUT, BLUT, C0, output Z);\\n\\tassign Z = C0 ? ALUT : BLUT;\\n\\tspecify\\n\\t\\t(ALUT => Z) = 98;\\n\\t\\t(BLUT => Z) = 98;\\n\\t\\t(C0 => Z) = 151;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n(* abc9_box, lib_whitebox *)\\nmodule TRELLIS_DPR16X4 (\\n\\tinput  [3:0] DI,\\n\\tinput  [3:0] WAD,\\n\\tinput        WRE,\\n\\tinput        WCK,\\n\\tinput  [3:0] RAD,\\n\\toutput [3:0] DO\\n);\\n\\tparameter WCKMUX = \\\"WCK\\\";\\n\\tparameter WREMUX = \\\"WRE\\\";\\n\\tparameter [63:0] INITVAL = 64'h0000000000000000;\\n\\n\\treg [3:0] mem[15:0];\\n\\n\\tinteger i;\\n\\tinitial begin\\n\\t\\tfor (i = 0; i < 16; i = i + 1)\\n\\t\\t\\tmem[i] <= INITVAL[4*i +: 4];\\n\\tend\\n\\n\\twire muxwck = (WCKMUX == \\\"INV\\\") ? ~WCK : WCK;\\n\\n\\treg muxwre;\\n\\talways @(*)\\n\\t\\tcase (WREMUX)\\n\\t\\t\\t\\\"1\\\": muxwre = 1'b1;\\n\\t\\t\\t\\\"0\\\": muxwre = 1'b0;\\n\\t\\t\\t\\\"INV\\\": muxwre = ~WRE;\\n\\t\\t\\tdefault: muxwre = WRE;\\n\\t\\tendcase\\n\\n\\talways @(posedge muxwck)\\n\\t\\tif (muxwre)\\n\\t\\t\\tmem[WAD] <= DI;\\n\\n\\tassign DO = mem[RAD];\\n\\n\\tspecify\\n\\t\\t// TODO\\n\\t\\t(RAD *> DO) = 0;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DPR16X4C (\\n\\t\\tinput [3:0] DI,\\n\\t\\tinput WCK, WRE,\\n\\t\\tinput [3:0] RAD,\\n\\t\\tinput [3:0] WAD,\\n\\t\\toutput [3:0] DO\\n);\\n\\t// For legacy Lattice compatibility, INITIVAL is a hex\\n\\t// string rather than a numeric parameter\\n\\tparameter INITVAL = \\\"0x0000000000000000\\\";\\n\\n\\tfunction [63:0] convert_initval;\\n\\t\\tinput [143:0] hex_initval;\\n\\t\\treg done;\\n\\t\\treg [63:0] temp;\\n\\t\\treg [7:0] char;\\n\\t\\tinteger i;\\n\\t\\tbegin\\n\\t\\t\\tdone = 1'b0;\\n\\t\\t\\ttemp = 0;\\n\\t\\t\\tfor (i = 0; i < 16; i = i + 1) begin\\n\\t\\t\\t\\tif (!done) begin\\n\\t\\t\\t\\t\\tchar = hex_initval[8*i +: 8];\\n\\t\\t\\t\\t\\tif (char == \\\"x\\\") begin\\n\\t\\t\\t\\t\\t\\tdone = 1'b1;\\n\\t\\t\\t\\t\\tend else begin\\n\\t\\t\\t\\t\\t\\tif (char >= \\\"0\\\" && char <= \\\"9\\\")\\n\\t\\t\\t\\t\\t\\t\\ttemp[4*i +: 4] = char - \\\"0\\\";\\n\\t\\t\\t\\t\\t\\telse if (char >= \\\"A\\\" && char <= \\\"F\\\")\\n\\t\\t\\t\\t\\t\\t\\ttemp[4*i +: 4] = 10 + char - \\\"A\\\";\\n\\t\\t\\t\\t\\t\\telse if (char >= \\\"a\\\" && char <= \\\"f\\\")\\n\\t\\t\\t\\t\\t\\t\\ttemp[4*i +: 4] = 10 + char - \\\"a\\\";\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\t\\t\\tconvert_initval = temp;\\n\\t\\tend\\n\\tendfunction\\n\\n\\tlocalparam conv_initval = convert_initval(INITVAL);\\n\\n\\treg [3:0] ram[0:15];\\n\\tinteger i;\\n\\tinitial begin\\n\\t\\tfor (i = 0; i < 15; i = i + 1) begin\\n\\t\\t\\tram[i] <= conv_initval[4*i +: 4];\\n\\t\\tend\\n\\tend\\n\\n\\talways @(posedge WCK)\\n\\t\\tif (WRE)\\n\\t\\t\\tram[WAD] <= DI;\\n\\n\\tassign DO = ram[RAD];\\n\\n\\tspecify\\n\\t\\t// TODO\\n\\t\\t(RAD *> DO) = 0;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n\\n(* lib_whitebox *)\\nmodule LUT2(input A, B, output Z);\\n    parameter [3:0] INIT = 4'h0;\\n    wire [1:0] s1 = B ?     INIT[ 3:2] :     INIT[1:0];\\n    assign Z =      A ?          s1[1] :         s1[0];\\nendmodule\\n\\n// ---------------------------------------\\n\\n`ifdef YOSYS\\n(* abc9_flop=(SRMODE != \\\"ASYNC\\\"), abc9_box=(SRMODE == \\\"ASYNC\\\"), lib_whitebox *)\\n`endif\\nmodule TRELLIS_FF(input CLK, LSR, CE, DI, M, output reg Q);\\n\\tparameter GSR = \\\"ENABLED\\\";\\n\\tparameter [127:0] CEMUX = \\\"1\\\";\\n\\tparameter CLKMUX = \\\"CLK\\\";\\n\\tparameter LSRMUX = \\\"LSR\\\";\\n\\tparameter SRMODE = \\\"LSR_OVER_CE\\\";\\n\\tparameter REGSET = \\\"RESET\\\";\\n\\tparameter [127:0] LSRMODE = \\\"LSR\\\";\\n\\n\\twire muxce;\\n\\tgenerate\\n\\t\\tcase (CEMUX)\\n\\t\\t\\t\\\"1\\\": assign muxce = 1'b1;\\n\\t\\t\\t\\\"0\\\": assign muxce = 1'b0;\\n\\t\\t\\t\\\"INV\\\": assign muxce = ~CE;\\n\\t\\t\\tdefault: assign muxce = CE;\\n\\t\\tendcase\\n\\tendgenerate\\n\\n\\twire muxlsr = (LSRMUX == \\\"INV\\\") ? ~LSR : LSR;\\n\\twire muxclk = (CLKMUX == \\\"INV\\\") ? ~CLK : CLK;\\n\\twire srval;\\n\\tgenerate\\n\\t\\tif (LSRMODE == \\\"PRLD\\\")\\n\\t\\t\\tassign srval = M;\\n\\t\\telse\\n\\t\\t\\tassign srval = (REGSET == \\\"SET\\\") ? 1'b1 : 1'b0;\\n\\tendgenerate\\n\\n\\tinitial Q = srval;\\n\\n\\tgenerate\\n\\t\\tif (SRMODE == \\\"ASYNC\\\") begin\\n\\t\\t\\talways @(posedge muxclk, posedge muxlsr)\\n\\t\\t\\t\\tif (muxlsr)\\n\\t\\t\\t\\t\\tQ <= srval;\\n\\t\\t\\t\\telse if (muxce)\\n\\t\\t\\t\\t\\tQ <= DI;\\n\\t\\tend else begin\\n\\t\\t\\talways @(posedge muxclk)\\n\\t\\t\\t\\tif (muxlsr)\\n\\t\\t\\t\\t\\tQ <= srval;\\n\\t\\t\\t\\telse if (muxce)\\n\\t\\t\\t\\t\\tQ <= DI;\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tspecify\\n\\t\\t$setup(DI, negedge CLK &&& CLKMUX == \\\"INV\\\", 0);\\n\\t\\t$setup(CE, negedge CLK &&& CLKMUX == \\\"INV\\\", 0);\\n\\t\\t$setup(LSR, negedge CLK &&& CLKMUX == \\\"INV\\\", 0);\\n\\t\\t$setup(DI, posedge CLK &&& CLKMUX != \\\"INV\\\", 0);\\n\\t\\t$setup(CE, posedge CLK &&& CLKMUX != \\\"INV\\\", 0);\\n\\t\\t$setup(LSR, posedge CLK &&& CLKMUX != \\\"INV\\\", 0);\\n`ifndef YOSYS\\n\\t\\tif (SRMODE == \\\"ASYNC\\\" && muxlsr && CLKMUX == \\\"INV\\\") (negedge CLK => (Q : srval)) = 0;\\n\\t\\tif (SRMODE == \\\"ASYNC\\\" && muxlsr && CLKMUX != \\\"INV\\\") (posedge CLK => (Q : srval)) = 0;\\n`else\\n\\t\\tif (SRMODE == \\\"ASYNC\\\" && muxlsr) (LSR => Q) = 0; \\t// Technically, this should be an edge sensitive path\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// but for facilitating a bypass box, let's pretend it's\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// a simple path\\n`endif\\n\\t\\tif (!muxlsr && muxce && CLKMUX == \\\"INV\\\") (negedge CLK => (Q : DI)) = 0;\\n\\t\\tif (!muxlsr && muxce && CLKMUX != \\\"INV\\\") (posedge CLK => (Q : DI)) = 0;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n(* keep *)\\nmodule TRELLIS_IO(\\n\\t(* iopad_external_pin *)\\n\\tinout B,\\n\\tinput I,\\n\\tinput T,\\n\\toutput O\\n);\\n\\tparameter DIR = \\\"INPUT\\\";\\n\\treg T_pd;\\n\\talways @(*) if (T === 1'bz) T_pd <= 1'b0; else T_pd <= T;\\n\\n\\tgenerate\\n\\t\\tif (DIR == \\\"INPUT\\\") begin\\n\\t\\t\\tassign B = 1'bz;\\n\\t\\t\\tassign O = B;\\n\\t\\tend else if (DIR == \\\"OUTPUT\\\") begin\\n\\t\\t\\tassign B = T_pd ? 1'bz : I;\\n\\t\\t\\tassign O = 1'bx;\\n\\t\\tend else if (DIR == \\\"BIDIR\\\") begin\\n\\t\\t\\tassign B = T_pd ? 1'bz : I;\\n\\t\\t\\tassign O = B;\\n\\t\\tend else begin\\n\\t\\t\\tERROR_UNKNOWN_IO_MODE error();\\n\\t\\tend\\n\\tendgenerate\\n\\nendmodule\\n\\n// ---------------------------------------\\n\\nmodule INV(input A, output Z);\\n\\tassign Z = !A;\\nendmodule\\n\\n// ---------------------------------------\\n\\nmodule TRELLIS_COMB(\\n\\tinput A, B, C, D, M,\\n\\tinput FCI, F1, FXA, FXB,\\n\\tinput WD,\\n\\tinput WAD0, WAD1, WAD2, WAD3,\\n\\tinput WRE, WCK,\\n\\toutput F, FCO, OFX\\n);\\n\\tparameter MODE = \\\"LOGIC\\\";\\n\\tparameter INITVAL = 16'h0;\\n\\tparameter CCU2_INJECT1 = \\\"NO\\\";\\n\\tparameter WREMUX = \\\"WRE\\\";\\n\\tparameter IS_Z1 = 1'b0;\\n\\n\\tgenerate\\n\\t\\tif (MODE == \\\"LOGIC\\\") begin: mode_logic\\n\\t\\t\\tLUT4 #(.INIT(INITVAL)) lut4 (.A(A), .B(B), .C(C), .D(D), .Z(F));\\n\\t\\tend else if (MODE == \\\"CCU2\\\") begin: mode_ccu2\\n\\t\\t\\twire l4o, l2o;\\n\\t\\t\\tLUT4 #(.INIT(INITVAL)) lut4_0(.A(A), .B(B), .C(C), .D(D), .Z(l4o));\\n\\t\\t\\tLUT2 #(.INIT(INITVAL[3:0])) lut2_0(.A(A), .B(B), .Z(l2o));\\n\\t\\t\\twire gated_cin_0 = (CCU2_INJECT1 == \\\"YES\\\") ? 1'b0 : FCI;\\n\\t\\t\\tassign F = l4o ^ gated_cin_0;\\n\\t\\t\\twire gated_lut2_0 = (CCU2_INJECT1 == \\\"YES\\\") ? 1'b0 : l2o;\\n\\t\\t\\twire FCO = (~l4o & gated_lut2_0) | (l4o & FCI);\\n\\t\\tend else if (MODE == \\\"DPRAM\\\") begin: mode_dpram\\n\\t\\t\\treg [15:0] ram = INITVAL;\\n\\t\\t\\talways @(posedge WCK)\\n\\t\\t\\t\\tif (WRE)\\n\\t\\t\\t\\t\\tram[{WAD3, WAD2, WAD1, WAD0}] <= WD;\\n\\t\\t\\tassign F = ram[{A, C, B, D}];\\n\\t\\tend else begin\\n\\t\\t\\t$error(\\\"unsupported COMB mode %s\\\", MODE);\\n\\t\\tend\\n\\n \\t\\tif (IS_Z1)\\n\\t\\t\\tL6MUX21 lutx_mux (.D0(FXA), .D1(FXB), .SD(M), .Z(OFX));\\n\\t\\telse\\n\\t\\t\\tPFUMX lut5_mux (.ALUT(F1), .BLUT(F), .C0(M), .Z(OFX));\\n\\tendgenerate\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule DP16KD(\\n  input DIA17, DIA16, DIA15, DIA14, DIA13, DIA12, DIA11, DIA10, DIA9, DIA8, DIA7, DIA6, DIA5, DIA4, DIA3, DIA2, DIA1, DIA0,\\n  input ADA13, ADA12, ADA11, ADA10, ADA9, ADA8, ADA7, ADA6, ADA5, ADA4, ADA3, ADA2, ADA1, ADA0,\\n  input CEA, OCEA, CLKA, WEA, RSTA,\\n  input CSA2, CSA1, CSA0,\\n  output DOA17, DOA16, DOA15, DOA14, DOA13, DOA12, DOA11, DOA10, DOA9, DOA8, DOA7, DOA6, DOA5, DOA4, DOA3, DOA2, DOA1, DOA0,\\n\\n  input DIB17, DIB16, DIB15, DIB14, DIB13, DIB12, DIB11, DIB10, DIB9, DIB8, DIB7, DIB6, DIB5, DIB4, DIB3, DIB2, DIB1, DIB0,\\n  input ADB13, ADB12, ADB11, ADB10, ADB9, ADB8, ADB7, ADB6, ADB5, ADB4, ADB3, ADB2, ADB1, ADB0,\\n  input CEB, OCEB, CLKB, WEB, RSTB,\\n  input CSB2, CSB1, CSB0,\\n  output DOB17, DOB16, DOB15, DOB14, DOB13, DOB12, DOB11, DOB10, DOB9, DOB8, DOB7, DOB6, DOB5, DOB4, DOB3, DOB2, DOB1, DOB0\\n);\\n\\tparameter DATA_WIDTH_A = 18;\\n\\tparameter DATA_WIDTH_B = 18;\\n\\n\\tparameter REGMODE_A = \\\"NOREG\\\";\\n\\tparameter REGMODE_B = \\\"NOREG\\\";\\n\\n\\tparameter RESETMODE = \\\"SYNC\\\";\\n\\tparameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n\\n\\tparameter CSDECODE_A = \\\"0b000\\\";\\n\\tparameter CSDECODE_B = \\\"0b000\\\";\\n\\n\\tparameter WRITEMODE_A = \\\"NORMAL\\\";\\n\\tparameter WRITEMODE_B = \\\"NORMAL\\\";\\n\\n\\tparameter DIA17MUX = \\\"DIA17\\\";\\n\\tparameter DIA16MUX = \\\"DIA16\\\";\\n\\tparameter DIA15MUX = \\\"DIA15\\\";\\n\\tparameter DIA14MUX = \\\"DIA14\\\";\\n\\tparameter DIA13MUX = \\\"DIA13\\\";\\n\\tparameter DIA12MUX = \\\"DIA12\\\";\\n\\tparameter DIA11MUX = \\\"DIA11\\\";\\n\\tparameter DIA10MUX = \\\"DIA10\\\";\\n\\tparameter DIA9MUX = \\\"DIA9\\\";\\n\\tparameter DIA8MUX = \\\"DIA8\\\";\\n\\tparameter DIA7MUX = \\\"DIA7\\\";\\n\\tparameter DIA6MUX = \\\"DIA6\\\";\\n\\tparameter DIA5MUX = \\\"DIA5\\\";\\n\\tparameter DIA4MUX = \\\"DIA4\\\";\\n\\tparameter DIA3MUX = \\\"DIA3\\\";\\n\\tparameter DIA2MUX = \\\"DIA2\\\";\\n\\tparameter DIA1MUX = \\\"DIA1\\\";\\n\\tparameter DIA0MUX = \\\"DIA0\\\";\\n\\tparameter ADA13MUX = \\\"ADA13\\\";\\n\\tparameter ADA12MUX = \\\"ADA12\\\";\\n\\tparameter ADA11MUX = \\\"ADA11\\\";\\n\\tparameter ADA10MUX = \\\"ADA10\\\";\\n\\tparameter ADA9MUX = \\\"ADA9\\\";\\n\\tparameter ADA8MUX = \\\"ADA8\\\";\\n\\tparameter ADA7MUX = \\\"ADA7\\\";\\n\\tparameter ADA6MUX = \\\"ADA6\\\";\\n\\tparameter ADA5MUX = \\\"ADA5\\\";\\n\\tparameter ADA4MUX = \\\"ADA4\\\";\\n\\tparameter ADA3MUX = \\\"ADA3\\\";\\n\\tparameter ADA2MUX = \\\"ADA2\\\";\\n\\tparameter ADA1MUX = \\\"ADA1\\\";\\n\\tparameter ADA0MUX = \\\"ADA0\\\";\\n\\tparameter CEAMUX = \\\"CEA\\\";\\n\\tparameter OCEAMUX = \\\"OCEA\\\";\\n\\tparameter CLKAMUX = \\\"CLKA\\\";\\n\\tparameter WEAMUX = \\\"WEA\\\";\\n\\tparameter RSTAMUX = \\\"RSTA\\\";\\n\\tparameter CSA2MUX = \\\"CSA2\\\";\\n\\tparameter CSA1MUX = \\\"CSA1\\\";\\n\\tparameter CSA0MUX = \\\"CSA0\\\";\\n\\tparameter DOA17MUX = \\\"DOA17\\\";\\n\\tparameter DOA16MUX = \\\"DOA16\\\";\\n\\tparameter DOA15MUX = \\\"DOA15\\\";\\n\\tparameter DOA14MUX = \\\"DOA14\\\";\\n\\tparameter DOA13MUX = \\\"DOA13\\\";\\n\\tparameter DOA12MUX = \\\"DOA12\\\";\\n\\tparameter DOA11MUX = \\\"DOA11\\\";\\n\\tparameter DOA10MUX = \\\"DOA10\\\";\\n\\tparameter DOA9MUX = \\\"DOA9\\\";\\n\\tparameter DOA8MUX = \\\"DOA8\\\";\\n\\tparameter DOA7MUX = \\\"DOA7\\\";\\n\\tparameter DOA6MUX = \\\"DOA6\\\";\\n\\tparameter DOA5MUX = \\\"DOA5\\\";\\n\\tparameter DOA4MUX = \\\"DOA4\\\";\\n\\tparameter DOA3MUX = \\\"DOA3\\\";\\n\\tparameter DOA2MUX = \\\"DOA2\\\";\\n\\tparameter DOA1MUX = \\\"DOA1\\\";\\n\\tparameter DOA0MUX = \\\"DOA0\\\";\\n\\tparameter DIB17MUX = \\\"DIB17\\\";\\n\\tparameter DIB16MUX = \\\"DIB16\\\";\\n\\tparameter DIB15MUX = \\\"DIB15\\\";\\n\\tparameter DIB14MUX = \\\"DIB14\\\";\\n\\tparameter DIB13MUX = \\\"DIB13\\\";\\n\\tparameter DIB12MUX = \\\"DIB12\\\";\\n\\tparameter DIB11MUX = \\\"DIB11\\\";\\n\\tparameter DIB10MUX = \\\"DIB10\\\";\\n\\tparameter DIB9MUX = \\\"DIB9\\\";\\n\\tparameter DIB8MUX = \\\"DIB8\\\";\\n\\tparameter DIB7MUX = \\\"DIB7\\\";\\n\\tparameter DIB6MUX = \\\"DIB6\\\";\\n\\tparameter DIB5MUX = \\\"DIB5\\\";\\n\\tparameter DIB4MUX = \\\"DIB4\\\";\\n\\tparameter DIB3MUX = \\\"DIB3\\\";\\n\\tparameter DIB2MUX = \\\"DIB2\\\";\\n\\tparameter DIB1MUX = \\\"DIB1\\\";\\n\\tparameter DIB0MUX = \\\"DIB0\\\";\\n\\tparameter ADB13MUX = \\\"ADB13\\\";\\n\\tparameter ADB12MUX = \\\"ADB12\\\";\\n\\tparameter ADB11MUX = \\\"ADB11\\\";\\n\\tparameter ADB10MUX = \\\"ADB10\\\";\\n\\tparameter ADB9MUX = \\\"ADB9\\\";\\n\\tparameter ADB8MUX = \\\"ADB8\\\";\\n\\tparameter ADB7MUX = \\\"ADB7\\\";\\n\\tparameter ADB6MUX = \\\"ADB6\\\";\\n\\tparameter ADB5MUX = \\\"ADB5\\\";\\n\\tparameter ADB4MUX = \\\"ADB4\\\";\\n\\tparameter ADB3MUX = \\\"ADB3\\\";\\n\\tparameter ADB2MUX = \\\"ADB2\\\";\\n\\tparameter ADB1MUX = \\\"ADB1\\\";\\n\\tparameter ADB0MUX = \\\"ADB0\\\";\\n\\tparameter CEBMUX = \\\"CEB\\\";\\n\\tparameter OCEBMUX = \\\"OCEB\\\";\\n\\tparameter CLKBMUX = \\\"CLKB\\\";\\n\\tparameter WEBMUX = \\\"WEB\\\";\\n\\tparameter RSTBMUX = \\\"RSTB\\\";\\n\\tparameter CSB2MUX = \\\"CSB2\\\";\\n\\tparameter CSB1MUX = \\\"CSB1\\\";\\n\\tparameter CSB0MUX = \\\"CSB0\\\";\\n\\tparameter DOB17MUX = \\\"DOB17\\\";\\n\\tparameter DOB16MUX = \\\"DOB16\\\";\\n\\tparameter DOB15MUX = \\\"DOB15\\\";\\n\\tparameter DOB14MUX = \\\"DOB14\\\";\\n\\tparameter DOB13MUX = \\\"DOB13\\\";\\n\\tparameter DOB12MUX = \\\"DOB12\\\";\\n\\tparameter DOB11MUX = \\\"DOB11\\\";\\n\\tparameter DOB10MUX = \\\"DOB10\\\";\\n\\tparameter DOB9MUX = \\\"DOB9\\\";\\n\\tparameter DOB8MUX = \\\"DOB8\\\";\\n\\tparameter DOB7MUX = \\\"DOB7\\\";\\n\\tparameter DOB6MUX = \\\"DOB6\\\";\\n\\tparameter DOB5MUX = \\\"DOB5\\\";\\n\\tparameter DOB4MUX = \\\"DOB4\\\";\\n\\tparameter DOB3MUX = \\\"DOB3\\\";\\n\\tparameter DOB2MUX = \\\"DOB2\\\";\\n\\tparameter DOB1MUX = \\\"DOB1\\\";\\n\\tparameter DOB0MUX = \\\"DOB0\\\";\\n\\n\\tparameter WID = 0;\\n\\n\\tparameter GSR = \\\"ENABLED\\\";\\n\\n\\tparameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n\\tparameter INIT_DATA = \\\"STATIC\\\";\\nendmodule\\n\\n`ifndef NO_INCLUDES\\n\\n`include \\\"cells_ff.vh\\\"\\n`include \\\"cells_io.vh\\\"\\n\\n`endif\\n\",\n            \"dsp_map.v\": \"module \\\\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);\\n\\n\\tparameter A_WIDTH = 18;\\n\\tparameter B_WIDTH = 18;\\n\\tparameter Y_WIDTH = 36;\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\n\\tMULT18X18D _TECHMAP_REPLACE_ (\\n\\t\\t.A0(A[0]), .A1(A[1]), .A2(A[2]), .A3(A[3]), .A4(A[4]), .A5(A[5]), .A6(A[6]), .A7(A[7]), .A8(A[8]), .A9(A[9]), .A10(A[10]), .A11(A[11]), .A12(A[12]), .A13(A[13]), .A14(A[14]), .A15(A[15]), .A16(A[16]), .A17(A[17]),\\n\\t\\t.B0(B[0]), .B1(B[1]), .B2(B[2]), .B3(B[3]), .B4(B[4]), .B5(B[5]), .B6(B[6]), .B7(B[7]), .B8(B[8]), .B9(B[9]), .B10(B[10]), .B11(B[11]), .B12(B[12]), .B13(B[13]), .B14(B[14]), .B15(B[15]), .B16(B[16]), .B17(B[17]),\\n\\t\\t.C17(1'b0), .C16(1'b0), .C15(1'b0), .C14(1'b0), .C13(1'b0), .C12(1'b0), .C11(1'b0), .C10(1'b0), .C9(1'b0), .C8(1'b0), .C7(1'b0), .C6(1'b0), .C5(1'b0), .C4(1'b0), .C3(1'b0), .C2(1'b0), .C1(1'b0), .C0(1'b0),\\n\\t\\t.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0), .SIGNEDB(B_SIGNED ? 1'b1 : 1'b0), .SOURCEA(1'b0), .SOURCEB(1'b0),\\n\\n\\t\\t.P0(Y[0]), .P1(Y[1]), .P2(Y[2]), .P3(Y[3]), .P4(Y[4]), .P5(Y[5]), .P6(Y[6]), .P7(Y[7]), .P8(Y[8]), .P9(Y[9]), .P10(Y[10]), .P11(Y[11]), .P12(Y[12]), .P13(Y[13]), .P14(Y[14]), .P15(Y[15]), .P16(Y[16]), .P17(Y[17]), .P18(Y[18]), .P19(Y[19]), .P20(Y[20]), .P21(Y[21]), .P22(Y[22]), .P23(Y[23]), .P24(Y[24]), .P25(Y[25]), .P26(Y[26]), .P27(Y[27]), .P28(Y[28]), .P29(Y[29]), .P30(Y[30]), .P31(Y[31]), .P32(Y[32]), .P33(Y[33]), .P34(Y[34]), .P35(Y[35])\\n\\t);\\nendmodule\\n\",\n            \"latches_map.v\": \"module \\\\$_DLATCH_N_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = !E ? D : Q;\\nendmodule\\n\\nmodule \\\\$_DLATCH_P_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = E ? D : Q;\\nendmodule\\n\",\n            \"lutrams.txt\": \"ram distributed $__TRELLIS_DPR16X4_ {\\n\\tabits 4;\\n\\twidth 4;\\n\\tcost 4;\\n\\tinit any;\\n\\tprune_rom;\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock anyedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\",\n            \"lutrams_map.v\": \"module $__TRELLIS_DPR16X4_(...);\\n\\nparameter INIT = 64'bx;\\nparameter PORT_W_CLK_POL = 1;\\n\\ninput PORT_W_CLK;\\ninput [3:0] PORT_W_ADDR;\\ninput [3:0] PORT_W_WR_DATA;\\ninput PORT_W_WR_EN;\\n\\ninput [3:0] PORT_R_ADDR;\\noutput [3:0] PORT_R_RD_DATA;\\n\\nlocalparam WCKMUX = PORT_W_CLK_POL ? \\\"WCK\\\" : \\\"INV\\\";\\n\\nTRELLIS_DPR16X4 #(\\n\\t.INITVAL(INIT),\\n\\t.WCKMUX(WCKMUX),\\n\\t.WREMUX(\\\"WRE\\\")\\n) _TECHMAP_REPLACE_ (\\n\\t.RAD(PORT_R_ADDR),\\n\\t.DO(PORT_R_RD_DATA),\\n\\n\\t.WAD(PORT_W_ADDR),\\n\\t.DI(PORT_W_WR_DATA),\\n\\t.WCK(PORT_W_CLK),\\n\\t.WRE(PORT_W_WR_EN)\\n);\\n\\nendmodule\\n\",\n        },\n        \"efinix\": {\n            \"arith_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2018  Miodrag Milanovic <micko@yosyshq.com>\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_efinix_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH  = 1;\\n\\tparameter B_WIDTH  = 1;\\n\\tparameter Y_WIDTH  = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n   \\n    wire CIx;\\n    (* force_downto *)\\n    wire [Y_WIDTH-1:0] COx;\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 2;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] C = { COx, CIx };\\n\\n    EFX_ADD #(.I0_POLARITY(1'b1),.I1_POLARITY(1'b1))\\n    adder_cin  (\\n        .I0(CI),\\n        .I1(1'b1),\\n        .CI(1'b0),\\n        .CO(CIx)\\n\\t);\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < Y_WIDTH; i = i + 1) begin: slice\\n\\t\\tEFX_ADD #(.I0_POLARITY(1'b1),.I1_POLARITY(1'b1))\\n\\t\\tadder_i (\\n\\t\\t\\t.I0(AA[i]),\\n\\t\\t\\t.I1(BB[i]),\\n\\t\\t\\t.CI(C[i]),\\n\\t\\t\\t.O(Y[i]),\\n\\t\\t\\t.CO(COx[i])\\n\\t\\t);\\n\\t\\tEFX_ADD #(.I0_POLARITY(1'b1),.I1_POLARITY(1'b1))\\t\\t\\t\\t\\n\\t\\tadder_cout  (\\n\\t\\t\\t.I0(1'b0),\\n\\t\\t\\t.I1(1'b0),\\n\\t\\t\\t.CI(COx[i]),\\n\\t\\t\\t.O(CO[i])\\n\\t\\t);\\n\\t  end: slice\\t  \\n\\tendgenerate\\n\\n   /* End implementation */\\n   assign X = AA ^ BB;\\nendmodule\\n\",\n            \"brams.txt\": \"ram block $__EFINIX_5K_ {\\n\\tabits 12;\\n\\twidths 1 2 5 10 20 per_port;\\n\\tcost 32;\\n\\tinit no_undef;\\n\\tport sr \\\"R\\\" {\\n\\t\\tclock anyedge;\\n\\t\\trden;\\n\\t}\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock anyedge;\\n\\t\\toption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\twrtrans \\\"R\\\" old;\\n\\t\\t}\\n\\t\\toption \\\"WRITE_MODE\\\" \\\"WRITE_FIRST\\\" {\\n\\t\\t\\twrtrans \\\"R\\\" new;\\n\\t\\t}\\n\\t}\\n}\\n\",\n            \"brams_map.v\": \"module $__EFINIX_5K_ (...);\\n\\tparameter INIT = 0;\\n\\tparameter OPTION_WRITE_MODE = \\\"READ_FIRST\\\";\\n\\n\\tparameter PORT_R_WIDTH = 20;\\n\\tparameter PORT_R_CLK_POL = 1;\\n\\tparameter PORT_W_WIDTH = 20;\\n\\tparameter PORT_W_CLK_POL = 1;\\n\\n\\tinput PORT_R_CLK;\\n\\tinput PORT_R_RD_EN;\\n\\tinput [11:0] PORT_R_ADDR;\\n\\toutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\n\\n\\tinput PORT_W_CLK;\\n\\tinput PORT_W_WR_EN;\\n\\tinput [11:0] PORT_W_ADDR;\\n\\tinput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\n\\n\\tlocalparam IS_5BIT = PORT_R_WIDTH >= 5 && PORT_W_WIDTH >= 5;\\n\\n\\tlocalparam RADDR_WIDTH =\\n\\t\\tPORT_R_WIDTH == 1 ? 12 :\\n\\t\\tPORT_R_WIDTH == 2 ? 11 :\\n\\t\\tPORT_R_WIDTH == 5 ? 10 :\\n\\t\\tPORT_R_WIDTH == 10 ? 9 :\\n\\t\\t8;\\n\\n\\tlocalparam WADDR_WIDTH =\\n\\t\\tPORT_W_WIDTH == 1 ? 12 :\\n\\t\\tPORT_W_WIDTH == 2 ? 11 :\\n\\t\\tPORT_W_WIDTH == 5 ? 10 :\\n\\t\\tPORT_W_WIDTH == 10 ? 9 :\\n\\t\\t8;\\n\\n\\tlocalparam READ_WIDTH = \\n\\t\\tPORT_R_WIDTH == 1 ? 1 :\\n\\t\\tPORT_R_WIDTH == 2 ? 2 :\\n\\t\\tPORT_R_WIDTH == 5 ? (IS_5BIT ? 5 : 4) :\\n\\t\\tPORT_R_WIDTH == 10 ? (IS_5BIT ? 10 : 8) :\\n\\t\\t(IS_5BIT ? 20 : 16);\\n\\n\\tlocalparam WRITE_WIDTH = \\n\\t\\tPORT_W_WIDTH == 1 ? 1 :\\n\\t\\tPORT_W_WIDTH == 2 ? 2 :\\n\\t\\tPORT_W_WIDTH == 5 ? (IS_5BIT ? 5 : 4) :\\n\\t\\tPORT_W_WIDTH == 10 ? (IS_5BIT ? 10 : 8) :\\n\\t\\t(IS_5BIT ? 20 : 16);\\n\\n\\twire [RADDR_WIDTH-1:0] RADDR = PORT_R_ADDR[11:12-RADDR_WIDTH];\\n\\twire [WADDR_WIDTH-1:0] WADDR = PORT_W_ADDR[11:12-WADDR_WIDTH];\\n\\n\\twire [WRITE_WIDTH-1:0] WDATA;\\n\\twire [READ_WIDTH-1:0] RDATA;\\n\\n\\tgenerate\\n\\t\\tcase (WRITE_WIDTH)\\n\\t\\t1:\\tassign WDATA = PORT_W_WR_DATA;\\n\\t\\t2:\\tassign WDATA = PORT_W_WR_DATA;\\n\\t\\t4:\\tassign WDATA = PORT_W_WR_DATA[3:0];\\n\\t\\t5:\\tassign WDATA = PORT_W_WR_DATA;\\n\\t\\t8:\\tassign WDATA = {\\n\\t\\t\\tPORT_W_WR_DATA[8:5],\\n\\t\\t\\tPORT_W_WR_DATA[3:0]\\n\\t\\t};\\n\\t\\t10:\\tassign WDATA = PORT_W_WR_DATA;\\n\\t\\t16:\\tassign WDATA = {\\n\\t\\t\\tPORT_W_WR_DATA[18:15],\\n\\t\\t\\tPORT_W_WR_DATA[13:10],\\n\\t\\t\\tPORT_W_WR_DATA[8:5],\\n\\t\\t\\tPORT_W_WR_DATA[3:0]\\n\\t\\t};\\n\\t\\t20:\\tassign WDATA = PORT_W_WR_DATA;\\n\\t\\tendcase\\n\\t\\tcase (READ_WIDTH)\\n\\t\\t1:\\tassign PORT_R_RD_DATA = RDATA;\\n\\t\\t2:\\tassign PORT_R_RD_DATA = RDATA;\\n\\t\\t4:\\tassign PORT_R_RD_DATA[3:0] = RDATA;\\n\\t\\t5:\\tassign PORT_R_RD_DATA = RDATA;\\n\\t\\t8:\\tassign {\\n\\t\\t\\tPORT_R_RD_DATA[8:5],\\n\\t\\t\\tPORT_R_RD_DATA[3:0]\\n\\t\\t} = RDATA;\\n\\t\\t10:\\tassign PORT_R_RD_DATA = RDATA;\\n\\t\\t16:\\tassign {\\n\\t\\t\\tPORT_R_RD_DATA[18:15],\\n\\t\\t\\tPORT_R_RD_DATA[13:10],\\n\\t\\t\\tPORT_R_RD_DATA[8:5],\\n\\t\\t\\tPORT_R_RD_DATA[3:0]\\n\\t\\t} = RDATA;\\n\\t\\t20:\\tassign PORT_R_RD_DATA = RDATA;\\n\\t\\tendcase\\n\\tendgenerate\\n\\n\\tfunction [255:0] init_slice;\\n\\t\\tinput integer idx;\\n\\t\\tinteger i;\\n\\t\\tif (IS_5BIT)\\n\\t\\t\\tinit_slice = INIT[idx * 256 +: 256];\\n\\t\\telse if (idx > 16)\\n\\t\\t\\tinit_slice = 0;\\n\\t\\telse\\n\\t\\t\\tfor (i = 0; i < 64; i = i + 1)\\n\\t\\t\\t\\tinit_slice[i*4+:4] = INIT[(idx * 64 + i) * 5+:4];\\n\\tendfunction\\n\\n\\tEFX_RAM_5K #(\\n\\t\\t.READ_WIDTH(READ_WIDTH),\\n\\t\\t.WRITE_WIDTH(WRITE_WIDTH),\\n\\t\\t.OUTPUT_REG(1'b0),\\n\\t\\t.RCLK_POLARITY(PORT_R_CLK_POL),\\n\\t\\t.RE_POLARITY(1'b1),\\n\\t\\t.WCLK_POLARITY(PORT_W_CLK_POL),\\n\\t\\t.WE_POLARITY(1'b1),\\n\\t\\t.WCLKE_POLARITY(1'b1),\\n\\t\\t.WRITE_MODE(OPTION_WRITE_MODE),\\n\\t\\t.INIT_0(init_slice('h00)),\\n\\t\\t.INIT_1(init_slice('h01)),\\n\\t\\t.INIT_2(init_slice('h02)),\\n\\t\\t.INIT_3(init_slice('h03)),\\n\\t\\t.INIT_4(init_slice('h04)),\\n\\t\\t.INIT_5(init_slice('h05)),\\n\\t\\t.INIT_6(init_slice('h06)),\\n\\t\\t.INIT_7(init_slice('h07)),\\n\\t\\t.INIT_8(init_slice('h08)),\\n\\t\\t.INIT_9(init_slice('h09)),\\n\\t\\t.INIT_A(init_slice('h0a)),\\n\\t\\t.INIT_B(init_slice('h0b)),\\n\\t\\t.INIT_C(init_slice('h0c)),\\n\\t\\t.INIT_D(init_slice('h0d)),\\n\\t\\t.INIT_E(init_slice('h0e)),\\n\\t\\t.INIT_F(init_slice('h0f)),\\n\\t\\t.INIT_10(init_slice('h10)),\\n\\t\\t.INIT_11(init_slice('h11)),\\n\\t\\t.INIT_12(init_slice('h12)),\\n\\t\\t.INIT_13(init_slice('h13)),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.WDATA(WDATA),\\n\\t\\t.WADDR(WADDR),\\n\\t\\t.WE(PORT_W_WR_EN),\\n\\t\\t.WCLK(PORT_W_CLK),\\n\\t\\t.WCLKE(1'b1),\\n\\t\\t.RDATA(RDATA),\\n\\t\\t.RADDR(RADDR),\\n\\t\\t.RE(PORT_R_RD_EN),\\n\\t\\t.RCLK(PORT_R_CLK)\\n\\t);\\n\\nendmodule\\n\",\n            \"cells_map.v\": \"(* techmap_celltype = \\\"$_DFFE_[PN][PN][01][PN]_\\\" *)\\nmodule  \\\\$_DFFE_xxxx_ (input D, C, R, E, output Q);\\n\\n  parameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n\\n  EFX_FF #(\\n    .CLK_POLARITY(_TECHMAP_CELLTYPE_[39:32] == \\\"P\\\"),\\n    .CE_POLARITY(_TECHMAP_CELLTYPE_[15:8] == \\\"P\\\"),\\n    .SR_POLARITY(_TECHMAP_CELLTYPE_[31:24] == \\\"P\\\"),\\n    .D_POLARITY(1'b1),\\n    .SR_SYNC(1'b0),\\n    .SR_VALUE(_TECHMAP_CELLTYPE_[23:16] == \\\"1\\\"),\\n    .SR_SYNC_PRIORITY(1'b1)\\n  ) _TECHMAP_REPLACE_ (.D(D), .CE(E), .CLK(C), .SR(R), .Q(Q));\\n\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\n\\nendmodule\\n\\n(* techmap_celltype = \\\"$_SDFFE_[PN][PN][01][PN]_\\\" *)\\nmodule  \\\\$_SDFFE_xxxx_ (input D, C, R, E, output Q);\\n\\n  parameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n\\n  EFX_FF #(\\n    .CLK_POLARITY(_TECHMAP_CELLTYPE_[39:32] == \\\"P\\\"),\\n    .CE_POLARITY(_TECHMAP_CELLTYPE_[15:8] == \\\"P\\\"),\\n    .SR_POLARITY(_TECHMAP_CELLTYPE_[31:24] == \\\"P\\\"),\\n    .D_POLARITY(1'b1),\\n    .SR_SYNC(1'b1),\\n    .SR_VALUE(_TECHMAP_CELLTYPE_[23:16] == \\\"1\\\"),\\n    .SR_SYNC_PRIORITY(1'b1)\\n  ) _TECHMAP_REPLACE_ (.D(D), .CE(E), .CLK(C), .SR(R), .Q(Q));\\n\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\n\\nendmodule\\n\\n(* techmap_celltype = \\\"$_SDFFCE_[PN][PN][01][PN]_\\\" *)\\nmodule  \\\\$_SDFFCE_xxxx_ (input D, C, R, E, output Q);\\n\\n  parameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n\\n  EFX_FF #(\\n    .CLK_POLARITY(_TECHMAP_CELLTYPE_[39:32] == \\\"P\\\"),\\n    .CE_POLARITY(_TECHMAP_CELLTYPE_[15:8] == \\\"P\\\"),\\n    .SR_POLARITY(_TECHMAP_CELLTYPE_[31:24] == \\\"P\\\"),\\n    .D_POLARITY(1'b1),\\n    .SR_SYNC(1'b1),\\n    .SR_VALUE(_TECHMAP_CELLTYPE_[23:16] == \\\"1\\\"),\\n    .SR_SYNC_PRIORITY(1'b0)\\n  ) _TECHMAP_REPLACE_ (.D(D), .CE(E), .CLK(C), .SR(R), .Q(Q));\\n\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\n\\nendmodule\\n\\nmodule \\\\$_DLATCH_N_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = !E ? D : Q;\\nendmodule\\n\\nmodule \\\\$_DLATCH_P_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = E ? D : Q;\\nendmodule\\n\\n`ifndef NO_LUT\\nmodule \\\\$lut (A, Y);\\n  parameter WIDTH = 0;\\n  parameter LUT = 0;\\n\\n  (* force_downto *)\\n  input [WIDTH-1:0] A;\\n  output Y;\\n\\n  generate\\n    if (WIDTH == 1) begin\\n      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(1'b0), .I2(1'b0), .I3(1'b0));\\n    end else\\n    if (WIDTH == 2) begin\\n      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(1'b0), .I3(1'b0));\\n    end else\\n    if (WIDTH == 3) begin\\n      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(1'b0));\\n    end else\\n    if (WIDTH == 4) begin\\n      EFX_LUT4 #(.LUTMASK(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));\\n    end else begin\\n      wire _TECHMAP_FAIL_ = 1;\\n    end\\n  endgenerate\\nendmodule\\n`endif\\n\",\n            \"cells_sim.v\": \"module EFX_LUT4(\\n   output O, \\n   input I0,\\n   input I1,\\n   input I2,\\n   input I3\\n);\\n\\tparameter LUTMASK = 16'h0000;\\n\\n\\twire [7:0] s3 = I3 ? LUTMASK[15:8] : LUTMASK[7:0];\\n\\twire [3:0] s2 = I2 ?      s3[ 7:4] :      s3[3:0];\\n\\twire [1:0] s1 = I1 ?      s2[ 3:2] :      s2[1:0];\\n\\tassign O = I0 ? s1[1] : s1[0];\\t   \\nendmodule\\n\\nmodule EFX_ADD(\\n   output O,\\n   output CO,\\n   input I0,\\n   input I1,\\n   input CI\\n);\\n   parameter I0_POLARITY   = 1;\\n   parameter I1_POLARITY   = 1;\\n\\n   wire i0;\\n   wire i1;\\n\\n   assign i0 = I0_POLARITY ? I0 : ~I0;\\n   assign i1 = I1_POLARITY ? I1 : ~I1;\\n\\n   assign {CO, O} = i0 + i1 + CI;\\nendmodule\\n\\nmodule EFX_FF(\\n   output reg Q,\\n   input D,\\n   input CE,\\n   (* clkbuf_sink *)\\n   input CLK,\\n   input SR\\n);\\n   parameter CLK_POLARITY = 1;\\n   parameter CE_POLARITY = 1;\\n   parameter SR_POLARITY = 1;\\n   parameter SR_SYNC = 0;\\n   parameter SR_VALUE = 0;\\n   parameter SR_SYNC_PRIORITY = 0;\\n   parameter D_POLARITY = 1;\\n\\n   wire clk;\\n   wire ce;\\n   wire sr;\\n   wire d;\\n   wire prio;\\n   wire sync;\\n   wire async;\\n\\n   assign clk = CLK_POLARITY ? CLK : ~CLK;\\n   assign ce = CE_POLARITY ? CE : ~CE;\\n   assign sr = SR_POLARITY ? SR : ~SR;\\n   assign d = D_POLARITY ? D : ~D;\\n\\n\\tinitial Q = 1'b0;\\n\\n   generate\\n   \\tif (SR_SYNC == 1) \\n      begin\\n         if (SR_SYNC_PRIORITY == 1) \\n         begin\\n            always @(posedge clk)\\n               if (sr)\\n                  Q <= SR_VALUE;\\n               else if (ce)\\n                  Q <= d;\\n         end\\n         else\\n         begin\\n            always @(posedge clk)\\n               if (ce)\\n               begin\\n                  if (sr)\\n                     Q <= SR_VALUE;\\n                  else\\n                     Q <= d;\\n               end\\n         end\\n      end\\n      else\\n      begin\\n         always @(posedge clk or posedge sr)\\n            if (sr)\\n               Q <= SR_VALUE;\\n            else if (ce)\\n               Q <= d;\\n         \\n      end\\n   endgenerate\\nendmodule\\n\\nmodule EFX_GBUFCE(\\n   input CE,\\n   input I,\\n   (* clkbuf_driver *)\\n   output O\\n);\\n   parameter CE_POLARITY = 1'b1;\\n\\n   wire ce;\\n   assign ce = CE_POLARITY ? CE : ~CE;\\n   \\n   assign O = I & ce;\\n   \\nendmodule\\n\\nmodule EFX_RAM_5K\\n# (\\n   parameter READ_WIDTH = 20,\\n   parameter WRITE_WIDTH = 20,\\n   localparam READ_ADDR_WIDTH = \\n\\t\\t\\t    (READ_WIDTH == 16) ? 8 :  // 256x16\\n\\t\\t\\t    (READ_WIDTH == 8)  ? 9 :  // 512x8\\n\\t\\t\\t    (READ_WIDTH == 4)  ? 10 : // 1024x4\\n\\t\\t\\t    (READ_WIDTH == 2)  ? 11 : // 2048x2\\n\\t\\t\\t    (READ_WIDTH == 1)  ? 12 : // 4096x1\\n\\t\\t\\t    (READ_WIDTH == 20) ? 8 :  // 256x20\\n\\t\\t\\t    (READ_WIDTH == 10) ? 9 :  // 512x10\\n\\t\\t\\t    (READ_WIDTH == 5)  ? 10 : -1, // 1024x5\\n   \\n   localparam WRITE_ADDR_WIDTH = \\n\\t\\t\\t    (WRITE_WIDTH == 16) ? 8 :  // 256x16\\n\\t\\t\\t    (WRITE_WIDTH == 8)  ? 9 :  // 512x8\\n\\t\\t\\t    (WRITE_WIDTH == 4)  ? 10 : // 1024x4\\n\\t\\t\\t    (WRITE_WIDTH == 2)  ? 11 : // 2048x2\\n\\t\\t\\t    (WRITE_WIDTH == 1)  ? 12 : // 4096x1\\n\\t\\t\\t    (WRITE_WIDTH == 20) ? 8 :  // 256x20\\n\\t\\t\\t    (WRITE_WIDTH == 10) ? 9 :  // 512x10\\n\\t\\t\\t    (WRITE_WIDTH == 5)  ? 10 : -1 // 1024x5\\n)\\n(\\n   input [WRITE_WIDTH-1:0] WDATA,\\n   input [WRITE_ADDR_WIDTH-1:0] WADDR,\\n   input WE, \\n   (* clkbuf_sink *)\\n   input WCLK,\\n   input WCLKE, \\n   output [READ_WIDTH-1:0] RDATA, \\n   input [READ_ADDR_WIDTH-1:0] RADDR,\\n   input RE, \\n   (* clkbuf_sink *)\\n   input RCLK\\n);\\n   parameter OUTPUT_REG = 1'b0;\\n   parameter RCLK_POLARITY  = 1'b1;\\n   parameter RE_POLARITY    = 1'b1;\\n   parameter WCLK_POLARITY  = 1'b1;\\n   parameter WE_POLARITY    = 1'b1;\\n   parameter WCLKE_POLARITY = 1'b1;\\n   parameter WRITE_MODE = \\\"READ_FIRST\\\";\\n   parameter INIT_0 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_1 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_2 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_3 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_4 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_5 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_6 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_7 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_8 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_9 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\n   parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nendmodule\\n\",\n            \"gbuf_map.v\": \"module \\\\$__EFX_GBUF (input I, output O);\\n  EFX_GBUFCE #(.CE_POLARITY(1'b1)) _TECHMAP_REPLACE_ (.I(I), .O(O), .CE(1'b1));\\nendmodule\\n\",\n        },\n        \"fabulous\": {\n            \"arith_map.v\": \"`default_nettype none\\n\\n`ifdef ARITH_ha\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_fabulous_ha_alu (A, B, CI, BI, X, Y, CO);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 1;\\nparameter B_WIDTH = 1;\\nparameter Y_WIDTH = 1;\\n\\nparameter _TECHMAP_CONSTMSK_CI_ = 0;\\nparameter _TECHMAP_CONSTVAL_CI_ = 0;\\n\\n(* force_downto *)\\ninput [A_WIDTH-1:0] A;\\n(* force_downto *)\\ninput [B_WIDTH-1:0] B;\\ninput CI, BI;\\n(* force_downto *)\\noutput [Y_WIDTH-1:0] X, Y, CO;\\n\\n(* force_downto *)\\nwire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n(* force_downto *)\\nwire [Y_WIDTH-1:0] AA = A_buf;\\n(* force_downto *)\\nwire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\\nwire [Y_WIDTH:0] CARRY;\\n\\n\\nLUT4_HA #(\\n\\t.INIT(16'b0),\\n\\t.I0MUX(1'b1)\\n) carry_statrt (\\n\\t.I0(), .I1(CI), .I2(CI), .I3(),\\n\\t.Ci(),\\n\\t.Co(CARRY[0])\\n);\\n\\n// Carry chain\\ngenvar i;\\ngenerate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice\\n\\tLUT4_HA #(\\n\\t\\t.INIT(16'b1001_0110_1001_0110), // full adder sum over (I2, I1, I0)\\n\\t\\t.I0MUX(1'b1)\\n\\t) lut_i (\\n\\t\\t.I0(), .I1(AA[i]), .I2(BB[i]), .I3(),\\n\\t\\t.Ci(CARRY[i]),\\n\\t\\t.O(Y[i]),\\n\\t\\t.Co(CARRY[i+1])\\n\\t);\\n\\n\\tassign CO[i] = (AA[i] && BB[i]) || ((Y[i] ^ AA[i] ^ BB[i]) && (AA[i] || BB[i]));\\nend endgenerate\\n\\nassign X = AA ^ BB;\\n\\nendmodule\\n`endif\\n\\n\",\n            \"cells_map.v\": \"module \\\\$lut (A, Y);\\n  parameter WIDTH = 0;\\n  parameter LUT = 0;\\n\\n  input [WIDTH-1:0] A;\\n  output Y;\\n\\n  generate\\n    if (WIDTH == 1) begin\\n      LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]));\\n\\n    end else\\n    if (WIDTH == 2) begin\\n      LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]));\\n\\n    end else\\n    if (WIDTH == 3) begin\\n      LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]));\\n    end else\\n    if (WIDTH == 4) begin\\n      LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));\\n    end else\\n    if (WIDTH == 5) begin\\n      LUT5 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]), .I4(A[4]));\\n    end else\\n    if (WIDTH == 6) begin\\n      LUT6 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]), .I4(A[4]), .I5(A[5]));\\n    end else begin\\n      wire _TECHMAP_FAIL_ = 1;\\n    end\\n  endgenerate\\nendmodule\\n\\nmodule  \\\\$_DFF_P_ (input D, C, output Q); LUTFF _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C)); endmodule\\n\",\n            \"ff_map.v\": \"module  \\\\$_DFF_P_ (input D, C, output Q); LUTFF _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C)); endmodule\\n\\nmodule  \\\\$_DFFE_PP_ (input D, C, E, output Q); LUTFF_E  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .E(E)); endmodule\\n\\nmodule  \\\\$_SDFF_PP0_ (input D, C, R, output Q); LUTFF_SR  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .R(R)); endmodule\\nmodule  \\\\$_SDFF_PP1_ (input D, C, R, output Q); LUTFF_SS  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .S(R)); endmodule\\n\\nmodule  \\\\$_SDFFCE_PP0P_ (input D, C, E, R, output Q); LUTFF_ESR  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .E(E), .R(R)); endmodule\\nmodule  \\\\$_SDFFCE_PP1P_ (input D, C, E, R, output Q); LUTFF_ESS  _TECHMAP_REPLACE_ (.D(D), .O(Q), .CLK(C), .E(E), .S(R)); endmodule\\n\",\n            \"io_map.v\": \"module \\\\$__FABULOUS_IBUF (input PAD, output O);\\n\\tIO_1_bidirectional_frame_config_pass _TECHMAP_REPLACE_ (.PAD(PAD), .O(O), .T(1'b1));\\nendmodule\\n\\nmodule \\\\$__FABULOUS_OBUF (output PAD, input I);\\n\\tIO_1_bidirectional_frame_config_pass _TECHMAP_REPLACE_ (.PAD(PAD), .I(I), .T(1'b0));\\nendmodule\\n\\n\",\n            \"latches_map.v\": \"module \\\\$_DLATCH_N_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = !E ? D : Q;\\nendmodule\\n\\nmodule \\\\$_DLATCH_P_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = E ? D : Q;\\nendmodule\\n\",\n            \"prims.v\": \"module LUT1(output O, input I0);\\n  parameter [1:0] INIT = 0;\\n  assign O = I0 ? INIT[1] : INIT[0];\\nendmodule\\n\\nmodule LUT2(output O, input I0, I1);\\n  parameter [3:0] INIT = 0;\\n  wire [ 1: 0] s1 = I1 ? INIT[ 3: 2] : INIT[ 1: 0];\\n  assign O = I0 ? s1[1] : s1[0];\\nendmodule\\n\\nmodule LUT3(output O, input I0, I1, I2);\\n  parameter [7:0] INIT = 0;\\n  wire [ 3: 0] s2 = I2 ? INIT[ 7: 4] : INIT[ 3: 0];\\n  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n  assign O = I0 ? s1[1] : s1[0];\\nendmodule\\n\\nmodule LUT4(output O, input I0, I1, I2, I3);\\n  parameter [15:0] INIT = 0;\\n  wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];\\n  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];\\n  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n  assign O = I0 ? s1[1] : s1[0];\\nendmodule\\n\\nmodule LUT4_HA(output O, Co, input I0, I1, I2, I3, Ci);\\n  parameter [15:0] INIT = 0;\\n  parameter I0MUX = 1'b1;\\n\\n  wire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];\\n  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];\\n  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n\\n  wire I0_sel = I0MUX ? Ci : I0;\\n  assign O = I0_sel ? s1[1] : s1[0];\\n\\n  assign Co = (Ci & I1) | (Ci & I2) | (I1 & I2);\\nendmodule\\n\\nmodule LUT5(output O, input I0, I1, I2, I3, I4);\\n  parameter [31:0] INIT = 0;\\n  wire [15: 0] s4 = I4 ? INIT[31:16] : INIT[15: 0];\\n  wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];\\n  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];\\n  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n  assign O = I0 ? s1[1] : s1[0];\\nendmodule\\n\\nmodule LUT6(output O, input I0, I1, I2, I3, I4, I5);\\n  parameter [63:0] INIT = 0;\\n  wire [31: 0] s5 = I5 ? INIT[63:32] : INIT[31: 0];\\n  wire [15: 0] s4 = I4 ?   s5[31:16] :   s5[15: 0];\\n  wire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];\\n  wire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];\\n  wire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n  assign O = I0 ? s1[1] : s1[0];\\nendmodule\\n\\nmodule LUT55_FCY (output O, Co, input I0, I1, I2, I3, I4, Ci);\\n  parameter [63:0] INIT = 0;\\n\\n  wire comb1, comb2;\\n\\n  LUT5 #(.INIT(INIT[31: 0])) l5_1 (.I0(I0), .I1(I1), .I2(I2), .I3(I3), .I4(I4), .O(comb1));\\n  LUT5 #(.INIT(INIT[63:32])) l5_2 (.I0(I0), .I1(I1), .I2(I2), .I3(I3), .I4(I4), .O(comb2));\\n\\n  assign O = comb1 ^ Ci;\\n  assign Co = comb1 ? Ci : comb2;\\nendmodule\\n\\n\\nmodule LUTFF(input CLK, D, output reg O);\\n  initial O = 1'b0;\\n  always @ (posedge CLK) begin\\n    O <= D;\\n  end\\nendmodule\\n\\nmodule FABULOUS_MUX2(input I0, I1, S0, output O);\\n  assign O = S0 ? I1 : I0;\\nendmodule\\n\\nmodule FABULOUS_MUX4(input I0, I1, I2, I3, S0, S1, output O);\\n  wire A0 = S0 ? I1 : I0;\\n  wire A1 = S0 ? I3 : I2;\\n  assign O = S1 ? A1 : A0;\\nendmodule\\n\\nmodule FABULOUS_MUX8(input I0, I1, I2, I3, I4, I5, I6, I7, S0, S1, S2, output O);\\n  wire A0 = S0 ? I1 : I0;\\n  wire A1 = S0 ? I3 : I2;\\n  wire A2 = S0 ? I5 : I4;\\n  wire A3 = S0 ? I7 : I6;\\n  wire B0 = S1 ? A1 : A0;\\n  wire B1 = S1 ? A3 : A2;\\n  assign O = S2 ? B1 : B0;\\nendmodule\\n\\nmodule FABULOUS_LC #(\\n  parameter K = 4,\\n  parameter [2**K-1:0] INIT = 0,\\n  parameter DFF_ENABLE = 1'b0\\n) (\\n  input CLK,\\n  input [K-1:0] I,\\n  output O,\\n  output Q\\n);\\n  wire f_wire;\\n  \\n  //LUT #(.K(K), .INIT(INIT)) lut_i(.I(I), .Q(f_wire));\\n  generate\\n    if (K == 1) begin\\n      LUT1 #(.INIT(INIT)) lut1 (.O(f_wire), .I0(I[0]));\\n    end else\\n    if (K == 2) begin\\n      LUT2 #(.INIT(INIT)) lut2 (.O(f_wire), .I0(I[0]), .I1(I[1]));\\n    end else\\n    if (K == 3) begin\\n      LUT3 #(.INIT(INIT)) lut3 (.O(f_wire), .I0(I[0]), .I1(I[1]), .I2(I[2]));\\n    end else\\n    if (K == 4) begin\\n      LUT4 #(.INIT(INIT)) lut4 (.O(f_wire), .I0(I[0]), .I1(I[1]), .I2(I[2]), .I3(I[3]));\\n    end\\n  endgenerate\\n        \\n  LUTFF dff_i(.CLK(CLK), .D(f_wire), .Q(Q));\\n\\n  assign O = f_wire;\\nendmodule\\n\\n(* blackbox *)\\nmodule Global_Clock (output CLK);\\n`ifndef SYNTHESIS\\n  initial CLK = 0;\\n  always #10 CLK = ~CLK;\\n`endif\\nendmodule\\n\\n(* blackbox, keep *)\\nmodule InPass4_frame_config (input CLK, output O0, O1, O2, O3);\\n\\nendmodule\\n\\n\\n(* blackbox, keep *)\\nmodule OutPass4_frame_config (input CLK, I0, I1, I2, I3);\\n\\nendmodule\\n\\n(* keep *)\\nmodule IO_1_bidirectional_frame_config_pass (input CLK, T, I, output Q, O, (* iopad_external_pin *) inout PAD);\\n  assign PAD = T ? 1'bz : I;\\n  assign O = PAD;\\n  reg Q_q;\\n  always @(posedge CLK) Q_q <= O;\\n  assign Q = Q_q;\\nendmodule\\n\\n\\nmodule MULADD (A7, A6, A5, A4, A3, A2, A1, A0, B7, B6, B5, B4, B3, B2, B1, B0, C19, C18, C17, C16, C15, C14, C13, C12, C11, C10, C9, C8, C7, C6, C5, C4, C3, C2, C1, C0, Q19, Q18, Q17, Q16, Q15, Q14, Q13, Q12, Q11, Q10, Q9, Q8, Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, clr, CLK);\\n  parameter A_reg = 1'b0;\\n  parameter B_reg = 1'b0;\\n  parameter C_reg = 1'b0;\\n  parameter ACC = 1'b0;\\n  parameter signExtension = 1'b0;\\n  parameter ACCout = 1'b0;\\n\\n  //parameter NoConfigBits = 6;// has to be adjusted manually (we don't use an arithmetic parser for the value)\\n  // IMPORTANT: this has to be in a dedicated line\\n  input A7;// operand A\\n  input A6;\\n  input A5;\\n  input A4;\\n  input A3;\\n  input A2;\\n  input A1;\\n  input A0;\\n  input B7;// operand B\\n  input B6;\\n  input B5;\\n  input B4;\\n  input B3;\\n  input B2;\\n  input B1;\\n  input B0;\\n  input C19;// operand C\\n  input C18;\\n  input C17;\\n  input C16;\\n  input C15;\\n  input C14;\\n  input C13;\\n  input C12;\\n  input C11;\\n  input C10;\\n  input C9;\\n  input C8;\\n  input C7;\\n  input C6;\\n  input C5;\\n  input C4;\\n  input C3;\\n  input C2;\\n  input C1;\\n  input C0;\\n  output Q19;// result\\n  output Q18;\\n  output Q17;\\n  output Q16;\\n  output Q15;\\n  output Q14;\\n  output Q13;\\n  output Q12;\\n  output Q11;\\n  output Q10;\\n  output Q9;\\n  output Q8;\\n  output Q7;\\n  output Q6;\\n  output Q5;\\n  output Q4;\\n  output Q3;\\n  output Q2;\\n  output Q1;\\n  output Q0;\\n\\n  input clr;\\n  input CLK; // EXTERNAL // SHARED_PORT // ## the EXTERNAL keyword will send this sisgnal all the way to top and the //SHARED Allows multiple BELs using the same port (e.g. for exporting a clock to the top)\\n  // GLOBAL all primitive pins that are connected to the switch matrix have to go before the GLOBAL label\\n\\n\\n  wire [7:0] A;   // port A read data \\n  wire [7:0] B;   // port B read data \\n  wire [19:0] C;    // port B read data \\n  reg [7:0] A_q;    // port A read data register\\n  reg [7:0] B_q;    // port B read data register\\n  reg [19:0] C_q;   // port B read data register\\n  wire [7:0] OPA;   // port A \\n  wire [7:0] OPB;   // port B \\n  wire [19:0] OPC;    // port B  \\n  reg [19:0] ACC_data ;    // accumulator register\\n  wire [19:0] sum;// port B read data register\\n  wire [19:0] sum_in;// port B read data register\\n  wire [15:0] product;\\n  wire [19:0] product_extended;\\n\\n  assign A = {A7,A6,A5,A4,A3,A2,A1,A0};\\n  assign B = {B7,B6,B5,B4,B3,B2,B1,B0};\\n  assign C = {C19,C18,C17,C16,C15,C14,C13,C12,C11,C10,C9,C8,C7,C6,C5,C4,C3,C2,C1,C0};\\n\\n  assign OPA = A_reg ? A_q : A;\\n  assign OPB = B_reg ? B_q : B;\\n  assign OPC = C_reg ? C_q : C;\\n\\n  assign sum_in = ACC ? ACC_data : OPC;// we can\\n\\n  assign product = OPA * OPB;\\n\\n// The sign extension was not tested\\n  assign product_extended = signExtension ? {product[15],product[15],product[15],product[15],product} : {4'b0000,product};\\n\\n  assign sum = product_extended + sum_in;\\n\\n  assign Q19  = ACCout ? ACC_data[19] : sum[19];\\n  assign Q18  = ACCout ? ACC_data[18] : sum[18];\\n  assign Q17  = ACCout ? ACC_data[17] : sum[17];\\n  assign Q16  = ACCout ? ACC_data[16] : sum[16];\\n  assign Q15  = ACCout ? ACC_data[15] : sum[15];\\n  assign Q14  = ACCout ? ACC_data[14] : sum[14];\\n  assign Q13  = ACCout ? ACC_data[13] : sum[13];\\n  assign Q12  = ACCout ? ACC_data[12] : sum[12];\\n  assign Q11  = ACCout ? ACC_data[11] : sum[11];\\n  assign Q10  = ACCout ? ACC_data[10] : sum[10];\\n  assign Q9 = ACCout ? ACC_data[9] : sum[9];\\n  assign Q8 = ACCout ? ACC_data[8] : sum[8];\\n  assign Q7 = ACCout ? ACC_data[7] : sum[7];\\n  assign Q6 = ACCout ? ACC_data[6] : sum[6];\\n  assign Q5 = ACCout ? ACC_data[5] : sum[5];\\n  assign Q4 = ACCout ? ACC_data[4] : sum[4];\\n  assign Q3 = ACCout ? ACC_data[3] : sum[3];\\n  assign Q2 = ACCout ? ACC_data[2] : sum[2];\\n  assign Q1 = ACCout ? ACC_data[1] : sum[1];\\n  assign Q0 = ACCout ? ACC_data[0] : sum[0];\\n\\n  always @ (posedge CLK)\\n  begin\\n    A_q <= A;\\n    B_q <= B;\\n    C_q <= C;\\n    if (clr == 1'b1) begin\\n      ACC_data <= 20'b00000000000000000000;\\n    end else begin\\n      ACC_data <= sum;\\n    end\\n  end\\n\\nendmodule\\n\\nmodule RegFile_32x4 (D0, D1, D2, D3, W_ADR0, W_ADR1, W_ADR2, W_ADR3, W_ADR4, W_en, AD0, AD1, AD2, AD3, A_ADR0, A_ADR1, A_ADR2, A_ADR3, A_ADR4, BD0, BD1, BD2, BD3, B_ADR0, B_ADR1, B_ADR2, B_ADR3, B_ADR4, CLK);\\n  //parameter NoConfigBits = 2;// has to be adjusted manually (we don't use an arithmetic parser for the value)\\n  parameter AD_reg = 1'b0;\\n  parameter BD_reg = 1'b0;\\n  // IMPORTANT: this has to be in a dedicated line\\n  input D0; // Register File write port\\n  input D1;\\n  input D2;\\n  input D3;\\n  input W_ADR0;\\n  input W_ADR1;\\n  input W_ADR2;\\n  input W_ADR3;\\n  input W_ADR4;\\n  input W_en;\\n  \\n  output AD0;// Register File read port A\\n  output AD1;\\n  output AD2;\\n  output AD3;\\n  input A_ADR0;\\n  input A_ADR1;\\n  input A_ADR2;\\n  input A_ADR3;\\n  input A_ADR4;\\n\\n  output BD0;//Register File read port B\\n  output BD1;\\n  output BD2;\\n  output BD3;\\n  input B_ADR0;\\n  input B_ADR1;\\n  input B_ADR2;\\n  input B_ADR3;\\n  input B_ADR4;\\n\\n  input CLK;// EXTERNAL // SHARED_PORT // ## the EXTERNAL keyword will send this sisgnal all the way to top and the //SHARED Allows multiple BELs using the same port (e.g. for exporting a clock to the top)\\n  \\n  // GLOBAL all primitive pins that are connected to the switch matrix have to go before the GLOBAL label\\n  \\n\\n  //type memtype is array (31 downto 0) of std_logic_vector(3 downto 0); // 32 entries of 4 bit\\n  //signal mem : memtype := (others => (others => '0'));\\n  reg [3:0] mem [31:0];\\n\\n  wire [4:0] W_ADR;// write address\\n  wire [4:0] A_ADR;// port A read address\\n  wire [4:0] B_ADR;// port B read address\\n\\n  wire [3:0] D;   // write data\\n  wire [3:0] AD;    // port A read data\\n  wire [3:0] BD;    // port B read data\\n\\n  reg [3:0] AD_q;   // port A read data register\\n  reg [3:0] BD_q;   // port B read data register\\n  \\n  integer i;\\n\\n  assign W_ADR = {W_ADR4,W_ADR3,W_ADR2,W_ADR1,W_ADR0};\\n  assign A_ADR = {A_ADR4,A_ADR3,A_ADR2,A_ADR1,A_ADR0};\\n  assign B_ADR = {B_ADR4,B_ADR3,B_ADR2,B_ADR1,B_ADR0};\\n\\n  assign D = {D3,D2,D1,D0};\\n  \\n  initial begin\\n    for (i=0; i<32; i=i+1) begin\\n      mem[i] = 4'b0000;\\n    end\\n  end\\n\\n  always @ (posedge CLK) begin : P_write\\n    if (W_en == 1'b1) begin\\n      mem[W_ADR] <= D ;\\n    end\\n  end\\n\\n  assign AD = mem[A_ADR];\\n  assign BD = mem[B_ADR];\\n\\n  always @ (posedge CLK) begin\\n    AD_q <= AD;\\n    BD_q <= BD;\\n  end\\n\\n  assign AD0 = AD_reg ? AD_q[0] : AD[0];\\n  assign AD1 = AD_reg ? AD_q[1] : AD[1];\\n  assign AD2 = AD_reg ? AD_q[2] : AD[2];\\n  assign AD3 = AD_reg ? AD_q[3] : AD[3];\\n\\n  assign BD0 = BD_reg ? BD_q[0] : BD[0];\\n  assign BD1 = BD_reg ? BD_q[1] : BD[1];\\n  assign BD2 = BD_reg ? BD_q[2] : BD[2];\\n  assign BD3 = BD_reg ? BD_q[3] : BD[3];\\n\\nendmodule\\n\\n`ifdef EQUIV\\n`define COMPLEX_DFF\\n`endif\\n\\n`ifdef COMPLEX_DFF\\nmodule LUTFF_E (\\n  output reg O,\\n  input CLK, E, D\\n);\\n  initial O = 1'b0;\\n  always @(posedge CLK)\\n    if (E)\\n      O <= D;\\nendmodule\\n\\nmodule LUTFF_SR (\\n  output reg O,\\n  input CLK, R, D\\n);\\n  initial O = 1'b0;\\n  always @(posedge CLK)\\n    if (R)\\n      O <= 0;\\n    else\\n      O <= D;\\nendmodule\\n\\nmodule LUTFF_SS (\\n  output reg O,\\n  input CLK, S, D\\n);\\n  initial O = 1'b0;\\n  always @(posedge CLK)\\n    if (S)\\n      O <= 1;\\n    else\\n      O <= D;\\nendmodule\\n\\nmodule LUTFF_ESR (\\n  output reg O,\\n  input CLK, E, R, D\\n);\\n  initial O = 1'b0;\\n  always @(posedge CLK)\\n    if (E) begin\\n      if (R)\\n        O <= 0;\\n      else\\n        O <= D;\\n    end\\nendmodule\\n\\nmodule LUTFF_ESS (\\n  output reg O,\\n  input CLK, E, S, D\\n);\\n  initial O = 1'b0;\\n  always @(posedge CLK)\\n    if (E) begin\\n      if (S)\\n        O <= 1;\\n      else\\n        O <= D;\\n    end\\nendmodule\\n`endif // COMPLEX_DFF\\n\",\n            \"ram_regfile.txt\": \"# Yosys doesn't support configurable sync/async ports.\\n# So we define three RAMs for 2xasync, 1xsync 1xasync and 2xsync\\n\\nram distributed $__REGFILE_AA_ {\\n    abits 5;\\n    width 4;\\n    cost 6;\\n    port sw \\\"W\\\" {\\n        clock posedge \\\"CLK\\\";\\n    }\\n    port ar \\\"A\\\" {\\n    }\\n    port ar \\\"B\\\" {\\n    }\\n}\\n\\nram distributed $__REGFILE_SA_ {\\n    abits 5;\\n    width 4;\\n    cost 5;\\n    port sw \\\"W\\\" {\\n        clock posedge \\\"CLK\\\";\\n        wrtrans all old;\\n    }\\n    port sr \\\"A\\\" {\\n        clock posedge \\\"CLK\\\";\\n    }\\n    port ar \\\"B\\\" {\\n    }\\n}\\n\\nram distributed $__REGFILE_SS_ {\\n    abits 5;\\n    width 4;\\n    cost 4;\\n    port sw \\\"W\\\" {\\n        clock posedge \\\"CLK\\\";\\n        wrtrans all old;\\n    }\\n    port sr \\\"A\\\" {\\n        clock posedge \\\"CLK\\\";\\n    }\\n    port sr \\\"B\\\" {\\n        clock posedge \\\"CLK\\\";\\n    }\\n}\\n\",\n            \"regfile_map.v\": \"(* techmap_celltype = \\\"$__REGFILE_[AS][AS]_\\\" *)\\nmodule \\\\$__REGFILE_XX_ (...);\\n\\nparameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\nlocalparam [0:0] B_SYNC = _TECHMAP_CELLTYPE_[15:8] == \\\"S\\\";\\nlocalparam [0:0] A_SYNC = _TECHMAP_CELLTYPE_[23:16] == \\\"S\\\";\\n\\nlocalparam WIDTH = 4;\\nlocalparam ABITS = 5;\\n\\ninput [WIDTH-1:0] PORT_W_WR_DATA;\\ninput [ABITS-1:0] PORT_W_ADDR;\\ninput PORT_W_WR_EN;\\n\\noutput [WIDTH-1:0] PORT_A_RD_DATA;\\ninput [ABITS-1:0] PORT_A_ADDR;\\n\\noutput [WIDTH-1:0] PORT_B_RD_DATA;\\ninput [ABITS-1:0] PORT_B_ADDR;\\n\\n// Unused - we have a shared clock - but keep techmap happy\\ninput PORT_W_CLK;\\ninput PORT_A_CLK;\\ninput PORT_B_CLK;\\n\\ninput CLK_CLK;\\n\\nRegFile_32x4 #(\\n\\t.AD_reg(A_SYNC),\\n\\t.BD_reg(B_SYNC)\\n) _TECHMAP_REPLACE_ (\\n\\t.D0(PORT_W_WR_DATA[0]), .D1(PORT_W_WR_DATA[1]), .D2(PORT_W_WR_DATA[2]), .D3(PORT_W_WR_DATA[3]),\\n\\t.W_ADR0(PORT_W_ADDR[0]), .W_ADR1(PORT_W_ADDR[1]), .W_ADR2(PORT_W_ADDR[2]), .W_ADR3(PORT_W_ADDR[3]), .W_ADR4(PORT_W_ADDR[4]),\\n\\t.W_en(PORT_W_WR_EN),\\n\\t.AD0(PORT_A_RD_DATA[0]), .AD1(PORT_A_RD_DATA[1]), .AD2(PORT_A_RD_DATA[2]), .AD3(PORT_A_RD_DATA[3]),\\n\\t.A_ADR0(PORT_A_ADDR[0]), .A_ADR1(PORT_A_ADDR[1]), .A_ADR2(PORT_A_ADDR[2]), .A_ADR3(PORT_A_ADDR[3]), .A_ADR4(PORT_A_ADDR[4]),\\n\\t.BD0(PORT_B_RD_DATA[0]), .BD1(PORT_B_RD_DATA[1]), .BD2(PORT_B_RD_DATA[2]), .BD3(PORT_B_RD_DATA[3]),\\n\\t.B_ADR0(PORT_B_ADDR[0]), .B_ADR1(PORT_B_ADDR[1]), .B_ADR2(PORT_B_ADDR[2]), .B_ADR3(PORT_B_ADDR[3]), .B_ADR4(PORT_B_ADDR[4]),\\n\\t.CLK(CLK_CLK)\\n);\\n\\nendmodule\\n\",\n        },\n        \"gate2lut.v\": \"(* techmap_celltype = \\\"$_NOT_\\\" *)\\nmodule _90_lut_not (A, Y);\\n    input A;\\n    output Y;\\n\\n    wire [`LUT_WIDTH-1:0] AA;\\n    assign AA = {A};\\n\\n    \\\\$lut #(\\n        .WIDTH(`LUT_WIDTH),\\n        .LUT(4'b01)\\n    ) lut (\\n        .A(AA),\\n        .Y(Y)\\n    );\\nendmodule\\n\\n(* techmap_celltype = \\\"$_OR_\\\" *)\\nmodule _90_lut_or (A, B, Y);\\n    input A, B;\\n    output Y;\\n\\n    wire [`LUT_WIDTH-1:0] AA;\\n    assign AA = {B, A};\\n\\n    \\\\$lut #(\\n        .WIDTH(`LUT_WIDTH),\\n        .LUT(4'b1110)\\n    ) lut (\\n        .A(AA),\\n        .Y(Y)\\n    );\\nendmodule\\n\\n(* techmap_celltype = \\\"$_AND_\\\" *)\\nmodule _90_lut_and (A, B, Y);\\n    input A, B;\\n    output Y;\\n\\n    wire [`LUT_WIDTH-1:0] AA;\\n    assign AA = {B, A};\\n\\n    \\\\$lut #(\\n        .WIDTH(`LUT_WIDTH),\\n        .LUT(4'b1000)\\n    ) lut (\\n        .A(AA),\\n        .Y(Y)\\n    );\\nendmodule\\n\\n(* techmap_celltype = \\\"$_XOR_\\\" *)\\nmodule _90_lut_xor (A, B, Y);\\n    input A, B;\\n    output Y;\\n\\n    wire [`LUT_WIDTH-1:0] AA;\\n    assign AA = {B, A};\\n\\n    \\\\$lut #(\\n        .WIDTH(`LUT_WIDTH),\\n        .LUT(4'b0110)\\n    ) lut (\\n        .A(AA),\\n        .Y(Y)\\n    );\\nendmodule\\n\\n(* techmap_celltype = \\\"$_MUX_\\\" *)\\nmodule _90_lut_mux (A, B, S, Y);\\n    input A, B, S;\\n    output Y;\\n\\n    wire [`LUT_WIDTH-1:0] AA;\\n    assign AA = {S, B, A};\\n\\n    \\\\$lut #(\\n        .WIDTH(`LUT_WIDTH),\\n        //     A 1010 1010\\n        //     B 1100 1100\\n        //     S 1111 0000\\n        .LUT(8'b 1100_1010)\\n    ) lut (\\n        .A(AA),\\n        .Y(Y)\\n    );\\nendmodule\\n\",\n        \"gatemate\": {\n            \"arith_map.v\": \"/*\\r\\n *  yosys -- Yosys Open SYnthesis Suite\\r\\n *\\r\\n *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\\r\\n *\\r\\n *  Permission to use, copy, modify, and/or distribute this software for any\\r\\n *  purpose with or without fee is hereby granted, provided that the above\\r\\n *  copyright notice and this permission notice appear in all copies.\\r\\n *\\r\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\r\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\r\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\r\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\r\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\r\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\r\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\r\\n *\\r\\n */\\r\\n\\r\\n(* techmap_celltype = \\\"$alu\\\" *)\\r\\nmodule _80_gatemate_alu(A, B, CI, BI, X, Y, CO);\\r\\n\\tparameter A_SIGNED = 0;\\r\\n\\tparameter B_SIGNED = 0;\\r\\n\\tparameter A_WIDTH = 1;\\r\\n\\tparameter B_WIDTH = 1;\\r\\n\\tparameter Y_WIDTH = 1;\\r\\n\\r\\n\\t(* force_downto *)\\r\\n\\tinput [A_WIDTH-1:0] A;\\r\\n\\t(* force_downto *)\\r\\n\\tinput [B_WIDTH-1:0] B;\\r\\n\\t(* force_downto *)\\r\\n\\toutput [Y_WIDTH-1:0] X, Y;\\r\\n\\r\\n\\tinput CI, BI;\\r\\n\\t(* force_downto *)\\r\\n\\toutput [Y_WIDTH-1:0] CO;\\r\\n\\r\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 2;\\r\\n\\r\\n\\t(* force_downto *)\\r\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\r\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\r\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\r\\n\\r\\n\\t(* force_downto *)\\r\\n\\twire [Y_WIDTH-1:0] AA = A_buf;\\r\\n\\t(* force_downto *)\\r\\n\\twire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\\r\\n\\t(* force_downto *)\\r\\n\\twire [Y_WIDTH-1:0] C = {CO, CI};\\r\\n\\r\\n\\tgenvar i;\\r\\n\\tgenerate\\r\\n\\t\\tfor (i = 0; i < Y_WIDTH; i = i + 1)\\r\\n\\t\\tbegin: slice\\r\\n\\t\\t\\tCC_ADDF addf_i (\\r\\n\\t\\t\\t\\t.A(AA[i]),\\r\\n\\t\\t\\t\\t.B(BB[i]),\\r\\n\\t\\t\\t\\t.CI(C[i]),\\r\\n\\t\\t\\t\\t.CO(CO[i]),\\r\\n\\t\\t\\t\\t.S(Y[i])\\r\\n\\t\\t\\t);\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\n\\r\\n\\tassign X = AA ^ BB;\\r\\n\\r\\nendmodule\\r\\n\",\n            \"brams.txt\": \"ram block $__CC_BRAM_TDP_ {\\n\\toption \\\"MODE\\\" \\\"20K\\\" {\\n\\t\\tabits 14;\\n\\t\\twidths 1 2 5 10 20 per_port;\\n\\t\\tcost 129;\\n\\t}\\n\\toption \\\"MODE\\\" \\\"40K\\\" {\\n\\t\\tabits 15;\\n\\t\\twidths 1 2 5 10 20 40 per_port;\\n\\t\\tcost 257;\\n\\t}\\n\\toption \\\"MODE\\\" \\\"CASCADE\\\" {\\n\\t\\tabits 16;\\n\\t\\t# hack to enforce same INIT layout as in the other modes\\n\\t\\twidths 1 2 5 per_port;\\n\\t\\tcost 513;\\n\\t}\\n\\tbyte 1;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\toption \\\"MODE\\\" \\\"20K\\\" {\\n\\t\\t\\twidth mix;\\n\\t\\t}\\n\\t\\toption \\\"MODE\\\" \\\"40K\\\" {\\n\\t\\t\\twidth mix;\\n\\t\\t}\\n\\t\\toption \\\"MODE\\\" \\\"CASCADE\\\" {\\n\\t\\t\\twidth mix 1;\\n\\t\\t}\\n\\t\\tportoption \\\"WR_MODE\\\" \\\"NO_CHANGE\\\" {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WR_MODE\\\" \\\"WRITE_THROUGH\\\" {\\n\\t\\t\\trdwr new;\\n\\t\\t\\twrtrans all new;\\n\\t\\t}\\n\\t\\twrbe_separate;\\n\\t\\toptional_rw;\\n\\t}\\n}\\n\\nram block $__CC_BRAM_SDP_ {\\n\\toption \\\"MODE\\\" \\\"20K\\\" {\\n\\t\\tabits 14;\\n\\t\\twidths 1 2 5 10 20 40 per_port;\\n\\t\\tcost 129;\\n\\t}\\n\\toption \\\"MODE\\\" \\\"40K\\\" {\\n\\t\\tabits 15;\\n\\t\\twidths 1 2 5 10 20 40 80 per_port;\\n\\t\\tcost 257;\\n\\t}\\n\\tbyte 1;\\n\\tinit no_undef;\\n\\tport sr \\\"R\\\" {\\n\\t\\toption \\\"MODE\\\" \\\"20K\\\" {\\n\\t\\t\\twidth 40;\\n\\t\\t}\\n\\t\\toption \\\"MODE\\\" \\\"40K\\\" {\\n\\t\\t\\twidth 80;\\n\\t\\t}\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\toptional;\\n\\t}\\n\\tport sw \\\"W\\\" {\\n\\t\\toption \\\"MODE\\\" \\\"20K\\\" {\\n\\t\\t\\twidth 40;\\n\\t\\t}\\n\\t\\toption \\\"MODE\\\" \\\"40K\\\" {\\n\\t\\t\\twidth 80;\\n\\t\\t}\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\twrbe_separate;\\n\\t\\toptional;\\n\\t}\\n}\\n\",\n            \"brams_init_20.vh\": \".INIT_00(permute_init(INIT[  0*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_01(permute_init(INIT[  1*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_02(permute_init(INIT[  2*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_03(permute_init(INIT[  3*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_04(permute_init(INIT[  4*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_05(permute_init(INIT[  5*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_06(permute_init(INIT[  6*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_07(permute_init(INIT[  7*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_08(permute_init(INIT[  8*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_09(permute_init(INIT[  9*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0A(permute_init(INIT[ 10*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0B(permute_init(INIT[ 11*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0C(permute_init(INIT[ 12*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0D(permute_init(INIT[ 13*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0E(permute_init(INIT[ 14*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0F(permute_init(INIT[ 15*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_10(permute_init(INIT[ 16*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_11(permute_init(INIT[ 17*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_12(permute_init(INIT[ 18*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_13(permute_init(INIT[ 19*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_14(permute_init(INIT[ 20*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_15(permute_init(INIT[ 21*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_16(permute_init(INIT[ 22*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_17(permute_init(INIT[ 23*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_18(permute_init(INIT[ 24*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_19(permute_init(INIT[ 25*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1A(permute_init(INIT[ 26*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1B(permute_init(INIT[ 27*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1C(permute_init(INIT[ 28*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1D(permute_init(INIT[ 29*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1E(permute_init(INIT[ 30*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1F(permute_init(INIT[ 31*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_20(permute_init(INIT[ 32*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_21(permute_init(INIT[ 33*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_22(permute_init(INIT[ 34*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_23(permute_init(INIT[ 35*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_24(permute_init(INIT[ 36*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_25(permute_init(INIT[ 37*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_26(permute_init(INIT[ 38*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_27(permute_init(INIT[ 39*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_28(permute_init(INIT[ 40*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_29(permute_init(INIT[ 41*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2A(permute_init(INIT[ 42*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2B(permute_init(INIT[ 43*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2C(permute_init(INIT[ 44*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2D(permute_init(INIT[ 45*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2E(permute_init(INIT[ 46*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2F(permute_init(INIT[ 47*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_30(permute_init(INIT[ 48*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_31(permute_init(INIT[ 49*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_32(permute_init(INIT[ 50*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_33(permute_init(INIT[ 51*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_34(permute_init(INIT[ 52*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_35(permute_init(INIT[ 53*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_36(permute_init(INIT[ 54*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_37(permute_init(INIT[ 55*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_38(permute_init(INIT[ 56*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_39(permute_init(INIT[ 57*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3A(permute_init(INIT[ 58*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3B(permute_init(INIT[ 59*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3C(permute_init(INIT[ 60*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3D(permute_init(INIT[ 61*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3E(permute_init(INIT[ 62*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3F(permute_init(INIT[ 63*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n\",\n            \"brams_init_40.vh\": \"`ifdef INIT_LOWER\\n.INIT_00(permute_init(INIT[  0*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_01(permute_init(INIT[  1*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_02(permute_init(INIT[  2*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_03(permute_init(INIT[  3*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_04(permute_init(INIT[  4*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_05(permute_init(INIT[  5*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_06(permute_init(INIT[  6*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_07(permute_init(INIT[  7*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_08(permute_init(INIT[  8*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_09(permute_init(INIT[  9*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0A(permute_init(INIT[ 10*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0B(permute_init(INIT[ 11*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0C(permute_init(INIT[ 12*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0D(permute_init(INIT[ 13*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0E(permute_init(INIT[ 14*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0F(permute_init(INIT[ 15*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_10(permute_init(INIT[ 16*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_11(permute_init(INIT[ 17*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_12(permute_init(INIT[ 18*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_13(permute_init(INIT[ 19*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_14(permute_init(INIT[ 20*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_15(permute_init(INIT[ 21*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_16(permute_init(INIT[ 22*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_17(permute_init(INIT[ 23*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_18(permute_init(INIT[ 24*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_19(permute_init(INIT[ 25*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1A(permute_init(INIT[ 26*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1B(permute_init(INIT[ 27*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1C(permute_init(INIT[ 28*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1D(permute_init(INIT[ 29*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1E(permute_init(INIT[ 30*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1F(permute_init(INIT[ 31*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_20(permute_init(INIT[ 32*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_21(permute_init(INIT[ 33*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_22(permute_init(INIT[ 34*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_23(permute_init(INIT[ 35*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_24(permute_init(INIT[ 36*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_25(permute_init(INIT[ 37*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_26(permute_init(INIT[ 38*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_27(permute_init(INIT[ 39*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_28(permute_init(INIT[ 40*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_29(permute_init(INIT[ 41*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2A(permute_init(INIT[ 42*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2B(permute_init(INIT[ 43*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2C(permute_init(INIT[ 44*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2D(permute_init(INIT[ 45*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2E(permute_init(INIT[ 46*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2F(permute_init(INIT[ 47*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_30(permute_init(INIT[ 48*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_31(permute_init(INIT[ 49*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_32(permute_init(INIT[ 50*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_33(permute_init(INIT[ 51*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_34(permute_init(INIT[ 52*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_35(permute_init(INIT[ 53*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_36(permute_init(INIT[ 54*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_37(permute_init(INIT[ 55*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_38(permute_init(INIT[ 56*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_39(permute_init(INIT[ 57*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3A(permute_init(INIT[ 58*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3B(permute_init(INIT[ 59*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3C(permute_init(INIT[ 60*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3D(permute_init(INIT[ 61*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3E(permute_init(INIT[ 62*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3F(permute_init(INIT[ 63*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_40(permute_init(INIT[ 64*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_41(permute_init(INIT[ 65*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_42(permute_init(INIT[ 66*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_43(permute_init(INIT[ 67*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_44(permute_init(INIT[ 68*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_45(permute_init(INIT[ 69*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_46(permute_init(INIT[ 70*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_47(permute_init(INIT[ 71*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_48(permute_init(INIT[ 72*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_49(permute_init(INIT[ 73*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4A(permute_init(INIT[ 74*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4B(permute_init(INIT[ 75*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4C(permute_init(INIT[ 76*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4D(permute_init(INIT[ 77*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4E(permute_init(INIT[ 78*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4F(permute_init(INIT[ 79*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_50(permute_init(INIT[ 80*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_51(permute_init(INIT[ 81*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_52(permute_init(INIT[ 82*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_53(permute_init(INIT[ 83*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_54(permute_init(INIT[ 84*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_55(permute_init(INIT[ 85*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_56(permute_init(INIT[ 86*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_57(permute_init(INIT[ 87*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_58(permute_init(INIT[ 88*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_59(permute_init(INIT[ 89*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5A(permute_init(INIT[ 90*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5B(permute_init(INIT[ 91*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5C(permute_init(INIT[ 92*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5D(permute_init(INIT[ 93*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5E(permute_init(INIT[ 94*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5F(permute_init(INIT[ 95*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_60(permute_init(INIT[ 96*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_61(permute_init(INIT[ 97*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_62(permute_init(INIT[ 98*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_63(permute_init(INIT[ 99*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_64(permute_init(INIT[100*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_65(permute_init(INIT[101*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_66(permute_init(INIT[102*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_67(permute_init(INIT[103*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_68(permute_init(INIT[104*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_69(permute_init(INIT[105*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6A(permute_init(INIT[106*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6B(permute_init(INIT[107*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6C(permute_init(INIT[108*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6D(permute_init(INIT[109*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6E(permute_init(INIT[110*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6F(permute_init(INIT[111*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_70(permute_init(INIT[112*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_71(permute_init(INIT[113*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_72(permute_init(INIT[114*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_73(permute_init(INIT[115*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_74(permute_init(INIT[116*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_75(permute_init(INIT[117*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_76(permute_init(INIT[118*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_77(permute_init(INIT[119*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_78(permute_init(INIT[120*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_79(permute_init(INIT[121*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7A(permute_init(INIT[122*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7B(permute_init(INIT[123*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7C(permute_init(INIT[124*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7D(permute_init(INIT[125*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7E(permute_init(INIT[126*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7F(permute_init(INIT[127*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n`endif\\n`ifdef INIT_UPPER\\n.INIT_00(permute_init(INIT[128*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_01(permute_init(INIT[129*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_02(permute_init(INIT[130*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_03(permute_init(INIT[131*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_04(permute_init(INIT[132*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_05(permute_init(INIT[133*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_06(permute_init(INIT[134*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_07(permute_init(INIT[135*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_08(permute_init(INIT[136*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_09(permute_init(INIT[137*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0A(permute_init(INIT[138*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0B(permute_init(INIT[139*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0C(permute_init(INIT[140*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0D(permute_init(INIT[141*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0E(permute_init(INIT[142*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_0F(permute_init(INIT[143*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_10(permute_init(INIT[144*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_11(permute_init(INIT[145*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_12(permute_init(INIT[146*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_13(permute_init(INIT[147*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_14(permute_init(INIT[148*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_15(permute_init(INIT[149*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_16(permute_init(INIT[150*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_17(permute_init(INIT[151*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_18(permute_init(INIT[152*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_19(permute_init(INIT[153*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1A(permute_init(INIT[154*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1B(permute_init(INIT[155*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1C(permute_init(INIT[156*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1D(permute_init(INIT[157*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1E(permute_init(INIT[158*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_1F(permute_init(INIT[159*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_20(permute_init(INIT[160*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_21(permute_init(INIT[161*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_22(permute_init(INIT[162*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_23(permute_init(INIT[163*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_24(permute_init(INIT[164*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_25(permute_init(INIT[165*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_26(permute_init(INIT[166*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_27(permute_init(INIT[167*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_28(permute_init(INIT[168*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_29(permute_init(INIT[169*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2A(permute_init(INIT[170*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2B(permute_init(INIT[171*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2C(permute_init(INIT[172*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2D(permute_init(INIT[173*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2E(permute_init(INIT[174*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_2F(permute_init(INIT[175*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_30(permute_init(INIT[176*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_31(permute_init(INIT[177*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_32(permute_init(INIT[178*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_33(permute_init(INIT[179*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_34(permute_init(INIT[180*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_35(permute_init(INIT[181*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_36(permute_init(INIT[182*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_37(permute_init(INIT[183*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_38(permute_init(INIT[184*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_39(permute_init(INIT[185*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3A(permute_init(INIT[186*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3B(permute_init(INIT[187*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3C(permute_init(INIT[188*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3D(permute_init(INIT[189*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3E(permute_init(INIT[190*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_3F(permute_init(INIT[191*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_40(permute_init(INIT[192*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_41(permute_init(INIT[193*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_42(permute_init(INIT[194*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_43(permute_init(INIT[195*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_44(permute_init(INIT[196*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_45(permute_init(INIT[197*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_46(permute_init(INIT[198*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_47(permute_init(INIT[199*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_48(permute_init(INIT[200*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_49(permute_init(INIT[201*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4A(permute_init(INIT[202*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4B(permute_init(INIT[203*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4C(permute_init(INIT[204*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4D(permute_init(INIT[205*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4E(permute_init(INIT[206*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_4F(permute_init(INIT[207*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_50(permute_init(INIT[208*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_51(permute_init(INIT[209*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_52(permute_init(INIT[210*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_53(permute_init(INIT[211*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_54(permute_init(INIT[212*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_55(permute_init(INIT[213*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_56(permute_init(INIT[214*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_57(permute_init(INIT[215*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_58(permute_init(INIT[216*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_59(permute_init(INIT[217*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5A(permute_init(INIT[218*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5B(permute_init(INIT[219*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5C(permute_init(INIT[220*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5D(permute_init(INIT[221*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5E(permute_init(INIT[222*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_5F(permute_init(INIT[223*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_60(permute_init(INIT[224*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_61(permute_init(INIT[225*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_62(permute_init(INIT[226*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_63(permute_init(INIT[227*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_64(permute_init(INIT[228*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_65(permute_init(INIT[229*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_66(permute_init(INIT[230*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_67(permute_init(INIT[231*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_68(permute_init(INIT[232*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_69(permute_init(INIT[233*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6A(permute_init(INIT[234*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6B(permute_init(INIT[235*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6C(permute_init(INIT[236*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6D(permute_init(INIT[237*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6E(permute_init(INIT[238*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_6F(permute_init(INIT[239*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_70(permute_init(INIT[240*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_71(permute_init(INIT[241*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_72(permute_init(INIT[242*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_73(permute_init(INIT[243*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_74(permute_init(INIT[244*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_75(permute_init(INIT[245*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_76(permute_init(INIT[246*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_77(permute_init(INIT[247*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_78(permute_init(INIT[248*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_79(permute_init(INIT[249*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7A(permute_init(INIT[250*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7B(permute_init(INIT[251*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7C(permute_init(INIT[252*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7D(permute_init(INIT[253*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7E(permute_init(INIT[254*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n.INIT_7F(permute_init(INIT[255*INIT_CHUNK_SIZE +: INIT_CHUNK_SIZE])),\\n`endif\\n\",\n            \"brams_map.v\": \"module $__CC_BRAM_TDP_(...);\\r\\n\\r\\nparameter INIT = 0;\\r\\nparameter OPTION_MODE = \\\"20K\\\";\\r\\n\\r\\nparameter PORT_A_CLK_POL = 1;\\r\\nparameter PORT_A_RD_USED = 1;\\r\\nparameter PORT_A_WR_USED = 1;\\r\\nparameter PORT_A_RD_WIDTH = 1;\\r\\nparameter PORT_A_WR_WIDTH = 1;\\r\\nparameter PORT_A_WR_BE_WIDTH = 1;\\r\\nparameter PORT_A_OPTION_WR_MODE = \\\"NO_CHANGE\\\";\\r\\n\\r\\nparameter PORT_B_CLK_POL = 1;\\r\\nparameter PORT_B_RD_USED = 1;\\r\\nparameter PORT_B_WR_USED = 1;\\r\\nparameter PORT_B_RD_WIDTH = 1;\\r\\nparameter PORT_B_WR_WIDTH = 1;\\r\\nparameter PORT_B_WR_BE_WIDTH = 1;\\r\\nparameter PORT_B_OPTION_WR_MODE = \\\"NO_CHANGE\\\";\\r\\n\\r\\ninput PORT_A_CLK;\\r\\ninput PORT_A_CLK_EN;\\r\\ninput PORT_A_WR_EN;\\r\\ninput [15:0] PORT_A_ADDR;\\r\\ninput [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;\\r\\ninput [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;\\r\\noutput [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;\\r\\n\\r\\ninput PORT_B_CLK;\\r\\ninput PORT_B_CLK_EN;\\r\\ninput PORT_B_WR_EN;\\r\\ninput [15:0] PORT_B_ADDR;\\r\\ninput [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;\\r\\ninput [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;\\r\\noutput [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;\\r\\n\\r\\ngenerate\\r\\n\\tif (OPTION_MODE == \\\"20K\\\") begin\\r\\n\\t\\tCC_BRAM_20K #(\\r\\n\\t\\t\\t.INIT_00(INIT['h00*320+:320]),\\r\\n\\t\\t\\t.INIT_01(INIT['h01*320+:320]),\\r\\n\\t\\t\\t.INIT_02(INIT['h02*320+:320]),\\r\\n\\t\\t\\t.INIT_03(INIT['h03*320+:320]),\\r\\n\\t\\t\\t.INIT_04(INIT['h04*320+:320]),\\r\\n\\t\\t\\t.INIT_05(INIT['h05*320+:320]),\\r\\n\\t\\t\\t.INIT_06(INIT['h06*320+:320]),\\r\\n\\t\\t\\t.INIT_07(INIT['h07*320+:320]),\\r\\n\\t\\t\\t.INIT_08(INIT['h08*320+:320]),\\r\\n\\t\\t\\t.INIT_09(INIT['h09*320+:320]),\\r\\n\\t\\t\\t.INIT_0A(INIT['h0a*320+:320]),\\r\\n\\t\\t\\t.INIT_0B(INIT['h0b*320+:320]),\\r\\n\\t\\t\\t.INIT_0C(INIT['h0c*320+:320]),\\r\\n\\t\\t\\t.INIT_0D(INIT['h0d*320+:320]),\\r\\n\\t\\t\\t.INIT_0E(INIT['h0e*320+:320]),\\r\\n\\t\\t\\t.INIT_0F(INIT['h0f*320+:320]),\\r\\n\\t\\t\\t.INIT_10(INIT['h10*320+:320]),\\r\\n\\t\\t\\t.INIT_11(INIT['h11*320+:320]),\\r\\n\\t\\t\\t.INIT_12(INIT['h12*320+:320]),\\r\\n\\t\\t\\t.INIT_13(INIT['h13*320+:320]),\\r\\n\\t\\t\\t.INIT_14(INIT['h14*320+:320]),\\r\\n\\t\\t\\t.INIT_15(INIT['h15*320+:320]),\\r\\n\\t\\t\\t.INIT_16(INIT['h16*320+:320]),\\r\\n\\t\\t\\t.INIT_17(INIT['h17*320+:320]),\\r\\n\\t\\t\\t.INIT_18(INIT['h18*320+:320]),\\r\\n\\t\\t\\t.INIT_19(INIT['h19*320+:320]),\\r\\n\\t\\t\\t.INIT_1A(INIT['h1a*320+:320]),\\r\\n\\t\\t\\t.INIT_1B(INIT['h1b*320+:320]),\\r\\n\\t\\t\\t.INIT_1C(INIT['h1c*320+:320]),\\r\\n\\t\\t\\t.INIT_1D(INIT['h1d*320+:320]),\\r\\n\\t\\t\\t.INIT_1E(INIT['h1e*320+:320]),\\r\\n\\t\\t\\t.INIT_1F(INIT['h1f*320+:320]),\\r\\n\\t\\t\\t.INIT_20(INIT['h20*320+:320]),\\r\\n\\t\\t\\t.INIT_21(INIT['h21*320+:320]),\\r\\n\\t\\t\\t.INIT_22(INIT['h22*320+:320]),\\r\\n\\t\\t\\t.INIT_23(INIT['h23*320+:320]),\\r\\n\\t\\t\\t.INIT_24(INIT['h24*320+:320]),\\r\\n\\t\\t\\t.INIT_25(INIT['h25*320+:320]),\\r\\n\\t\\t\\t.INIT_26(INIT['h26*320+:320]),\\r\\n\\t\\t\\t.INIT_27(INIT['h27*320+:320]),\\r\\n\\t\\t\\t.INIT_28(INIT['h28*320+:320]),\\r\\n\\t\\t\\t.INIT_29(INIT['h29*320+:320]),\\r\\n\\t\\t\\t.INIT_2A(INIT['h2a*320+:320]),\\r\\n\\t\\t\\t.INIT_2B(INIT['h2b*320+:320]),\\r\\n\\t\\t\\t.INIT_2C(INIT['h2c*320+:320]),\\r\\n\\t\\t\\t.INIT_2D(INIT['h2d*320+:320]),\\r\\n\\t\\t\\t.INIT_2E(INIT['h2e*320+:320]),\\r\\n\\t\\t\\t.INIT_2F(INIT['h2f*320+:320]),\\r\\n\\t\\t\\t.INIT_30(INIT['h30*320+:320]),\\r\\n\\t\\t\\t.INIT_31(INIT['h31*320+:320]),\\r\\n\\t\\t\\t.INIT_32(INIT['h32*320+:320]),\\r\\n\\t\\t\\t.INIT_33(INIT['h33*320+:320]),\\r\\n\\t\\t\\t.INIT_34(INIT['h34*320+:320]),\\r\\n\\t\\t\\t.INIT_35(INIT['h35*320+:320]),\\r\\n\\t\\t\\t.INIT_36(INIT['h36*320+:320]),\\r\\n\\t\\t\\t.INIT_37(INIT['h37*320+:320]),\\r\\n\\t\\t\\t.INIT_38(INIT['h38*320+:320]),\\r\\n\\t\\t\\t.INIT_39(INIT['h39*320+:320]),\\r\\n\\t\\t\\t.INIT_3A(INIT['h3a*320+:320]),\\r\\n\\t\\t\\t.INIT_3B(INIT['h3b*320+:320]),\\r\\n\\t\\t\\t.INIT_3C(INIT['h3c*320+:320]),\\r\\n\\t\\t\\t.INIT_3D(INIT['h3d*320+:320]),\\r\\n\\t\\t\\t.INIT_3E(INIT['h3e*320+:320]),\\r\\n\\t\\t\\t.INIT_3F(INIT['h3f*320+:320]),\\r\\n\\t\\t\\t.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\\r\\n\\t\\t\\t.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\\r\\n\\t\\t\\t.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\\r\\n\\t\\t\\t.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\\r\\n\\t\\t\\t.RAM_MODE(\\\"TDP\\\"),\\r\\n\\t\\t\\t.A_WR_MODE(PORT_A_OPTION_WR_MODE),\\r\\n\\t\\t\\t.B_WR_MODE(PORT_B_OPTION_WR_MODE),\\r\\n\\t\\t\\t.A_CLK_INV(!PORT_A_CLK_POL),\\r\\n\\t\\t\\t.B_CLK_INV(!PORT_B_CLK_POL),\\r\\n\\t\\t) _TECHMAP_REPLACE_ (\\r\\n\\t\\t\\t.A_CLK(PORT_A_CLK),\\r\\n\\t\\t\\t.A_EN(PORT_A_CLK_EN),\\r\\n\\t\\t\\t.A_WE(PORT_A_WR_EN),\\r\\n\\t\\t\\t.A_BM(PORT_A_WR_BE),\\r\\n\\t\\t\\t.A_DI(PORT_A_WR_DATA),\\r\\n\\t\\t\\t.A_ADDR({PORT_A_ADDR[13:5], 1'b0, PORT_A_ADDR[4:0], 1'b0}),\\r\\n\\t\\t\\t.A_DO(PORT_A_RD_DATA),\\r\\n\\t\\t\\t.B_CLK(PORT_B_CLK),\\r\\n\\t\\t\\t.B_EN(PORT_B_CLK_EN),\\r\\n\\t\\t\\t.B_WE(PORT_B_WR_EN),\\r\\n\\t\\t\\t.B_BM(PORT_B_WR_BE),\\r\\n\\t\\t\\t.B_DI(PORT_B_WR_DATA),\\r\\n\\t\\t\\t.B_ADDR({PORT_B_ADDR[13:5], 1'b0, PORT_B_ADDR[4:0], 1'b0}),\\r\\n\\t\\t\\t.B_DO(PORT_B_RD_DATA),\\r\\n\\t\\t);\\r\\n\\tend else if (OPTION_MODE == \\\"40K\\\") begin\\r\\n\\t\\tCC_BRAM_40K #(\\r\\n\\t\\t\\t.INIT_00(INIT['h00*320+:320]),\\r\\n\\t\\t\\t.INIT_01(INIT['h01*320+:320]),\\r\\n\\t\\t\\t.INIT_02(INIT['h02*320+:320]),\\r\\n\\t\\t\\t.INIT_03(INIT['h03*320+:320]),\\r\\n\\t\\t\\t.INIT_04(INIT['h04*320+:320]),\\r\\n\\t\\t\\t.INIT_05(INIT['h05*320+:320]),\\r\\n\\t\\t\\t.INIT_06(INIT['h06*320+:320]),\\r\\n\\t\\t\\t.INIT_07(INIT['h07*320+:320]),\\r\\n\\t\\t\\t.INIT_08(INIT['h08*320+:320]),\\r\\n\\t\\t\\t.INIT_09(INIT['h09*320+:320]),\\r\\n\\t\\t\\t.INIT_0A(INIT['h0a*320+:320]),\\r\\n\\t\\t\\t.INIT_0B(INIT['h0b*320+:320]),\\r\\n\\t\\t\\t.INIT_0C(INIT['h0c*320+:320]),\\r\\n\\t\\t\\t.INIT_0D(INIT['h0d*320+:320]),\\r\\n\\t\\t\\t.INIT_0E(INIT['h0e*320+:320]),\\r\\n\\t\\t\\t.INIT_0F(INIT['h0f*320+:320]),\\r\\n\\t\\t\\t.INIT_10(INIT['h10*320+:320]),\\r\\n\\t\\t\\t.INIT_11(INIT['h11*320+:320]),\\r\\n\\t\\t\\t.INIT_12(INIT['h12*320+:320]),\\r\\n\\t\\t\\t.INIT_13(INIT['h13*320+:320]),\\r\\n\\t\\t\\t.INIT_14(INIT['h14*320+:320]),\\r\\n\\t\\t\\t.INIT_15(INIT['h15*320+:320]),\\r\\n\\t\\t\\t.INIT_16(INIT['h16*320+:320]),\\r\\n\\t\\t\\t.INIT_17(INIT['h17*320+:320]),\\r\\n\\t\\t\\t.INIT_18(INIT['h18*320+:320]),\\r\\n\\t\\t\\t.INIT_19(INIT['h19*320+:320]),\\r\\n\\t\\t\\t.INIT_1A(INIT['h1a*320+:320]),\\r\\n\\t\\t\\t.INIT_1B(INIT['h1b*320+:320]),\\r\\n\\t\\t\\t.INIT_1C(INIT['h1c*320+:320]),\\r\\n\\t\\t\\t.INIT_1D(INIT['h1d*320+:320]),\\r\\n\\t\\t\\t.INIT_1E(INIT['h1e*320+:320]),\\r\\n\\t\\t\\t.INIT_1F(INIT['h1f*320+:320]),\\r\\n\\t\\t\\t.INIT_20(INIT['h20*320+:320]),\\r\\n\\t\\t\\t.INIT_21(INIT['h21*320+:320]),\\r\\n\\t\\t\\t.INIT_22(INIT['h22*320+:320]),\\r\\n\\t\\t\\t.INIT_23(INIT['h23*320+:320]),\\r\\n\\t\\t\\t.INIT_24(INIT['h24*320+:320]),\\r\\n\\t\\t\\t.INIT_25(INIT['h25*320+:320]),\\r\\n\\t\\t\\t.INIT_26(INIT['h26*320+:320]),\\r\\n\\t\\t\\t.INIT_27(INIT['h27*320+:320]),\\r\\n\\t\\t\\t.INIT_28(INIT['h28*320+:320]),\\r\\n\\t\\t\\t.INIT_29(INIT['h29*320+:320]),\\r\\n\\t\\t\\t.INIT_2A(INIT['h2a*320+:320]),\\r\\n\\t\\t\\t.INIT_2B(INIT['h2b*320+:320]),\\r\\n\\t\\t\\t.INIT_2C(INIT['h2c*320+:320]),\\r\\n\\t\\t\\t.INIT_2D(INIT['h2d*320+:320]),\\r\\n\\t\\t\\t.INIT_2E(INIT['h2e*320+:320]),\\r\\n\\t\\t\\t.INIT_2F(INIT['h2f*320+:320]),\\r\\n\\t\\t\\t.INIT_30(INIT['h30*320+:320]),\\r\\n\\t\\t\\t.INIT_31(INIT['h31*320+:320]),\\r\\n\\t\\t\\t.INIT_32(INIT['h32*320+:320]),\\r\\n\\t\\t\\t.INIT_33(INIT['h33*320+:320]),\\r\\n\\t\\t\\t.INIT_34(INIT['h34*320+:320]),\\r\\n\\t\\t\\t.INIT_35(INIT['h35*320+:320]),\\r\\n\\t\\t\\t.INIT_36(INIT['h36*320+:320]),\\r\\n\\t\\t\\t.INIT_37(INIT['h37*320+:320]),\\r\\n\\t\\t\\t.INIT_38(INIT['h38*320+:320]),\\r\\n\\t\\t\\t.INIT_39(INIT['h39*320+:320]),\\r\\n\\t\\t\\t.INIT_3A(INIT['h3a*320+:320]),\\r\\n\\t\\t\\t.INIT_3B(INIT['h3b*320+:320]),\\r\\n\\t\\t\\t.INIT_3C(INIT['h3c*320+:320]),\\r\\n\\t\\t\\t.INIT_3D(INIT['h3d*320+:320]),\\r\\n\\t\\t\\t.INIT_3E(INIT['h3e*320+:320]),\\r\\n\\t\\t\\t.INIT_3F(INIT['h3f*320+:320]),\\r\\n\\t\\t\\t.INIT_40(INIT['h40*320+:320]),\\r\\n\\t\\t\\t.INIT_41(INIT['h41*320+:320]),\\r\\n\\t\\t\\t.INIT_42(INIT['h42*320+:320]),\\r\\n\\t\\t\\t.INIT_43(INIT['h43*320+:320]),\\r\\n\\t\\t\\t.INIT_44(INIT['h44*320+:320]),\\r\\n\\t\\t\\t.INIT_45(INIT['h45*320+:320]),\\r\\n\\t\\t\\t.INIT_46(INIT['h46*320+:320]),\\r\\n\\t\\t\\t.INIT_47(INIT['h47*320+:320]),\\r\\n\\t\\t\\t.INIT_48(INIT['h48*320+:320]),\\r\\n\\t\\t\\t.INIT_49(INIT['h49*320+:320]),\\r\\n\\t\\t\\t.INIT_4A(INIT['h4a*320+:320]),\\r\\n\\t\\t\\t.INIT_4B(INIT['h4b*320+:320]),\\r\\n\\t\\t\\t.INIT_4C(INIT['h4c*320+:320]),\\r\\n\\t\\t\\t.INIT_4D(INIT['h4d*320+:320]),\\r\\n\\t\\t\\t.INIT_4E(INIT['h4e*320+:320]),\\r\\n\\t\\t\\t.INIT_4F(INIT['h4f*320+:320]),\\r\\n\\t\\t\\t.INIT_50(INIT['h50*320+:320]),\\r\\n\\t\\t\\t.INIT_51(INIT['h51*320+:320]),\\r\\n\\t\\t\\t.INIT_52(INIT['h52*320+:320]),\\r\\n\\t\\t\\t.INIT_53(INIT['h53*320+:320]),\\r\\n\\t\\t\\t.INIT_54(INIT['h54*320+:320]),\\r\\n\\t\\t\\t.INIT_55(INIT['h55*320+:320]),\\r\\n\\t\\t\\t.INIT_56(INIT['h56*320+:320]),\\r\\n\\t\\t\\t.INIT_57(INIT['h57*320+:320]),\\r\\n\\t\\t\\t.INIT_58(INIT['h58*320+:320]),\\r\\n\\t\\t\\t.INIT_59(INIT['h59*320+:320]),\\r\\n\\t\\t\\t.INIT_5A(INIT['h5a*320+:320]),\\r\\n\\t\\t\\t.INIT_5B(INIT['h5b*320+:320]),\\r\\n\\t\\t\\t.INIT_5C(INIT['h5c*320+:320]),\\r\\n\\t\\t\\t.INIT_5D(INIT['h5d*320+:320]),\\r\\n\\t\\t\\t.INIT_5E(INIT['h5e*320+:320]),\\r\\n\\t\\t\\t.INIT_5F(INIT['h5f*320+:320]),\\r\\n\\t\\t\\t.INIT_60(INIT['h60*320+:320]),\\r\\n\\t\\t\\t.INIT_61(INIT['h61*320+:320]),\\r\\n\\t\\t\\t.INIT_62(INIT['h62*320+:320]),\\r\\n\\t\\t\\t.INIT_63(INIT['h63*320+:320]),\\r\\n\\t\\t\\t.INIT_64(INIT['h64*320+:320]),\\r\\n\\t\\t\\t.INIT_65(INIT['h65*320+:320]),\\r\\n\\t\\t\\t.INIT_66(INIT['h66*320+:320]),\\r\\n\\t\\t\\t.INIT_67(INIT['h67*320+:320]),\\r\\n\\t\\t\\t.INIT_68(INIT['h68*320+:320]),\\r\\n\\t\\t\\t.INIT_69(INIT['h69*320+:320]),\\r\\n\\t\\t\\t.INIT_6A(INIT['h6a*320+:320]),\\r\\n\\t\\t\\t.INIT_6B(INIT['h6b*320+:320]),\\r\\n\\t\\t\\t.INIT_6C(INIT['h6c*320+:320]),\\r\\n\\t\\t\\t.INIT_6D(INIT['h6d*320+:320]),\\r\\n\\t\\t\\t.INIT_6E(INIT['h6e*320+:320]),\\r\\n\\t\\t\\t.INIT_6F(INIT['h6f*320+:320]),\\r\\n\\t\\t\\t.INIT_70(INIT['h70*320+:320]),\\r\\n\\t\\t\\t.INIT_71(INIT['h71*320+:320]),\\r\\n\\t\\t\\t.INIT_72(INIT['h72*320+:320]),\\r\\n\\t\\t\\t.INIT_73(INIT['h73*320+:320]),\\r\\n\\t\\t\\t.INIT_74(INIT['h74*320+:320]),\\r\\n\\t\\t\\t.INIT_75(INIT['h75*320+:320]),\\r\\n\\t\\t\\t.INIT_76(INIT['h76*320+:320]),\\r\\n\\t\\t\\t.INIT_77(INIT['h77*320+:320]),\\r\\n\\t\\t\\t.INIT_78(INIT['h78*320+:320]),\\r\\n\\t\\t\\t.INIT_79(INIT['h79*320+:320]),\\r\\n\\t\\t\\t.INIT_7A(INIT['h7a*320+:320]),\\r\\n\\t\\t\\t.INIT_7B(INIT['h7b*320+:320]),\\r\\n\\t\\t\\t.INIT_7C(INIT['h7c*320+:320]),\\r\\n\\t\\t\\t.INIT_7D(INIT['h7d*320+:320]),\\r\\n\\t\\t\\t.INIT_7E(INIT['h7e*320+:320]),\\r\\n\\t\\t\\t.INIT_7F(INIT['h7f*320+:320]),\\r\\n\\t\\t\\t.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\\r\\n\\t\\t\\t.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\\r\\n\\t\\t\\t.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\\r\\n\\t\\t\\t.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\\r\\n\\t\\t\\t.RAM_MODE(\\\"TDP\\\"),\\r\\n\\t\\t\\t.A_WR_MODE(PORT_A_OPTION_WR_MODE),\\r\\n\\t\\t\\t.B_WR_MODE(PORT_B_OPTION_WR_MODE),\\r\\n\\t\\t\\t.A_CLK_INV(!PORT_A_CLK_POL),\\r\\n\\t\\t\\t.B_CLK_INV(!PORT_B_CLK_POL),\\r\\n\\t\\t) _TECHMAP_REPLACE_ (\\r\\n\\t\\t\\t.A_CLK(PORT_A_CLK),\\r\\n\\t\\t\\t.A_EN(PORT_A_CLK_EN),\\r\\n\\t\\t\\t.A_WE(PORT_A_WR_EN),\\r\\n\\t\\t\\t.A_BM(PORT_A_WR_BE),\\r\\n\\t\\t\\t.A_DI(PORT_A_WR_DATA),\\r\\n\\t\\t\\t.A_ADDR({PORT_A_ADDR[14:0], 1'b0}),\\r\\n\\t\\t\\t.A_DO(PORT_A_RD_DATA),\\r\\n\\t\\t\\t.B_CLK(PORT_B_CLK),\\r\\n\\t\\t\\t.B_EN(PORT_B_CLK_EN),\\r\\n\\t\\t\\t.B_WE(PORT_B_WR_EN),\\r\\n\\t\\t\\t.B_BM(PORT_B_WR_BE),\\r\\n\\t\\t\\t.B_DI(PORT_B_WR_DATA),\\r\\n\\t\\t\\t.B_ADDR({PORT_B_ADDR[14:0], 1'b0}),\\r\\n\\t\\t\\t.B_DO(PORT_B_RD_DATA),\\r\\n\\t\\t);\\r\\n\\tend else begin\\r\\n\\t\\twire CAS_A, CAS_B;\\r\\n\\t\\tCC_BRAM_40K #(\\r\\n\\t\\t\\t.INIT_00(INIT['h00*320+:320]),\\r\\n\\t\\t\\t.INIT_01(INIT['h01*320+:320]),\\r\\n\\t\\t\\t.INIT_02(INIT['h02*320+:320]),\\r\\n\\t\\t\\t.INIT_03(INIT['h03*320+:320]),\\r\\n\\t\\t\\t.INIT_04(INIT['h04*320+:320]),\\r\\n\\t\\t\\t.INIT_05(INIT['h05*320+:320]),\\r\\n\\t\\t\\t.INIT_06(INIT['h06*320+:320]),\\r\\n\\t\\t\\t.INIT_07(INIT['h07*320+:320]),\\r\\n\\t\\t\\t.INIT_08(INIT['h08*320+:320]),\\r\\n\\t\\t\\t.INIT_09(INIT['h09*320+:320]),\\r\\n\\t\\t\\t.INIT_0A(INIT['h0a*320+:320]),\\r\\n\\t\\t\\t.INIT_0B(INIT['h0b*320+:320]),\\r\\n\\t\\t\\t.INIT_0C(INIT['h0c*320+:320]),\\r\\n\\t\\t\\t.INIT_0D(INIT['h0d*320+:320]),\\r\\n\\t\\t\\t.INIT_0E(INIT['h0e*320+:320]),\\r\\n\\t\\t\\t.INIT_0F(INIT['h0f*320+:320]),\\r\\n\\t\\t\\t.INIT_10(INIT['h10*320+:320]),\\r\\n\\t\\t\\t.INIT_11(INIT['h11*320+:320]),\\r\\n\\t\\t\\t.INIT_12(INIT['h12*320+:320]),\\r\\n\\t\\t\\t.INIT_13(INIT['h13*320+:320]),\\r\\n\\t\\t\\t.INIT_14(INIT['h14*320+:320]),\\r\\n\\t\\t\\t.INIT_15(INIT['h15*320+:320]),\\r\\n\\t\\t\\t.INIT_16(INIT['h16*320+:320]),\\r\\n\\t\\t\\t.INIT_17(INIT['h17*320+:320]),\\r\\n\\t\\t\\t.INIT_18(INIT['h18*320+:320]),\\r\\n\\t\\t\\t.INIT_19(INIT['h19*320+:320]),\\r\\n\\t\\t\\t.INIT_1A(INIT['h1a*320+:320]),\\r\\n\\t\\t\\t.INIT_1B(INIT['h1b*320+:320]),\\r\\n\\t\\t\\t.INIT_1C(INIT['h1c*320+:320]),\\r\\n\\t\\t\\t.INIT_1D(INIT['h1d*320+:320]),\\r\\n\\t\\t\\t.INIT_1E(INIT['h1e*320+:320]),\\r\\n\\t\\t\\t.INIT_1F(INIT['h1f*320+:320]),\\r\\n\\t\\t\\t.INIT_20(INIT['h20*320+:320]),\\r\\n\\t\\t\\t.INIT_21(INIT['h21*320+:320]),\\r\\n\\t\\t\\t.INIT_22(INIT['h22*320+:320]),\\r\\n\\t\\t\\t.INIT_23(INIT['h23*320+:320]),\\r\\n\\t\\t\\t.INIT_24(INIT['h24*320+:320]),\\r\\n\\t\\t\\t.INIT_25(INIT['h25*320+:320]),\\r\\n\\t\\t\\t.INIT_26(INIT['h26*320+:320]),\\r\\n\\t\\t\\t.INIT_27(INIT['h27*320+:320]),\\r\\n\\t\\t\\t.INIT_28(INIT['h28*320+:320]),\\r\\n\\t\\t\\t.INIT_29(INIT['h29*320+:320]),\\r\\n\\t\\t\\t.INIT_2A(INIT['h2a*320+:320]),\\r\\n\\t\\t\\t.INIT_2B(INIT['h2b*320+:320]),\\r\\n\\t\\t\\t.INIT_2C(INIT['h2c*320+:320]),\\r\\n\\t\\t\\t.INIT_2D(INIT['h2d*320+:320]),\\r\\n\\t\\t\\t.INIT_2E(INIT['h2e*320+:320]),\\r\\n\\t\\t\\t.INIT_2F(INIT['h2f*320+:320]),\\r\\n\\t\\t\\t.INIT_30(INIT['h30*320+:320]),\\r\\n\\t\\t\\t.INIT_31(INIT['h31*320+:320]),\\r\\n\\t\\t\\t.INIT_32(INIT['h32*320+:320]),\\r\\n\\t\\t\\t.INIT_33(INIT['h33*320+:320]),\\r\\n\\t\\t\\t.INIT_34(INIT['h34*320+:320]),\\r\\n\\t\\t\\t.INIT_35(INIT['h35*320+:320]),\\r\\n\\t\\t\\t.INIT_36(INIT['h36*320+:320]),\\r\\n\\t\\t\\t.INIT_37(INIT['h37*320+:320]),\\r\\n\\t\\t\\t.INIT_38(INIT['h38*320+:320]),\\r\\n\\t\\t\\t.INIT_39(INIT['h39*320+:320]),\\r\\n\\t\\t\\t.INIT_3A(INIT['h3a*320+:320]),\\r\\n\\t\\t\\t.INIT_3B(INIT['h3b*320+:320]),\\r\\n\\t\\t\\t.INIT_3C(INIT['h3c*320+:320]),\\r\\n\\t\\t\\t.INIT_3D(INIT['h3d*320+:320]),\\r\\n\\t\\t\\t.INIT_3E(INIT['h3e*320+:320]),\\r\\n\\t\\t\\t.INIT_3F(INIT['h3f*320+:320]),\\r\\n\\t\\t\\t.INIT_40(INIT['h40*320+:320]),\\r\\n\\t\\t\\t.INIT_41(INIT['h41*320+:320]),\\r\\n\\t\\t\\t.INIT_42(INIT['h42*320+:320]),\\r\\n\\t\\t\\t.INIT_43(INIT['h43*320+:320]),\\r\\n\\t\\t\\t.INIT_44(INIT['h44*320+:320]),\\r\\n\\t\\t\\t.INIT_45(INIT['h45*320+:320]),\\r\\n\\t\\t\\t.INIT_46(INIT['h46*320+:320]),\\r\\n\\t\\t\\t.INIT_47(INIT['h47*320+:320]),\\r\\n\\t\\t\\t.INIT_48(INIT['h48*320+:320]),\\r\\n\\t\\t\\t.INIT_49(INIT['h49*320+:320]),\\r\\n\\t\\t\\t.INIT_4A(INIT['h4a*320+:320]),\\r\\n\\t\\t\\t.INIT_4B(INIT['h4b*320+:320]),\\r\\n\\t\\t\\t.INIT_4C(INIT['h4c*320+:320]),\\r\\n\\t\\t\\t.INIT_4D(INIT['h4d*320+:320]),\\r\\n\\t\\t\\t.INIT_4E(INIT['h4e*320+:320]),\\r\\n\\t\\t\\t.INIT_4F(INIT['h4f*320+:320]),\\r\\n\\t\\t\\t.INIT_50(INIT['h50*320+:320]),\\r\\n\\t\\t\\t.INIT_51(INIT['h51*320+:320]),\\r\\n\\t\\t\\t.INIT_52(INIT['h52*320+:320]),\\r\\n\\t\\t\\t.INIT_53(INIT['h53*320+:320]),\\r\\n\\t\\t\\t.INIT_54(INIT['h54*320+:320]),\\r\\n\\t\\t\\t.INIT_55(INIT['h55*320+:320]),\\r\\n\\t\\t\\t.INIT_56(INIT['h56*320+:320]),\\r\\n\\t\\t\\t.INIT_57(INIT['h57*320+:320]),\\r\\n\\t\\t\\t.INIT_58(INIT['h58*320+:320]),\\r\\n\\t\\t\\t.INIT_59(INIT['h59*320+:320]),\\r\\n\\t\\t\\t.INIT_5A(INIT['h5a*320+:320]),\\r\\n\\t\\t\\t.INIT_5B(INIT['h5b*320+:320]),\\r\\n\\t\\t\\t.INIT_5C(INIT['h5c*320+:320]),\\r\\n\\t\\t\\t.INIT_5D(INIT['h5d*320+:320]),\\r\\n\\t\\t\\t.INIT_5E(INIT['h5e*320+:320]),\\r\\n\\t\\t\\t.INIT_5F(INIT['h5f*320+:320]),\\r\\n\\t\\t\\t.INIT_60(INIT['h60*320+:320]),\\r\\n\\t\\t\\t.INIT_61(INIT['h61*320+:320]),\\r\\n\\t\\t\\t.INIT_62(INIT['h62*320+:320]),\\r\\n\\t\\t\\t.INIT_63(INIT['h63*320+:320]),\\r\\n\\t\\t\\t.INIT_64(INIT['h64*320+:320]),\\r\\n\\t\\t\\t.INIT_65(INIT['h65*320+:320]),\\r\\n\\t\\t\\t.INIT_66(INIT['h66*320+:320]),\\r\\n\\t\\t\\t.INIT_67(INIT['h67*320+:320]),\\r\\n\\t\\t\\t.INIT_68(INIT['h68*320+:320]),\\r\\n\\t\\t\\t.INIT_69(INIT['h69*320+:320]),\\r\\n\\t\\t\\t.INIT_6A(INIT['h6a*320+:320]),\\r\\n\\t\\t\\t.INIT_6B(INIT['h6b*320+:320]),\\r\\n\\t\\t\\t.INIT_6C(INIT['h6c*320+:320]),\\r\\n\\t\\t\\t.INIT_6D(INIT['h6d*320+:320]),\\r\\n\\t\\t\\t.INIT_6E(INIT['h6e*320+:320]),\\r\\n\\t\\t\\t.INIT_6F(INIT['h6f*320+:320]),\\r\\n\\t\\t\\t.INIT_70(INIT['h70*320+:320]),\\r\\n\\t\\t\\t.INIT_71(INIT['h71*320+:320]),\\r\\n\\t\\t\\t.INIT_72(INIT['h72*320+:320]),\\r\\n\\t\\t\\t.INIT_73(INIT['h73*320+:320]),\\r\\n\\t\\t\\t.INIT_74(INIT['h74*320+:320]),\\r\\n\\t\\t\\t.INIT_75(INIT['h75*320+:320]),\\r\\n\\t\\t\\t.INIT_76(INIT['h76*320+:320]),\\r\\n\\t\\t\\t.INIT_77(INIT['h77*320+:320]),\\r\\n\\t\\t\\t.INIT_78(INIT['h78*320+:320]),\\r\\n\\t\\t\\t.INIT_79(INIT['h79*320+:320]),\\r\\n\\t\\t\\t.INIT_7A(INIT['h7a*320+:320]),\\r\\n\\t\\t\\t.INIT_7B(INIT['h7b*320+:320]),\\r\\n\\t\\t\\t.INIT_7C(INIT['h7c*320+:320]),\\r\\n\\t\\t\\t.INIT_7D(INIT['h7d*320+:320]),\\r\\n\\t\\t\\t.INIT_7E(INIT['h7e*320+:320]),\\r\\n\\t\\t\\t.INIT_7F(INIT['h7f*320+:320]),\\r\\n\\t\\t\\t.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\\r\\n\\t\\t\\t.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\\r\\n\\t\\t\\t.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\\r\\n\\t\\t\\t.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\\r\\n\\t\\t\\t.RAM_MODE(\\\"TDP\\\"),\\r\\n\\t\\t\\t.A_WR_MODE(PORT_A_OPTION_WR_MODE),\\r\\n\\t\\t\\t.B_WR_MODE(PORT_B_OPTION_WR_MODE),\\r\\n\\t\\t\\t.A_CLK_INV(!PORT_A_CLK_POL),\\r\\n\\t\\t\\t.B_CLK_INV(!PORT_B_CLK_POL),\\r\\n\\t\\t\\t.CAS(\\\"LOWER\\\"),\\r\\n\\t\\t) lower (\\r\\n\\t\\t\\t.A_CO(CAS_A),\\r\\n\\t\\t\\t.B_CO(CAS_B),\\r\\n\\t\\t\\t.A_CLK(PORT_A_CLK),\\r\\n\\t\\t\\t.A_EN(PORT_A_CLK_EN),\\r\\n\\t\\t\\t.A_WE(PORT_A_WR_EN),\\r\\n\\t\\t\\t.A_BM(PORT_A_WR_BE),\\r\\n\\t\\t\\t.A_DI(PORT_A_WR_DATA),\\r\\n\\t\\t\\t.A_ADDR({PORT_A_ADDR[14:0], PORT_A_ADDR[15]}),\\r\\n\\t\\t\\t.B_CLK(PORT_B_CLK),\\r\\n\\t\\t\\t.B_EN(PORT_B_CLK_EN),\\r\\n\\t\\t\\t.B_WE(PORT_B_WR_EN),\\r\\n\\t\\t\\t.B_BM(PORT_B_WR_BE),\\r\\n\\t\\t\\t.B_DI(PORT_B_WR_DATA),\\r\\n\\t\\t\\t.B_ADDR({PORT_B_ADDR[14:0], PORT_B_ADDR[15]}),\\r\\n\\t\\t);\\r\\n\\t\\tCC_BRAM_40K #(\\r\\n\\t\\t\\t.INIT_00(INIT['h80*320+:320]),\\r\\n\\t\\t\\t.INIT_01(INIT['h81*320+:320]),\\r\\n\\t\\t\\t.INIT_02(INIT['h82*320+:320]),\\r\\n\\t\\t\\t.INIT_03(INIT['h83*320+:320]),\\r\\n\\t\\t\\t.INIT_04(INIT['h84*320+:320]),\\r\\n\\t\\t\\t.INIT_05(INIT['h85*320+:320]),\\r\\n\\t\\t\\t.INIT_06(INIT['h86*320+:320]),\\r\\n\\t\\t\\t.INIT_07(INIT['h87*320+:320]),\\r\\n\\t\\t\\t.INIT_08(INIT['h88*320+:320]),\\r\\n\\t\\t\\t.INIT_09(INIT['h89*320+:320]),\\r\\n\\t\\t\\t.INIT_0A(INIT['h8a*320+:320]),\\r\\n\\t\\t\\t.INIT_0B(INIT['h8b*320+:320]),\\r\\n\\t\\t\\t.INIT_0C(INIT['h8c*320+:320]),\\r\\n\\t\\t\\t.INIT_0D(INIT['h8d*320+:320]),\\r\\n\\t\\t\\t.INIT_0E(INIT['h8e*320+:320]),\\r\\n\\t\\t\\t.INIT_0F(INIT['h8f*320+:320]),\\r\\n\\t\\t\\t.INIT_10(INIT['h90*320+:320]),\\r\\n\\t\\t\\t.INIT_11(INIT['h91*320+:320]),\\r\\n\\t\\t\\t.INIT_12(INIT['h92*320+:320]),\\r\\n\\t\\t\\t.INIT_13(INIT['h93*320+:320]),\\r\\n\\t\\t\\t.INIT_14(INIT['h94*320+:320]),\\r\\n\\t\\t\\t.INIT_15(INIT['h95*320+:320]),\\r\\n\\t\\t\\t.INIT_16(INIT['h96*320+:320]),\\r\\n\\t\\t\\t.INIT_17(INIT['h97*320+:320]),\\r\\n\\t\\t\\t.INIT_18(INIT['h98*320+:320]),\\r\\n\\t\\t\\t.INIT_19(INIT['h99*320+:320]),\\r\\n\\t\\t\\t.INIT_1A(INIT['h9a*320+:320]),\\r\\n\\t\\t\\t.INIT_1B(INIT['h9b*320+:320]),\\r\\n\\t\\t\\t.INIT_1C(INIT['h9c*320+:320]),\\r\\n\\t\\t\\t.INIT_1D(INIT['h9d*320+:320]),\\r\\n\\t\\t\\t.INIT_1E(INIT['h9e*320+:320]),\\r\\n\\t\\t\\t.INIT_1F(INIT['h9f*320+:320]),\\r\\n\\t\\t\\t.INIT_20(INIT['ha0*320+:320]),\\r\\n\\t\\t\\t.INIT_21(INIT['ha1*320+:320]),\\r\\n\\t\\t\\t.INIT_22(INIT['ha2*320+:320]),\\r\\n\\t\\t\\t.INIT_23(INIT['ha3*320+:320]),\\r\\n\\t\\t\\t.INIT_24(INIT['ha4*320+:320]),\\r\\n\\t\\t\\t.INIT_25(INIT['ha5*320+:320]),\\r\\n\\t\\t\\t.INIT_26(INIT['ha6*320+:320]),\\r\\n\\t\\t\\t.INIT_27(INIT['ha7*320+:320]),\\r\\n\\t\\t\\t.INIT_28(INIT['ha8*320+:320]),\\r\\n\\t\\t\\t.INIT_29(INIT['ha9*320+:320]),\\r\\n\\t\\t\\t.INIT_2A(INIT['haa*320+:320]),\\r\\n\\t\\t\\t.INIT_2B(INIT['hab*320+:320]),\\r\\n\\t\\t\\t.INIT_2C(INIT['hac*320+:320]),\\r\\n\\t\\t\\t.INIT_2D(INIT['had*320+:320]),\\r\\n\\t\\t\\t.INIT_2E(INIT['hae*320+:320]),\\r\\n\\t\\t\\t.INIT_2F(INIT['haf*320+:320]),\\r\\n\\t\\t\\t.INIT_30(INIT['hb0*320+:320]),\\r\\n\\t\\t\\t.INIT_31(INIT['hb1*320+:320]),\\r\\n\\t\\t\\t.INIT_32(INIT['hb2*320+:320]),\\r\\n\\t\\t\\t.INIT_33(INIT['hb3*320+:320]),\\r\\n\\t\\t\\t.INIT_34(INIT['hb4*320+:320]),\\r\\n\\t\\t\\t.INIT_35(INIT['hb5*320+:320]),\\r\\n\\t\\t\\t.INIT_36(INIT['hb6*320+:320]),\\r\\n\\t\\t\\t.INIT_37(INIT['hb7*320+:320]),\\r\\n\\t\\t\\t.INIT_38(INIT['hb8*320+:320]),\\r\\n\\t\\t\\t.INIT_39(INIT['hb9*320+:320]),\\r\\n\\t\\t\\t.INIT_3A(INIT['hba*320+:320]),\\r\\n\\t\\t\\t.INIT_3B(INIT['hbb*320+:320]),\\r\\n\\t\\t\\t.INIT_3C(INIT['hbc*320+:320]),\\r\\n\\t\\t\\t.INIT_3D(INIT['hbd*320+:320]),\\r\\n\\t\\t\\t.INIT_3E(INIT['hbe*320+:320]),\\r\\n\\t\\t\\t.INIT_3F(INIT['hbf*320+:320]),\\r\\n\\t\\t\\t.INIT_40(INIT['hc0*320+:320]),\\r\\n\\t\\t\\t.INIT_41(INIT['hc1*320+:320]),\\r\\n\\t\\t\\t.INIT_42(INIT['hc2*320+:320]),\\r\\n\\t\\t\\t.INIT_43(INIT['hc3*320+:320]),\\r\\n\\t\\t\\t.INIT_44(INIT['hc4*320+:320]),\\r\\n\\t\\t\\t.INIT_45(INIT['hc5*320+:320]),\\r\\n\\t\\t\\t.INIT_46(INIT['hc6*320+:320]),\\r\\n\\t\\t\\t.INIT_47(INIT['hc7*320+:320]),\\r\\n\\t\\t\\t.INIT_48(INIT['hc8*320+:320]),\\r\\n\\t\\t\\t.INIT_49(INIT['hc9*320+:320]),\\r\\n\\t\\t\\t.INIT_4A(INIT['hca*320+:320]),\\r\\n\\t\\t\\t.INIT_4B(INIT['hcb*320+:320]),\\r\\n\\t\\t\\t.INIT_4C(INIT['hcc*320+:320]),\\r\\n\\t\\t\\t.INIT_4D(INIT['hcd*320+:320]),\\r\\n\\t\\t\\t.INIT_4E(INIT['hce*320+:320]),\\r\\n\\t\\t\\t.INIT_4F(INIT['hcf*320+:320]),\\r\\n\\t\\t\\t.INIT_50(INIT['hd0*320+:320]),\\r\\n\\t\\t\\t.INIT_51(INIT['hd1*320+:320]),\\r\\n\\t\\t\\t.INIT_52(INIT['hd2*320+:320]),\\r\\n\\t\\t\\t.INIT_53(INIT['hd3*320+:320]),\\r\\n\\t\\t\\t.INIT_54(INIT['hd4*320+:320]),\\r\\n\\t\\t\\t.INIT_55(INIT['hd5*320+:320]),\\r\\n\\t\\t\\t.INIT_56(INIT['hd6*320+:320]),\\r\\n\\t\\t\\t.INIT_57(INIT['hd7*320+:320]),\\r\\n\\t\\t\\t.INIT_58(INIT['hd8*320+:320]),\\r\\n\\t\\t\\t.INIT_59(INIT['hd9*320+:320]),\\r\\n\\t\\t\\t.INIT_5A(INIT['hda*320+:320]),\\r\\n\\t\\t\\t.INIT_5B(INIT['hdb*320+:320]),\\r\\n\\t\\t\\t.INIT_5C(INIT['hdc*320+:320]),\\r\\n\\t\\t\\t.INIT_5D(INIT['hdd*320+:320]),\\r\\n\\t\\t\\t.INIT_5E(INIT['hde*320+:320]),\\r\\n\\t\\t\\t.INIT_5F(INIT['hdf*320+:320]),\\r\\n\\t\\t\\t.INIT_60(INIT['he0*320+:320]),\\r\\n\\t\\t\\t.INIT_61(INIT['he1*320+:320]),\\r\\n\\t\\t\\t.INIT_62(INIT['he2*320+:320]),\\r\\n\\t\\t\\t.INIT_63(INIT['he3*320+:320]),\\r\\n\\t\\t\\t.INIT_64(INIT['he4*320+:320]),\\r\\n\\t\\t\\t.INIT_65(INIT['he5*320+:320]),\\r\\n\\t\\t\\t.INIT_66(INIT['he6*320+:320]),\\r\\n\\t\\t\\t.INIT_67(INIT['he7*320+:320]),\\r\\n\\t\\t\\t.INIT_68(INIT['he8*320+:320]),\\r\\n\\t\\t\\t.INIT_69(INIT['he9*320+:320]),\\r\\n\\t\\t\\t.INIT_6A(INIT['hea*320+:320]),\\r\\n\\t\\t\\t.INIT_6B(INIT['heb*320+:320]),\\r\\n\\t\\t\\t.INIT_6C(INIT['hec*320+:320]),\\r\\n\\t\\t\\t.INIT_6D(INIT['hed*320+:320]),\\r\\n\\t\\t\\t.INIT_6E(INIT['hee*320+:320]),\\r\\n\\t\\t\\t.INIT_6F(INIT['hef*320+:320]),\\r\\n\\t\\t\\t.INIT_70(INIT['hf0*320+:320]),\\r\\n\\t\\t\\t.INIT_71(INIT['hf1*320+:320]),\\r\\n\\t\\t\\t.INIT_72(INIT['hf2*320+:320]),\\r\\n\\t\\t\\t.INIT_73(INIT['hf3*320+:320]),\\r\\n\\t\\t\\t.INIT_74(INIT['hf4*320+:320]),\\r\\n\\t\\t\\t.INIT_75(INIT['hf5*320+:320]),\\r\\n\\t\\t\\t.INIT_76(INIT['hf6*320+:320]),\\r\\n\\t\\t\\t.INIT_77(INIT['hf7*320+:320]),\\r\\n\\t\\t\\t.INIT_78(INIT['hf8*320+:320]),\\r\\n\\t\\t\\t.INIT_79(INIT['hf9*320+:320]),\\r\\n\\t\\t\\t.INIT_7A(INIT['hfa*320+:320]),\\r\\n\\t\\t\\t.INIT_7B(INIT['hfb*320+:320]),\\r\\n\\t\\t\\t.INIT_7C(INIT['hfc*320+:320]),\\r\\n\\t\\t\\t.INIT_7D(INIT['hfd*320+:320]),\\r\\n\\t\\t\\t.INIT_7E(INIT['hfe*320+:320]),\\r\\n\\t\\t\\t.INIT_7F(INIT['hff*320+:320]),\\r\\n\\t\\t\\t.A_RD_WIDTH(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0),\\r\\n\\t\\t\\t.A_WR_WIDTH(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0),\\r\\n\\t\\t\\t.B_RD_WIDTH(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0),\\r\\n\\t\\t\\t.B_WR_WIDTH(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0),\\r\\n\\t\\t\\t.RAM_MODE(\\\"TDP\\\"),\\r\\n\\t\\t\\t.A_WR_MODE(PORT_A_OPTION_WR_MODE),\\r\\n\\t\\t\\t.B_WR_MODE(PORT_B_OPTION_WR_MODE),\\r\\n\\t\\t\\t.A_CLK_INV(!PORT_A_CLK_POL),\\r\\n\\t\\t\\t.B_CLK_INV(!PORT_B_CLK_POL),\\r\\n\\t\\t\\t.CAS(\\\"UPPER\\\"),\\r\\n\\t\\t) upper (\\r\\n\\t\\t\\t.A_CI(CAS_A),\\r\\n\\t\\t\\t.B_CI(CAS_B),\\r\\n\\t\\t\\t.A_CLK(PORT_A_CLK),\\r\\n\\t\\t\\t.A_EN(PORT_A_CLK_EN),\\r\\n\\t\\t\\t.A_WE(PORT_A_WR_EN),\\r\\n\\t\\t\\t.A_BM(PORT_A_WR_BE),\\r\\n\\t\\t\\t.A_DI(PORT_A_WR_DATA),\\r\\n\\t\\t\\t.A_DO(PORT_A_RD_DATA),\\r\\n\\t\\t\\t.A_ADDR({PORT_A_ADDR[14:0], PORT_A_ADDR[15]}),\\r\\n\\t\\t\\t.B_CLK(PORT_B_CLK),\\r\\n\\t\\t\\t.B_EN(PORT_B_CLK_EN),\\r\\n\\t\\t\\t.B_WE(PORT_B_WR_EN),\\r\\n\\t\\t\\t.B_BM(PORT_B_WR_BE),\\r\\n\\t\\t\\t.B_DI(PORT_B_WR_DATA),\\r\\n\\t\\t\\t.B_DO(PORT_B_RD_DATA),\\r\\n\\t\\t\\t.B_ADDR({PORT_B_ADDR[14:0], PORT_B_ADDR[15]}),\\r\\n\\t\\t);\\r\\n\\tend\\r\\nendgenerate\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule $__CC_BRAM_SDP_(...);\\r\\n\\r\\nparameter INIT = 0;\\r\\nparameter OPTION_MODE = \\\"20K\\\";\\r\\nparameter OPTION_WR_MODE = \\\"NO_CHANGE\\\";\\r\\n\\r\\nparameter PORT_W_CLK_POL = 1;\\r\\nparameter PORT_W_USED = 1;\\r\\nparameter PORT_W_WIDTH = 40;\\r\\nparameter PORT_W_WR_BE_WIDTH = 40;\\r\\n\\r\\nparameter PORT_R_CLK_POL = 1;\\r\\nparameter PORT_R_USED = 1;\\r\\nparameter PORT_R_WIDTH = 40;\\r\\n\\r\\ninput PORT_W_CLK;\\r\\ninput PORT_W_CLK_EN;\\r\\ninput PORT_W_WR_EN;\\r\\ninput [15:0] PORT_W_ADDR;\\r\\ninput [PORT_W_WR_BE_WIDTH-1:0] PORT_W_WR_BE;\\r\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\r\\n\\r\\ninput PORT_R_CLK;\\r\\ninput PORT_R_CLK_EN;\\r\\ninput [15:0] PORT_R_ADDR;\\r\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\r\\n\\r\\ngenerate\\r\\n\\tif (OPTION_MODE == \\\"20K\\\") begin\\r\\n\\t\\tCC_BRAM_20K #(\\r\\n\\t\\t\\t.INIT_00(INIT['h00*320+:320]),\\r\\n\\t\\t\\t.INIT_01(INIT['h01*320+:320]),\\r\\n\\t\\t\\t.INIT_02(INIT['h02*320+:320]),\\r\\n\\t\\t\\t.INIT_03(INIT['h03*320+:320]),\\r\\n\\t\\t\\t.INIT_04(INIT['h04*320+:320]),\\r\\n\\t\\t\\t.INIT_05(INIT['h05*320+:320]),\\r\\n\\t\\t\\t.INIT_06(INIT['h06*320+:320]),\\r\\n\\t\\t\\t.INIT_07(INIT['h07*320+:320]),\\r\\n\\t\\t\\t.INIT_08(INIT['h08*320+:320]),\\r\\n\\t\\t\\t.INIT_09(INIT['h09*320+:320]),\\r\\n\\t\\t\\t.INIT_0A(INIT['h0a*320+:320]),\\r\\n\\t\\t\\t.INIT_0B(INIT['h0b*320+:320]),\\r\\n\\t\\t\\t.INIT_0C(INIT['h0c*320+:320]),\\r\\n\\t\\t\\t.INIT_0D(INIT['h0d*320+:320]),\\r\\n\\t\\t\\t.INIT_0E(INIT['h0e*320+:320]),\\r\\n\\t\\t\\t.INIT_0F(INIT['h0f*320+:320]),\\r\\n\\t\\t\\t.INIT_10(INIT['h10*320+:320]),\\r\\n\\t\\t\\t.INIT_11(INIT['h11*320+:320]),\\r\\n\\t\\t\\t.INIT_12(INIT['h12*320+:320]),\\r\\n\\t\\t\\t.INIT_13(INIT['h13*320+:320]),\\r\\n\\t\\t\\t.INIT_14(INIT['h14*320+:320]),\\r\\n\\t\\t\\t.INIT_15(INIT['h15*320+:320]),\\r\\n\\t\\t\\t.INIT_16(INIT['h16*320+:320]),\\r\\n\\t\\t\\t.INIT_17(INIT['h17*320+:320]),\\r\\n\\t\\t\\t.INIT_18(INIT['h18*320+:320]),\\r\\n\\t\\t\\t.INIT_19(INIT['h19*320+:320]),\\r\\n\\t\\t\\t.INIT_1A(INIT['h1a*320+:320]),\\r\\n\\t\\t\\t.INIT_1B(INIT['h1b*320+:320]),\\r\\n\\t\\t\\t.INIT_1C(INIT['h1c*320+:320]),\\r\\n\\t\\t\\t.INIT_1D(INIT['h1d*320+:320]),\\r\\n\\t\\t\\t.INIT_1E(INIT['h1e*320+:320]),\\r\\n\\t\\t\\t.INIT_1F(INIT['h1f*320+:320]),\\r\\n\\t\\t\\t.INIT_20(INIT['h20*320+:320]),\\r\\n\\t\\t\\t.INIT_21(INIT['h21*320+:320]),\\r\\n\\t\\t\\t.INIT_22(INIT['h22*320+:320]),\\r\\n\\t\\t\\t.INIT_23(INIT['h23*320+:320]),\\r\\n\\t\\t\\t.INIT_24(INIT['h24*320+:320]),\\r\\n\\t\\t\\t.INIT_25(INIT['h25*320+:320]),\\r\\n\\t\\t\\t.INIT_26(INIT['h26*320+:320]),\\r\\n\\t\\t\\t.INIT_27(INIT['h27*320+:320]),\\r\\n\\t\\t\\t.INIT_28(INIT['h28*320+:320]),\\r\\n\\t\\t\\t.INIT_29(INIT['h29*320+:320]),\\r\\n\\t\\t\\t.INIT_2A(INIT['h2a*320+:320]),\\r\\n\\t\\t\\t.INIT_2B(INIT['h2b*320+:320]),\\r\\n\\t\\t\\t.INIT_2C(INIT['h2c*320+:320]),\\r\\n\\t\\t\\t.INIT_2D(INIT['h2d*320+:320]),\\r\\n\\t\\t\\t.INIT_2E(INIT['h2e*320+:320]),\\r\\n\\t\\t\\t.INIT_2F(INIT['h2f*320+:320]),\\r\\n\\t\\t\\t.INIT_30(INIT['h30*320+:320]),\\r\\n\\t\\t\\t.INIT_31(INIT['h31*320+:320]),\\r\\n\\t\\t\\t.INIT_32(INIT['h32*320+:320]),\\r\\n\\t\\t\\t.INIT_33(INIT['h33*320+:320]),\\r\\n\\t\\t\\t.INIT_34(INIT['h34*320+:320]),\\r\\n\\t\\t\\t.INIT_35(INIT['h35*320+:320]),\\r\\n\\t\\t\\t.INIT_36(INIT['h36*320+:320]),\\r\\n\\t\\t\\t.INIT_37(INIT['h37*320+:320]),\\r\\n\\t\\t\\t.INIT_38(INIT['h38*320+:320]),\\r\\n\\t\\t\\t.INIT_39(INIT['h39*320+:320]),\\r\\n\\t\\t\\t.INIT_3A(INIT['h3a*320+:320]),\\r\\n\\t\\t\\t.INIT_3B(INIT['h3b*320+:320]),\\r\\n\\t\\t\\t.INIT_3C(INIT['h3c*320+:320]),\\r\\n\\t\\t\\t.INIT_3D(INIT['h3d*320+:320]),\\r\\n\\t\\t\\t.INIT_3E(INIT['h3e*320+:320]),\\r\\n\\t\\t\\t.INIT_3F(INIT['h3f*320+:320]),\\r\\n\\t\\t\\t.A_RD_WIDTH(0),\\r\\n\\t\\t\\t.A_WR_WIDTH(PORT_W_USED ? PORT_W_WIDTH : 0),\\r\\n\\t\\t\\t.B_RD_WIDTH(PORT_R_USED ? PORT_R_WIDTH : 0),\\r\\n\\t\\t\\t.B_WR_WIDTH(0),\\r\\n\\t\\t\\t.RAM_MODE(\\\"SDP\\\"),\\r\\n\\t\\t\\t.A_WR_MODE(OPTION_WR_MODE),\\r\\n\\t\\t\\t.B_WR_MODE(OPTION_WR_MODE),\\r\\n\\t\\t\\t.A_CLK_INV(!PORT_W_CLK_POL),\\r\\n\\t\\t\\t.B_CLK_INV(!PORT_R_CLK_POL),\\r\\n\\t\\t) _TECHMAP_REPLACE_ (\\r\\n\\t\\t\\t.A_CLK(PORT_W_CLK),\\r\\n\\t\\t\\t.A_EN(PORT_W_CLK_EN),\\r\\n\\t\\t\\t.A_WE(PORT_W_WR_EN),\\r\\n\\t\\t\\t.A_BM(PORT_W_WR_BE[19:0]),\\r\\n\\t\\t\\t.B_BM(PORT_W_WR_BE[39:20]),\\r\\n\\t\\t\\t.A_DI(PORT_W_WR_DATA[19:0]),\\r\\n\\t\\t\\t.B_DI(PORT_W_WR_DATA[39:20]),\\r\\n\\t\\t\\t.A_ADDR({PORT_W_ADDR[13:5], 1'b0, PORT_W_ADDR[4:0], 1'b0}),\\r\\n\\t\\t\\t.B_CLK(PORT_R_CLK),\\r\\n\\t\\t\\t.B_EN(PORT_R_CLK_EN),\\r\\n\\t\\t\\t.B_WE(1'b0),\\r\\n\\t\\t\\t.B_ADDR({PORT_R_ADDR[13:5], 1'b0, PORT_R_ADDR[4:0], 1'b0}),\\r\\n\\t\\t\\t.A_DO(PORT_R_RD_DATA[19:0]),\\r\\n\\t\\t\\t.B_DO(PORT_R_RD_DATA[39:20]),\\r\\n\\t\\t);\\r\\n\\tend else if (OPTION_MODE == \\\"40K\\\") begin\\r\\n\\t\\tCC_BRAM_40K #(\\r\\n\\t\\t\\t.INIT_00(INIT['h00*320+:320]),\\r\\n\\t\\t\\t.INIT_01(INIT['h01*320+:320]),\\r\\n\\t\\t\\t.INIT_02(INIT['h02*320+:320]),\\r\\n\\t\\t\\t.INIT_03(INIT['h03*320+:320]),\\r\\n\\t\\t\\t.INIT_04(INIT['h04*320+:320]),\\r\\n\\t\\t\\t.INIT_05(INIT['h05*320+:320]),\\r\\n\\t\\t\\t.INIT_06(INIT['h06*320+:320]),\\r\\n\\t\\t\\t.INIT_07(INIT['h07*320+:320]),\\r\\n\\t\\t\\t.INIT_08(INIT['h08*320+:320]),\\r\\n\\t\\t\\t.INIT_09(INIT['h09*320+:320]),\\r\\n\\t\\t\\t.INIT_0A(INIT['h0a*320+:320]),\\r\\n\\t\\t\\t.INIT_0B(INIT['h0b*320+:320]),\\r\\n\\t\\t\\t.INIT_0C(INIT['h0c*320+:320]),\\r\\n\\t\\t\\t.INIT_0D(INIT['h0d*320+:320]),\\r\\n\\t\\t\\t.INIT_0E(INIT['h0e*320+:320]),\\r\\n\\t\\t\\t.INIT_0F(INIT['h0f*320+:320]),\\r\\n\\t\\t\\t.INIT_10(INIT['h10*320+:320]),\\r\\n\\t\\t\\t.INIT_11(INIT['h11*320+:320]),\\r\\n\\t\\t\\t.INIT_12(INIT['h12*320+:320]),\\r\\n\\t\\t\\t.INIT_13(INIT['h13*320+:320]),\\r\\n\\t\\t\\t.INIT_14(INIT['h14*320+:320]),\\r\\n\\t\\t\\t.INIT_15(INIT['h15*320+:320]),\\r\\n\\t\\t\\t.INIT_16(INIT['h16*320+:320]),\\r\\n\\t\\t\\t.INIT_17(INIT['h17*320+:320]),\\r\\n\\t\\t\\t.INIT_18(INIT['h18*320+:320]),\\r\\n\\t\\t\\t.INIT_19(INIT['h19*320+:320]),\\r\\n\\t\\t\\t.INIT_1A(INIT['h1a*320+:320]),\\r\\n\\t\\t\\t.INIT_1B(INIT['h1b*320+:320]),\\r\\n\\t\\t\\t.INIT_1C(INIT['h1c*320+:320]),\\r\\n\\t\\t\\t.INIT_1D(INIT['h1d*320+:320]),\\r\\n\\t\\t\\t.INIT_1E(INIT['h1e*320+:320]),\\r\\n\\t\\t\\t.INIT_1F(INIT['h1f*320+:320]),\\r\\n\\t\\t\\t.INIT_20(INIT['h20*320+:320]),\\r\\n\\t\\t\\t.INIT_21(INIT['h21*320+:320]),\\r\\n\\t\\t\\t.INIT_22(INIT['h22*320+:320]),\\r\\n\\t\\t\\t.INIT_23(INIT['h23*320+:320]),\\r\\n\\t\\t\\t.INIT_24(INIT['h24*320+:320]),\\r\\n\\t\\t\\t.INIT_25(INIT['h25*320+:320]),\\r\\n\\t\\t\\t.INIT_26(INIT['h26*320+:320]),\\r\\n\\t\\t\\t.INIT_27(INIT['h27*320+:320]),\\r\\n\\t\\t\\t.INIT_28(INIT['h28*320+:320]),\\r\\n\\t\\t\\t.INIT_29(INIT['h29*320+:320]),\\r\\n\\t\\t\\t.INIT_2A(INIT['h2a*320+:320]),\\r\\n\\t\\t\\t.INIT_2B(INIT['h2b*320+:320]),\\r\\n\\t\\t\\t.INIT_2C(INIT['h2c*320+:320]),\\r\\n\\t\\t\\t.INIT_2D(INIT['h2d*320+:320]),\\r\\n\\t\\t\\t.INIT_2E(INIT['h2e*320+:320]),\\r\\n\\t\\t\\t.INIT_2F(INIT['h2f*320+:320]),\\r\\n\\t\\t\\t.INIT_30(INIT['h30*320+:320]),\\r\\n\\t\\t\\t.INIT_31(INIT['h31*320+:320]),\\r\\n\\t\\t\\t.INIT_32(INIT['h32*320+:320]),\\r\\n\\t\\t\\t.INIT_33(INIT['h33*320+:320]),\\r\\n\\t\\t\\t.INIT_34(INIT['h34*320+:320]),\\r\\n\\t\\t\\t.INIT_35(INIT['h35*320+:320]),\\r\\n\\t\\t\\t.INIT_36(INIT['h36*320+:320]),\\r\\n\\t\\t\\t.INIT_37(INIT['h37*320+:320]),\\r\\n\\t\\t\\t.INIT_38(INIT['h38*320+:320]),\\r\\n\\t\\t\\t.INIT_39(INIT['h39*320+:320]),\\r\\n\\t\\t\\t.INIT_3A(INIT['h3a*320+:320]),\\r\\n\\t\\t\\t.INIT_3B(INIT['h3b*320+:320]),\\r\\n\\t\\t\\t.INIT_3C(INIT['h3c*320+:320]),\\r\\n\\t\\t\\t.INIT_3D(INIT['h3d*320+:320]),\\r\\n\\t\\t\\t.INIT_3E(INIT['h3e*320+:320]),\\r\\n\\t\\t\\t.INIT_3F(INIT['h3f*320+:320]),\\r\\n\\t\\t\\t.INIT_40(INIT['h40*320+:320]),\\r\\n\\t\\t\\t.INIT_41(INIT['h41*320+:320]),\\r\\n\\t\\t\\t.INIT_42(INIT['h42*320+:320]),\\r\\n\\t\\t\\t.INIT_43(INIT['h43*320+:320]),\\r\\n\\t\\t\\t.INIT_44(INIT['h44*320+:320]),\\r\\n\\t\\t\\t.INIT_45(INIT['h45*320+:320]),\\r\\n\\t\\t\\t.INIT_46(INIT['h46*320+:320]),\\r\\n\\t\\t\\t.INIT_47(INIT['h47*320+:320]),\\r\\n\\t\\t\\t.INIT_48(INIT['h48*320+:320]),\\r\\n\\t\\t\\t.INIT_49(INIT['h49*320+:320]),\\r\\n\\t\\t\\t.INIT_4A(INIT['h4a*320+:320]),\\r\\n\\t\\t\\t.INIT_4B(INIT['h4b*320+:320]),\\r\\n\\t\\t\\t.INIT_4C(INIT['h4c*320+:320]),\\r\\n\\t\\t\\t.INIT_4D(INIT['h4d*320+:320]),\\r\\n\\t\\t\\t.INIT_4E(INIT['h4e*320+:320]),\\r\\n\\t\\t\\t.INIT_4F(INIT['h4f*320+:320]),\\r\\n\\t\\t\\t.INIT_50(INIT['h50*320+:320]),\\r\\n\\t\\t\\t.INIT_51(INIT['h51*320+:320]),\\r\\n\\t\\t\\t.INIT_52(INIT['h52*320+:320]),\\r\\n\\t\\t\\t.INIT_53(INIT['h53*320+:320]),\\r\\n\\t\\t\\t.INIT_54(INIT['h54*320+:320]),\\r\\n\\t\\t\\t.INIT_55(INIT['h55*320+:320]),\\r\\n\\t\\t\\t.INIT_56(INIT['h56*320+:320]),\\r\\n\\t\\t\\t.INIT_57(INIT['h57*320+:320]),\\r\\n\\t\\t\\t.INIT_58(INIT['h58*320+:320]),\\r\\n\\t\\t\\t.INIT_59(INIT['h59*320+:320]),\\r\\n\\t\\t\\t.INIT_5A(INIT['h5a*320+:320]),\\r\\n\\t\\t\\t.INIT_5B(INIT['h5b*320+:320]),\\r\\n\\t\\t\\t.INIT_5C(INIT['h5c*320+:320]),\\r\\n\\t\\t\\t.INIT_5D(INIT['h5d*320+:320]),\\r\\n\\t\\t\\t.INIT_5E(INIT['h5e*320+:320]),\\r\\n\\t\\t\\t.INIT_5F(INIT['h5f*320+:320]),\\r\\n\\t\\t\\t.INIT_60(INIT['h60*320+:320]),\\r\\n\\t\\t\\t.INIT_61(INIT['h61*320+:320]),\\r\\n\\t\\t\\t.INIT_62(INIT['h62*320+:320]),\\r\\n\\t\\t\\t.INIT_63(INIT['h63*320+:320]),\\r\\n\\t\\t\\t.INIT_64(INIT['h64*320+:320]),\\r\\n\\t\\t\\t.INIT_65(INIT['h65*320+:320]),\\r\\n\\t\\t\\t.INIT_66(INIT['h66*320+:320]),\\r\\n\\t\\t\\t.INIT_67(INIT['h67*320+:320]),\\r\\n\\t\\t\\t.INIT_68(INIT['h68*320+:320]),\\r\\n\\t\\t\\t.INIT_69(INIT['h69*320+:320]),\\r\\n\\t\\t\\t.INIT_6A(INIT['h6a*320+:320]),\\r\\n\\t\\t\\t.INIT_6B(INIT['h6b*320+:320]),\\r\\n\\t\\t\\t.INIT_6C(INIT['h6c*320+:320]),\\r\\n\\t\\t\\t.INIT_6D(INIT['h6d*320+:320]),\\r\\n\\t\\t\\t.INIT_6E(INIT['h6e*320+:320]),\\r\\n\\t\\t\\t.INIT_6F(INIT['h6f*320+:320]),\\r\\n\\t\\t\\t.INIT_70(INIT['h70*320+:320]),\\r\\n\\t\\t\\t.INIT_71(INIT['h71*320+:320]),\\r\\n\\t\\t\\t.INIT_72(INIT['h72*320+:320]),\\r\\n\\t\\t\\t.INIT_73(INIT['h73*320+:320]),\\r\\n\\t\\t\\t.INIT_74(INIT['h74*320+:320]),\\r\\n\\t\\t\\t.INIT_75(INIT['h75*320+:320]),\\r\\n\\t\\t\\t.INIT_76(INIT['h76*320+:320]),\\r\\n\\t\\t\\t.INIT_77(INIT['h77*320+:320]),\\r\\n\\t\\t\\t.INIT_78(INIT['h78*320+:320]),\\r\\n\\t\\t\\t.INIT_79(INIT['h79*320+:320]),\\r\\n\\t\\t\\t.INIT_7A(INIT['h7a*320+:320]),\\r\\n\\t\\t\\t.INIT_7B(INIT['h7b*320+:320]),\\r\\n\\t\\t\\t.INIT_7C(INIT['h7c*320+:320]),\\r\\n\\t\\t\\t.INIT_7D(INIT['h7d*320+:320]),\\r\\n\\t\\t\\t.INIT_7E(INIT['h7e*320+:320]),\\r\\n\\t\\t\\t.INIT_7F(INIT['h7f*320+:320]),\\r\\n\\t\\t\\t.A_RD_WIDTH(0),\\r\\n\\t\\t\\t.A_WR_WIDTH(PORT_W_USED ? PORT_W_WIDTH : 0),\\r\\n\\t\\t\\t.B_RD_WIDTH(PORT_R_USED ? PORT_R_WIDTH : 0),\\r\\n\\t\\t\\t.B_WR_WIDTH(0),\\r\\n\\t\\t\\t.RAM_MODE(\\\"SDP\\\"),\\r\\n\\t\\t\\t.A_WR_MODE(OPTION_WR_MODE),\\r\\n\\t\\t\\t.B_WR_MODE(OPTION_WR_MODE),\\r\\n\\t\\t\\t.A_CLK_INV(!PORT_W_CLK_POL),\\r\\n\\t\\t\\t.B_CLK_INV(!PORT_R_CLK_POL),\\r\\n\\t\\t) _TECHMAP_REPLACE_ (\\r\\n\\t\\t\\t.A_CLK(PORT_W_CLK),\\r\\n\\t\\t\\t.A_EN(PORT_W_CLK_EN),\\r\\n\\t\\t\\t.A_WE(PORT_W_WR_EN),\\r\\n\\t\\t\\t.A_BM(PORT_W_WR_BE[39:0]),\\r\\n\\t\\t\\t.B_BM(PORT_W_WR_BE[79:40]),\\r\\n\\t\\t\\t.A_DI(PORT_W_WR_DATA[39:0]),\\r\\n\\t\\t\\t.B_DI(PORT_W_WR_DATA[79:40]),\\r\\n\\t\\t\\t.A_ADDR({PORT_W_ADDR[14:0], 1'b0}),\\r\\n\\t\\t\\t.B_CLK(PORT_R_CLK),\\r\\n\\t\\t\\t.B_EN(PORT_R_CLK_EN),\\r\\n\\t\\t\\t.B_WE(1'b0),\\r\\n\\t\\t\\t.B_ADDR({PORT_R_ADDR[14:0], 1'b0}),\\r\\n\\t\\t\\t.A_DO(PORT_R_RD_DATA[39:0]),\\r\\n\\t\\t\\t.B_DO(PORT_R_RD_DATA[79:40]),\\r\\n\\t\\t);\\r\\n\\tend\\r\\nendgenerate\\r\\n\\r\\nendmodule\\r\\n\",\n            \"cells_bb.v\": \"/*\\r\\n *  yosys -- Yosys Open SYnthesis Suite\\r\\n *\\r\\n *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\\r\\n *\\r\\n *  Permission to use, copy, modify, and/or distribute this software for any\\r\\n *  purpose with or without fee is hereby granted, provided that the above\\r\\n *  copyright notice and this permission notice appear in all copies.\\r\\n *\\r\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\r\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\r\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\r\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\r\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\r\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\r\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\r\\n *\\r\\n */\\r\\n\\r\\n(* blackbox *)\\r\\nmodule CC_PLL #(\\r\\n\\tparameter REF_CLK = \\\"\\\", // e.g. \\\"10.0\\\"\\r\\n\\tparameter OUT_CLK = \\\"\\\", // e.g. \\\"50.0\\\"\\r\\n\\tparameter PERF_MD = \\\"\\\", // LOWPOWER, ECONOMY, SPEED\\r\\n\\tparameter LOCK_REQ = 1,\\r\\n\\tparameter CLK270_DOUB = 0,\\r\\n\\tparameter CLK180_DOUB = 0,\\r\\n\\tparameter LOW_JITTER = 1,\\r\\n\\tparameter CI_FILTER_CONST = 2,\\r\\n\\tparameter CP_FILTER_CONST = 4\\r\\n)(\\r\\n\\tinput  CLK_REF, CLK_FEEDBACK, USR_CLK_REF,\\r\\n\\tinput  USR_LOCKED_STDY_RST,\\r\\n\\toutput USR_PLL_LOCKED_STDY, USR_PLL_LOCKED,\\r\\n\\toutput CLK270, CLK180, CLK90, CLK0, CLK_REF_OUT\\r\\n);\\r\\nendmodule\\r\\n\\r\\n(* blackbox *)\\r\\nmodule CC_PLL_ADV #(\\r\\n\\tparameter [95:0] PLL_CFG_A = 96'bx,\\r\\n\\tparameter [95:0] PLL_CFG_B = 96'bx\\r\\n)(\\r\\n\\tinput  CLK_REF, CLK_FEEDBACK, USR_CLK_REF,\\r\\n\\tinput  USR_LOCKED_STDY_RST, USR_SEL_A_B,\\r\\n\\toutput USR_PLL_LOCKED_STDY, USR_PLL_LOCKED,\\r\\n\\toutput CLK270, CLK180, CLK90, CLK0, CLK_REF_OUT\\r\\n);\\r\\nendmodule\\r\\n\\r\\n(* blackbox *) (* keep *)\\r\\nmodule CC_SERDES #(\\r\\n\\tparameter SERDES_CFG = \\\"\\\"\\r\\n)(\\r\\n\\tinput [63:0] TX_DATA_I,\\r\\n\\tinput TX_RESET_I,\\r\\n\\tinput TX_PCS_RESET_I,\\r\\n\\tinput TX_PMA_RESET_I,\\r\\n\\tinput PLL_RESET_I,\\r\\n\\tinput TX_POWERDOWN_N_I,\\r\\n\\tinput TX_POLARITY_I,\\r\\n\\tinput [2:0] TX_PRBS_SEL_I,\\r\\n\\tinput TX_PRBS_FORCE_ERR_I,\\r\\n\\tinput TX_8B10B_EN_I,\\r\\n\\tinput [7:0] TX_8B10B_BYPASS_I,\\r\\n\\tinput [7:0] TX_CHAR_IS_K_I,\\r\\n\\tinput [7:0] TX_CHAR_DISPMODE_I,\\r\\n\\tinput [7:0] TX_CHAR_DISPVAL_I,\\r\\n\\tinput TX_ELEC_IDLE_I,\\r\\n\\tinput TX_DETECT_RX_I,\\r\\n\\tinput [2:0] LOOPBACK_I,\\r\\n\\tinput CLK_CORE_TX_I,\\r\\n\\tinput CLK_CORE_RX_I,\\r\\n\\tinput RX_RESET_I,\\r\\n\\tinput RX_PMA_RESET_I,\\r\\n\\tinput RX_EQA_RESET_I,\\r\\n\\tinput RX_CDR_RESET_I,\\r\\n\\tinput RX_PCS_RESET_I,\\r\\n\\tinput RX_BUF_RESET_I,\\r\\n\\tinput RX_POWERDOWN_N_I,\\r\\n\\tinput RX_POLARITY_I,\\r\\n\\tinput [2:0] RX_PRBS_SEL_I,\\r\\n\\tinput RX_PRBS_CNT_RESET_I,\\r\\n\\tinput RX_8B10B_EN_I,\\r\\n\\tinput [7:0] RX_8B10B_BYPASS_I,\\r\\n\\tinput RX_EN_EI_DETECTOR_I,\\r\\n\\tinput RX_COMMA_DETECT_EN_I,\\r\\n\\tinput RX_SLIDE_I,\\r\\n\\tinput RX_MCOMMA_ALIGN_I,\\r\\n\\tinput RX_PCOMMA_ALIGN_I,\\r\\n\\tinput CLK_REG_I,\\r\\n\\tinput REGFILE_WE_I,\\r\\n\\tinput REGFILE_EN_I,\\r\\n\\tinput [7:0] REGFILE_ADDR_I,\\r\\n\\tinput [15:0] REGFILE_DI_I,\\r\\n\\tinput [15:0] REGFILE_MASK_I,\\r\\n\\toutput [63:0] RX_DATA_O,\\r\\n\\toutput [7:0] RX_NOT_IN_TABLE_O,\\r\\n\\toutput [7:0] RX_CHAR_IS_COMMA_O,\\r\\n\\toutput [7:0] RX_CHAR_IS_K_O,\\r\\n\\toutput [7:0] RX_DISP_ERR_O,\\r\\n\\toutput RX_DETECT_DONE_O,\\r\\n\\toutput RX_PRESENT_O,\\r\\n\\toutput TX_BUF_ERR_O,\\r\\n\\toutput TX_RESETDONE_O,\\r\\n\\toutput RX_PRBS_ERR_O,\\r\\n\\toutput RX_BUF_ERR_O,\\r\\n\\toutput RX_BYTE_IS_ALIGNED_O,\\r\\n\\toutput RX_BYTE_REALIGN_O,\\r\\n\\toutput RX_RESETDONE_O,\\r\\n\\toutput RX_EI_EN_O,\\r\\n\\toutput CLK_CORE_RX_O,\\r\\n\\toutput CLK_CORE_PLL_O,\\r\\n\\toutput [15:0] REGFILE_DO_O,\\r\\n\\toutput REGFILE_RDY_O\\r\\n);\\r\\nendmodule\\r\\n\\r\\n(* blackbox *) (* keep *)\\r\\nmodule CC_CFG_CTRL(\\r\\n\\tinput [7:0] DATA,\\r\\n\\tinput CLK,\\r\\n\\tinput EN,\\r\\n\\tinput RECFG,\\r\\n\\tinput VALID\\r\\n);\\r\\nendmodule\\r\\n\\r\\n(* blackbox *) (* keep *)\\r\\nmodule CC_USR_RSTN (\\r\\n\\toutput USR_RSTN\\r\\n);\\r\\nendmodule\\r\\n\",\n            \"cells_sim.v\": \"/*\\r\\n *  yosys -- Yosys Open SYnthesis Suite\\r\\n *\\r\\n *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\\r\\n *\\r\\n *  Permission to use, copy, modify, and/or distribute this software for any\\r\\n *  purpose with or without fee is hereby granted, provided that the above\\r\\n *  copyright notice and this permission notice appear in all copies.\\r\\n *\\r\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\r\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\r\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\r\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\r\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\r\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\r\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\r\\n *\\r\\n */\\r\\n\\r\\n`timescale 1ps/1ps\\r\\n\\r\\nmodule CC_IBUF #(\\r\\n\\tparameter PIN_NAME = \\\"UNPLACED\\\",\\r\\n\\tparameter V_IO = \\\"UNDEFINED\\\",\\r\\n\\tparameter [0:0] PULLUP = 1'bx,\\r\\n\\tparameter [0:0] PULLDOWN = 1'bx,\\r\\n\\tparameter [0:0] KEEPER = 1'bx,\\r\\n\\tparameter [0:0] SCHMITT_TRIGGER = 1'bx,\\r\\n\\t// IOSEL\\r\\n\\tparameter [3:0] DELAY_IBF = 1'bx,\\r\\n\\tparameter [0:0] FF_IBF = 1'bx\\r\\n)(\\r\\n\\t(* iopad_external_pin *)\\r\\n\\tinput  I,\\r\\n\\toutput Y\\r\\n);\\r\\n\\tassign Y = I;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_OBUF #(\\r\\n\\tparameter PIN_NAME = \\\"UNPLACED\\\",\\r\\n\\tparameter V_IO = \\\"UNDEFINED\\\",\\r\\n\\tparameter DRIVE = \\\"UNDEFINED\\\",\\r\\n\\tparameter SLEW = \\\"UNDEFINED\\\",\\r\\n\\t// IOSEL\\r\\n\\tparameter [3:0] DELAY_OBF = 1'bx,\\r\\n\\tparameter [0:0] FF_OBF = 1'bx\\r\\n)(\\r\\n\\tinput  A,\\r\\n\\t(* iopad_external_pin *)\\r\\n\\toutput O\\r\\n);\\r\\n\\tassign O = A;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_TOBUF #(\\r\\n\\tparameter PIN_NAME = \\\"UNPLACED\\\",\\r\\n\\tparameter V_IO = \\\"UNDEFINED\\\",\\r\\n\\tparameter DRIVE = \\\"UNDEFINED\\\",\\r\\n\\tparameter SLEW = \\\"UNDEFINED\\\",\\r\\n\\tparameter [0:0] PULLUP = 1'bx,\\r\\n\\tparameter [0:0] PULLDOWN = 1'bx,\\r\\n\\tparameter [0:0] KEEPER = 1'bx,\\r\\n\\t// IOSEL\\r\\n\\tparameter [3:0] DELAY_OBF = 1'bx,\\r\\n\\tparameter [0:0] FF_OBF = 1'bx\\r\\n)(\\r\\n\\tinput  A, T,\\r\\n\\t(* iopad_external_pin *)\\r\\n\\toutput O\\r\\n);\\r\\n\\tassign O = T ? 1'bz : A;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_IOBUF #(\\r\\n\\tparameter PIN_NAME = \\\"UNPLACED\\\",\\r\\n\\tparameter V_IO = \\\"UNDEFINED\\\",\\r\\n\\tparameter DRIVE = \\\"UNDEFINED\\\",\\r\\n\\tparameter SLEW = \\\"UNDEFINED\\\",\\r\\n\\tparameter [0:0] PULLUP = 1'bx,\\r\\n\\tparameter [0:0] PULLDOWN = 1'bx,\\r\\n\\tparameter [0:0] KEEPER = 1'bx,\\r\\n\\tparameter [0:0] SCHMITT_TRIGGER = 1'bx,\\r\\n\\t// IOSEL\\r\\n\\tparameter [3:0] DELAY_IBF = 1'bx,\\r\\n\\tparameter [3:0] DELAY_OBF = 1'bx,\\r\\n\\tparameter [0:0] FF_IBF = 1'bx,\\r\\n\\tparameter [0:0] FF_OBF = 1'bx\\r\\n)(\\r\\n\\tinput  A, T,\\r\\n\\toutput Y,\\r\\n\\t(* iopad_external_pin *)\\r\\n\\tinout  IO\\r\\n);\\r\\n\\tassign IO = T ? 1'bz : A;\\r\\n\\tassign Y = IO;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_LVDS_IBUF #(\\r\\n\\tparameter PIN_NAME_P = \\\"UNPLACED\\\",\\r\\n\\tparameter PIN_NAME_N = \\\"UNPLACED\\\",\\r\\n\\tparameter V_IO = \\\"UNDEFINED\\\",\\r\\n\\tparameter [0:0] LVDS_RTERM = 1'bx,\\r\\n\\t// IOSEL\\r\\n\\tparameter [3:0] DELAY_IBF = 1'bx,\\r\\n\\tparameter [0:0] FF_IBF = 1'bx\\r\\n)(\\r\\n\\t(* iopad_external_pin *)\\r\\n\\tinput  I_P, I_N,\\r\\n\\toutput Y\\r\\n);\\r\\n\\tassign Y = I_P;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_LVDS_OBUF #(\\r\\n\\tparameter PIN_NAME_P = \\\"UNPLACED\\\",\\r\\n\\tparameter PIN_NAME_N = \\\"UNPLACED\\\",\\r\\n\\tparameter V_IO = \\\"UNDEFINED\\\",\\r\\n\\tparameter [0:0] LVDS_BOOST = 1'bx,\\r\\n\\t// IOSEL\\r\\n\\tparameter [3:0] DELAY_OBF = 1'bx,\\r\\n\\tparameter [0:0] FF_OBF = 1'bx\\r\\n)(\\r\\n\\tinput  A,\\r\\n\\t(* iopad_external_pin *)\\r\\n\\toutput O_P, O_N\\r\\n);\\r\\n\\tassign O_P = A;\\r\\n\\tassign O_N = ~A;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_LVDS_TOBUF #(\\r\\n\\tparameter PIN_NAME_P = \\\"UNPLACED\\\",\\r\\n\\tparameter PIN_NAME_N = \\\"UNPLACED\\\",\\r\\n\\tparameter V_IO = \\\"UNDEFINED\\\",\\r\\n\\tparameter [0:0] LVDS_BOOST = 1'bx,\\r\\n\\t// IOSEL\\r\\n\\tparameter [3:0] DELAY_OBF = 1'bx,\\r\\n\\tparameter [0:0] FF_OBF = 1'bx\\r\\n)(\\r\\n\\tinput  A, T,\\r\\n\\t(* iopad_external_pin *)\\r\\n\\toutput O_P, O_N\\r\\n);\\r\\n\\tassign O_P = T ? 1'bz :  A;\\r\\n\\tassign O_N = T ? 1'bz : ~A;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_LVDS_IOBUF #(\\r\\n\\tparameter PIN_NAME_P = \\\"UNPLACED\\\",\\r\\n\\tparameter PIN_NAME_N = \\\"UNPLACED\\\",\\r\\n\\tparameter V_IO = \\\"UNDEFINED\\\",\\r\\n\\tparameter [0:0] LVDS_RTERM = 1'bx,\\r\\n\\tparameter [0:0] LVDS_BOOST = 1'bx,\\r\\n\\t// IOSEL\\r\\n\\tparameter [3:0] DELAY_IBF = 1'bx,\\r\\n\\tparameter [3:0] DELAY_OBF = 1'bx,\\r\\n\\tparameter [0:0] FF_IBF = 1'bx,\\r\\n\\tparameter [0:0] FF_OBF = 1'bx\\r\\n)(\\r\\n\\tinput  A, T,\\r\\n\\t(* iopad_external_pin *)\\r\\n\\tinout  IO_P, IO_N,\\r\\n\\toutput Y\\r\\n);\\r\\n\\tassign IO_P = T ? 1'bz :  A;\\r\\n\\tassign IO_N = T ? 1'bz : ~A;\\r\\n\\tassign Y = IO_P;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_IDDR #(\\r\\n\\tparameter [0:0] CLK_INV = 1'b0\\r\\n)(\\r\\n\\tinput D,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput CLK,\\r\\n\\toutput reg Q0, Q1\\r\\n);\\r\\n\\twire clk;\\r\\n\\tassign clk = (CLK_INV) ? ~CLK : CLK;\\r\\n\\r\\n\\talways @(posedge clk)\\r\\n\\tbegin\\r\\n\\t\\tQ0 <= D;\\r\\n\\tend\\r\\n\\r\\n\\talways @(negedge clk)\\r\\n\\tbegin\\r\\n\\t\\tQ1 <= D;\\r\\n\\tend\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_ODDR #(\\r\\n\\tparameter [0:0] CLK_INV = 1'b0\\r\\n)(\\r\\n\\tinput D0,\\r\\n\\tinput D1,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput CLK,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput DDR,\\r\\n\\toutput Q\\r\\n);\\r\\n\\twire clk;\\r\\n\\tassign clk = (CLK_INV) ? ~CLK : CLK;\\r\\n\\r\\n\\treg q0, q1;\\r\\n\\tassign Q = (DDR) ? q0 : q1;\\r\\n\\r\\n\\talways @(posedge clk)\\r\\n\\tbegin\\r\\n\\t\\tq0 <= D0;\\r\\n\\tend\\r\\n\\r\\n\\talways @(negedge clk)\\r\\n\\tbegin\\r\\n\\t\\tq1 <= D1;\\r\\n\\tend\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_DFF #(\\r\\n\\tparameter [0:0] CLK_INV = 1'b0,\\r\\n\\tparameter [0:0] EN_INV  = 1'b0,\\r\\n\\tparameter [0:0] SR_INV  = 1'b0,\\r\\n\\tparameter [0:0] SR_VAL  = 1'b0,\\r\\n\\tparameter [0:0] INIT    = 1'bx\\r\\n)(\\r\\n\\tinput D,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput CLK,\\r\\n\\tinput EN,\\r\\n\\tinput SR,\\r\\n\\toutput reg Q\\r\\n);\\r\\n\\twire clk, en, sr;\\r\\n\\tassign clk = (CLK_INV) ? ~CLK : CLK;\\r\\n\\tassign en  = (EN_INV)  ?  ~EN :  EN;\\r\\n\\tassign sr  = (SR_INV)  ?  ~SR :  SR;\\r\\n\\r\\n\\tinitial Q = INIT;\\r\\n\\r\\n\\talways @(posedge clk or posedge sr)\\r\\n\\tbegin\\r\\n\\t\\tif (sr) begin\\r\\n\\t\\t\\tQ <= SR_VAL;\\r\\n\\t\\tend\\r\\n\\t\\telse if (en) begin\\r\\n\\t\\t\\tQ <= D;\\r\\n\\t\\tend\\r\\n\\tend\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_DLT #(\\r\\n\\tparameter [0:0] G_INV  = 1'b0,\\r\\n\\tparameter [0:0] SR_INV = 1'b0,\\r\\n\\tparameter [0:0] SR_VAL = 1'b0,\\r\\n\\tparameter [0:0] INIT   = 1'bx\\r\\n)(\\r\\n\\tinput D,\\r\\n\\tinput G,\\r\\n\\tinput SR,\\r\\n\\toutput reg Q\\r\\n);\\r\\n\\twire en, sr;\\r\\n\\tassign en  = (G_INV) ? ~G : G;\\r\\n\\tassign sr  = (SR_INV) ? ~SR : SR;\\r\\n\\r\\n\\tinitial Q = INIT;\\r\\n\\r\\n\\talways @(*)\\r\\n\\tbegin\\r\\n\\t\\tif (sr) begin\\r\\n\\t\\t\\tQ <= SR_VAL;\\r\\n\\t\\tend\\r\\n\\t\\telse if (en) begin\\r\\n\\t\\t\\tQ <= D;\\r\\n\\t\\tend\\r\\n\\tend\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_LUT1 (\\r\\n\\toutput O,\\r\\n\\tinput  I0\\r\\n);\\r\\n\\tparameter [1:0] INIT = 0;\\r\\n\\r\\n\\tassign O = I0 ? INIT[1] : INIT[0];\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_LUT2 (\\r\\n\\toutput O,\\r\\n\\tinput  I0, I1\\r\\n);\\r\\n\\tparameter [3:0] INIT = 0;\\r\\n\\r\\n\\twire [1:0] s1 = I1 ? INIT[3:2] : INIT[1:0];\\r\\n\\tassign O = I0 ? s1[1] : s1[0];\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_LUT3 (\\r\\n\\toutput O,\\r\\n\\tinput  I0, I1, I2\\r\\n);\\r\\n\\tparameter [7:0] INIT = 0;\\r\\n\\r\\n\\twire [3:0] s2 = I2 ? INIT[7:4] : INIT[3:0];\\r\\n\\twire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];\\r\\n\\tassign O = I0 ? s1[1] : s1[0];\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_LUT4 (\\r\\n\\toutput O,\\r\\n\\tinput  I0, I1, I2, I3\\r\\n);\\r\\n\\tparameter [15:0] INIT = 0;\\r\\n\\r\\n\\twire [7:0] s3 = I3 ? INIT[15:8] : INIT[7:0];\\r\\n\\twire [3:0] s2 = I2 ? s3[7:4] : s3[3:0];\\r\\n\\twire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];\\r\\n\\tassign O = I0 ? s1[1] : s1[0];\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_MX2 (\\r\\n\\tinput  D0, D1,\\r\\n\\tinput  S0,\\r\\n\\toutput Y\\r\\n);\\r\\n\\tassign Y = S0 ? D1 : D0;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_MX4 (\\r\\n\\tinput  D0, D1, D2, D3,\\r\\n\\tinput  S0, S1,\\r\\n\\toutput Y\\r\\n);\\r\\n\\tassign Y = S1 ? (S0 ? D3 : D2) :\\r\\n\\t\\t\\t\\t\\t(S0 ? D1 : D0);\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_MX8 (\\r\\n\\tinput  D0, D1, D2, D3,\\r\\n\\tinput  D4, D5, D6, D7,\\r\\n\\tinput  S0, S1, S2,\\r\\n\\toutput Y\\r\\n);\\r\\n\\tassign Y = S2 ? (S1 ? (S0 ? D7 : D6) :\\r\\n\\t\\t\\t\\t\\t\\t  (S0 ? D5 : D4)) :\\r\\n\\t\\t\\t\\t\\t(S1 ? (S0 ? D3 : D2) :\\r\\n\\t\\t\\t\\t\\t\\t  (S0 ? D1 : D0));\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_ADDF (\\r\\n\\tinput  A, B, CI,\\r\\n\\toutput CO, S\\r\\n);\\r\\n\\tassign {CO, S} = A + B + CI;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_MULT #(\\r\\n\\tparameter A_WIDTH = 0,\\r\\n\\tparameter B_WIDTH = 0,\\r\\n\\tparameter P_WIDTH = 0\\r\\n)(\\r\\n\\tinput signed [A_WIDTH-1:0] A,\\r\\n\\tinput signed [B_WIDTH-1:0] B,\\r\\n\\toutput reg signed [P_WIDTH-1:0] P\\r\\n);\\r\\n\\talways @(*)\\r\\n\\tbegin\\r\\n\\t\\tP <= A * B;\\r\\n\\tend\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_BUFG (\\r\\n\\tinput  I,\\r\\n\\t(* clkbuf_driver *)\\r\\n\\toutput O\\r\\n);\\r\\n\\tassign O = I;\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_BRAM_20K (\\r\\n\\toutput [19:0] A_DO,\\r\\n\\toutput [19:0] B_DO,\\r\\n\\toutput ECC_1B_ERR,\\r\\n\\toutput ECC_2B_ERR,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput A_CLK,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput B_CLK,\\r\\n\\tinput A_EN,\\r\\n\\tinput B_EN,\\r\\n\\tinput A_WE,\\r\\n\\tinput B_WE,\\r\\n\\tinput [15:0] A_ADDR,\\r\\n\\tinput [15:0] B_ADDR,\\r\\n\\tinput [19:0] A_DI,\\r\\n\\tinput [19:0] B_DI,\\r\\n\\tinput [19:0] A_BM,\\r\\n\\tinput [19:0] B_BM\\r\\n);\\r\\n\\t// Location format: D(0..N-1)(0..N-1)X(0..3)Y(0..7)Z(0..1) or UNPLACED\\r\\n\\tparameter LOC = \\\"UNPLACED\\\";\\r\\n\\r\\n\\t// Port Widths\\r\\n\\tparameter A_RD_WIDTH = 0;\\r\\n\\tparameter B_RD_WIDTH = 0;\\r\\n\\tparameter A_WR_WIDTH = 0;\\r\\n\\tparameter B_WR_WIDTH = 0;\\r\\n\\r\\n\\t// RAM and Write Modes\\r\\n\\tparameter RAM_MODE = \\\"SDP\\\";\\r\\n\\tparameter A_WR_MODE = \\\"NO_CHANGE\\\";\\r\\n\\tparameter B_WR_MODE = \\\"NO_CHANGE\\\";\\r\\n\\r\\n\\t// Inverting Control Pins\\r\\n\\tparameter A_CLK_INV = 1'b0;\\r\\n\\tparameter B_CLK_INV = 1'b0;\\r\\n\\tparameter A_EN_INV = 1'b0;\\r\\n\\tparameter B_EN_INV = 1'b0;\\r\\n\\tparameter A_WE_INV = 1'b0;\\r\\n\\tparameter B_WE_INV = 1'b0;\\r\\n\\r\\n\\t// Output Register\\r\\n\\tparameter A_DO_REG = 1'b0;\\r\\n\\tparameter B_DO_REG = 1'b0;\\r\\n\\r\\n\\t// Error Checking and Correction\\r\\n\\tparameter ECC_EN = 1'b0;\\r\\n\\r\\n\\t// RAM Contents\\r\\n\\tparameter INIT_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n\\tlocalparam WIDTH_MODE_A = (A_RD_WIDTH > A_WR_WIDTH) ? A_RD_WIDTH : A_WR_WIDTH;\\r\\n\\tlocalparam WIDTH_MODE_B = (B_RD_WIDTH > B_WR_WIDTH) ? B_RD_WIDTH : B_WR_WIDTH;\\r\\n\\r\\n\\tinteger i, k;\\r\\n\\r\\n\\t// 512 x 40 bit\\r\\n\\treg [20479:0] memory = 20480'b0;\\r\\n\\r\\n\\tinitial begin\\r\\n\\t\\t// Check parameters\\r\\n\\t\\tif ((RAM_MODE != \\\"SDP\\\") && (RAM_MODE != \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal RAM MODE %d.\\\", RAM_MODE);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((A_WR_MODE != \\\"WRITE_THROUGH\\\") && (A_WR_MODE != \\\"NO_CHANGE\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal RAM MODE %d.\\\", RAM_MODE);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((RAM_MODE == \\\"SDP\\\") && (A_WR_MODE == \\\"WRITE_THROUGH\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: %s is not supported in %s mode.\\\", A_WR_MODE, RAM_MODE);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif (ECC_EN != 1'b0) begin\\r\\n\\t\\t\\t$display(\\\"WARNING: ECC feature not supported in simulation.\\\");\\r\\n\\t\\tend\\r\\n\\t\\tif ((ECC_EN == 1'b1) && (RAM_MODE != \\\"SDP\\\") && (WIDTH_MODE_A != 40)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal ECC Port configuration. Must be SDP 40 bit, but is %s %d.\\\", RAM_MODE, WIDTH_MODE_A);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((WIDTH_MODE_A == 40) && (RAM_MODE == \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Port A width of 40 bits is only supported in SDP mode.\\\");\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((WIDTH_MODE_B == 40) && (RAM_MODE == \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Port B width of 40 bits is only supported in SDP mode.\\\");\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((WIDTH_MODE_A != 40) && (WIDTH_MODE_A != 20) && (WIDTH_MODE_A != 10) &&\\r\\n\\t\\t\\t(WIDTH_MODE_A != 5)  && (WIDTH_MODE_A != 2)  && (WIDTH_MODE_A != 1) && (WIDTH_MODE_A != 0)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal %s Port A width configuration %d.\\\", RAM_MODE, WIDTH_MODE_A);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((WIDTH_MODE_B != 40) && (WIDTH_MODE_B != 20) && (WIDTH_MODE_B != 10) &&\\r\\n\\t\\t\\t(WIDTH_MODE_B != 5)  && (WIDTH_MODE_B != 2)  && (WIDTH_MODE_B != 1) && (WIDTH_MODE_B != 0)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal %s Port B width configuration %d.\\\", RAM_MODE, WIDTH_MODE_B);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\t// RAM initialization\\r\\n\\t\\tmemory[320*0+319:320*0]   = INIT_00;\\r\\n\\t\\tmemory[320*1+319:320*1]   = INIT_01;\\r\\n\\t\\tmemory[320*2+319:320*2]   = INIT_02;\\r\\n\\t\\tmemory[320*3+319:320*3]   = INIT_03;\\r\\n\\t\\tmemory[320*4+319:320*4]   = INIT_04;\\r\\n\\t\\tmemory[320*5+319:320*5]   = INIT_05;\\r\\n\\t\\tmemory[320*6+319:320*6]   = INIT_06;\\r\\n\\t\\tmemory[320*7+319:320*7]   = INIT_07;\\r\\n\\t\\tmemory[320*8+319:320*8]   = INIT_08;\\r\\n\\t\\tmemory[320*9+319:320*9]   = INIT_09;\\r\\n\\t\\tmemory[320*10+319:320*10] = INIT_0A;\\r\\n\\t\\tmemory[320*11+319:320*11] = INIT_0B;\\r\\n\\t\\tmemory[320*12+319:320*12] = INIT_0C;\\r\\n\\t\\tmemory[320*13+319:320*13] = INIT_0D;\\r\\n\\t\\tmemory[320*14+319:320*14] = INIT_0E;\\r\\n\\t\\tmemory[320*15+319:320*15] = INIT_0F;\\r\\n\\t\\tmemory[320*16+319:320*16] = INIT_10;\\r\\n\\t\\tmemory[320*17+319:320*17] = INIT_11;\\r\\n\\t\\tmemory[320*18+319:320*18] = INIT_12;\\r\\n\\t\\tmemory[320*19+319:320*19] = INIT_13;\\r\\n\\t\\tmemory[320*20+319:320*20] = INIT_14;\\r\\n\\t\\tmemory[320*21+319:320*21] = INIT_15;\\r\\n\\t\\tmemory[320*22+319:320*22] = INIT_16;\\r\\n\\t\\tmemory[320*23+319:320*23] = INIT_17;\\r\\n\\t\\tmemory[320*24+319:320*24] = INIT_18;\\r\\n\\t\\tmemory[320*25+319:320*25] = INIT_19;\\r\\n\\t\\tmemory[320*26+319:320*26] = INIT_1A;\\r\\n\\t\\tmemory[320*27+319:320*27] = INIT_1B;\\r\\n\\t\\tmemory[320*28+319:320*28] = INIT_1C;\\r\\n\\t\\tmemory[320*29+319:320*29] = INIT_1D;\\r\\n\\t\\tmemory[320*30+319:320*30] = INIT_1E;\\r\\n\\t\\tmemory[320*31+319:320*31] = INIT_1F;\\r\\n\\t\\tmemory[320*32+319:320*32] = INIT_20;\\r\\n\\t\\tmemory[320*33+319:320*33] = INIT_21;\\r\\n\\t\\tmemory[320*34+319:320*34] = INIT_22;\\r\\n\\t\\tmemory[320*35+319:320*35] = INIT_23;\\r\\n\\t\\tmemory[320*36+319:320*36] = INIT_24;\\r\\n\\t\\tmemory[320*37+319:320*37] = INIT_25;\\r\\n\\t\\tmemory[320*38+319:320*38] = INIT_26;\\r\\n\\t\\tmemory[320*39+319:320*39] = INIT_27;\\r\\n\\t\\tmemory[320*40+319:320*40] = INIT_28;\\r\\n\\t\\tmemory[320*41+319:320*41] = INIT_29;\\r\\n\\t\\tmemory[320*42+319:320*42] = INIT_2A;\\r\\n\\t\\tmemory[320*43+319:320*43] = INIT_2B;\\r\\n\\t\\tmemory[320*44+319:320*44] = INIT_2C;\\r\\n\\t\\tmemory[320*45+319:320*45] = INIT_2D;\\r\\n\\t\\tmemory[320*46+319:320*46] = INIT_2E;\\r\\n\\t\\tmemory[320*47+319:320*47] = INIT_2F;\\r\\n\\t\\tmemory[320*48+319:320*48] = INIT_30;\\r\\n\\t\\tmemory[320*49+319:320*49] = INIT_31;\\r\\n\\t\\tmemory[320*50+319:320*50] = INIT_32;\\r\\n\\t\\tmemory[320*51+319:320*51] = INIT_33;\\r\\n\\t\\tmemory[320*52+319:320*52] = INIT_34;\\r\\n\\t\\tmemory[320*53+319:320*53] = INIT_35;\\r\\n\\t\\tmemory[320*54+319:320*54] = INIT_36;\\r\\n\\t\\tmemory[320*55+319:320*55] = INIT_37;\\r\\n\\t\\tmemory[320*56+319:320*56] = INIT_38;\\r\\n\\t\\tmemory[320*57+319:320*57] = INIT_39;\\r\\n\\t\\tmemory[320*58+319:320*58] = INIT_3A;\\r\\n\\t\\tmemory[320*59+319:320*59] = INIT_3B;\\r\\n\\t\\tmemory[320*60+319:320*60] = INIT_3C;\\r\\n\\t\\tmemory[320*61+319:320*61] = INIT_3D;\\r\\n\\t\\tmemory[320*62+319:320*62] = INIT_3E;\\r\\n\\t\\tmemory[320*63+319:320*63] = INIT_3F;\\r\\n\\tend\\r\\n\\r\\n\\t// Signal inversion\\r\\n\\twire clka = A_CLK_INV ^ A_CLK;\\r\\n\\twire clkb = B_CLK_INV ^ B_CLK;\\r\\n\\twire ena  = A_EN_INV ^ A_EN;\\r\\n\\twire enb  = B_EN_INV ^ B_EN;\\r\\n\\twire wea  = A_WE_INV ^ A_WE;\\r\\n\\twire web  = B_WE_INV ^ B_WE;\\r\\n\\r\\n\\t// Internal signals\\r\\n\\twire [15:0] addra;\\r\\n\\twire [15:0] addrb;\\r\\n\\treg  [19:0] A_DO_out = 0, A_DO_reg = 0;\\r\\n\\treg  [19:0] B_DO_out = 0, B_DO_reg = 0;\\r\\n\\r\\n\\tgenerate\\r\\n\\t\\tif (RAM_MODE == \\\"SDP\\\") begin\\r\\n\\t\\t\\t// Port A (write)\\r\\n\\t\\t\\tif (A_WR_WIDTH == 40) begin\\r\\n\\t\\t\\t\\tassign addra = A_ADDR[15:7]*40;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// Port B (read)\\r\\n\\t\\t\\tif (B_RD_WIDTH == 40) begin\\r\\n\\t\\t\\t\\tassign addrb = B_ADDR[15:7]*40;\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\t\\telse if (RAM_MODE == \\\"TDP\\\") begin\\r\\n\\t\\t\\t// Port A\\r\\n\\t\\t\\tif (WIDTH_MODE_A <= 1) begin\\r\\n\\t\\t\\t\\twire [15:0] tmpa = {2'b0, A_ADDR[15:7], A_ADDR[5:1]};\\r\\n\\t\\t\\t\\tassign addra = tmpa + (tmpa/4);\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_A <= 2) begin\\r\\n\\t\\t\\t\\twire [15:0] tmpa = {3'b0, A_ADDR[15:7], A_ADDR[5:2]};\\r\\n\\t\\t\\t\\tassign addra = tmpa*2 + (tmpa/2);\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_A <= 5) begin\\r\\n\\t\\t\\t\\tassign addra = {4'b0, A_ADDR[15:7], A_ADDR[5:3]}*5;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_A <= 10) begin\\r\\n\\t\\t\\t\\tassign addra = {5'b0, A_ADDR[15:7], A_ADDR[5:4]}*10;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_A <= 20) begin\\r\\n\\t\\t\\t\\tassign addra = {6'b0, A_ADDR[15:7], A_ADDR[5]}*20;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// Port B\\r\\n\\t\\t\\tif (WIDTH_MODE_B <= 1) begin\\r\\n\\t\\t\\t\\twire [15:0] tmpb = {2'b0, B_ADDR[15:7], B_ADDR[5:1]};\\r\\n\\t\\t\\t\\tassign addrb = tmpb + (tmpb/4);\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_B <= 2) begin\\r\\n\\t\\t\\t\\twire [15:0] tmpb = {3'b0, B_ADDR[15:7], B_ADDR[5:2]};\\r\\n\\t\\t\\t\\tassign addrb = tmpb*2 + (tmpb/2);\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_B <= 5) begin\\r\\n\\t\\t\\t\\tassign addrb = {4'b0, B_ADDR[15:7], B_ADDR[5:3]}*5;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_B <= 10) begin\\r\\n\\t\\t\\t\\tassign addrb = {5'b0, B_ADDR[15:7], B_ADDR[5:4]}*10;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_B <= 20) begin\\r\\n\\t\\t\\t\\tassign addrb = {6'b0, B_ADDR[15:7], B_ADDR[5]}*20;\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\n\\r\\n\\tgenerate\\r\\n\\t\\tif (RAM_MODE == \\\"SDP\\\") begin\\r\\n\\t\\t\\t// SDP write port\\r\\n\\t\\t\\talways @(posedge clka)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (k=0; k < A_WR_WIDTH; k=k+1) begin\\r\\n\\t\\t\\t\\t\\tif (k < 20) begin\\r\\n\\t\\t\\t\\t\\t\\tif (ena && wea && A_BM[k]) memory[addra+k] <= A_DI[k];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse begin // use both ports\\r\\n\\t\\t\\t\\t\\t\\tif (ena && wea && B_BM[k-20]) memory[addra+k] <= B_DI[k-20];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// SDP read port\\r\\n\\t\\t\\talways @(posedge clkb)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (k=0; k < B_RD_WIDTH; k=k+1) begin\\r\\n\\t\\t\\t\\t\\tif (k < 20) begin\\r\\n\\t\\t\\t\\t\\t\\tif (enb) A_DO_out[k] <= memory[addrb+k];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse begin // use both ports\\r\\n\\t\\t\\t\\t\\t\\tif (enb) B_DO_out[k-20] <= memory[addrb+k];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\t\\telse if (RAM_MODE == \\\"TDP\\\") begin\\r\\n\\t\\t\\t// TDP port A\\r\\n\\t\\t\\talways @(posedge clka)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (i=0; i < WIDTH_MODE_A; i=i+1) begin\\r\\n\\t\\t\\t\\t\\tif (ena && wea && A_BM[i]) memory[addra+i] <= A_DI[i];\\r\\n\\r\\n\\t\\t\\t\\t\\tif (A_WR_MODE == \\\"NO_CHANGE\\\") begin\\r\\n\\t\\t\\t\\t\\t\\tif (ena && !wea) A_DO_out[i] <= memory[addra+i];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse if (A_WR_MODE == \\\"WRITE_THROUGH\\\") begin\\r\\n\\t\\t\\t\\t\\t\\tif (ena) begin\\r\\n\\t\\t\\t\\t\\t\\t\\tif (wea && A_BM[i]) begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tA_DO_out[i] <= A_DI[i];\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\t\\telse begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tA_DO_out[i] <= memory[addra+i];\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// TDP port B\\r\\n\\t\\t\\talways @(posedge clkb)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (i=0; i < WIDTH_MODE_B; i=i+1) begin\\r\\n\\t\\t\\t\\t\\tif (enb && web && B_BM[i]) memory[addrb+i] <= B_DI[i];\\r\\n\\r\\n\\t\\t\\t\\t\\tif (B_WR_MODE == \\\"NO_CHANGE\\\") begin\\r\\n\\t\\t\\t\\t\\t\\tif (enb && !web) B_DO_out[i] <= memory[addrb+i];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse if (B_WR_MODE == \\\"WRITE_THROUGH\\\") begin\\r\\n\\t\\t\\t\\t\\t\\tif (enb) begin\\r\\n\\t\\t\\t\\t\\t\\t\\tif (web && B_BM[i]) begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tB_DO_out[i] <= B_DI[i];\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\t\\telse begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tB_DO_out[i] <= memory[addrb+i];\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\n\\r\\n\\t// Optional output register\\r\\n\\tgenerate\\r\\n\\t\\tif (A_DO_REG) begin\\r\\n\\t\\t\\talways @(posedge clka) begin\\r\\n\\t\\t\\t\\tA_DO_reg <= A_DO_out;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\tassign A_DO = A_DO_reg;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\tassign A_DO = A_DO_out;\\r\\n\\t\\tend\\r\\n\\t\\tif (B_DO_REG) begin\\r\\n\\t\\t\\talways @(posedge clkb) begin\\r\\n\\t\\t\\t\\tB_DO_reg <= B_DO_out;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\tassign B_DO = B_DO_reg;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\tassign B_DO = B_DO_out;\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_BRAM_40K (\\r\\n\\toutput [39:0] A_DO,\\r\\n\\toutput [39:0] B_DO,\\r\\n\\toutput A_ECC_1B_ERR,\\r\\n\\toutput B_ECC_1B_ERR,\\r\\n\\toutput A_ECC_2B_ERR,\\r\\n\\toutput B_ECC_2B_ERR,\\r\\n\\toutput reg A_CO = 0,\\r\\n\\toutput reg B_CO = 0,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput A_CLK,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput B_CLK,\\r\\n\\tinput A_EN,\\r\\n\\tinput B_EN,\\r\\n\\tinput A_WE,\\r\\n\\tinput B_WE,\\r\\n\\tinput [15:0] A_ADDR,\\r\\n\\tinput [15:0] B_ADDR,\\r\\n\\tinput [39:0] A_DI,\\r\\n\\tinput [39:0] B_DI,\\r\\n\\tinput [39:0] A_BM,\\r\\n\\tinput [39:0] B_BM,\\r\\n\\tinput A_CI,\\r\\n\\tinput B_CI\\r\\n);\\r\\n\\t// Location format: D(0..N-1)X(0..3)Y(0..7) or UNPLACED\\r\\n\\tparameter LOC = \\\"UNPLACED\\\";\\r\\n\\tparameter CAS = \\\"NONE\\\"; // NONE, UPPER, LOWER\\r\\n\\r\\n\\t// Port Widths\\r\\n\\tparameter A_RD_WIDTH = 0;\\r\\n\\tparameter B_RD_WIDTH = 0;\\r\\n\\tparameter A_WR_WIDTH = 0;\\r\\n\\tparameter B_WR_WIDTH = 0;\\r\\n\\r\\n\\t// RAM and Write Modes\\r\\n\\tparameter RAM_MODE = \\\"SDP\\\";\\r\\n\\tparameter A_WR_MODE = \\\"NO_CHANGE\\\";\\r\\n\\tparameter B_WR_MODE = \\\"NO_CHANGE\\\";\\r\\n\\r\\n\\t// Inverting Control Pins\\r\\n\\tparameter A_CLK_INV = 1'b0;\\r\\n\\tparameter B_CLK_INV = 1'b0;\\r\\n\\tparameter A_EN_INV = 1'b0;\\r\\n\\tparameter B_EN_INV = 1'b0;\\r\\n\\tparameter A_WE_INV = 1'b0;\\r\\n\\tparameter B_WE_INV = 1'b0;\\r\\n\\r\\n\\t// Output Register\\r\\n\\tparameter A_DO_REG = 1'b0;\\r\\n\\tparameter B_DO_REG = 1'b0;\\r\\n\\r\\n\\t// Error Checking and Correction\\r\\n\\tparameter A_ECC_EN  = 1'b0;\\r\\n\\tparameter B_ECC_EN  = 1'b0;\\r\\n\\r\\n\\tparameter INIT_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_40 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_41 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_42 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_43 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_44 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_45 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_46 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_47 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_48 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_49 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_4A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_4B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_4C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_4D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_4E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_4F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_50 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_51 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_52 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_53 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_54 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_55 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_56 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_57 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_58 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_59 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_5A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_5B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_5C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_5D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_5E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_5F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_60 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_61 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_62 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_63 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_64 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_65 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_66 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_67 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_68 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_69 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_6A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_6B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_6C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_6D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_6E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_6F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_70 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_71 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_72 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_73 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_74 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_75 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_76 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_77 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_78 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_79 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_7A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_7B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_7C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_7D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_7E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\tparameter INIT_7F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n\\tlocalparam WIDTH_MODE_A = (A_RD_WIDTH > A_WR_WIDTH) ? A_RD_WIDTH : A_WR_WIDTH;\\r\\n\\tlocalparam WIDTH_MODE_B = (B_RD_WIDTH > B_WR_WIDTH) ? B_RD_WIDTH : B_WR_WIDTH;\\r\\n\\r\\n\\tinteger i, k;\\r\\n\\r\\n\\t// 512 x 80 bit\\r\\n\\treg [40959:0] memory = 40960'b0;\\r\\n\\r\\n\\tinitial begin\\r\\n\\t\\t// Check parameters\\r\\n\\t\\tif ((RAM_MODE != \\\"SDP\\\") && (RAM_MODE != \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal RAM MODE %d.\\\", RAM_MODE);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((A_WR_MODE != \\\"WRITE_THROUGH\\\") && (A_WR_MODE != \\\"NO_CHANGE\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal RAM MODE %d.\\\", RAM_MODE);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((RAM_MODE == \\\"SDP\\\") && (A_WR_MODE == \\\"WRITE_THROUGH\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: %s is not supported in %s mode.\\\", A_WR_MODE, RAM_MODE);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((A_ECC_EN != 1'b0) || (B_ECC_EN != 1'b0)) begin\\r\\n\\t\\t\\t$display(\\\"WARNING: ECC feature not supported in simulation.\\\");\\r\\n\\t\\tend\\r\\n\\t\\tif ((A_ECC_EN == 1'b1) && (RAM_MODE != \\\"SDP\\\") && (WIDTH_MODE_A != 40)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal ECC Port A configuration. Must be SDP 40 bit, but is %s %d.\\\", RAM_MODE, WIDTH_MODE_A);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((WIDTH_MODE_A == 80) && (RAM_MODE == \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Port A width of 80 bits is only supported in SDP mode.\\\");\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((WIDTH_MODE_B == 80) && (RAM_MODE == \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Port B width of 80 bits is only supported in SDP mode.\\\");\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((WIDTH_MODE_A != 80) && (WIDTH_MODE_A != 40) && (WIDTH_MODE_A != 20) && (WIDTH_MODE_A != 10) &&\\r\\n\\t\\t\\t(WIDTH_MODE_A != 5)  && (WIDTH_MODE_A != 2)  && (WIDTH_MODE_A != 1) && (WIDTH_MODE_A != 0)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal %s Port A width configuration %d.\\\", RAM_MODE, WIDTH_MODE_A);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((WIDTH_MODE_B != 80) && (WIDTH_MODE_B != 40) && (WIDTH_MODE_B != 20) && (WIDTH_MODE_B != 10) &&\\r\\n\\t\\t\\t(WIDTH_MODE_B != 5)  && (WIDTH_MODE_B != 2)  && (WIDTH_MODE_B != 1) && (WIDTH_MODE_B != 0)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal %s Port B width configuration %d.\\\", RAM_MODE, WIDTH_MODE_B);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((CAS != \\\"NONE\\\") && ((WIDTH_MODE_A > 1) || (WIDTH_MODE_B > 1))) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Cascade feature only supported in 1 bit data width mode.\\\");\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((CAS != \\\"NONE\\\") && (RAM_MODE != \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Cascade feature only supported in TDP mode.\\\");\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\t// RAM initialization\\r\\n\\t\\tmemory[320*0+319:320*0]     = INIT_00;\\r\\n\\t\\tmemory[320*1+319:320*1]     = INIT_01;\\r\\n\\t\\tmemory[320*2+319:320*2]     = INIT_02;\\r\\n\\t\\tmemory[320*3+319:320*3]     = INIT_03;\\r\\n\\t\\tmemory[320*4+319:320*4]     = INIT_04;\\r\\n\\t\\tmemory[320*5+319:320*5]     = INIT_05;\\r\\n\\t\\tmemory[320*6+319:320*6]     = INIT_06;\\r\\n\\t\\tmemory[320*7+319:320*7]     = INIT_07;\\r\\n\\t\\tmemory[320*8+319:320*8]     = INIT_08;\\r\\n\\t\\tmemory[320*9+319:320*9]     = INIT_09;\\r\\n\\t\\tmemory[320*10+319:320*10]   = INIT_0A;\\r\\n\\t\\tmemory[320*11+319:320*11]   = INIT_0B;\\r\\n\\t\\tmemory[320*12+319:320*12]   = INIT_0C;\\r\\n\\t\\tmemory[320*13+319:320*13]   = INIT_0D;\\r\\n\\t\\tmemory[320*14+319:320*14]   = INIT_0E;\\r\\n\\t\\tmemory[320*15+319:320*15]   = INIT_0F;\\r\\n\\t\\tmemory[320*16+319:320*16]   = INIT_10;\\r\\n\\t\\tmemory[320*17+319:320*17]   = INIT_11;\\r\\n\\t\\tmemory[320*18+319:320*18]   = INIT_12;\\r\\n\\t\\tmemory[320*19+319:320*19]   = INIT_13;\\r\\n\\t\\tmemory[320*20+319:320*20]   = INIT_14;\\r\\n\\t\\tmemory[320*21+319:320*21]   = INIT_15;\\r\\n\\t\\tmemory[320*22+319:320*22]   = INIT_16;\\r\\n\\t\\tmemory[320*23+319:320*23]   = INIT_17;\\r\\n\\t\\tmemory[320*24+319:320*24]   = INIT_18;\\r\\n\\t\\tmemory[320*25+319:320*25]   = INIT_19;\\r\\n\\t\\tmemory[320*26+319:320*26]   = INIT_1A;\\r\\n\\t\\tmemory[320*27+319:320*27]   = INIT_1B;\\r\\n\\t\\tmemory[320*28+319:320*28]   = INIT_1C;\\r\\n\\t\\tmemory[320*29+319:320*29]   = INIT_1D;\\r\\n\\t\\tmemory[320*30+319:320*30]   = INIT_1E;\\r\\n\\t\\tmemory[320*31+319:320*31]   = INIT_1F;\\r\\n\\t\\tmemory[320*32+319:320*32]   = INIT_20;\\r\\n\\t\\tmemory[320*33+319:320*33]   = INIT_21;\\r\\n\\t\\tmemory[320*34+319:320*34]   = INIT_22;\\r\\n\\t\\tmemory[320*35+319:320*35]   = INIT_23;\\r\\n\\t\\tmemory[320*36+319:320*36]   = INIT_24;\\r\\n\\t\\tmemory[320*37+319:320*37]   = INIT_25;\\r\\n\\t\\tmemory[320*38+319:320*38]   = INIT_26;\\r\\n\\t\\tmemory[320*39+319:320*39]   = INIT_27;\\r\\n\\t\\tmemory[320*40+319:320*40]   = INIT_28;\\r\\n\\t\\tmemory[320*41+319:320*41]   = INIT_29;\\r\\n\\t\\tmemory[320*42+319:320*42]   = INIT_2A;\\r\\n\\t\\tmemory[320*43+319:320*43]   = INIT_2B;\\r\\n\\t\\tmemory[320*44+319:320*44]   = INIT_2C;\\r\\n\\t\\tmemory[320*45+319:320*45]   = INIT_2D;\\r\\n\\t\\tmemory[320*46+319:320*46]   = INIT_2E;\\r\\n\\t\\tmemory[320*47+319:320*47]   = INIT_2F;\\r\\n\\t\\tmemory[320*48+319:320*48]   = INIT_30;\\r\\n\\t\\tmemory[320*49+319:320*49]   = INIT_31;\\r\\n\\t\\tmemory[320*50+319:320*50]   = INIT_32;\\r\\n\\t\\tmemory[320*51+319:320*51]   = INIT_33;\\r\\n\\t\\tmemory[320*52+319:320*52]   = INIT_34;\\r\\n\\t\\tmemory[320*53+319:320*53]   = INIT_35;\\r\\n\\t\\tmemory[320*54+319:320*54]   = INIT_36;\\r\\n\\t\\tmemory[320*55+319:320*55]   = INIT_37;\\r\\n\\t\\tmemory[320*56+319:320*56]   = INIT_38;\\r\\n\\t\\tmemory[320*57+319:320*57]   = INIT_39;\\r\\n\\t\\tmemory[320*58+319:320*58]   = INIT_3A;\\r\\n\\t\\tmemory[320*59+319:320*59]   = INIT_3B;\\r\\n\\t\\tmemory[320*60+319:320*60]   = INIT_3C;\\r\\n\\t\\tmemory[320*61+319:320*61]   = INIT_3D;\\r\\n\\t\\tmemory[320*62+319:320*62]   = INIT_3E;\\r\\n\\t\\tmemory[320*63+319:320*63]   = INIT_3F;\\r\\n\\t\\tmemory[320*64+319:320*64]   = INIT_40;\\r\\n\\t\\tmemory[320*65+319:320*65]   = INIT_41;\\r\\n\\t\\tmemory[320*66+319:320*66]   = INIT_42;\\r\\n\\t\\tmemory[320*67+319:320*67]   = INIT_43;\\r\\n\\t\\tmemory[320*68+319:320*68]   = INIT_44;\\r\\n\\t\\tmemory[320*69+319:320*69]   = INIT_45;\\r\\n\\t\\tmemory[320*70+319:320*70]   = INIT_46;\\r\\n\\t\\tmemory[320*71+319:320*71]   = INIT_47;\\r\\n\\t\\tmemory[320*72+319:320*72]   = INIT_48;\\r\\n\\t\\tmemory[320*73+319:320*73]   = INIT_49;\\r\\n\\t\\tmemory[320*74+319:320*74]   = INIT_4A;\\r\\n\\t\\tmemory[320*75+319:320*75]   = INIT_4B;\\r\\n\\t\\tmemory[320*76+319:320*76]   = INIT_4C;\\r\\n\\t\\tmemory[320*77+319:320*77]   = INIT_4D;\\r\\n\\t\\tmemory[320*78+319:320*78]   = INIT_4E;\\r\\n\\t\\tmemory[320*79+319:320*79]   = INIT_4F;\\r\\n\\t\\tmemory[320*80+319:320*80]   = INIT_50;\\r\\n\\t\\tmemory[320*81+319:320*81]   = INIT_51;\\r\\n\\t\\tmemory[320*82+319:320*82]   = INIT_52;\\r\\n\\t\\tmemory[320*83+319:320*83]   = INIT_53;\\r\\n\\t\\tmemory[320*84+319:320*84]   = INIT_54;\\r\\n\\t\\tmemory[320*85+319:320*85]   = INIT_55;\\r\\n\\t\\tmemory[320*86+319:320*86]   = INIT_56;\\r\\n\\t\\tmemory[320*87+319:320*87]   = INIT_57;\\r\\n\\t\\tmemory[320*88+319:320*88]   = INIT_58;\\r\\n\\t\\tmemory[320*89+319:320*89]   = INIT_59;\\r\\n\\t\\tmemory[320*90+319:320*90]   = INIT_5A;\\r\\n\\t\\tmemory[320*91+319:320*91]   = INIT_5B;\\r\\n\\t\\tmemory[320*92+319:320*92]   = INIT_5C;\\r\\n\\t\\tmemory[320*93+319:320*93]   = INIT_5D;\\r\\n\\t\\tmemory[320*94+319:320*94]   = INIT_5E;\\r\\n\\t\\tmemory[320*95+319:320*95]   = INIT_5F;\\r\\n\\t\\tmemory[320*96+319:320*96]   = INIT_60;\\r\\n\\t\\tmemory[320*97+319:320*97]   = INIT_61;\\r\\n\\t\\tmemory[320*98+319:320*98]   = INIT_62;\\r\\n\\t\\tmemory[320*99+319:320*99]   = INIT_63;\\r\\n\\t\\tmemory[320*100+319:320*100] = INIT_64;\\r\\n\\t\\tmemory[320*101+319:320*101] = INIT_65;\\r\\n\\t\\tmemory[320*102+319:320*102] = INIT_66;\\r\\n\\t\\tmemory[320*103+319:320*103] = INIT_67;\\r\\n\\t\\tmemory[320*104+319:320*104] = INIT_68;\\r\\n\\t\\tmemory[320*105+319:320*105] = INIT_69;\\r\\n\\t\\tmemory[320*106+319:320*106] = INIT_6A;\\r\\n\\t\\tmemory[320*107+319:320*107] = INIT_6B;\\r\\n\\t\\tmemory[320*108+319:320*108] = INIT_6C;\\r\\n\\t\\tmemory[320*109+319:320*109] = INIT_6D;\\r\\n\\t\\tmemory[320*110+319:320*110] = INIT_6E;\\r\\n\\t\\tmemory[320*111+319:320*111] = INIT_6F;\\r\\n\\t\\tmemory[320*112+319:320*112] = INIT_70;\\r\\n\\t\\tmemory[320*113+319:320*113] = INIT_71;\\r\\n\\t\\tmemory[320*114+319:320*114] = INIT_72;\\r\\n\\t\\tmemory[320*115+319:320*115] = INIT_73;\\r\\n\\t\\tmemory[320*116+319:320*116] = INIT_74;\\r\\n\\t\\tmemory[320*117+319:320*117] = INIT_75;\\r\\n\\t\\tmemory[320*118+319:320*118] = INIT_76;\\r\\n\\t\\tmemory[320*119+319:320*119] = INIT_77;\\r\\n\\t\\tmemory[320*120+319:320*120] = INIT_78;\\r\\n\\t\\tmemory[320*121+319:320*121] = INIT_79;\\r\\n\\t\\tmemory[320*122+319:320*122] = INIT_7A;\\r\\n\\t\\tmemory[320*123+319:320*123] = INIT_7B;\\r\\n\\t\\tmemory[320*124+319:320*124] = INIT_7C;\\r\\n\\t\\tmemory[320*125+319:320*125] = INIT_7D;\\r\\n\\t\\tmemory[320*126+319:320*126] = INIT_7E;\\r\\n\\t\\tmemory[320*127+319:320*127] = INIT_7F;\\r\\n\\tend\\r\\n\\r\\n\\t// Signal inversion\\r\\n\\twire clka = A_CLK_INV ^ A_CLK;\\r\\n\\twire clkb = B_CLK_INV ^ B_CLK;\\r\\n\\twire ena  = A_EN_INV ^ A_EN;\\r\\n\\twire enb  = B_EN_INV ^ B_EN;\\r\\n\\twire wea  = A_WE_INV ^ A_WE;\\r\\n\\twire web  = B_WE_INV ^ B_WE;\\r\\n\\r\\n\\t// Internal signals\\r\\n\\twire [15:0] addra;\\r\\n\\twire [15:0] addrb;\\r\\n\\treg  [39:0] A_DO_out = 0, A_DO_reg = 0;\\r\\n\\treg  [39:0] B_DO_out = 0, B_DO_reg = 0;\\r\\n\\r\\n\\tgenerate\\r\\n\\t\\tif (RAM_MODE == \\\"SDP\\\") begin\\r\\n\\t\\t\\t// Port A (write)\\r\\n\\t\\t\\t if (A_WR_WIDTH == 80) begin\\r\\n\\t\\t\\t\\tassign addra = A_ADDR[15:7]*80;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// Port B (read)\\r\\n\\t\\t\\tif (B_RD_WIDTH == 80) begin\\r\\n\\t\\t\\t\\tassign addrb = B_ADDR[15:7]*80;\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\t\\telse if (RAM_MODE == \\\"TDP\\\") begin\\r\\n\\t\\t\\t// Port A\\r\\n\\t\\t\\tif (WIDTH_MODE_A <= 1) begin\\r\\n\\t\\t\\t\\twire [15:0] tmpa = {1'b0, A_ADDR[15:1]};\\r\\n\\t\\t\\t\\tassign addra = tmpa + (tmpa/4);\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_A <= 2) begin\\r\\n\\t\\t\\t\\twire [15:0] tmpa = {2'b0, A_ADDR[15:2]};\\r\\n\\t\\t\\t\\tassign addra = tmpa*2 + (tmpa/2);\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_A <= 5) begin\\r\\n\\t\\t\\t\\tassign addra = {3'b0, A_ADDR[15:3]}*5;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_A <= 10) begin\\r\\n\\t\\t\\t\\tassign addra = {4'b0, A_ADDR[15:4]}*10;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_A <= 20) begin\\r\\n\\t\\t\\t\\tassign addra = {5'b0, A_ADDR[15:5]}*20;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_A <= 40) begin\\r\\n\\t\\t\\t\\tassign addra = {6'b0, A_ADDR[15:6]}*40;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// Port B\\r\\n\\t\\t\\tif (WIDTH_MODE_B <= 1) begin\\r\\n\\t\\t\\t\\twire [15:0] tmpb = {1'b0, B_ADDR[15:1]};\\r\\n\\t\\t\\t\\tassign addrb = tmpb + (tmpb/4);\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_B <= 2) begin\\r\\n\\t\\t\\t\\twire [15:0] tmpb = {2'b0, B_ADDR[15:2]};\\r\\n\\t\\t\\t\\tassign addrb = tmpb*2 + (tmpb/2);\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_B <= 5) begin\\r\\n\\t\\t\\t\\tassign addrb = {3'b0, B_ADDR[15:3]}*5;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_B <= 10) begin\\r\\n\\t\\t\\t\\tassign addrb = {4'b0, B_ADDR[15:4]}*10;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_B <= 20) begin\\r\\n\\t\\t\\t\\tassign addrb = {5'b0, B_ADDR[15:5]}*20;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\telse if (WIDTH_MODE_B <= 40) begin\\r\\n\\t\\t\\t\\tassign addrb = {6'b0, B_ADDR[15:6]}*40;\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\n\\r\\n\\tgenerate\\r\\n\\t\\tif (RAM_MODE == \\\"SDP\\\") begin\\r\\n\\t\\t\\t// SDP write port\\r\\n\\t\\t\\talways @(posedge clka)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (k=0; k < A_WR_WIDTH; k=k+1) begin\\r\\n\\t\\t\\t\\t\\tif (k < 40) begin\\r\\n\\t\\t\\t\\t\\t\\tif (ena && wea && A_BM[k]) memory[addra+k] <= A_DI[k];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse begin // use both ports\\r\\n\\t\\t\\t\\t\\t\\tif (ena && wea && B_BM[k-40]) memory[addra+k] <= B_DI[k-40];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// SDP read port\\r\\n\\t\\t\\talways @(posedge clkb)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (k=0; k < B_RD_WIDTH; k=k+1) begin\\r\\n\\t\\t\\t\\t\\tif (k < 40) begin\\r\\n\\t\\t\\t\\t\\t\\tif (enb) A_DO_out[k] <= memory[addrb+k];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse begin // use both ports\\r\\n\\t\\t\\t\\t\\t\\tif (enb) B_DO_out[k-40] <= memory[addrb+k];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\t\\telse if (RAM_MODE == \\\"TDP\\\") begin\\r\\n\\t\\t\\t// {A,B}_ADDR[0]=0 selects lower, {A,B}_ADDR[0]=1 selects upper cascade memory\\r\\n\\t\\t\\twire upper_sel_a = ((CAS == \\\"UPPER\\\") && (A_ADDR[0] == 1));\\r\\n\\t\\t\\twire lower_sel_a = ((CAS == \\\"LOWER\\\") && (A_ADDR[0] == 0));\\r\\n\\t\\t\\twire upper_sel_b = ((CAS == \\\"UPPER\\\") && (B_ADDR[0] == 1));\\r\\n\\t\\t\\twire lower_sel_b = ((CAS == \\\"LOWER\\\") && (B_ADDR[0] == 0));\\r\\n\\r\\n\\t\\t\\treg dumm;\\r\\n\\r\\n\\t\\t\\t// Cascade output port A\\r\\n\\t\\t\\talways @(*)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tif ((A_WR_MODE == \\\"NO_CHANGE\\\") && lower_sel_a) begin\\r\\n\\t\\t\\t\\t\\tA_CO = memory[addra];\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\telse if ((A_WR_MODE == \\\"WRITE_THROUGH\\\") && lower_sel_a) begin\\r\\n\\t\\t\\t\\t\\tA_CO = ((wea && A_BM[0]) ? (A_DI[0]) : (memory[addra]));\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\r\\n\\t\\t\\t// Cascade output port B\\r\\n\\t\\t\\talways @(*)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tif ((B_WR_MODE == \\\"NO_CHANGE\\\") && lower_sel_b) begin\\r\\n\\t\\t\\t\\t\\tB_CO = memory[addrb];\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\telse if ((B_WR_MODE == \\\"WRITE_THROUGH\\\") && lower_sel_b) begin\\r\\n\\t\\t\\t\\t\\tB_CO = ((web && B_BM[0]) ? (B_DI[0]) : (memory[addrb]));\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\r\\n\\t\\t\\t// TDP port A\\r\\n\\t\\t\\talways @(posedge clka)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (i=0; i < WIDTH_MODE_A; i=i+1) begin\\r\\n\\t\\t\\t\\t\\tif (upper_sel_a || lower_sel_a || (CAS == \\\"NONE\\\")) begin\\r\\n\\t\\t\\t\\t\\t\\tif (ena && wea && A_BM[i])\\r\\n\\t\\t\\t\\t\\t\\t\\tmemory[addra+i] <= A_DI[i];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\r\\n\\t\\t\\t\\t\\tif (A_WR_MODE == \\\"NO_CHANGE\\\") begin\\r\\n\\t\\t\\t\\t\\t\\tif (ena && !wea) begin\\r\\n\\t\\t\\t\\t\\t\\t\\tif (CAS == \\\"UPPER\\\") begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tA_DO_out[i] <= ((A_ADDR[0] == 1) ? (memory[addra+i]) : (A_CI));\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\t\\telse if (CAS == \\\"NONE\\\") begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tA_DO_out[i] <= memory[addra+i];\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse if (A_WR_MODE == \\\"WRITE_THROUGH\\\") begin\\r\\n\\t\\t\\t\\t\\t\\tif (ena) begin\\r\\n\\t\\t\\t\\t\\t\\t\\tif (CAS == \\\"UPPER\\\") begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif (A_ADDR[0] == 1) begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tA_DO_out[i] <= ((wea && A_BM[i]) ? (A_DI[i]) : (memory[addra+i]));\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tend else begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tA_DO_out[i] <= A_CI;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\t\\telse if (CAS == \\\"NONE\\\") begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tA_DO_out[i] <= ((wea && A_BM[i]) ? (A_DI[i]) : (memory[addra+i]));\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// TDP port B\\r\\n\\t\\t\\talways @(posedge clkb)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (i=0; i < WIDTH_MODE_B; i=i+1) begin\\r\\n\\t\\t\\t\\t\\tif (upper_sel_b || lower_sel_b || (CAS == \\\"NONE\\\")) begin\\r\\n\\t\\t\\t\\t\\t\\tif (enb && web && B_BM[i])\\r\\n\\t\\t\\t\\t\\t\\t\\tmemory[addrb+i] <= B_DI[i];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\r\\n\\t\\t\\t\\t\\tif (B_WR_MODE == \\\"NO_CHANGE\\\") begin\\r\\n\\t\\t\\t\\t\\t\\tif (enb && !web) begin\\r\\n\\t\\t\\t\\t\\t\\t\\tif (CAS == \\\"UPPER\\\") begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tB_DO_out[i] <= ((B_ADDR[0] == 1) ? (memory[addrb+i]) : (B_CI));\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\t\\telse if (CAS == \\\"NONE\\\") begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tB_DO_out[i] <= memory[addrb+i];\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse if (B_WR_MODE == \\\"WRITE_THROUGH\\\") begin\\r\\n\\t\\t\\t\\t\\t\\tif (enb) begin\\r\\n\\t\\t\\t\\t\\t\\t\\tif (CAS == \\\"UPPER\\\") begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif (B_ADDR[0] == 1) begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tB_DO_out[i] <= ((web && B_BM[i]) ? (B_DI[i]) : (memory[addrb+i]));\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tend else begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tB_DO_out[i] <= B_CI;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\t\\telse if (CAS == \\\"NONE\\\") begin\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tB_DO_out[i] <= ((web && B_BM[i]) ? (B_DI[i]) : (memory[addrb+i]));\\r\\n\\t\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\n\\r\\n\\t// Optional output register\\r\\n\\tgenerate\\r\\n\\t\\tif (A_DO_REG) begin\\r\\n\\t\\t\\talways @(posedge clka) begin\\r\\n\\t\\t\\t\\tA_DO_reg <= A_DO_out;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\tassign A_DO = A_DO_reg;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\tassign A_DO = A_DO_out;\\r\\n\\t\\tend\\r\\n\\t\\tif (B_DO_REG) begin\\r\\n\\t\\t\\talways @(posedge clkb) begin\\r\\n\\t\\t\\t\\tB_DO_reg <= B_DO_out;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\tassign B_DO = B_DO_reg;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\tassign B_DO = B_DO_out;\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\nendmodule\\r\\n\\r\\nmodule CC_FIFO_40K (\\r\\n\\toutput A_ECC_1B_ERR,\\r\\n\\toutput B_ECC_1B_ERR,\\r\\n\\toutput A_ECC_2B_ERR,\\r\\n\\toutput B_ECC_2B_ERR,\\r\\n\\t// FIFO pop port\\r\\n\\toutput [39:0] A_DO,\\r\\n\\toutput [39:0] B_DO,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput  A_CLK,\\r\\n\\tinput  A_EN,\\r\\n\\t// FIFO push port\\r\\n\\tinput  [39:0] A_DI,\\r\\n\\tinput  [39:0] B_DI,\\r\\n\\tinput  [39:0] A_BM,\\r\\n\\tinput  [39:0] B_BM,\\r\\n\\t(* clkbuf_sink *)\\r\\n\\tinput  B_CLK,\\r\\n\\tinput  B_EN,\\r\\n\\tinput  B_WE,\\r\\n\\t// FIFO control\\r\\n\\tinput  F_RST_N,\\r\\n\\tinput  [14:0] F_ALMOST_FULL_OFFSET,\\r\\n\\tinput  [14:0] F_ALMOST_EMPTY_OFFSET,\\r\\n\\t// FIFO status signals\\r\\n\\toutput F_FULL,\\r\\n\\toutput F_EMPTY,\\r\\n\\toutput F_ALMOST_FULL,\\r\\n\\toutput F_ALMOST_EMPTY,\\r\\n\\toutput F_RD_ERROR,\\r\\n\\toutput F_WR_ERROR,\\r\\n\\toutput [15:0] F_RD_PTR,\\r\\n\\toutput [15:0] F_WR_PTR\\r\\n);\\r\\n\\t// Location format: D(0..N-1)X(0..3)Y(0..7) or UNPLACED\\r\\n\\tparameter LOC = \\\"UNPLACED\\\";\\r\\n\\r\\n\\t// Offset configuration\\r\\n\\tparameter DYN_STAT_SELECT = 1'b0;\\r\\n\\tparameter [14:0] ALMOST_FULL_OFFSET = 15'b0;\\r\\n\\tparameter [14:0] ALMOST_EMPTY_OFFSET = 15'b0;\\r\\n\\r\\n\\t// Port Widths\\r\\n\\tparameter A_WIDTH = 0;\\r\\n\\tparameter B_WIDTH = 0;\\r\\n\\r\\n\\t// RAM and Write Modes\\r\\n\\tparameter RAM_MODE = \\\"TDP\\\"; // \\\"TDP\\\" or \\\"SDP\\\"\\r\\n\\tparameter FIFO_MODE = \\\"SYNC\\\"; // \\\"ASYNC\\\" or \\\"SYNC\\\"\\r\\n\\r\\n\\t// Inverting Control Pins\\r\\n\\tparameter A_CLK_INV = 1'b0;\\r\\n\\tparameter B_CLK_INV = 1'b0;\\r\\n\\tparameter A_EN_INV = 1'b0;\\r\\n\\tparameter B_EN_INV = 1'b0;\\r\\n\\tparameter A_WE_INV = 1'b0;\\r\\n\\tparameter B_WE_INV = 1'b0;\\r\\n\\r\\n\\t// Output Register\\r\\n\\tparameter A_DO_REG = 1'b0;\\r\\n\\tparameter B_DO_REG = 1'b0;\\r\\n\\r\\n\\t// Error Checking and Correction\\r\\n\\tparameter A_ECC_EN  = 1'b0;\\r\\n\\tparameter B_ECC_EN  = 1'b0;\\r\\n\\r\\n\\tinteger i, k;\\r\\n\\r\\n\\t// 512 x 80 bit\\r\\n\\treg [40959:0] memory = 40960'b0;\\r\\n\\r\\n\\treg [15:0] counter_max;\\r\\n\\treg [15:0] sram_depth;\\r\\n\\tlocalparam tp = (A_WIDTH ==  1) ? 15 :\\r\\n\\t\\t\\t\\t\\t(A_WIDTH ==  2) ? 14 :\\r\\n\\t\\t\\t\\t\\t(A_WIDTH ==  5) ? 13 :\\r\\n\\t\\t\\t\\t\\t(A_WIDTH == 10) ? 12 :\\r\\n\\t\\t\\t\\t\\t(A_WIDTH == 20) ? 11 :\\r\\n\\t\\t\\t\\t\\t(A_WIDTH == 40) ? 10 : 9;\\r\\n\\r\\n\\tinitial begin\\r\\n\\t\\t// Check parameters\\r\\n\\t\\tif ((RAM_MODE != \\\"SDP\\\") && (RAM_MODE != \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal RAM MODE %d.\\\", RAM_MODE);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((FIFO_MODE != \\\"ASYNC\\\") && (FIFO_MODE != \\\"SYNC\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal FIFO MODE %d.\\\", FIFO_MODE);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((RAM_MODE == \\\"SDP\\\") && (DYN_STAT_SELECT == 1)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Dynamic offset configuration is not supported in %s mode.\\\", RAM_MODE);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((RAM_MODE == \\\"SDP\\\") && ((A_WIDTH != 80) || (B_WIDTH != 80))) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: SDP is ony supported in 80 bit mode.\\\");\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((A_WIDTH == 80) && (RAM_MODE == \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Port A width of 80 bits is only supported in SDP mode.\\\");\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((B_WIDTH == 80) && (RAM_MODE == \\\"TDP\\\")) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Port B width of 80 bits is only supported in SDP mode.\\\");\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((A_WIDTH != 80) && (A_WIDTH != 40) && (A_WIDTH != 20) && (A_WIDTH != 10) &&\\r\\n\\t\\t\\t(A_WIDTH != 5)  && (A_WIDTH != 2)  && (A_WIDTH != 1) && (A_WIDTH != 0)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal %s Port A width configuration %d.\\\", RAM_MODE, A_WIDTH);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif ((B_WIDTH != 80) && (B_WIDTH != 40) && (B_WIDTH != 20) && (B_WIDTH != 10) &&\\r\\n\\t\\t\\t(B_WIDTH != 5)  && (B_WIDTH != 2)  && (B_WIDTH != 1) && (B_WIDTH != 0)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal %s Port B width configuration %d.\\\", RAM_MODE, B_WIDTH);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\tif (A_WIDTH != B_WIDTH) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: The values of A_WIDTH and B_WIDTH must be equal.\\\");\\r\\n\\t\\tend\\r\\n\\t\\tif ((A_ECC_EN == 1'b1) && (RAM_MODE != \\\"SDP\\\") && (A_WIDTH != 40)) begin\\r\\n\\t\\t\\t$display(\\\"ERROR: Illegal ECC Port A configuration. ECC mode requires TDP >=40 bit or SDP 80 bit, but is %s %d.\\\", RAM_MODE, A_WIDTH);\\r\\n\\t\\t\\t$finish();\\r\\n\\t\\tend\\r\\n\\t\\t// Set local parameters\\r\\n\\t\\tif (A_WIDTH == 1) begin // A_WIDTH=B_WIDTH\\r\\n\\t\\t\\tcounter_max = 2 * 32*1024 - 1;\\r\\n\\t\\t\\tsram_depth  =     32*1024;\\r\\n\\t\\tend\\r\\n\\t\\telse if (A_WIDTH == 2) begin\\r\\n\\t\\t\\tcounter_max = 2 * 16*1024 - 1;\\r\\n\\t\\t\\tsram_depth  =     16*1024;\\r\\n\\t\\tend\\r\\n\\t\\telse if (A_WIDTH == 5) begin\\r\\n\\t\\t\\tcounter_max = 2 * 8*1024 - 1;\\r\\n\\t\\t\\tsram_depth  =     8*1024;\\r\\n\\t\\tend\\r\\n\\t\\telse if (A_WIDTH == 10) begin\\r\\n\\t\\t\\tcounter_max = 2 * 4*1024 - 1;\\r\\n\\t\\t\\tsram_depth  =     4*1024;\\r\\n\\t\\tend\\r\\n\\t\\telse if (A_WIDTH == 20) begin\\r\\n\\t\\t\\tcounter_max = 2 * 2*1024 - 1;\\r\\n\\t\\t\\tsram_depth  =     2*1024;\\r\\n\\t\\tend\\r\\n\\t\\telse if (A_WIDTH == 40) begin\\r\\n\\t\\t\\tcounter_max = 2 * 1*1024 - 1;\\r\\n\\t\\t\\tsram_depth  =     1*1024;\\r\\n\\t\\tend\\r\\n\\t\\telse begin // 80 bit SDP\\r\\n\\t\\t\\tcounter_max = 2 * 512 - 1;\\r\\n\\t\\t\\tsram_depth  =     512;\\r\\n\\t\\tend\\r\\n\\tend\\r\\n\\r\\n\\t// Internal signals\\r\\n\\twire fifo_rdclk = A_CLK ^ A_CLK_INV;\\r\\n\\twire fifo_wrclk = (FIFO_MODE == \\\"ASYNC\\\") ? (B_CLK ^ B_CLK_INV) : (A_CLK ^ A_CLK_INV);\\r\\n\\twire [15:0] almost_full_offset  = DYN_STAT_SELECT ? F_ALMOST_FULL_OFFSET  : ALMOST_FULL_OFFSET;\\r\\n\\twire [15:0] almost_empty_offset = DYN_STAT_SELECT ? F_ALMOST_EMPTY_OFFSET : ALMOST_EMPTY_OFFSET;\\r\\n\\treg  [39:0] A_DO_out = 0, A_DO_reg = 0;\\r\\n\\treg  [39:0] B_DO_out = 0, B_DO_reg = 0;\\r\\n\\r\\n\\t// Status signals\\r\\n\\treg fifo_full;\\r\\n\\treg fifo_empty;\\r\\n\\treg fifo_almost_full;\\r\\n\\treg fifo_almost_empty;\\r\\n\\tassign F_FULL         = fifo_full;\\r\\n\\tassign F_EMPTY        = fifo_empty;\\r\\n\\tassign F_ALMOST_FULL  = fifo_almost_full;\\r\\n\\tassign F_ALMOST_EMPTY = fifo_almost_empty;\\r\\n\\tassign F_WR_ERROR     = (F_FULL && (B_EN ^ B_EN_INV) && (B_WE ^ B_WE_INV));\\r\\n\\tassign F_RD_ERROR     = (F_EMPTY && (A_EN ^ A_EN_INV));\\r\\n\\twire ram_we = (~F_FULL  && (B_EN ^ B_EN_INV) && (B_WE ^ B_WE_INV));\\r\\n\\twire ram_en = (~F_EMPTY && (A_EN ^ A_EN_INV));\\r\\n\\r\\n\\t// Reset synchronizers\\r\\n\\treg  [1:0] aclk_reset_q, bclk_reset_q;\\r\\n\\twire fifo_sync_rstn    = aclk_reset_q;\\r\\n\\twire fifo_async_wrrstn = bclk_reset_q;\\r\\n\\twire fifo_async_rdrstn = aclk_reset_q;\\r\\n\\r\\n\\talways @(posedge fifo_rdclk or negedge F_RST_N)\\r\\n\\tbegin\\r\\n\\t\\tif (F_RST_N == 1'b0) begin\\r\\n\\t\\t\\taclk_reset_q <= 2'b0;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\taclk_reset_q[1] <= aclk_reset_q[0];\\r\\n\\t\\t\\taclk_reset_q[0] <= 1'b1;\\r\\n\\t\\tend\\r\\n\\tend\\r\\n\\r\\n\\talways @(posedge fifo_wrclk or negedge F_RST_N)\\r\\n\\tbegin\\r\\n\\t\\tif (F_RST_N == 1'b0) begin\\r\\n\\t\\t\\tbclk_reset_q <= 2'b0;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\tbclk_reset_q[1] <= bclk_reset_q[0];\\r\\n\\t\\t\\tbclk_reset_q[0] <= 1'b1;\\r\\n\\t\\tend\\r\\n\\tend\\r\\n\\r\\n\\t// Push/pop pointers\\r\\n\\treg  [15:0] rd_pointer, rd_pointer_int;\\r\\n\\treg  [15:0] wr_pointer, wr_pointer_int;\\r\\n\\treg  [15:0] rd_pointer_cmp, wr_pointer_cmp;\\r\\n\\twire [15:0] rd_pointer_nxt;\\r\\n\\twire [15:0] wr_pointer_nxt;\\r\\n\\treg  [15:0] fifo_rdaddr, rdaddr;\\r\\n\\treg  [15:0] fifo_wraddr, wraddr;\\r\\n\\tassign F_RD_PTR = fifo_rdaddr;\\r\\n\\tassign F_WR_PTR = fifo_wraddr;\\r\\n\\r\\n\\talways @(posedge fifo_rdclk or negedge F_RST_N)\\r\\n\\tbegin\\r\\n\\t\\tif (F_RST_N == 1'b0) begin\\r\\n\\t\\t\\trd_pointer <= 0;\\r\\n\\t\\t\\trd_pointer_int <= 0;\\r\\n\\t\\tend\\r\\n\\t\\telse if (ram_en) begin\\r\\n\\t\\t\\trd_pointer <= rd_pointer_nxt;\\r\\n\\t\\t\\trd_pointer_int <= rd_pointer_nxt[15:1] ^ rd_pointer_nxt[14:0];\\r\\n\\t\\tend\\r\\n\\tend\\r\\n\\r\\n\\tassign rd_pointer_nxt = (rd_pointer == counter_max) ? (0) : (rd_pointer + 1'b1);\\r\\n\\r\\n\\talways @(posedge fifo_wrclk or negedge F_RST_N)\\r\\n\\tbegin\\r\\n\\t\\tif (F_RST_N == 1'b0) begin\\r\\n\\t\\t\\twr_pointer <= 0;\\r\\n\\t\\t\\twr_pointer_int <= 0;\\r\\n\\t\\tend\\r\\n\\t\\telse if (ram_we) begin\\r\\n\\t\\t\\twr_pointer <= wr_pointer_nxt;\\r\\n\\t\\t\\twr_pointer_int <= wr_pointer_nxt[15:1] ^ wr_pointer_nxt[14:0];\\r\\n\\t\\tend\\r\\n\\tend\\r\\n\\r\\n\\tassign wr_pointer_nxt = (wr_pointer == counter_max) ? (0) : (wr_pointer + 1'b1);\\r\\n\\r\\n\\t// Address synchronizers\\r\\n\\treg [15:0] rd_pointer_sync, wr_pointer_sync;\\r\\n\\treg [15:0] rd_pointer_sync_0, rd_pointer_sync_1;\\r\\n\\treg [15:0] wr_pointer_sync_0, wr_pointer_sync_1;\\r\\n\\r\\n\\talways @(posedge fifo_rdclk or negedge F_RST_N)\\r\\n\\tbegin\\r\\n\\t\\tif (F_RST_N == 1'b0) begin\\r\\n\\t\\t\\twr_pointer_sync_0 <= 0;\\r\\n\\t\\t\\twr_pointer_sync_1 <= 0;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\twr_pointer_sync_0 <= wraddr;\\r\\n\\t\\t\\twr_pointer_sync_1 <= wr_pointer_sync_0;\\r\\n\\t\\tend\\r\\n\\t end\\r\\n\\r\\n\\talways @(posedge fifo_wrclk or negedge F_RST_N)\\r\\n\\t begin\\r\\n\\t\\tif (F_RST_N == 1'b0) begin\\r\\n\\t\\t\\trd_pointer_sync_0 <= 0;\\r\\n\\t\\t\\trd_pointer_sync_1 <= 0;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\trd_pointer_sync_0 <= rdaddr;\\r\\n\\t\\t\\trd_pointer_sync_1 <= rd_pointer_sync_0;\\r\\n\\t\\tend\\r\\n\\t end\\r\\n\\r\\n\\talways @(*) begin\\r\\n\\t\\tfifo_wraddr = {wr_pointer[tp-1:0], {(15-tp){1'b0}}};\\r\\n\\t\\tfifo_rdaddr = {rd_pointer[tp-1:0], {(15-tp){1'b0}}};\\r\\n\\r\\n\\t\\trdaddr = {rd_pointer[tp], rd_pointer_int[tp-1:0]};\\r\\n\\t\\twraddr = {{(15-tp){1'b0}}, wr_pointer[tp], wr_pointer_int[tp:0]};\\r\\n\\r\\n\\t\\tif (FIFO_MODE == \\\"ASYNC\\\")\\r\\n\\t\\t\\tfifo_full = (wraddr[tp-2:0] == rd_pointer_sync_1[tp-2:0] ) && (wraddr[tp] != rd_pointer_sync_1[tp] ) && ( wraddr[tp-1] != rd_pointer_sync_1[tp-1] );\\r\\n\\t\\telse\\r\\n\\t\\t\\tfifo_full = (wr_pointer[tp-1:0] == rd_pointer[tp-1:0]) && (wr_pointer[tp] ^ rd_pointer[tp]);\\r\\n\\r\\n\\t\\tif (FIFO_MODE == \\\"ASYNC\\\")\\r\\n\\t\\t\\tfifo_empty = (wr_pointer_sync_1[tp:0] == rdaddr[tp:0]);\\r\\n\\t\\telse\\r\\n\\t\\t\\tfifo_empty = (wr_pointer[tp:0] == rd_pointer[tp:0]);\\r\\n\\r\\n\\t\\trd_pointer_cmp = (FIFO_MODE == \\\"ASYNC\\\") ? rd_pointer_sync : rd_pointer;\\r\\n\\t\\tif (wr_pointer[tp] == rd_pointer_cmp[tp])\\r\\n\\t\\t\\tfifo_almost_full = ((wr_pointer[tp-1:0] - rd_pointer_cmp[tp-1:0]) >= (sram_depth - almost_full_offset));\\r\\n\\t\\telse\\r\\n\\t\\t\\tfifo_almost_full = ((rd_pointer_cmp[tp-1:0] - wr_pointer[tp-1:0]) <= almost_full_offset);\\r\\n\\r\\n\\t\\twr_pointer_cmp = (FIFO_MODE == \\\"ASYNC\\\") ? wr_pointer_sync : wr_pointer;\\r\\n\\t\\tif (wr_pointer_cmp[tp] == rd_pointer[tp])\\r\\n\\t\\t\\tfifo_almost_empty = ((wr_pointer_cmp[tp-1:0] - rd_pointer[tp-1:0]) <= almost_empty_offset);\\r\\n\\t\\telse\\r\\n\\t\\t\\tfifo_almost_empty = ((rd_pointer[tp-1:0] - wr_pointer_cmp[tp-1:0]) >= (sram_depth - almost_empty_offset));\\r\\n\\tend\\r\\n\\r\\n\\tgenerate\\r\\n\\t\\talways @(*) begin\\r\\n\\t\\t\\twr_pointer_sync = 0;\\r\\n\\t\\t\\trd_pointer_sync = 0;\\r\\n\\t\\t\\tfor (i=tp; i >= 0; i=i-1) begin\\r\\n\\t\\t\\t\\tif (i == tp) begin\\r\\n\\t\\t\\t\\t\\twr_pointer_sync[i] = wr_pointer_sync_1[i];\\r\\n\\t\\t\\t\\t\\trd_pointer_sync[i] = rd_pointer_sync_1[i];\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\telse begin\\r\\n\\t\\t\\t\\t\\twr_pointer_sync[i] = wr_pointer_sync_1[i] ^ wr_pointer_sync[i+1];\\r\\n\\t\\t\\t\\t\\trd_pointer_sync[i] = rd_pointer_sync_1[i] ^ rd_pointer_sync[i+1];\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\t\\tif (RAM_MODE == \\\"SDP\\\") begin\\r\\n\\t\\t\\t// SDP push ports A+B\\r\\n\\t\\t\\talways @(posedge fifo_wrclk)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (k=0; k < A_WIDTH; k=k+1) begin\\r\\n\\t\\t\\t\\t\\tif (k < 40) begin\\r\\n\\t\\t\\t\\t\\t\\tif (ram_we && A_BM[k]) memory[fifo_wraddr+k] <= A_DI[k];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse begin // use both ports\\r\\n\\t\\t\\t\\t\\t\\tif (ram_we && B_BM[k-40]) memory[fifo_wraddr+k] <= B_DI[k-40];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// SDP pop ports A+B\\r\\n\\t\\t\\talways @(posedge fifo_rdclk)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (k=0; k < B_WIDTH; k=k+1) begin\\r\\n\\t\\t\\t\\t\\tif (k < 40) begin\\r\\n\\t\\t\\t\\t\\t\\tif (ram_en) A_DO_out[k] <= memory[fifo_rdaddr+k];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\t\\telse begin // use both ports\\r\\n\\t\\t\\t\\t\\t\\tif (ram_en) B_DO_out[k-40] <= memory[fifo_rdaddr+k];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\t\\telse if (RAM_MODE == \\\"TDP\\\") begin\\r\\n\\t\\t\\t// TDP pop port A\\r\\n\\t\\t\\talways @(posedge fifo_rdclk)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (i=0; i < A_WIDTH; i=i+1) begin\\r\\n\\t\\t\\t\\t\\tif (ram_en) begin\\r\\n\\t\\t\\t\\t\\t\\tA_DO_out[i] <= memory[fifo_rdaddr+i];\\r\\n\\t\\t\\t\\t\\tend\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\t// TDP push port B\\r\\n\\t\\t\\talways @(posedge fifo_wrclk)\\r\\n\\t\\t\\tbegin\\r\\n\\t\\t\\t\\tfor (i=0; i < B_WIDTH; i=i+1) begin\\r\\n\\t\\t\\t\\t\\tif (ram_we && B_BM[i])\\r\\n\\t\\t\\t\\t\\t\\tmemory[fifo_wraddr+i] <= B_DI[i];\\r\\n\\t\\t\\t\\tend\\r\\n\\t\\t\\tend\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\n\\r\\n\\t// Optional output register\\r\\n\\tgenerate\\r\\n\\t\\tif (A_DO_REG) begin\\r\\n\\t\\t\\talways @(posedge fifo_rdclk) begin\\r\\n\\t\\t\\t\\tA_DO_reg <= A_DO_out;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\tassign A_DO = A_DO_reg;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\tassign A_DO = A_DO_out;\\r\\n\\t\\tend\\r\\n\\t\\tif (B_DO_REG) begin\\r\\n\\t\\t\\talways @(posedge fifo_rdclk) begin\\r\\n\\t\\t\\t\\tB_DO_reg <= B_DO_out;\\r\\n\\t\\t\\tend\\r\\n\\t\\t\\tassign B_DO = B_DO_reg;\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\tassign B_DO = B_DO_out;\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\nendmodule\\r\\n\\r\\n// Models of the LUT2 tree primitives\\r\\nmodule CC_L2T4(\\r\\n\\toutput O,\\r\\n\\tinput I0, I1, I2, I3\\r\\n);\\r\\n\\tparameter [3:0] INIT_L00 = 4'b0000;\\r\\n\\tparameter [3:0] INIT_L01 = 4'b0000;\\r\\n\\tparameter [3:0] INIT_L10 = 4'b0000;\\r\\n\\r\\n\\twire [1:0] l00_s1 = I1 ? INIT_L00[3:2] : INIT_L00[1:0];\\r\\n\\twire l00 = I0 ? l00_s1[1] : l00_s1[0];\\r\\n\\r\\n\\twire [1:0] l01_s1 = I3 ? INIT_L01[3:2] : INIT_L01[1:0];\\r\\n\\twire l01 = I2 ? l01_s1[1] : l01_s1[0];\\r\\n\\r\\n\\twire [1:0] l10_s1 = l01 ? INIT_L10[3:2] : INIT_L10[1:0];\\r\\n\\tassign O = l00 ? l10_s1[1] : l10_s1[0];\\r\\n\\r\\nendmodule\\r\\n\\r\\n\\r\\nmodule CC_L2T5(\\r\\n\\toutput O,\\r\\n\\tinput I0, I1, I2, I3, I4\\r\\n);\\r\\n\\tparameter [3:0] INIT_L02 = 4'b0000;\\r\\n\\tparameter [3:0] INIT_L03 = 4'b0000;\\r\\n\\tparameter [3:0] INIT_L11 = 4'b0000;\\r\\n\\tparameter [3:0] INIT_L20 = 4'b0000;\\r\\n\\r\\n\\twire [1:0] l02_s1 = I1 ? INIT_L02[3:2] : INIT_L02[1:0];\\r\\n\\twire l02 = I0 ? l02_s1[1] : l02_s1[0];\\r\\n\\r\\n\\twire [1:0] l03_s1 = I3 ? INIT_L03[3:2] : INIT_L03[1:0];\\r\\n\\twire l03 = I2 ? l03_s1[1] : l03_s1[0];\\r\\n\\r\\n\\twire [1:0] l11_s1 = l03 ? INIT_L11[3:2] : INIT_L11[1:0];\\r\\n\\twire l11 = l02 ? l11_s1[1] : l11_s1[0];\\r\\n\\r\\n\\twire [1:0] l20_s1 = l11 ? INIT_L20[3:2] : INIT_L20[1:0];\\r\\n\\tassign O = I4 ? l20_s1[1] : l20_s1[0];\\r\\n\\r\\nendmodule\\r\\n\",\n            \"inv_map.v\": \"// Any inverters not folded into LUTs are mapped to a LUT of their own\\nmodule \\\\$__CC_NOT (input A, output Y);\\n\\tCC_LUT1 #(.INIT(2'b01)) _TECHMAP_REPLACE_ (.I0(A), .O(Y));\\nendmodule\\n\",\n            \"lut_map.v\": \"/*\\r\\n *  yosys -- Yosys Open SYnthesis Suite\\r\\n *\\r\\n *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\\r\\n *\\r\\n *  Permission to use, copy, modify, and/or distribute this software for any\\r\\n *  purpose with or without fee is hereby granted, provided that the above\\r\\n *  copyright notice and this permission notice appear in all copies.\\r\\n *\\r\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\r\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\r\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\r\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\r\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\r\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\r\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\r\\n *\\r\\n */\\r\\n\\r\\nmodule \\\\$lut (A, Y);\\r\\n\\tparameter WIDTH = 0;\\r\\n\\tparameter LUT = 0;\\r\\n\\r\\n\\t(* force_downto *)\\r\\n\\tinput [WIDTH-1:0] A;\\r\\n\\toutput Y;\\r\\n\\r\\n\\tgenerate\\r\\n\\t\\tif (WIDTH == 1) begin\\r\\n\\t\\t\\tCC_LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]));\\r\\n\\t\\tend\\r\\n\\t\\telse if (WIDTH == 2) begin\\r\\n\\t\\t\\tCC_LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]));\\r\\n\\t\\tend\\r\\n\\t\\telse if (WIDTH == 3) begin\\r\\n\\t\\t\\tCC_LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]));\\r\\n\\t\\tend\\r\\n\\t\\telse if (WIDTH == 4) begin\\r\\n\\t\\t\\tCC_LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y), .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));\\r\\n\\t\\tend\\r\\n\\t\\telse begin\\r\\n\\t\\t\\twire _TECHMAP_FAIL_ = 1;\\r\\n\\t\\tend\\r\\n\\tendgenerate\\r\\nendmodule\\r\\n\",\n            \"lut_tree_cells.genlib\": \"GATE $__ZERO 0 Y=CONST0;\\nGATE $__ONE 0 Y=CONST1;\\n\\nGATE $__CC_BUF 5 Y=A;\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC_NOT 0 Y=!A;\\nPIN * INV 1 9999 10 5 10 5\\n\\nGATE $__CC_MUX 5 Y=((A*!C)+(B*C));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC2_A 10 Y=(A*B);\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC3_A_O 12 Y=(E+(A*B));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC3_A_X 12 Y=((E*(!A+!B))+(!E*(A*B)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC2_O 10 Y=(A+B);\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC3_O_A 12 Y=(E*(A+B));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC3_O_X 12 Y=((E*(!A*!B))+(!E*(A+B)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC2_X 10 Y=((A*!B)+(!A*B));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC3_X_A 12 Y=(E*((A*!B)+(!A*B)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC3_X_O 12 Y=(E+((A*!B)+(!A*B)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC3_AA 10 Y=((A*B)*C);\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_AA_O 12 Y=(E+((A*B)*C));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_AA_X 12 Y=((E*((!A+!B)+!C))+(!E*((A*B)*C)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC3_OO 10 Y=((A+B)+C);\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_OO_A 12 Y=(E*((A+B)+C));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_OO_X 12 Y=((E*((!A*!B)*!C))+(!E*((A+B)+C)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC3_XX 10 Y=((((A*!B)+(!A*B))*!C)+(((!A+B)*(A+!B))*C));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_XX_A 12 Y=(E*((((A*!B)+(!A*B))*!C)+(((!A+B)*(A+!B))*C)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_XX_O 12 Y=(E+((((A*!B)+(!A*B))*!C)+(((!A+B)*(A+!B))*C)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC3_AO 10 Y=((A*B)+C);\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_AO_A 12 Y=(E*((A*B)+C));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_AO_O 12 Y=(E+((A*B)+C));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_AO_X 12 Y=((E*((!A+!B)*!C))+(!E*((A*B)+C)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC3_OA 10 Y=((A+B)*C);\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_OA_A 12 Y=(E*((A+B)*C));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_OA_O 12 Y=(E+((A+B)*C));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC4_OA_X 12 Y=((E*((!A*!B)+!C))+(!E*((A+B)*C)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC3_AX 10 Y=(((A*B)*!C)+((!A+!B)*C));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AX_A 12 Y=(E*(((A*B)*!C)+((!A+!B)*C)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AX_O 12 Y=(E+(((A*B)*!C)+((!A+!B)*C)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AX_X 12 Y=((E*(((!A+!B)+C)*((A*B)+!C)))+(!E*(((A*B)*!C)+((!A+!B)*C))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC3_XA 10 Y=(((A*!B)+(!A*B))*C);\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_XA_A 12 Y=(E*(((A*!B)+(!A*B))*C));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_XA_O 12 Y=(E+(((A*!B)+(!A*B))*C));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_XA_X 12 Y=((E*(((!A+B)*(A+!B))+!C))+(!E*(((A*!B)+(!A*B))*C)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AAA 10 Y=((A*B)*(C*D));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC5_AAA_A 12 Y=(E*((A*B)*(C*D)));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC5_AAA_O 12 Y=(E+((A*B)*(C*D)));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC5_AAA_X 12 Y=((E*((!A+!B)+(!C+!D)))+(!E*((A*B)*(C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AXA 10 Y=(((A*B)*(!C+!D))+((!A+!B)*(C*D)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AXA_A 12 Y=(E*(((A*B)*(!C+!D))+((!A+!B)*(C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AXA_O 12 Y=(E+(((A*B)*(!C+!D))+((!A+!B)*(C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AXA_X 12 Y=((E*(((!A+!B)+(C*D))*((A*B)+(!C+!D))))+(!E*(((A*B)*(!C+!D))+((!A+!B)*(C*D)))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_XAX 10 Y=(((A*!B)+(!A*B))*((C*!D)+(!C*D)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_XAX_A 12 Y=(E*(((A*!B)+(!A*B))*((C*!D)+(!C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_XAX_O 12 Y=(E+(((A*!B)+(!A*B))*((C*!D)+(!C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_XAX_X 12 Y=((E*(((!A+B)*(A+!B))+((!C+D)*(C+!D))))+(!E*(((A*!B)+(!A*B))*((C*!D)+(!C*D)))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AAX 10 Y=((A*B)*((C*!D)+(!C*D)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AAX_A 12 Y=(E*((A*B)*((C*!D)+(!C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AAX_O 12 Y=(E+((A*B)*((C*!D)+(!C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AAX_X 12 Y=((E*((!A+!B)+((!C+D)*(C+!D))))+(!E*((A*B)*((C*!D)+(!C*D)))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AXX 10 Y=(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AXX_A 12 Y=(E*(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D)))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AXX_O 12 Y=(E+(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D)))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AXX_X 12 Y=((E*(((!A+!B)+((C*!D)+(!C*D)))*((A*B)+((!C+D)*(C+!D)))))+(!E*(((A*B)*((!C+D)*(C+!D)))+((!A+!B)*((C*!D)+(!C*D))))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_XXX 10 Y=((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_XXX_A 12 Y=(E*((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D)))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_XXX_O 12 Y=(E+((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D)))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_XXX_X 12 Y=((E*((((!A+B)*(A+!B))+((C*!D)+(!C*D)))*(((A*!B)+(!A*B))+((!C+D)*(C+!D)))))+(!E*((((A*!B)+(!A*B))*((!C+D)*(C+!D)))+(((!A+B)*(A+!B))*((C*!D)+(!C*D))))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AAO 10 Y=((A*B)*(C+D));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC5_AAO_A 12 Y=(E*((A*B)*(C+D)));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC5_AAO_O 12 Y=(E+((A*B)*(C+D)));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC5_AAO_X 12 Y=((E*((!A+!B)+(!C*!D)))+(!E*((A*B)*(C+D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AOA 10 Y=((A*B)+(C*D));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC5_AOA_A 12 Y=(E*((A*B)+(C*D)));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC5_AOA_O 12 Y=(E+((A*B)+(C*D)));\\nPIN * NONINV 1 9999 10 5 10 5\\n\\nGATE $__CC5_AOA_X 12 Y=((E*((!A+!B)*(!C+!D)))+(!E*((A*B)+(C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC4_AOX 10 Y=((A*B)+((C*!D)+(!C*D)));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AOX_A 12 Y=(E*((A*B)+((C*!D)+(!C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AOX_O 12 Y=(E+((A*B)+((C*!D)+(!C*D))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\\nGATE $__CC5_AOX_X 12 Y=((E*((!A+!B)*((!C+D)*(C+!D))))+(!E*((A*B)+((C*!D)+(!C*D)))));\\nPIN * UNKNOWN 1 9999 10 5 10 5\\n\",\n            \"lut_tree_map.v\": \"\\nmodule \\\\$__ZERO (output Y); assign Y = 1'b0; endmodule\\nmodule \\\\$__ONE (output Y); assign Y = 1'b1; endmodule\\n\\nmodule \\\\$__CC_BUF (input A, output Y); assign Y = A; endmodule\\n\\nmodule \\\\$__CC_MUX (input A, B, C, output Y);\\n    CC_MX2 _TECHMAP_REPLACE_ (\\n        .D0(A), .D1(B), .S0(C),\\n        .Y(Y)\\n    );\\nendmodule\\n\\n\\nmodule \\\\$__CC2_A (input A, B, output Y);\\n    CC_LUT2 #(\\n        .INIT(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_A_O (input A, B, E, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1010),\\n        .INIT_L01(4'b1000),\\n        .INIT_L10(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(E), .I1(), .I2(A), .I3(B),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_A_X (input A, B, E, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1010),\\n        .INIT_L01(4'b1000),\\n        .INIT_L10(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(E), .I1(), .I2(A), .I3(B),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC2_O (input A, B, output Y);\\n    CC_LUT2 #(\\n        .INIT(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_O_A (input A, B, E, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1010),\\n        .INIT_L01(4'b1110),\\n        .INIT_L10(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(E), .I1(), .I2(A), .I3(B),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_O_X (input A, B, E, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1010),\\n        .INIT_L01(4'b1110),\\n        .INIT_L10(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(E), .I1(), .I2(A), .I3(B),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC2_X (input A, B, output Y);\\n    CC_LUT2 #(\\n        .INIT(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_X_A (input A, B, E, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1010),\\n        .INIT_L01(4'b0110),\\n        .INIT_L10(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(E), .I1(), .I2(A), .I3(B),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_X_O (input A, B, E, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1010),\\n        .INIT_L01(4'b0110),\\n        .INIT_L10(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(E), .I1(), .I2(A), .I3(B),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_AA (input A, B, C, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b1010),\\n        .INIT_L10(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AA_O (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AA_X (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_OO (input A, B, C, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1110),\\n        .INIT_L01(4'b1010),\\n        .INIT_L10(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_OO_A (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_OO_X (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_XX (input A, B, C, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b0110),\\n        .INIT_L01(4'b1010),\\n        .INIT_L10(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_XX_A (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_XX_O (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_AO (input A, B, C, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b1010),\\n        .INIT_L10(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AO_A (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AO_O (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AO_X (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_OA (input A, B, C, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1110),\\n        .INIT_L01(4'b1010),\\n        .INIT_L10(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_OA_A (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_OA_O (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_OA_X (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_AX (input A, B, C, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b1010),\\n        .INIT_L10(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AX_A (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AX_O (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AX_X (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC3_XA (input A, B, C, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b0110),\\n        .INIT_L01(4'b1010),\\n        .INIT_L10(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_XA_A (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_XA_O (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_XA_X (input A, B, C, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b1010),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AAA (input A, B, C, D, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b1000),\\n        .INIT_L10(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AAA_A (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1000),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AAA_O (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1000),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AAA_X (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1000),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AXA (input A, B, C, D, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b1000),\\n        .INIT_L10(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AXA_A (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1000),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AXA_O (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1000),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AXA_X (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1000),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_XAX (input A, B, C, D, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b0110),\\n        .INIT_L01(4'b0110),\\n        .INIT_L10(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_XAX_A (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_XAX_O (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_XAX_X (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AAX (input A, B, C, D, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b0110),\\n        .INIT_L10(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AAX_A (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AAX_O (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AAX_X (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AXX (input A, B, C, D, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b0110),\\n        .INIT_L10(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AXX_A (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AXX_O (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AXX_X (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_XXX (input A, B, C, D, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b0110),\\n        .INIT_L01(4'b0110),\\n        .INIT_L10(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_XXX_A (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_XXX_O (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_XXX_X (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b0110),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b0110),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AAO (input A, B, C, D, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b1110),\\n        .INIT_L10(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AAO_A (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1110),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AAO_O (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1110),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AAO_X (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1110),\\n        .INIT_L11(4'b1000),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AOA (input A, B, C, D, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b1000),\\n        .INIT_L10(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AOA_A (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1000),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AOA_O (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1000),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AOA_X (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b1000),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC4_AOX (input A, B, C, D, output Y);\\n    CC_L2T4 #(\\n        .INIT_L00(4'b1000),\\n        .INIT_L01(4'b0110),\\n        .INIT_L10(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AOX_A (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b1000),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AOX_O (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b1110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\\nmodule \\\\$__CC5_AOX_X (input A, B, C, D, E, output Y);\\n    CC_L2T5 #(\\n        .INIT_L02(4'b1000),\\n        .INIT_L03(4'b0110),\\n        .INIT_L11(4'b1110),\\n        .INIT_L20(4'b0110),\\n    ) _TECHMAP_REPLACE_ (\\n         .I0(A), .I1(B), .I2(C), .I3(D), .I4(E),\\n         .O(Y)\\n    );\\nendmodule\\n\",\n            \"mul_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$mul $__mul\\\" *)\\nmodule \\\\$__MULMXN (A, B, Y);\\n\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\tlocalparam A_ADJWIDTH = A_WIDTH + (A_SIGNED ? 0 : 1);\\n\\tlocalparam B_ADJWIDTH = B_WIDTH + (B_SIGNED ? 0 : 1);\\n\\n\\tgenerate\\n\\t\\tif (A_SIGNED) begin: blkA\\n\\t\\t\\twire signed [A_ADJWIDTH-1:0] Aext = $signed(A);\\n\\t\\tend\\n\\t\\telse begin: blkA\\n\\t\\t\\twire [A_ADJWIDTH-1:0] Aext = A;\\n\\t\\tend\\n\\t\\tif (B_SIGNED) begin: blkB\\n\\t\\t\\twire signed [B_ADJWIDTH-1:0] Bext = $signed(B);\\n\\t\\tend\\n\\t\\telse begin: blkB\\n\\t\\t\\twire [B_ADJWIDTH-1:0] Bext = B;\\n\\t\\tend\\n\\n\\t\\tif (A_WIDTH >= B_WIDTH) begin\\n\\t\\t\\tCC_MULT #(\\n\\t\\t\\t\\t.A_WIDTH(A_ADJWIDTH),\\n\\t\\t\\t\\t.B_WIDTH(B_ADJWIDTH),\\n\\t\\t\\t\\t.P_WIDTH(Y_WIDTH),\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t.A(blkA.Aext),\\n\\t\\t\\t\\t.B(blkB.Bext),\\n\\t\\t\\t\\t.P(Y)\\n\\t\\t\\t);\\n\\t\\tend\\n\\t\\telse begin // swap A,B\\n\\t\\t\\tCC_MULT #(\\n\\t\\t\\t\\t.A_WIDTH(B_ADJWIDTH),\\n\\t\\t\\t\\t.B_WIDTH(A_ADJWIDTH),\\n\\t\\t\\t\\t.P_WIDTH(Y_WIDTH),\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t.A(blkB.Bext),\\n\\t\\t\\t\\t.B(blkA.Aext),\\n\\t\\t\\t\\t.P(Y)\\n\\t\\t\\t);\\n\\t\\tend\\n\\tendgenerate\\n\\nendmodule\\n\",\n            \"mux_map.v\": \"/*\\r\\n *  yosys -- Yosys Open SYnthesis Suite\\r\\n *\\r\\n *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\\r\\n *\\r\\n *  Permission to use, copy, modify, and/or distribute this software for any\\r\\n *  purpose with or without fee is hereby granted, provided that the above\\r\\n *  copyright notice and this permission notice appear in all copies.\\r\\n *\\r\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\r\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\r\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\r\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\r\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\r\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\r\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\r\\n *\\r\\n */\\r\\n\\r\\nmodule \\\\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);\\r\\n\\tinput  A, B, C, D, E, F, G, H, S, T, U;\\r\\n\\toutput Y;\\r\\n\\r\\n\\tCC_MX8 _TECHMAP_REPLACE_ (\\r\\n\\t\\t.D0(A), .D1(B), .D2(C), .D3(D),\\r\\n\\t\\t.D4(E), .D5(F), .D6(G), .D7(H),\\r\\n\\t\\t.S0(S), .S1(T), .S2(U),\\r\\n\\t\\t.Y(Y)\\r\\n\\t);\\r\\n\\r\\nendmodule\\r\\n\\r\\nmodule \\\\$_MUX4_ (A, B, C, D, S, T, Y);\\r\\n\\tinput  A, B, C, D, S, T;\\r\\n\\toutput Y;\\r\\n\\r\\n\\tCC_MX4 _TECHMAP_REPLACE_ (\\r\\n\\t\\t.D0(A), .D1(B), .D2(C), .D3(D),\\r\\n\\t\\t.S0(S), .S1(T),\\r\\n\\t\\t.Y(Y)\\r\\n\\t);\\r\\n\\r\\nendmodule\\r\\n\\r\\n/*\\r\\nmodule \\\\$_MUX_ (A, B, S, Y);\\r\\n\\tinput  A, B, S;\\r\\n\\toutput Y;\\r\\n\\r\\n\\tCC_MX2 _TECHMAP_REPLACE_ (\\r\\n\\t\\t.D0(A), .D1(B), .S0(S),\\r\\n\\t\\t.Y(Y)\\r\\n\\t);\\r\\n\\r\\nendmodule\\r\\n*/\\r\\n\",\n            \"reg_map.v\": \"/*\\r\\n *  yosys -- Yosys Open SYnthesis Suite\\r\\n *\\r\\n *  Copyright (C) 2021  Cologne Chip AG <support@colognechip.com>\\r\\n *\\r\\n *  Permission to use, copy, modify, and/or distribute this software for any\\r\\n *  purpose with or without fee is hereby granted, provided that the above\\r\\n *  copyright notice and this permission notice appear in all copies.\\r\\n *\\r\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\r\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\r\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\r\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\r\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\r\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\r\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\r\\n *\\r\\n */\\r\\n\\r\\n(* techmap_celltype = \\\"$_DFFE_[NP][NP][01][NP]_\\\" *)\\r\\nmodule \\\\$_DFFE_xxxx_ (input D, C, R, E, output Q);\\r\\n\\r\\n\\tparameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\r\\n\\tparameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\r\\n\\r\\n\\tCC_DFF #(\\r\\n\\t\\t.CLK_INV(_TECHMAP_CELLTYPE_[39:32] == \\\"N\\\"),\\r\\n\\t\\t.EN_INV(_TECHMAP_CELLTYPE_[15:8] == \\\"N\\\"),\\r\\n\\t\\t.SR_INV(_TECHMAP_CELLTYPE_[31:24] == \\\"N\\\"),\\r\\n\\t\\t.SR_VAL(_TECHMAP_CELLTYPE_[23:16] == \\\"1\\\"),\\r\\n\\t\\t.INIT(_TECHMAP_WIREINIT_Q_)\\r\\n\\t) _TECHMAP_REPLACE_ (.D(D), .EN(E), .CLK(C), .SR(R), .Q(Q));\\r\\n\\r\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\r\\nendmodule\\r\\n\\r\\n(* techmap_celltype = \\\"$_DLATCH_[NP][NP][01]_\\\" *)\\r\\nmodule \\\\$_DLATCH_xxx_ (input E, R, D, output Q);\\r\\n\\r\\n\\tparameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\r\\n\\tparameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\r\\n\\r\\n\\tCC_DLT #(\\r\\n\\t\\t.G_INV(_TECHMAP_CELLTYPE_[31:24] == \\\"N\\\"),\\r\\n\\t\\t.SR_INV(_TECHMAP_CELLTYPE_[23:16] == \\\"N\\\"),\\r\\n\\t\\t.SR_VAL(_TECHMAP_CELLTYPE_[15:8] == \\\"1\\\"),\\r\\n\\t\\t.INIT(_TECHMAP_WIREINIT_Q_)\\r\\n\\t) _TECHMAP_REPLACE_ (.D(D), .G(E), .SR(R), .Q(Q));\\r\\n\\r\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\r\\nendmodule\\r\\n\",\n        },\n        \"gowin\": {\n            \"arith_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *  Copyright (C) 2018  gatecat <gatecat@ds0.me>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_gw1n_alu(A, B, CI, BI, X, Y, CO);\\n   parameter A_SIGNED = 0;\\n   parameter B_SIGNED = 0;\\n   parameter A_WIDTH = 1;\\n   parameter B_WIDTH = 1;\\n   parameter Y_WIDTH = 1;\\n\\n   (* force_downto *)\\n   input [A_WIDTH-1:0] A;\\n   (* force_downto *)\\n   input [B_WIDTH-1:0] B;\\n   (* force_downto *)\\n   output [Y_WIDTH-1:0] X, Y;\\n\\n   input \\t\\tCI, BI;\\n   (* force_downto *)\\n   output [Y_WIDTH-1:0] CO;\\n\\n   wire \\t\\t_TECHMAP_FAIL_ = Y_WIDTH <= 2;\\n\\n   (* force_downto *)\\n   wire [Y_WIDTH-1:0] \\tA_buf, B_buf;\\n   \\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n   \\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n   (* force_downto *)\\n   wire [Y_WIDTH-1:0] \\tAA = A_buf;\\n   (* force_downto *)\\n   wire [Y_WIDTH-1:0] \\tBB = B_buf;\\n   (* force_downto *)\\n   wire [Y_WIDTH-1:0] \\tC = {CO, CI};\\n\\n   genvar \\t\\ti;\\n   generate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice\\n      ALU #(.ALU_MODE(2)) // ADDSUB I3 ? add : sub\\n      alu(.I0(AA[i]),\\n\\t  .I1(BB[i]),\\n\\t  .I3(~BI),\\n\\t  .CIN(C[i]),\\n\\t  .COUT(CO[i]),\\n\\t  .SUM(Y[i])\\n\\t  );\\n   end endgenerate\\n   assign X = AA ^ BB ^ {Y_WIDTH{BI}};\\nendmodule\\n\\n\",\n            \"brams.txt\": \"ram block $__GOWIN_SP_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 36 per_port;\\n\\tcost 128;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" {\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t\\toption \\\"RESET_MODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated;\\n\\t\\t}\\n\\t\\toption \\\"RESET_MODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t\\tportoption \\\"WRITE_MODE\\\" 0 {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITE_MODE\\\" 1 {\\n\\t\\t\\trdwr new;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITE_MODE\\\" 2 {\\n\\t\\t\\trdwr old;\\n\\t\\t}\\n\\t}\\n}\\n\\nram block $__GOWIN_DP_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 per_port;\\n\\tcost 128;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t\\toption \\\"RESET_MODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated;\\n\\t\\t}\\n\\t\\toption \\\"RESET_MODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t\\tportoption \\\"WRITE_MODE\\\" 0 {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITE_MODE\\\" 1 {\\n\\t\\t\\trdwr new;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITE_MODE\\\" 2 {\\n\\t\\t\\trdwr old;\\n\\t\\t}\\n\\t}\\n}\\n\\nram block $__GOWIN_SDP_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 36 per_port;\\n\\tcost 128;\\n\\tinit no_undef;\\n\\tport sr \\\"R\\\" {\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t\\toption \\\"RESET_MODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated;\\n\\t\\t}\\n\\t\\toption \\\"RESET_MODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t}\\n}\\n\",\n            \"brams_map.v\": \"`define DEF_FUNCS \\\\\\n\\tfunction [255:0] init_slice_x8; \\\\\\n\\t\\tinput integer idx; \\\\\\n\\t\\tinteger i; \\\\\\n\\t\\tfor (i = 0; i < 32; i = i + 1) begin \\\\\\n\\t\\t\\tinit_slice_x8[i*8+:8] = INIT[(idx * 32 + i) * 9+:8]; \\\\\\n\\t\\tend \\\\\\n\\tendfunction \\\\\\n\\tfunction [287:0] init_slice_x9; \\\\\\n\\t\\tinput integer idx; \\\\\\n\\t\\tinit_slice_x9 = INIT[idx * 288+:288]; \\\\\\n\\tendfunction \\\\\\n\\n`define x8_width(width) (width / 9 * 8 + width % 9)\\n`define x8_rd_data(data) {1'bx, data[31:24], 1'bx, data[23:16], 1'bx, data[15:8], 1'bx, data[7:0]}\\n`define x8_wr_data(data) {data[34:27], data[25:18], data[16:9], data[7:0]}\\n`define addrbe_always(width, addr) (width < 18 ? addr :  width == 18 ? {addr[13:4], 4'b0011} : {addr[13:5], 5'b01111})\\n\\n\\n`define INIT(func) \\\\\\n\\t.INIT_RAM_00(func('h00)), \\\\\\n\\t.INIT_RAM_01(func('h01)), \\\\\\n\\t.INIT_RAM_02(func('h02)), \\\\\\n\\t.INIT_RAM_03(func('h03)), \\\\\\n\\t.INIT_RAM_04(func('h04)), \\\\\\n\\t.INIT_RAM_05(func('h05)), \\\\\\n\\t.INIT_RAM_06(func('h06)), \\\\\\n\\t.INIT_RAM_07(func('h07)), \\\\\\n\\t.INIT_RAM_08(func('h08)), \\\\\\n\\t.INIT_RAM_09(func('h09)), \\\\\\n\\t.INIT_RAM_0A(func('h0a)), \\\\\\n\\t.INIT_RAM_0B(func('h0b)), \\\\\\n\\t.INIT_RAM_0C(func('h0c)), \\\\\\n\\t.INIT_RAM_0D(func('h0d)), \\\\\\n\\t.INIT_RAM_0E(func('h0e)), \\\\\\n\\t.INIT_RAM_0F(func('h0f)), \\\\\\n\\t.INIT_RAM_10(func('h10)), \\\\\\n\\t.INIT_RAM_11(func('h11)), \\\\\\n\\t.INIT_RAM_12(func('h12)), \\\\\\n\\t.INIT_RAM_13(func('h13)), \\\\\\n\\t.INIT_RAM_14(func('h14)), \\\\\\n\\t.INIT_RAM_15(func('h15)), \\\\\\n\\t.INIT_RAM_16(func('h16)), \\\\\\n\\t.INIT_RAM_17(func('h17)), \\\\\\n\\t.INIT_RAM_18(func('h18)), \\\\\\n\\t.INIT_RAM_19(func('h19)), \\\\\\n\\t.INIT_RAM_1A(func('h1a)), \\\\\\n\\t.INIT_RAM_1B(func('h1b)), \\\\\\n\\t.INIT_RAM_1C(func('h1c)), \\\\\\n\\t.INIT_RAM_1D(func('h1d)), \\\\\\n\\t.INIT_RAM_1E(func('h1e)), \\\\\\n\\t.INIT_RAM_1F(func('h1f)), \\\\\\n\\t.INIT_RAM_20(func('h20)), \\\\\\n\\t.INIT_RAM_21(func('h21)), \\\\\\n\\t.INIT_RAM_22(func('h22)), \\\\\\n\\t.INIT_RAM_23(func('h23)), \\\\\\n\\t.INIT_RAM_24(func('h24)), \\\\\\n\\t.INIT_RAM_25(func('h25)), \\\\\\n\\t.INIT_RAM_26(func('h26)), \\\\\\n\\t.INIT_RAM_27(func('h27)), \\\\\\n\\t.INIT_RAM_28(func('h28)), \\\\\\n\\t.INIT_RAM_29(func('h29)), \\\\\\n\\t.INIT_RAM_2A(func('h2a)), \\\\\\n\\t.INIT_RAM_2B(func('h2b)), \\\\\\n\\t.INIT_RAM_2C(func('h2c)), \\\\\\n\\t.INIT_RAM_2D(func('h2d)), \\\\\\n\\t.INIT_RAM_2E(func('h2e)), \\\\\\n\\t.INIT_RAM_2F(func('h2f)), \\\\\\n\\t.INIT_RAM_30(func('h30)), \\\\\\n\\t.INIT_RAM_31(func('h31)), \\\\\\n\\t.INIT_RAM_32(func('h32)), \\\\\\n\\t.INIT_RAM_33(func('h33)), \\\\\\n\\t.INIT_RAM_34(func('h34)), \\\\\\n\\t.INIT_RAM_35(func('h35)), \\\\\\n\\t.INIT_RAM_36(func('h36)), \\\\\\n\\t.INIT_RAM_37(func('h37)), \\\\\\n\\t.INIT_RAM_38(func('h38)), \\\\\\n\\t.INIT_RAM_39(func('h39)), \\\\\\n\\t.INIT_RAM_3A(func('h3a)), \\\\\\n\\t.INIT_RAM_3B(func('h3b)), \\\\\\n\\t.INIT_RAM_3C(func('h3c)), \\\\\\n\\t.INIT_RAM_3D(func('h3d)), \\\\\\n\\t.INIT_RAM_3E(func('h3e)), \\\\\\n\\t.INIT_RAM_3F(func('h3f)),\\n\\nmodule $__GOWIN_SP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESET_MODE = \\\"SYNC\\\";\\n\\nparameter PORT_A_WIDTH = 36;\\nparameter PORT_A_OPTION_WRITE_MODE = 0;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput PORT_A_WR_EN;\\ninput PORT_A_RD_SRST;\\ninput PORT_A_RD_ARST;\\ninput [13:0] PORT_A_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\n\\n`DEF_FUNCS\\n\\nwire RST = OPTION_RESET_MODE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST;\\nwire [13:0] AD = `addrbe_always(PORT_A_WIDTH, PORT_A_ADDR);\\n\\ngenerate\\n\\nif (PORT_A_WIDTH < 9) begin\\n\\n\\twire [31:0] DI = `x8_wr_data(PORT_A_WR_DATA);\\n\\twire [31:0] DO;\\n\\n\\tassign PORT_A_RD_DATA = `x8_rd_data(DO);\\n\\n\\tSP #(\\n\\t\\t`INIT(init_slice_x8)\\n\\t\\t.READ_MODE(1'b0),\\n\\t\\t.WRITE_MODE(PORT_A_OPTION_WRITE_MODE),\\n\\t\\t.BIT_WIDTH(`x8_width(PORT_A_WIDTH)),\\n\\t\\t.BLK_SEL(3'b000),\\n\\t\\t.RESET_MODE(OPTION_RESET_MODE),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.BLKSEL(3'b000),\\n\\t\\t.CLK(PORT_A_CLK),\\n\\t\\t.CE(PORT_A_CLK_EN),\\n\\t\\t.WRE(PORT_A_WR_EN),\\n\\t\\t.RESET(RST),\\n\\t\\t.OCE(1'b1),\\n\\t\\t.AD(AD),\\n\\t\\t.DI(DI),\\n\\t\\t.DO(DO),\\n\\t);\\n\\nend else begin\\n\\n\\twire [35:0] DI = PORT_A_WR_DATA;\\n\\twire [35:0] DO;\\n\\n\\tassign PORT_A_RD_DATA = DO;\\n\\n\\tSPX9 #(\\n\\t\\t`INIT(init_slice_x9)\\n\\t\\t.READ_MODE(1'b0),\\n\\t\\t.WRITE_MODE(PORT_A_OPTION_WRITE_MODE),\\n\\t\\t.BIT_WIDTH(PORT_A_WIDTH),\\n\\t\\t.BLK_SEL(3'b000),\\n\\t\\t.RESET_MODE(OPTION_RESET_MODE),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.BLKSEL(3'b000),\\n\\t\\t.CLK(PORT_A_CLK),\\n\\t\\t.CE(PORT_A_CLK_EN),\\n\\t\\t.WRE(PORT_A_WR_EN),\\n\\t\\t.RESET(RST),\\n\\t\\t.OCE(1'b1),\\n\\t\\t.AD(AD),\\n\\t\\t.DI(DI),\\n\\t\\t.DO(DO),\\n\\t);\\n\\nend\\n\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__GOWIN_DP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESET_MODE = \\\"SYNC\\\";\\n\\nparameter PORT_A_WIDTH = 18;\\nparameter PORT_A_OPTION_WRITE_MODE = 0;\\n\\nparameter PORT_B_WIDTH = 18;\\nparameter PORT_B_OPTION_WRITE_MODE = 0;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput PORT_A_WR_EN;\\ninput PORT_A_RD_SRST;\\ninput PORT_A_RD_ARST;\\ninput [13:0] PORT_A_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput PORT_B_WR_EN;\\ninput PORT_B_RD_SRST;\\ninput PORT_B_RD_ARST;\\ninput [13:0] PORT_B_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_B_WR_DATA;\\noutput [PORT_A_WIDTH-1:0] PORT_B_RD_DATA;\\n\\n`DEF_FUNCS\\n\\nwire RSTA = OPTION_RESET_MODE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST;\\nwire RSTB = OPTION_RESET_MODE == \\\"SYNC\\\" ? PORT_B_RD_SRST : PORT_B_RD_ARST;\\nwire [13:0] ADA = `addrbe_always(PORT_A_WIDTH, PORT_A_ADDR);\\nwire [13:0] ADB = `addrbe_always(PORT_B_WIDTH, PORT_B_ADDR);\\n\\ngenerate\\n\\nif (PORT_A_WIDTH < 9 || PORT_B_WIDTH < 9) begin\\n\\n\\twire [15:0] DIA = `x8_wr_data(PORT_A_WR_DATA);\\n\\twire [15:0] DIB = `x8_wr_data(PORT_B_WR_DATA);\\n\\twire [15:0] DOA;\\n\\twire [15:0] DOB;\\n\\n\\tassign PORT_A_RD_DATA = `x8_rd_data(DOA);\\n\\tassign PORT_B_RD_DATA = `x8_rd_data(DOB);\\n\\n\\tDPB #(\\n\\t\\t`INIT(init_slice_x8)\\n\\t\\t.READ_MODE0(1'b0),\\n\\t\\t.READ_MODE1(1'b0),\\n\\t\\t.WRITE_MODE0(PORT_A_OPTION_WRITE_MODE),\\n\\t\\t.WRITE_MODE1(PORT_B_OPTION_WRITE_MODE),\\n\\t\\t.BIT_WIDTH_0(`x8_width(PORT_A_WIDTH)),\\n\\t\\t.BIT_WIDTH_1(`x8_width(PORT_B_WIDTH)),\\n\\t\\t.BLK_SEL_0(3'b000),\\n\\t\\t.BLK_SEL_1(3'b000),\\n\\t\\t.RESET_MODE(OPTION_RESET_MODE),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.BLKSELA(3'b000),\\n\\t\\t.BLKSELB(3'b000),\\n\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CEA(PORT_A_CLK_EN),\\n\\t\\t.WREA(PORT_A_WR_EN),\\n\\t\\t.RESETA(RSTA),\\n\\t\\t.OCEA(1'b1),\\n\\t\\t.ADA(ADA),\\n\\t\\t.DIA(DIA),\\n\\t\\t.DOA(DOA),\\n\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.CEB(PORT_B_CLK_EN),\\n\\t\\t.WREB(PORT_B_WR_EN),\\n\\t\\t.RESETB(RSTB),\\n\\t\\t.OCEB(1'b1),\\n\\t\\t.ADB(ADB),\\n\\t\\t.DIB(DIB),\\n\\t\\t.DOB(DOB),\\n\\t);\\n\\nend else begin\\n\\n\\twire [17:0] DIA = PORT_A_WR_DATA;\\n\\twire [17:0] DIB = PORT_B_WR_DATA;\\n\\twire [17:0] DOA;\\n\\twire [17:0] DOB;\\n\\n\\tassign PORT_A_RD_DATA = DOA;\\n\\tassign PORT_B_RD_DATA = DOB;\\n\\n\\tDPX9B #(\\n\\t\\t`INIT(init_slice_x9)\\n\\t\\t.READ_MODE0(1'b0),\\n\\t\\t.READ_MODE1(1'b0),\\n\\t\\t.WRITE_MODE0(PORT_A_OPTION_WRITE_MODE),\\n\\t\\t.WRITE_MODE1(PORT_B_OPTION_WRITE_MODE),\\n\\t\\t.BIT_WIDTH_0(PORT_A_WIDTH),\\n\\t\\t.BIT_WIDTH_1(PORT_B_WIDTH),\\n\\t\\t.BLK_SEL_0(3'b000),\\n\\t\\t.BLK_SEL_1(3'b000),\\n\\t\\t.RESET_MODE(OPTION_RESET_MODE),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.BLKSELA(3'b000),\\n\\t\\t.BLKSELB(3'b000),\\n\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CEA(PORT_A_CLK_EN),\\n\\t\\t.WREA(PORT_A_WR_EN),\\n\\t\\t.RESETA(RSTA),\\n\\t\\t.OCEA(1'b1),\\n\\t\\t.ADA(ADA),\\n\\t\\t.DIA(DIA),\\n\\t\\t.DOA(DOA),\\n\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.CEB(PORT_B_CLK_EN),\\n\\t\\t.WREB(PORT_B_WR_EN),\\n\\t\\t.RESETB(RSTB),\\n\\t\\t.OCEB(1'b1),\\n\\t\\t.ADB(ADB),\\n\\t\\t.DIB(DIB),\\n\\t\\t.DOB(DOB),\\n\\t);\\n\\nend\\n\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__GOWIN_SDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESET_MODE = \\\"SYNC\\\";\\n\\nparameter PORT_R_WIDTH = 18;\\nparameter PORT_W_WIDTH = 18;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput PORT_R_RD_SRST;\\ninput PORT_R_RD_ARST;\\ninput [13:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput PORT_W_WR_EN;\\ninput [13:0] PORT_W_ADDR;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\n\\n`DEF_FUNCS\\n\\nwire RST = OPTION_RESET_MODE == \\\"SYNC\\\" ? PORT_R_RD_SRST : PORT_R_RD_ARST;\\nwire [13:0] ADW = `addrbe_always(PORT_W_WIDTH, PORT_W_ADDR);\\nwire WRE = PORT_W_CLK_EN & PORT_W_WR_EN;\\n\\ngenerate\\n\\nif (PORT_W_WIDTH < 9 || PORT_R_WIDTH < 9) begin\\n\\n\\twire [31:0] DI = `x8_wr_data(PORT_W_WR_DATA);\\n\\twire [31:0] DO;\\n\\n\\tassign PORT_R_RD_DATA = `x8_rd_data(DO);\\n\\n\\tSDPB #(\\n\\t\\t`INIT(init_slice_x8)\\n\\t\\t.READ_MODE(1'b0),\\n\\t\\t.BIT_WIDTH_0(`x8_width(PORT_W_WIDTH)),\\n\\t\\t.BIT_WIDTH_1(`x8_width(PORT_R_WIDTH)),\\n\\t\\t.BLK_SEL_0(3'b000),\\n\\t\\t.BLK_SEL_1(3'b000),\\n\\t\\t.RESET_MODE(OPTION_RESET_MODE),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.BLKSELA(3'b000),\\n\\t\\t.BLKSELB(3'b000),\\n\\n\\t\\t.CLKA(PORT_W_CLK),\\n\\t\\t.CEA(WRE),\\n\\t\\t.RESETA(1'b0),\\n\\t\\t.ADA(ADW),\\n\\t\\t.DI(DI),\\n\\n\\t\\t.CLKB(PORT_R_CLK),\\n\\t\\t.CEB(PORT_R_CLK_EN),\\n\\t\\t.RESETB(RST),\\n\\t\\t.OCE(1'b1),\\n\\t\\t.ADB(PORT_R_ADDR),\\n\\t\\t.DO(DO),\\n\\t);\\n\\nend else begin\\n\\n\\twire [35:0] DI = PORT_W_WR_DATA;\\n\\twire [35:0] DO;\\n\\n\\tassign PORT_R_RD_DATA = DO;\\n\\n\\tSDPX9B #(\\n\\t\\t`INIT(init_slice_x9)\\n\\t\\t.READ_MODE(1'b0),\\n\\t\\t.BIT_WIDTH_0(PORT_W_WIDTH),\\n\\t\\t.BIT_WIDTH_1(PORT_R_WIDTH),\\n\\t\\t.BLK_SEL_0(3'b000),\\n\\t\\t.BLK_SEL_1(3'b000),\\n\\t\\t.RESET_MODE(OPTION_RESET_MODE),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.BLKSELA(3'b000),\\n\\t\\t.BLKSELB(3'b000),\\n\\n\\t\\t.CLKA(PORT_W_CLK),\\n\\t\\t.CEA(WRE),\\n\\t\\t.RESETA(1'b0),\\n\\t\\t.ADA(ADW),\\n\\t\\t.DI(DI),\\n\\n\\t\\t.CLKB(PORT_R_CLK),\\n\\t\\t.CEB(PORT_R_CLK_EN),\\n\\t\\t.RESETB(RST),\\n\\t\\t.OCE(1'b1),\\n\\t\\t.ADB(PORT_R_ADDR),\\n\\t\\t.DO(DO),\\n\\t);\\n\\nend\\n\\nendgenerate\\n\\nendmodule\\n\",\n            \"cells_map.v\": \"`default_nettype none\\n//All DFF* have INIT, but the hardware is always initialised to the reset\\n//value regardless. The parameter is ignored.\\n\\n// DFFN\\t\\t\\t D Flip-Flop with Negative-Edge Clock\\nmodule\\t\\\\$_DFF_N_ (input D, C, output Q);\\n\\tDFFN _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFF\\t\\t\\t D Flip-Flop\\nmodule\\t\\\\$_DFF_P_ (input D, C, output Q);\\n\\tDFF _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFE\\t\\t\\t D Flip-Flop with Clock Enable\\nmodule\\t\\\\$_DFFE_PP_ (input D, C, E, output Q);\\n\\tDFFE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFNE\\t\\t D Flip-Flop with Negative-Edge Clock and Clock Enable\\nmodule\\t\\\\$_DFFE_NP_ (input D, C, E, output Q);\\n\\tDFFNE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFR\\t\\t\\t D Flip-Flop with Synchronous Reset\\nmodule\\t\\\\$_SDFF_PP0_ (input D, C, R, output Q);\\n\\tDFFR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFNR\\t\\t D Flip-Flop with Negative-Edge Clock and Synchronous Reset\\nmodule\\t\\\\$_SDFF_NP0_ (input D, C, R, output Q);\\n\\tDFFNR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFRE\\t\\t D Flip-Flop with Clock Enable and Synchronous Reset\\nmodule\\t\\\\$_SDFFE_PP0P_ (input D, C, R, E, output Q);\\n\\tDFFRE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFNRE\\t\\t D Flip-Flop with Negative-Edge Clock,Clock Enable, and Synchronous Reset\\nmodule\\t\\\\$_SDFFE_NP0P_ (input D, C, R, E, output Q);\\n\\tDFFNRE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .RESET(R), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFS\\t\\t\\t D Flip-Flop with Synchronous Set\\nmodule\\t\\\\$_SDFF_PP1_ (input D, C, R, output Q);\\n\\tDFFS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFNS\\t\\t D Flip-Flop with Negative-Edge Clock and Synchronous Set\\nmodule\\t\\\\$_SDFF_NP1_ (input D, C, R, output Q);\\n\\tDFFNS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFSE\\t\\t D Flip-Flop with Clock Enable and Synchronous Set\\nmodule\\t\\\\$_SDFFE_PP1P_ (input D, C, R, E, output Q);\\n\\tDFFSE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFNSE\\t\\t D Flip-Flop with Negative-Edge Clock,Clock Enable,and Synchronous Set\\nmodule\\t\\\\$_SDFFE_NP1P_ (input D, C, R, E, output Q);\\n\\tDFFNSE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .SET(R), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFP\\t\\t\\t D Flip-Flop with Asynchronous Preset\\nmodule\\t\\\\$_DFF_PP1_ (input D, C, R, output Q);\\n\\tDFFP _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFNP\\t\\t D Flip-Flop with Negative-Edge Clock and Asynchronous Preset\\nmodule\\t\\\\$_DFF_NP1_ (input D, C, R, output Q);\\n\\tDFFNP _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFC\\t\\t\\t D Flip-Flop with Asynchronous Clear\\nmodule\\t\\\\$_DFF_PP0_ (input D, C, R, output Q);\\n\\tDFFC _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFNC\\t\\t D Flip-Flop with Negative-Edge Clock and Asynchronous Clear\\nmodule\\t\\\\$_DFF_NP0_ (input D, C, R, output Q);\\n\\tDFFNC _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFPE\\t\\t D Flip-Flop with Clock Enable and Asynchronous Preset\\nmodule\\t\\\\$_DFFE_PP1P_ (input D, C, R, E, output Q);\\n\\tDFFPE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFNPE\\t\\t D Flip-Flop with Negative-Edge Clock,Clock Enable, and Asynchronous Preset\\nmodule\\t\\\\$_DFFE_NP1P_ (input D, C, R, E, output Q);\\n\\tDFFNPE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .PRESET(R), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFCE\\t\\t D Flip-Flop with Clock Enable and Asynchronous Clear\\nmodule\\t\\\\$_DFFE_PP0P_ (input D, C, R, E, output Q);\\n\\tDFFCE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// DFFNCE\\t\\t D Flip-Flop with Negative-Edge Clock,Clock Enable and Asynchronous Clear\\nmodule\\t\\\\$_DFFE_NP0P_ (input D, C, R, E, output Q);\\n\\tDFFNCE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CLEAR(R), .CE(E));\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\nmodule \\\\$lut (A, Y);\\n\\tparameter WIDTH = 0;\\n\\tparameter LUT = 0;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] A;\\n\\toutput Y;\\n\\n\\tgenerate\\n\\t\\tif (WIDTH == 1) begin\\n\\t\\t\\tLUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),\\n\\t\\t\\t\\t.I0(A[0]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 2) begin\\n\\t\\t\\tLUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),\\n\\t\\t\\t\\t.I0(A[0]), .I1(A[1]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 3) begin\\n\\t\\t\\tLUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),\\n\\t\\t\\t\\t.I0(A[0]), .I1(A[1]), .I2(A[2]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 4) begin\\n\\t\\t\\tLUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.F(Y),\\n\\t\\t\\t\\t.I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 5) begin\\n\\t\\t\\twire f0, f1;\\n\\t\\t\\t\\\\$lut #(.LUT(LUT[15: 0]), .WIDTH(4)) lut0 (.A(A[3:0]), .Y(f0));\\n\\t\\t\\t\\\\$lut #(.LUT(LUT[31:16]), .WIDTH(4)) lut1 (.A(A[3:0]), .Y(f1));\\n\\t\\t\\tMUX2_LUT5 mux5(.I0(f0), .I1(f1), .S0(A[4]), .O(Y));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 6) begin\\n\\t\\t\\twire f0, f1;\\n\\t\\t\\t\\\\$lut #(.LUT(LUT[31: 0]), .WIDTH(5)) lut0 (.A(A[4:0]), .Y(f0));\\n\\t\\t\\t\\\\$lut #(.LUT(LUT[63:32]), .WIDTH(5)) lut1 (.A(A[4:0]), .Y(f1));\\n\\t\\t\\tMUX2_LUT6 mux6(.I0(f0), .I1(f1), .S0(A[5]), .O(Y));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 7) begin\\n\\t\\t\\twire f0, f1;\\n\\t\\t\\t\\\\$lut #(.LUT(LUT[63: 0]), .WIDTH(6)) lut0 (.A(A[5:0]), .Y(f0));\\n\\t\\t\\t\\\\$lut #(.LUT(LUT[127:64]), .WIDTH(6)) lut1 (.A(A[5:0]), .Y(f1));\\n\\t\\t\\tMUX2_LUT7 mux7(.I0(f0), .I1(f1), .S0(A[6]), .O(Y));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 8) begin\\n\\t\\t\\twire f0, f1;\\n\\t\\t\\t\\\\$lut #(.LUT(LUT[127: 0]), .WIDTH(7)) lut0 (.A(A[6:0]), .Y(f0));\\n\\t\\t\\t\\\\$lut #(.LUT(LUT[255:128]), .WIDTH(7)) lut1 (.A(A[6:0]), .Y(f1));\\n\\t\\t\\tMUX2_LUT8 mux8(.I0(f0), .I1(f1), .S0(A[7]), .O(Y));\\n\\t\\tend else begin\\n\\t\\t\\twire _TECHMAP_FAIL_ = 1;\\n\\t\\tend\\n\\tendgenerate\\nendmodule\\n\",\n            \"cells_sim.v\": \"(* abc9_lut=1 *)\\nmodule LUT1(output F, input I0);\\n\\tparameter [1:0] INIT = 0;\\n\\tspecify\\n\\t\\t(I0 => F) = (555, 902);\\n\\tendspecify\\n\\tassign F = I0 ? INIT[1] : INIT[0];\\nendmodule\\n\\n(* abc9_lut=1 *)\\nmodule LUT2(output F, input I0, I1);\\n\\tparameter [3:0] INIT = 0;\\n\\tspecify\\n\\t\\t(I0 => F) = (867, 1184);\\n\\t\\t(I1 => F) = (555, 902);\\n\\tendspecify\\n\\twire [ 1: 0] s1 = I1 ? INIT[ 3: 2] : INIT[ 1: 0];\\n\\tassign F = I0 ? s1[1] : s1[0];\\nendmodule\\n\\n(* abc9_lut=1 *)\\nmodule LUT3(output F, input I0, I1, I2);\\n\\tparameter [7:0] INIT = 0;\\n\\tspecify\\n\\t\\t(I0 => F) = (1054, 1486);\\n\\t\\t(I1 => F) = (867, 1184);\\n\\t\\t(I2 => F) = (555, 902);\\n\\tendspecify\\t\\n\\twire [ 3: 0] s2 = I2 ? INIT[ 7: 4] : INIT[ 3: 0];\\n\\twire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n\\tassign F = I0 ? s1[1] : s1[0];\\nendmodule\\n\\n(* abc9_lut=1 *)\\nmodule LUT4(output F, input I0, I1, I2, I3);\\n\\tparameter [15:0] INIT = 0;\\n\\tspecify\\n\\t\\t(I0 => F) = (1054, 1486);\\n\\t\\t(I1 => F) = (1053, 1583);\\n\\t\\t(I2 => F) = (867, 1184);\\n\\t\\t(I3 => F) = (555, 902);\\n\\tendspecify\\t\\n\\twire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];\\n\\twire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];\\n\\twire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n\\tassign F = I0 ? s1[1] : s1[0];\\nendmodule\\n\\n(* abc9_lut=2 *)\\nmodule __APICULA_LUT5(output F, input I0, I1, I2, I3, M0);\\n\\tspecify\\n\\t\\t(I0 => F) = (1187, 1638);\\n\\t\\t(I1 => F) = (1184, 1638);\\n\\t\\t(I2 => F) = (995, 1371);\\n\\t\\t(I3 => F) = (808, 1116);\\n\\t\\t(M0 => F) = (486, 680);\\n\\tendspecify\\t\\nendmodule\\n\\n(* abc9_lut=4 *)\\nmodule __APICULA_LUT6(output F, input I0, I1, I2, I3, M0, M1);\\n\\tspecify\\n\\t\\t(I0 => F) = (1187 + 136, 1638 + 255);\\n\\t\\t(I1 => F) = (1184 + 136, 1638 + 255);\\n\\t\\t(I2 => F) = (995 + 136, 1371 + 255);\\n\\t\\t(I3 => F) = (808 + 136, 1116 + 255);\\n\\t\\t(M0 => F) = (486 + 136, 680 + 255);\\n\\t\\t(M1 => F) = (478, 723);\\n\\tendspecify\\t\\nendmodule\\n\\n(* abc9_lut=8 *)\\nmodule __APICULA_LUT7(output F, input I0, I1, I2, I3, M0, M1, M2);\\n\\tspecify\\n\\t\\t(I0 => F) = (1187 + 136 + 136, 1638 + 255 + 255);\\n\\t\\t(I1 => F) = (1184 + 136 + 136, 1638 + 255 + 255);\\n\\t\\t(I2 => F) = (995 + 136 + 136, 1371 + 255 + 255);\\n\\t\\t(I3 => F) = (808 + 136 + 136, 1116 + 255 + 255);\\n\\t\\t(M0 => F) = (486 + 136 + 136, 680 + 255 + 255);\\n\\t\\t(M1 => F) = (478 + 136, 723 + 255);\\n\\t\\t(M2 => F) = (478, 723);\\n\\tendspecify\\t\\nendmodule\\n\\n(* abc9_lut=16 *)\\nmodule __APICULA_LUT8(output F, input I0, I1, I2, I3, M0, M1, M2, M3);\\n\\t\\tspecify\\n\\t\\t(I0 => F) = (1187 + 136 + 136 + 136, 1638 + 255 + 255 + 255);\\n\\t\\t(I1 => F) = (1184 + 136 + 136 + 136, 1638 + 255 + 255 + 255);\\n\\t\\t(I2 => F) = (995 + 136 + 136 + 136, 1371 + 255 + 255 + 255);\\n\\t\\t(I3 => F) = (808 + 136 + 136 + 136, 1116 + 255 + 255 + 255);\\n\\t\\t(M0 => F) = (486 + 136 + 136 + 136, 680 + 255 + 255 + 255);\\n\\t\\t(M1 => F) = (478 + 136 + 136, 723 + 255 + 255);\\n\\t\\t(M2 => F) = (478 + 136, 723 + 255);\\n\\t\\t(M3 => F) = (478, 723);\\n\\t\\tendspecify\\t\\n\\tendmodule\\n\\nmodule MUX2 (O, I0, I1, S0);\\n  input I0,I1;\\n  input S0;\\n  output O;\\n\\n\\tspecify\\n\\t\\t(I0 => O) = (141, 160);\\n\\t\\t(I1 => O) = (141, 160);\\n\\t\\t(S0 => O) = (486, 680);\\n\\tendspecify\\n\\n  assign O = S0 ? I1 : I0;\\nendmodule\\n\\nmodule MUX2_LUT5 (O, I0, I1, S0);\\n  input I0,I1;\\n  input S0;\\n  output O;\\n\\n\\tspecify\\n\\t\\t(I0 => O) = (141, 160);\\n\\t\\t(I1 => O) = (141, 160);\\n\\t\\t(S0 => O) = (486, 680);\\n\\tendspecify\\n\\n  MUX2 mux2_lut5 (O, I0, I1, S0);\\nendmodule\\n\\nmodule MUX2_LUT6 (O, I0, I1, S0);\\n  input I0,I1;\\n  input S0;\\n  output O;\\n\\n\\tspecify\\n\\t\\t(I0 => O) = (136, 255);\\n\\t\\t(I1 => O) = (136, 255);\\n\\t\\t(S0 => O) = (478, 723);\\n\\tendspecify\\n\\n  MUX2 mux2_lut6 (O, I0, I1, S0);\\nendmodule\\n\\nmodule MUX2_LUT7 (O, I0, I1, S0);\\n  input I0,I1;\\n  input S0;\\n  output O;\\n\\n\\tspecify\\n\\t\\t(I0 => O) = (136, 255);\\n\\t\\t(I1 => O) = (136, 255);\\n\\t\\t(S0 => O) = (478, 723);\\n\\tendspecify\\n\\n  MUX2 mux2_lut7 (O, I0, I1, S0);\\nendmodule\\n\\nmodule MUX2_LUT8 (O, I0, I1, S0);\\n  input I0,I1;\\n  input S0;\\n  output O;\\n\\n\\tspecify\\n\\t\\t(I0 => O) = (136, 255);\\n\\t\\t(I1 => O) = (136, 255);\\n\\t\\t(S0 => O) = (478, 723);\\n\\tendspecify\\n\\n  MUX2 mux2_lut8 (O, I0, I1, S0);\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFF (output reg Q, input CLK, D);\\n\\tparameter [0:0] INIT = 1'b0;\\n\\tinitial Q = INIT;\\n\\n\\tspecify\\n\\t\\t(posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, posedge CLK, 576);\\n\\tendspecify\\n\\n\\talways @(posedge CLK)\\n\\t\\tQ <= D;\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFE (output reg Q, input D, CLK, CE);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\tif (CE) (posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, posedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, posedge CLK, 63);\\n\\tendspecify\\n\\n  always @(posedge CLK) begin\\n    if (CE)\\n      Q <= D;\\n  end\\nendmodule // DFFE (positive clock edge; clock enable)\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFS (output reg Q, input D, CLK, SET);\\n  parameter [0:0] INIT = 1'b1;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\t(posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, posedge CLK, 576);\\n\\t\\t$setup(SET, posedge CLK, 63);\\n\\tendspecify\\n\\n  always @(posedge CLK) begin\\n    if (SET)\\n      Q <= 1'b1;\\n    else\\n      Q <= D;\\t\\n  end\\nendmodule // DFFS (positive clock edge; synchronous set)\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFSE (output reg Q, input D, CLK, CE, SET);\\n  parameter [0:0] INIT = 1'b1;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\tif (CE) (posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, posedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, posedge CLK, 63);\\n\\t\\t$setup(SET, posedge CLK, 63);\\n\\tendspecify\\n\\n  always @(posedge CLK) begin\\n    if (SET)\\n      Q <= 1'b1;\\n    else if (CE)\\n      Q <= D;\\nend\\nendmodule // DFFSE (positive clock edge; synchronous set takes precedence over clock enable)\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFR (output reg Q, input D, CLK, RESET);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\t(posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, posedge CLK, 576);\\n\\t\\t$setup(RESET, posedge CLK, 63);\\n\\tendspecify\\n\\n  always @(posedge CLK) begin\\n    if (RESET)\\n      Q <= 1'b0;\\n    else\\n      Q <= D;\\n  end\\nendmodule // DFFR (positive clock edge; synchronous reset)\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFRE (output reg Q, input D, CLK, CE, RESET);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\tif (CE) (posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, posedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, posedge CLK, 63);\\n\\t\\t$setup(RESET, posedge CLK, 63);\\n\\tendspecify\\n\\n  always @(posedge CLK) begin\\n    if (RESET)\\n      Q <= 1'b0;\\n    else if (CE)\\n      Q <= D;\\n  end\\nendmodule // DFFRE (positive clock edge; synchronous reset takes precedence over clock enable)\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DFFP (output reg Q, input D, CLK, PRESET);\\n  parameter [0:0] INIT = 1'b1;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\t(posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t(PRESET => Q) = (1800, 2679);\\n\\t\\t$setup(D, posedge CLK, 576);\\n\\tendspecify\\n\\n  always @(posedge CLK or posedge PRESET) begin\\n    if(PRESET)\\n      Q <= 1'b1;\\n    else\\n      Q <= D;\\n  end\\nendmodule // DFFP (positive clock edge; asynchronous preset)\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DFFPE (output reg Q, input D, CLK, CE, PRESET);\\n  parameter [0:0] INIT = 1'b1;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\tif (CE) (posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t(PRESET => Q) = (1800, 2679);\\n\\t\\t$setup(D, posedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, posedge CLK, 63);\\n\\tendspecify\\n\\n  always @(posedge CLK or posedge PRESET) begin\\n    if(PRESET)\\n      Q <= 1'b1;\\n    else if (CE)\\n      Q <= D;\\n  end\\nendmodule // DFFPE (positive clock edge; asynchronous preset; clock enable)\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DFFC (output reg Q, input D, CLK, CLEAR);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\t(posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t(CLEAR => Q) = (1800, 2679);\\n\\t\\t$setup(D, posedge CLK, 576);\\n\\tendspecify\\n\\n  always @(posedge CLK or posedge CLEAR) begin\\n    if(CLEAR)\\n      Q <= 1'b0;\\n    else\\n      Q <= D;\\n  end\\nendmodule // DFFC (positive clock edge; asynchronous clear)\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DFFCE (output reg Q, input D, CLK, CE, CLEAR);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\tif (CE) (posedge CLK => (Q : D)) = (480, 660);\\n\\t\\t(CLEAR => Q) = (1800, 2679);\\n\\t\\t$setup(D, posedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, posedge CLK, 63);\\n\\tendspecify\\n\\n  always @(posedge CLK or posedge CLEAR) begin\\n    if(CLEAR)\\n      Q <= 1'b0;\\n    else if (CE)\\n      Q <= D;\\n  end\\nendmodule // DFFCE (positive clock edge; asynchronous clear; clock enable)\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFN (output reg Q, input CLK, D);\\n\\tparameter [0:0] INIT = 1'b0;\\n\\tinitial Q = INIT;\\n\\n  specify\\n    (negedge CLK => (Q : D)) = (480, 660);\\n    $setup(D, negedge CLK, 576);\\n  endspecify\\n\\n\\talways @(negedge CLK)\\n\\t\\tQ <= D;\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFNE (output reg Q, input D, CLK, CE);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\tif (CE) (negedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, negedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, negedge CLK, 63);\\n\\tendspecify\\n\\n  always @(negedge CLK) begin\\n    if (CE)\\n      Q <= D;\\n  end\\nendmodule // DFFNE (negative clock edge; clock enable)\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFNS (output reg Q, input D, CLK, SET);\\n  parameter [0:0] INIT = 1'b1;\\n  initial Q = INIT;\\n  \\n\\tspecify\\n\\t\\t(negedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, negedge CLK, 576);\\n\\t\\t$setup(SET, negedge CLK, 63);\\n\\tendspecify\\n\\n  always @(negedge CLK) begin\\n    if (SET)\\n      Q <= 1'b1;\\n    else\\n      Q <= D;\\t\\n  end\\nendmodule // DFFNS (negative clock edge; synchronous set)\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFNSE (output reg Q, input D, CLK, CE, SET);\\n  parameter [0:0] INIT = 1'b1;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\tif (CE) (negedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, negedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, negedge CLK, 63);\\n\\t\\t$setup(SET, negedge CLK, 63);\\n\\tendspecify\\n\\n  always @(negedge CLK) begin\\n    if (SET)\\n      Q <= 1'b1;\\n    else if (CE)\\n      Q <= D;\\nend\\nendmodule // DFFNSE (negative clock edge; synchronous set takes precedence over clock enable)\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFNR (output reg Q, input D, CLK, RESET);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\t(negedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, negedge CLK, 576);\\n\\t\\t$setup(RESET, negedge CLK, 63);\\n\\tendspecify\\n\\n  always @(negedge CLK) begin\\n    if (RESET)\\n      Q <= 1'b0;\\n    else\\n      Q <= D;\\n  end\\nendmodule // DFFNR (negative clock edge; synchronous reset)\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule DFFNRE (output reg Q, input D, CLK, CE, RESET);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\tif (CE) (negedge CLK => (Q : D)) = (480, 660);\\n\\t\\t$setup(D, negedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, negedge CLK, 63);\\n\\t\\t$setup(RESET, negedge CLK, 63);\\n\\tendspecify\\n\\n  always @(negedge CLK) begin\\n    if (RESET)\\n      Q <= 1'b0;\\n    else if (CE)\\n      Q <= D;\\n  end\\nendmodule // DFFNRE (negative clock edge; synchronous reset takes precedence over clock enable)\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DFFNP (output reg Q, input D, CLK, PRESET);\\n  parameter [0:0] INIT = 1'b1;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\t(negedge CLK => (Q : D)) = (480, 660);\\n\\t\\t(PRESET => Q) = (1800, 2679);\\n\\t\\t$setup(D, negedge CLK, 576);\\n\\tendspecify\\n\\n  always @(negedge CLK or posedge PRESET) begin\\n    if(PRESET)\\n      Q <= 1'b1;\\n    else\\n      Q <= D;\\n  end\\nendmodule // DFFNP (negative clock edge; asynchronous preset)\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DFFNPE (output reg Q, input D, CLK, CE, PRESET);\\n  parameter [0:0] INIT = 1'b1;\\n  initial Q = INIT;\\n  \\n\\tspecify\\n\\t\\tif (CE) (negedge CLK => (Q : D)) = (480, 660);\\n\\t\\t(PRESET => Q) = (1800, 2679);\\n\\t\\t$setup(D, negedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, negedge CLK, 63);\\n\\tendspecify\\n\\n  always @(negedge CLK or posedge PRESET) begin\\n    if(PRESET)\\n      Q <= 1'b1;\\n    else if (CE)\\n      Q <= D;\\n  end\\nendmodule // DFFNPE (negative clock edge; asynchronous preset; clock enable)\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DFFNC (output reg Q, input D, CLK, CLEAR);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\t(negedge CLK => (Q : D)) = (480, 660);\\n\\t\\t(CLEAR => Q) = (1800, 2679);\\n\\t\\t$setup(D, negedge CLK, 576);\\n\\tendspecify\\n\\n  always @(negedge CLK or posedge CLEAR) begin\\n    if(CLEAR)\\n      Q <= 1'b0;\\n    else\\n      Q <= D;\\n  end\\nendmodule // DFFNC (negative clock edge; asynchronous clear)\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DFFNCE (output reg Q, input D, CLK, CE, CLEAR);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n\\tspecify\\n\\t\\tif (CE) (negedge CLK => (Q : D)) = (480, 660);\\n\\t\\t(CLEAR => Q) = (1800, 2679);\\n\\t\\t$setup(D, negedge CLK &&& CE, 576);\\n\\t\\t$setup(CE, negedge CLK, 63);\\n\\tendspecify\\n\\n  always @(negedge CLK or posedge CLEAR) begin\\n    if(CLEAR)\\n      Q <= 1'b0;\\n    else if (CE)\\n      Q <= D;\\n  end\\nendmodule // DFFNCE (negative clock edge; asynchronous clear; clock enable)\\n\\n// TODO add more DFF sim cells\\n\\nmodule VCC(output V);\\n\\tassign V = 1;\\nendmodule\\n\\nmodule GND(output G);\\n\\tassign G = 0;\\nendmodule\\n\\nmodule IBUF(output O, input I);\\n\\n\\tspecify\\n\\t\\t(I => O) = 0;\\n\\tendspecify\\n\\n\\tassign O = I;\\nendmodule\\n\\nmodule OBUF(output O, input I);\\n\\n\\tspecify\\n\\t\\t(I => O) = 0;\\n\\tendspecify\\n\\n\\tassign O = I;\\nendmodule\\n\\nmodule TBUF (O, I, OEN);\\n  input I, OEN;\\n  output O;\\n  assign O = OEN ? 1'bz : I;\\nendmodule\\n\\nmodule IOBUF (O, IO, I, OEN);\\n  input I,OEN;\\n  output O;\\n  inout IO;\\n  assign IO = OEN ? 1'bz : I;\\n  assign I = IO;\\nendmodule\\n\\nmodule ELVDS_OBUF (I, O, OB);\\n  input I;\\n  output O;\\n  output OB;\\n  assign O = I;\\n  assign OB = ~I;\\nendmodule\\n\\nmodule TLVDS_OBUF (I, O, OB);\\n  input I;\\n  output O;\\n  output OB;\\n  assign O = I;\\n  assign OB = ~I;\\nendmodule\\n\\nmodule OSER4(D3, D2, D1, D0, TX1, TX0, FCLK, PCLK, RESET, Q1, Q0);\\n\\toutput Q1;\\n\\toutput Q0;\\n\\n\\tinput D3;\\n\\tinput D2;\\n\\tinput D1;\\n\\tinput D0;\\n\\tinput TX1;\\n\\tinput TX0;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\n\\tparameter TXCLK_POL = 0;\\n\\tparameter HWL = \\\"false\\\";\\nendmodule\\n\\nmodule OSER8(D7, D6, D5, D4, D3, D2, D1, D0, TX3, TX2, TX1, TX0, FCLK, PCLK, RESET, Q1, Q0);\\n\\toutput Q1;\\n\\toutput Q0;\\n\\n\\tinput D7;\\n\\tinput D6;\\n\\tinput D5;\\n\\tinput D4;\\n\\tinput D3;\\n\\tinput D2;\\n\\tinput D1;\\n\\tinput D0;\\n\\tinput TX3;\\n\\tinput TX2;\\n\\tinput TX1;\\n\\tinput TX0;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\n\\tparameter TXCLK_POL = 0;\\n\\tparameter HWL = \\\"false\\\";\\nendmodule\\n\\nmodule OSER10(D9, D8, D7, D6, D5, D4, D3, D2, D1, D0, FCLK, PCLK, RESET, Q);\\n\\toutput Q;\\n\\n\\tinput D9;\\n\\tinput D8;\\n\\tinput D7;\\n\\tinput D6;\\n\\tinput D5;\\n\\tinput D4;\\n\\tinput D3;\\n\\tinput D2;\\n\\tinput D1;\\n\\tinput D0;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\nendmodule\\n\\nmodule OVIDEO(D6, D5, D4, D3, D2, D1, D0, FCLK, PCLK, RESET, Q);\\n\\toutput Q;\\n\\n\\tinput D6;\\n\\tinput D5;\\n\\tinput D4;\\n\\tinput D3;\\n\\tinput D2;\\n\\tinput D1;\\n\\tinput D0;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\nendmodule\\n\\nmodule OSER16(D15, D14, D13, D12, D11, D10, \\nD9, D8, D7, D6, D5, D4, D3, D2, D1, D0, FCLK, PCLK,\\nRESET, Q);\\n\\toutput Q;\\n\\n\\tinput D15;\\n\\tinput D14;\\n\\tinput D13;\\n\\tinput D12;\\n\\tinput D11;\\n\\tinput D10;\\n\\tinput D9;\\n\\tinput D8;\\n\\tinput D7;\\n\\tinput D6;\\n\\tinput D5;\\n\\tinput D4;\\n\\tinput D3;\\n\\tinput D2;\\n\\tinput D1;\\n\\tinput D0;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\nendmodule\\n\\nmodule IDES4(Q3, Q2, Q1, Q0, FCLK, PCLK,\\nRESET, CALIB, D);\\n\\tinput D;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\tinput CALIB;\\n\\n\\toutput Q3;\\n\\toutput Q2;\\n\\toutput Q1;\\n\\toutput Q0;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\nendmodule\\n\\nmodule IDES8(Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,\\nRESET, CALIB, D);\\n\\tinput D;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\tinput CALIB;\\n\\n\\toutput Q7;\\n\\toutput Q6;\\n\\toutput Q5;\\n\\toutput Q4;\\n\\toutput Q3;\\n\\toutput Q2;\\n\\toutput Q1;\\n\\toutput Q0;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\nendmodule\\n\\nmodule IDES10(Q9, Q8, Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,\\nRESET, CALIB, D);\\n\\tinput D;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\tinput CALIB;\\n\\n\\toutput Q9;\\n\\toutput Q8;\\n\\toutput Q7;\\n\\toutput Q6;\\n\\toutput Q5;\\n\\toutput Q4;\\n\\toutput Q3;\\n\\toutput Q2;\\n\\toutput Q1;\\n\\toutput Q0;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\nendmodule\\n\\nmodule IVIDEO(Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,\\nRESET, CALIB, D);\\n\\tinput D;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\tinput CALIB;\\n\\n\\toutput Q6;\\n\\toutput Q5;\\n\\toutput Q4;\\n\\toutput Q3;\\n\\toutput Q2;\\n\\toutput Q1;\\n\\toutput Q0;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\nendmodule\\n\\nmodule IDES16(Q15, Q14, Q13, Q12, Q11, Q10, \\nQ9, Q8, Q7, Q6, Q5, Q4, Q3, Q2, Q1, Q0, FCLK, PCLK,\\nRESET, CALIB, D);\\n\\tinput D;\\n\\tinput FCLK;\\n\\tinput PCLK;\\n\\tinput RESET;\\n\\tinput CALIB;\\n\\n\\toutput Q15;\\n\\toutput Q14;\\n\\toutput Q13;\\n\\toutput Q12;\\n\\toutput Q11;\\n\\toutput Q10;\\n\\toutput Q9;\\n\\toutput Q8;\\n\\toutput Q7;\\n\\toutput Q6;\\n\\toutput Q5;\\n\\toutput Q4;\\n\\toutput Q3;\\n\\toutput Q2;\\n\\toutput Q1;\\n\\toutput Q0;\\n\\n\\tparameter GSREN = \\\"false\\\";\\n\\tparameter LSREN = \\\"true\\\";\\nendmodule\\n\\nmodule IDDR(D, CLK, Q0, Q1);\\n\\tinput D;\\n\\tinput CLK;\\n\\toutput Q0;\\n\\toutput Q1;\\n\\tparameter Q0_INIT = 1'b0;\\n\\tparameter Q1_INIT = 1'b0;\\nendmodule\\n\\nmodule IDDRC(D, CLK, CLEAR, Q0, Q1);\\n\\tinput D;\\n\\tinput CLK;\\n\\tinput CLEAR;\\n\\toutput Q0;\\n\\toutput Q1;\\n\\tparameter Q0_INIT = 1'b0;\\n\\tparameter Q1_INIT = 1'b0;\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDR(D0, D1, TX, CLK, Q0, Q1);\\n\\tinput D0;\\n\\tinput D1;\\n\\tinput TX;\\n\\tinput CLK;\\n\\toutput Q0;\\n\\toutput Q1;\\n\\tparameter TXCLK_POL = 0;\\n\\tparameter INIT = 0;\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDRC(D0, D1, CLEAR, TX, CLK, Q0, Q1);\\n\\tinput D0;\\n\\tinput D1;\\n\\tinput CLEAR;\\n\\tinput TX;\\n\\tinput CLK;\\n\\toutput Q0;\\n\\toutput Q1;\\n\\tparameter TXCLK_POL = 0;\\n\\tparameter INIT = 0;\\nendmodule\\n\\nmodule GSR (input GSRI);\\n\\twire GSRO = GSRI;\\nendmodule\\n\\n(* abc9_box, lib_whitebox *)\\nmodule ALU (SUM, COUT, I0, I1, I3, CIN);\\n\\ninput I0;\\ninput I1;\\ninput I3;\\n(* abc9_carry *) input CIN;\\noutput SUM;\\n(* abc9_carry *) output COUT;\\n\\nlocalparam ADD = 0;\\nlocalparam SUB = 1;\\nlocalparam ADDSUB = 2;\\nlocalparam NE = 3;\\nlocalparam GE = 4;\\nlocalparam LE = 5;\\nlocalparam CUP = 6;\\nlocalparam CDN = 7;\\nlocalparam CUPCDN = 8;\\nlocalparam MULT = 9;\\n\\nparameter ALU_MODE = 0;\\n\\nreg S, C;\\n\\nspecify\\n\\t(I0 => SUM) = (1043, 1432);\\n\\t(I1 => SUM) = (775, 1049);\\n\\t(I3 => SUM) = (751, 1010);\\n\\t(CIN => SUM) = (694, 811);\\n\\t(I0  => COUT) = (1010, 1380);\\n\\t(I1  => COUT) = (1021, 1505);\\n\\t(I3  => COUT) = (483, 792);\\n\\t(CIN => COUT) = (49, 82);\\nendspecify\\n\\nassign SUM = S ^ CIN;\\nassign COUT = S? CIN : C;\\n\\nalways @* begin\\n\\tcase (ALU_MODE)\\n\\t\\tADD: begin\\n\\t\\t\\tS = I0 ^ I1;\\n\\t\\t\\tC = I0;\\n\\t\\tend\\n\\t\\tSUB: begin\\n\\t\\t\\tS = I0 ^ ~I1;\\n\\t\\t\\tC = I0;\\n\\t\\tend\\n\\t\\tADDSUB: begin\\n\\t\\t\\tS = I3? I0 ^ I1 : I0 ^ ~I1;\\n\\t\\t\\tC = I0;\\n\\t\\tend\\n\\t\\tNE: begin\\n\\t\\t\\tS = I0 ^ ~I1;\\n\\t\\t\\tC = 1'b1;\\n\\t\\tend\\n\\t\\tGE: begin\\n\\t\\t\\tS = I0 ^ ~I1;\\n\\t\\t\\tC = I0;\\n\\t\\tend\\n\\t\\tLE: begin\\n\\t\\t\\tS = ~I0 ^ I1;\\n\\t\\t\\tC = I1;\\n\\t\\tend\\n\\t\\tCUP: begin\\n\\t\\t\\tS = I0;\\n\\t\\t\\tC = 1'b0;\\n\\t\\tend\\n\\t\\tCDN: begin\\n\\t\\t\\tS = ~I0;\\n\\t\\t\\tC = 1'b1;\\n\\t\\tend\\n\\t\\tCUPCDN: begin\\n\\t\\t\\tS = I3? I0 : ~I0;\\n\\t\\t\\tC = I0;\\n\\t\\tend\\n\\t\\tMULT: begin\\n\\t\\t\\tS = I0 & I1;\\n\\t\\t\\tC = I0 & I1;\\n\\t\\tend\\n\\tendcase\\nend\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule RAM16S1 (DO, DI, AD, WRE, CLK);\\n\\nparameter INIT_0 = 16'h0000;\\n\\ninput [3:0] AD;\\ninput DI;\\noutput DO;\\ninput CLK;\\ninput WRE;\\n\\nspecify\\n\\t(AD *> DO) = (270, 405);\\n\\t$setup(DI, posedge CLK, 62);\\n\\t$setup(WRE, posedge CLK, 62);\\n\\t$setup(AD, posedge CLK, 62);\\n\\t(posedge CLK => (DO : 1'bx)) = (474, 565);\\nendspecify\\n\\nreg [15:0] mem;\\n\\ninitial begin\\n\\tmem = INIT_0;\\nend\\n\\nassign DO = mem[AD];\\n\\nalways @(posedge CLK) begin\\n\\tif (WRE) begin\\n\\t\\tmem[AD] <= DI;\\n\\tend\\nend\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule RAM16S2 (DO, DI, AD, WRE, CLK);\\n\\nparameter INIT_0 = 16'h0000;\\nparameter INIT_1 = 16'h0000;\\n\\ninput [3:0] AD;\\ninput [1:0] DI;\\noutput [1:0] DO;\\ninput CLK;\\ninput WRE;\\n\\nspecify\\n\\t(AD *> DO) = (270, 405);\\n\\t$setup(DI, posedge CLK, 62);\\n\\t$setup(WRE, posedge CLK, 62);\\n\\t$setup(AD, posedge CLK, 62);\\n\\t(posedge CLK => (DO : 2'bx)) = (474, 565);\\nendspecify\\n\\nreg [15:0] mem0, mem1;\\n\\ninitial begin\\n\\tmem0 = INIT_0;\\n\\tmem1 = INIT_1;\\nend\\n\\nassign DO[0] = mem0[AD];\\nassign DO[1] = mem1[AD];\\n\\nalways @(posedge CLK) begin\\n\\tif (WRE) begin\\n\\t\\tmem0[AD] <= DI[0];\\n\\t\\tmem1[AD] <= DI[1];\\n\\tend\\nend\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule RAM16S4 (DO, DI, AD, WRE, CLK);\\n\\nparameter INIT_0 = 16'h0000;\\nparameter INIT_1 = 16'h0000;\\nparameter INIT_2 = 16'h0000;\\nparameter INIT_3 = 16'h0000;\\n\\ninput [3:0] AD;\\ninput [3:0] DI;\\noutput [3:0] DO;\\ninput CLK;\\ninput WRE;\\n\\nspecify\\n\\t(AD *> DO) = (270, 405);\\n\\t$setup(DI, posedge CLK, 62);\\n\\t$setup(WRE, posedge CLK, 62);\\n\\t$setup(AD, posedge CLK, 62);\\n\\t(posedge CLK => (DO : 4'bx)) = (474, 565);\\nendspecify\\n\\nreg [15:0] mem0, mem1, mem2, mem3;\\n\\ninitial begin\\n\\tmem0 = INIT_0;\\n\\tmem1 = INIT_1;\\n\\tmem2 = INIT_2;\\n\\tmem3 = INIT_3;\\nend\\n\\nassign DO[0] = mem0[AD];\\nassign DO[1] = mem1[AD];\\nassign DO[2] = mem2[AD];\\nassign DO[3] = mem3[AD];\\n\\nalways @(posedge CLK) begin\\n\\tif (WRE) begin\\n\\t\\tmem0[AD] <= DI[0];\\n\\t\\tmem1[AD] <= DI[1];\\n\\t\\tmem2[AD] <= DI[2];\\n\\t\\tmem3[AD] <= DI[3];\\n\\tend\\nend\\n\\nendmodule\\n\\n\\nmodule RAM16SDP1 (DO, DI, WAD, RAD, WRE, CLK);\\n\\nparameter INIT_0 = 16'h0000;\\n\\ninput [3:0] WAD;\\ninput [3:0] RAD;\\ninput DI;\\noutput DO;\\ninput CLK;\\ninput WRE;\\n\\nspecify\\n\\t(RAD *> DO) = (270, 405);\\n\\t$setup(DI, posedge CLK, 62);\\n\\t$setup(WRE, posedge CLK, 62);\\n\\t$setup(WAD, posedge CLK, 62);\\n\\t(posedge CLK => (DO : 1'bx)) = (474, 565);\\nendspecify\\n\\nreg [15:0] mem;\\n\\ninitial begin\\n\\tmem = INIT_0;\\nend\\n\\nassign DO = mem[RAD];\\n\\nalways @(posedge CLK) begin\\n\\tif (WRE) begin\\n\\t\\tmem[WAD] <= DI;\\n\\tend\\nend\\n\\nendmodule\\n\\n\\nmodule RAM16SDP2 (DO, DI, WAD, RAD, WRE, CLK);\\n\\nparameter INIT_0 = 16'h0000;\\nparameter INIT_1 = 16'h0000;\\n\\ninput [3:0] WAD;\\ninput [3:0] RAD;\\ninput [1:0] DI;\\noutput [1:0] DO;\\ninput CLK;\\ninput WRE;\\n\\nspecify\\n\\t(RAD *> DO) = (270, 405);\\n\\t$setup(DI, posedge CLK, 62);\\n\\t$setup(WRE, posedge CLK, 62);\\n\\t$setup(WAD, posedge CLK, 62);\\n\\t(posedge CLK => (DO : 2'bx)) = (474, 565);\\nendspecify\\n\\nreg [15:0] mem0, mem1;\\n\\ninitial begin\\n\\tmem0 = INIT_0;\\n\\tmem1 = INIT_1;\\nend\\n\\nassign DO[0] = mem0[RAD];\\nassign DO[1] = mem1[RAD];\\n\\nalways @(posedge CLK) begin\\n\\tif (WRE) begin\\n\\t\\tmem0[WAD] <= DI[0];\\n\\t\\tmem1[WAD] <= DI[1];\\n\\tend\\nend\\n\\nendmodule\\n\\n\\nmodule RAM16SDP4 (DO, DI, WAD, RAD, WRE, CLK);\\n\\nparameter INIT_0 = 16'h0000;\\nparameter INIT_1 = 16'h0000;\\nparameter INIT_2 = 16'h0000;\\nparameter INIT_3 = 16'h0000;\\n\\ninput [3:0] WAD;\\ninput [3:0] RAD;\\ninput [3:0] DI;\\noutput [3:0] DO;\\ninput CLK;\\ninput WRE;\\n\\nspecify\\n\\t(RAD *> DO) = (270, 405);\\n\\t$setup(DI, posedge CLK, 62);\\n\\t$setup(WRE, posedge CLK, 62);\\n\\t$setup(WAD, posedge CLK, 62);\\n\\t(posedge CLK => (DO : 4'bx)) = (474, 565);\\nendspecify\\n\\nreg [15:0] mem0, mem1, mem2, mem3;\\n\\ninitial begin\\n\\tmem0 = INIT_0;\\n\\tmem1 = INIT_1;\\n\\tmem2 = INIT_2;\\n\\tmem3 = INIT_3;\\nend\\n\\nassign DO[0] = mem0[RAD];\\nassign DO[1] = mem1[RAD];\\nassign DO[2] = mem2[RAD];\\nassign DO[3] = mem3[RAD];\\n\\nalways @(posedge CLK) begin\\n\\tif (WRE) begin\\n\\t\\tmem0[WAD] <= DI[0];\\n\\t\\tmem1[WAD] <= DI[1];\\n\\t\\tmem2[WAD] <= DI[2];\\n\\t\\tmem3[WAD] <= DI[3];\\n\\tend\\nend\\n\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule SP (DO, DI, BLKSEL, AD, WRE, CLK, CE, OCE, RESET);\\n\\n// 1 Enables output pipeline registers.\\nparameter READ_MODE = 1'b0;\\n// 0: no read on write, 1: transparent, 2: read-before-write\\nparameter WRITE_MODE = 2'b00;\\nparameter BIT_WIDTH = 32; // 1, 2, 4, 8, 16, 32\\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\";\\nparameter INIT_RAM_00 = 256'h0;\\nparameter INIT_RAM_01 = 256'h0;\\nparameter INIT_RAM_02 = 256'h0;\\nparameter INIT_RAM_03 = 256'h0;\\nparameter INIT_RAM_04 = 256'h0;\\nparameter INIT_RAM_05 = 256'h0;\\nparameter INIT_RAM_06 = 256'h0;\\nparameter INIT_RAM_07 = 256'h0;\\nparameter INIT_RAM_08 = 256'h0;\\nparameter INIT_RAM_09 = 256'h0;\\nparameter INIT_RAM_0A = 256'h0;\\nparameter INIT_RAM_0B = 256'h0;\\nparameter INIT_RAM_0C = 256'h0;\\nparameter INIT_RAM_0D = 256'h0;\\nparameter INIT_RAM_0E = 256'h0;\\nparameter INIT_RAM_0F = 256'h0;\\nparameter INIT_RAM_10 = 256'h0;\\nparameter INIT_RAM_11 = 256'h0;\\nparameter INIT_RAM_12 = 256'h0;\\nparameter INIT_RAM_13 = 256'h0;\\nparameter INIT_RAM_14 = 256'h0;\\nparameter INIT_RAM_15 = 256'h0;\\nparameter INIT_RAM_16 = 256'h0;\\nparameter INIT_RAM_17 = 256'h0;\\nparameter INIT_RAM_18 = 256'h0;\\nparameter INIT_RAM_19 = 256'h0;\\nparameter INIT_RAM_1A = 256'h0;\\nparameter INIT_RAM_1B = 256'h0;\\nparameter INIT_RAM_1C = 256'h0;\\nparameter INIT_RAM_1D = 256'h0;\\nparameter INIT_RAM_1E = 256'h0;\\nparameter INIT_RAM_1F = 256'h0;\\nparameter INIT_RAM_20 = 256'h0;\\nparameter INIT_RAM_21 = 256'h0;\\nparameter INIT_RAM_22 = 256'h0;\\nparameter INIT_RAM_23 = 256'h0;\\nparameter INIT_RAM_24 = 256'h0;\\nparameter INIT_RAM_25 = 256'h0;\\nparameter INIT_RAM_26 = 256'h0;\\nparameter INIT_RAM_27 = 256'h0;\\nparameter INIT_RAM_28 = 256'h0;\\nparameter INIT_RAM_29 = 256'h0;\\nparameter INIT_RAM_2A = 256'h0;\\nparameter INIT_RAM_2B = 256'h0;\\nparameter INIT_RAM_2C = 256'h0;\\nparameter INIT_RAM_2D = 256'h0;\\nparameter INIT_RAM_2E = 256'h0;\\nparameter INIT_RAM_2F = 256'h0;\\nparameter INIT_RAM_30 = 256'h0;\\nparameter INIT_RAM_31 = 256'h0;\\nparameter INIT_RAM_32 = 256'h0;\\nparameter INIT_RAM_33 = 256'h0;\\nparameter INIT_RAM_34 = 256'h0;\\nparameter INIT_RAM_35 = 256'h0;\\nparameter INIT_RAM_36 = 256'h0;\\nparameter INIT_RAM_37 = 256'h0;\\nparameter INIT_RAM_38 = 256'h0;\\nparameter INIT_RAM_39 = 256'h0;\\nparameter INIT_RAM_3A = 256'h0;\\nparameter INIT_RAM_3B = 256'h0;\\nparameter INIT_RAM_3C = 256'h0;\\nparameter INIT_RAM_3D = 256'h0;\\nparameter INIT_RAM_3E = 256'h0;\\nparameter INIT_RAM_3F = 256'h0;\\n\\noutput [31:0] DO;\\ninput [31:0] DI;\\ninput [2:0] BLKSEL;\\ninput [13:0] AD;\\ninput WRE;\\ninput CLK;\\ninput CE;\\ninput OCE;\\ninput RESET;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule SPX9 (DO, DI, BLKSEL, AD, WRE, CLK, CE, OCE, RESET);\\n\\n// 1 Enables output pipeline registers.\\nparameter READ_MODE = 1'b0;\\n// 0: no read on write, 1: transparent, 2: read-before-write\\nparameter WRITE_MODE = 2'b00;\\nparameter BIT_WIDTH = 36; // 9, 18, 36\\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\";\\nparameter INIT_RAM_00 = 288'h0;\\nparameter INIT_RAM_01 = 288'h0;\\nparameter INIT_RAM_02 = 288'h0;\\nparameter INIT_RAM_03 = 288'h0;\\nparameter INIT_RAM_04 = 288'h0;\\nparameter INIT_RAM_05 = 288'h0;\\nparameter INIT_RAM_06 = 288'h0;\\nparameter INIT_RAM_07 = 288'h0;\\nparameter INIT_RAM_08 = 288'h0;\\nparameter INIT_RAM_09 = 288'h0;\\nparameter INIT_RAM_0A = 288'h0;\\nparameter INIT_RAM_0B = 288'h0;\\nparameter INIT_RAM_0C = 288'h0;\\nparameter INIT_RAM_0D = 288'h0;\\nparameter INIT_RAM_0E = 288'h0;\\nparameter INIT_RAM_0F = 288'h0;\\nparameter INIT_RAM_10 = 288'h0;\\nparameter INIT_RAM_11 = 288'h0;\\nparameter INIT_RAM_12 = 288'h0;\\nparameter INIT_RAM_13 = 288'h0;\\nparameter INIT_RAM_14 = 288'h0;\\nparameter INIT_RAM_15 = 288'h0;\\nparameter INIT_RAM_16 = 288'h0;\\nparameter INIT_RAM_17 = 288'h0;\\nparameter INIT_RAM_18 = 288'h0;\\nparameter INIT_RAM_19 = 288'h0;\\nparameter INIT_RAM_1A = 288'h0;\\nparameter INIT_RAM_1B = 288'h0;\\nparameter INIT_RAM_1C = 288'h0;\\nparameter INIT_RAM_1D = 288'h0;\\nparameter INIT_RAM_1E = 288'h0;\\nparameter INIT_RAM_1F = 288'h0;\\nparameter INIT_RAM_20 = 288'h0;\\nparameter INIT_RAM_21 = 288'h0;\\nparameter INIT_RAM_22 = 288'h0;\\nparameter INIT_RAM_23 = 288'h0;\\nparameter INIT_RAM_24 = 288'h0;\\nparameter INIT_RAM_25 = 288'h0;\\nparameter INIT_RAM_26 = 288'h0;\\nparameter INIT_RAM_27 = 288'h0;\\nparameter INIT_RAM_28 = 288'h0;\\nparameter INIT_RAM_29 = 288'h0;\\nparameter INIT_RAM_2A = 288'h0;\\nparameter INIT_RAM_2B = 288'h0;\\nparameter INIT_RAM_2C = 288'h0;\\nparameter INIT_RAM_2D = 288'h0;\\nparameter INIT_RAM_2E = 288'h0;\\nparameter INIT_RAM_2F = 288'h0;\\nparameter INIT_RAM_30 = 288'h0;\\nparameter INIT_RAM_31 = 288'h0;\\nparameter INIT_RAM_32 = 288'h0;\\nparameter INIT_RAM_33 = 288'h0;\\nparameter INIT_RAM_34 = 288'h0;\\nparameter INIT_RAM_35 = 288'h0;\\nparameter INIT_RAM_36 = 288'h0;\\nparameter INIT_RAM_37 = 288'h0;\\nparameter INIT_RAM_38 = 288'h0;\\nparameter INIT_RAM_39 = 288'h0;\\nparameter INIT_RAM_3A = 288'h0;\\nparameter INIT_RAM_3B = 288'h0;\\nparameter INIT_RAM_3C = 288'h0;\\nparameter INIT_RAM_3D = 288'h0;\\nparameter INIT_RAM_3E = 288'h0;\\nparameter INIT_RAM_3F = 288'h0;\\n\\noutput [35:0] DO;\\ninput [35:0] DI;\\ninput [2:0] BLKSEL;\\ninput [13:0] AD;\\ninput WRE;\\ninput CLK;\\ninput CE;\\ninput OCE;\\ninput RESET;\\n\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule SDP (DO, DI, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCE, RESETA, RESETB);\\n\\nparameter READ_MODE = 1'b0;\\nparameter BIT_WIDTH_0 = 32; // 1, 2, 4, 8, 16, 32\\nparameter BIT_WIDTH_1 = 32; // 1, 2, 4, 8, 16, 32\\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\";\\nparameter INIT_RAM_00 = 256'h0;\\nparameter INIT_RAM_01 = 256'h0;\\nparameter INIT_RAM_02 = 256'h0;\\nparameter INIT_RAM_03 = 256'h0;\\nparameter INIT_RAM_04 = 256'h0;\\nparameter INIT_RAM_05 = 256'h0;\\nparameter INIT_RAM_06 = 256'h0;\\nparameter INIT_RAM_07 = 256'h0;\\nparameter INIT_RAM_08 = 256'h0;\\nparameter INIT_RAM_09 = 256'h0;\\nparameter INIT_RAM_0A = 256'h0;\\nparameter INIT_RAM_0B = 256'h0;\\nparameter INIT_RAM_0C = 256'h0;\\nparameter INIT_RAM_0D = 256'h0;\\nparameter INIT_RAM_0E = 256'h0;\\nparameter INIT_RAM_0F = 256'h0;\\nparameter INIT_RAM_10 = 256'h0;\\nparameter INIT_RAM_11 = 256'h0;\\nparameter INIT_RAM_12 = 256'h0;\\nparameter INIT_RAM_13 = 256'h0;\\nparameter INIT_RAM_14 = 256'h0;\\nparameter INIT_RAM_15 = 256'h0;\\nparameter INIT_RAM_16 = 256'h0;\\nparameter INIT_RAM_17 = 256'h0;\\nparameter INIT_RAM_18 = 256'h0;\\nparameter INIT_RAM_19 = 256'h0;\\nparameter INIT_RAM_1A = 256'h0;\\nparameter INIT_RAM_1B = 256'h0;\\nparameter INIT_RAM_1C = 256'h0;\\nparameter INIT_RAM_1D = 256'h0;\\nparameter INIT_RAM_1E = 256'h0;\\nparameter INIT_RAM_1F = 256'h0;\\nparameter INIT_RAM_20 = 256'h0;\\nparameter INIT_RAM_21 = 256'h0;\\nparameter INIT_RAM_22 = 256'h0;\\nparameter INIT_RAM_23 = 256'h0;\\nparameter INIT_RAM_24 = 256'h0;\\nparameter INIT_RAM_25 = 256'h0;\\nparameter INIT_RAM_26 = 256'h0;\\nparameter INIT_RAM_27 = 256'h0;\\nparameter INIT_RAM_28 = 256'h0;\\nparameter INIT_RAM_29 = 256'h0;\\nparameter INIT_RAM_2A = 256'h0;\\nparameter INIT_RAM_2B = 256'h0;\\nparameter INIT_RAM_2C = 256'h0;\\nparameter INIT_RAM_2D = 256'h0;\\nparameter INIT_RAM_2E = 256'h0;\\nparameter INIT_RAM_2F = 256'h0;\\nparameter INIT_RAM_30 = 256'h0;\\nparameter INIT_RAM_31 = 256'h0;\\nparameter INIT_RAM_32 = 256'h0;\\nparameter INIT_RAM_33 = 256'h0;\\nparameter INIT_RAM_34 = 256'h0;\\nparameter INIT_RAM_35 = 256'h0;\\nparameter INIT_RAM_36 = 256'h0;\\nparameter INIT_RAM_37 = 256'h0;\\nparameter INIT_RAM_38 = 256'h0;\\nparameter INIT_RAM_39 = 256'h0;\\nparameter INIT_RAM_3A = 256'h0;\\nparameter INIT_RAM_3B = 256'h0;\\nparameter INIT_RAM_3C = 256'h0;\\nparameter INIT_RAM_3D = 256'h0;\\nparameter INIT_RAM_3E = 256'h0;\\nparameter INIT_RAM_3F = 256'h0;\\n\\noutput [31:0] DO;\\ninput [31:0] DI;\\ninput [2:0] BLKSEL;\\ninput [13:0] ADA, ADB;\\ninput WREA, WREB;\\ninput CLKA, CLKB;\\ninput CEA, CEB;\\ninput OCE;\\ninput RESETA, RESETB;\\n\\nspecify\\n\\t(posedge CLKB => (DO : DI)) = (419, 493);\\n\\t$setup(RESETA, posedge CLKA, 62);\\n\\t$setup(RESETB, posedge CLKB, 62);\\n\\t$setup(OCE, posedge CLKB, 62);\\n\\t$setup(CEA, posedge CLKA, 62);\\n\\t$setup(CEB, posedge CLKB, 62);\\n\\t$setup(OCE, posedge CLKB, 62);\\n\\t$setup(WREA, posedge CLKA, 62);\\n\\t$setup(WREB, posedge CLKB, 62);\\n\\t$setup(DI, posedge CLKA, 62);\\n\\t$setup(ADA, posedge CLKA, 62);\\n\\t$setup(ADB, posedge CLKB, 62);\\n\\t$setup(BLKSEL, posedge CLKA, 62);\\nendspecify\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule SDPX9 (DO, DI, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCE, RESETA, RESETB);\\n\\nparameter READ_MODE = 1'b0;\\nparameter BIT_WIDTH_0 = 36; // 9, 18, 36\\nparameter BIT_WIDTH_1 = 36; // 9, 18, 36\\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\";\\nparameter INIT_RAM_00 = 288'h0;\\nparameter INIT_RAM_01 = 288'h0;\\nparameter INIT_RAM_02 = 288'h0;\\nparameter INIT_RAM_03 = 288'h0;\\nparameter INIT_RAM_04 = 288'h0;\\nparameter INIT_RAM_05 = 288'h0;\\nparameter INIT_RAM_06 = 288'h0;\\nparameter INIT_RAM_07 = 288'h0;\\nparameter INIT_RAM_08 = 288'h0;\\nparameter INIT_RAM_09 = 288'h0;\\nparameter INIT_RAM_0A = 288'h0;\\nparameter INIT_RAM_0B = 288'h0;\\nparameter INIT_RAM_0C = 288'h0;\\nparameter INIT_RAM_0D = 288'h0;\\nparameter INIT_RAM_0E = 288'h0;\\nparameter INIT_RAM_0F = 288'h0;\\nparameter INIT_RAM_10 = 288'h0;\\nparameter INIT_RAM_11 = 288'h0;\\nparameter INIT_RAM_12 = 288'h0;\\nparameter INIT_RAM_13 = 288'h0;\\nparameter INIT_RAM_14 = 288'h0;\\nparameter INIT_RAM_15 = 288'h0;\\nparameter INIT_RAM_16 = 288'h0;\\nparameter INIT_RAM_17 = 288'h0;\\nparameter INIT_RAM_18 = 288'h0;\\nparameter INIT_RAM_19 = 288'h0;\\nparameter INIT_RAM_1A = 288'h0;\\nparameter INIT_RAM_1B = 288'h0;\\nparameter INIT_RAM_1C = 288'h0;\\nparameter INIT_RAM_1D = 288'h0;\\nparameter INIT_RAM_1E = 288'h0;\\nparameter INIT_RAM_1F = 288'h0;\\nparameter INIT_RAM_20 = 288'h0;\\nparameter INIT_RAM_21 = 288'h0;\\nparameter INIT_RAM_22 = 288'h0;\\nparameter INIT_RAM_23 = 288'h0;\\nparameter INIT_RAM_24 = 288'h0;\\nparameter INIT_RAM_25 = 288'h0;\\nparameter INIT_RAM_26 = 288'h0;\\nparameter INIT_RAM_27 = 288'h0;\\nparameter INIT_RAM_28 = 288'h0;\\nparameter INIT_RAM_29 = 288'h0;\\nparameter INIT_RAM_2A = 288'h0;\\nparameter INIT_RAM_2B = 288'h0;\\nparameter INIT_RAM_2C = 288'h0;\\nparameter INIT_RAM_2D = 288'h0;\\nparameter INIT_RAM_2E = 288'h0;\\nparameter INIT_RAM_2F = 288'h0;\\nparameter INIT_RAM_30 = 288'h0;\\nparameter INIT_RAM_31 = 288'h0;\\nparameter INIT_RAM_32 = 288'h0;\\nparameter INIT_RAM_33 = 288'h0;\\nparameter INIT_RAM_34 = 288'h0;\\nparameter INIT_RAM_35 = 288'h0;\\nparameter INIT_RAM_36 = 288'h0;\\nparameter INIT_RAM_37 = 288'h0;\\nparameter INIT_RAM_38 = 288'h0;\\nparameter INIT_RAM_39 = 288'h0;\\nparameter INIT_RAM_3A = 288'h0;\\nparameter INIT_RAM_3B = 288'h0;\\nparameter INIT_RAM_3C = 288'h0;\\nparameter INIT_RAM_3D = 288'h0;\\nparameter INIT_RAM_3E = 288'h0;\\nparameter INIT_RAM_3F = 288'h0;\\n\\noutput [35:0] DO;\\ninput [35:0] DI;\\ninput [2:0] BLKSEL;\\ninput [13:0] ADA, ADB;\\ninput WREA, WREB;\\ninput CLKA, CLKB;\\ninput CEA, CEB;\\ninput OCE;\\ninput RESETA, RESETB;\\n\\nspecify\\n\\t(posedge CLKB => (DO : DI)) = (419, 493);\\n\\t$setup(RESETA, posedge CLKA, 62);\\n\\t$setup(RESETB, posedge CLKB, 62);\\n\\t$setup(OCE, posedge CLKB, 62);\\n\\t$setup(CEA, posedge CLKA, 62);\\n\\t$setup(CEB, posedge CLKB, 62);\\n\\t$setup(OCE, posedge CLKB, 62);\\n\\t$setup(WREA, posedge CLKA, 62);\\n\\t$setup(WREB, posedge CLKB, 62);\\n\\t$setup(DI, posedge CLKA, 62);\\n\\t$setup(ADA, posedge CLKA, 62);\\n\\t$setup(ADB, posedge CLKB, 62);\\n\\t$setup(BLKSEL, posedge CLKA, 62);\\nendspecify\\n\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule DP (DOA, DOB, DIA, DIB, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCEA, OCEB, RESETA, RESETB);\\n\\nparameter READ_MODE0 = 1'b0;\\nparameter READ_MODE1 = 1'b0;\\nparameter WRITE_MODE0 = 2'b00;\\nparameter WRITE_MODE1 = 2'b00;\\nparameter BIT_WIDTH_0 = 16; // 1, 2, 4, 8, 16\\nparameter BIT_WIDTH_1 = 16; // 1, 2, 4, 8, 16\\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\";\\nparameter INIT_RAM_00 = 256'h0;\\nparameter INIT_RAM_01 = 256'h0;\\nparameter INIT_RAM_02 = 256'h0;\\nparameter INIT_RAM_03 = 256'h0;\\nparameter INIT_RAM_04 = 256'h0;\\nparameter INIT_RAM_05 = 256'h0;\\nparameter INIT_RAM_06 = 256'h0;\\nparameter INIT_RAM_07 = 256'h0;\\nparameter INIT_RAM_08 = 256'h0;\\nparameter INIT_RAM_09 = 256'h0;\\nparameter INIT_RAM_0A = 256'h0;\\nparameter INIT_RAM_0B = 256'h0;\\nparameter INIT_RAM_0C = 256'h0;\\nparameter INIT_RAM_0D = 256'h0;\\nparameter INIT_RAM_0E = 256'h0;\\nparameter INIT_RAM_0F = 256'h0;\\nparameter INIT_RAM_10 = 256'h0;\\nparameter INIT_RAM_11 = 256'h0;\\nparameter INIT_RAM_12 = 256'h0;\\nparameter INIT_RAM_13 = 256'h0;\\nparameter INIT_RAM_14 = 256'h0;\\nparameter INIT_RAM_15 = 256'h0;\\nparameter INIT_RAM_16 = 256'h0;\\nparameter INIT_RAM_17 = 256'h0;\\nparameter INIT_RAM_18 = 256'h0;\\nparameter INIT_RAM_19 = 256'h0;\\nparameter INIT_RAM_1A = 256'h0;\\nparameter INIT_RAM_1B = 256'h0;\\nparameter INIT_RAM_1C = 256'h0;\\nparameter INIT_RAM_1D = 256'h0;\\nparameter INIT_RAM_1E = 256'h0;\\nparameter INIT_RAM_1F = 256'h0;\\nparameter INIT_RAM_20 = 256'h0;\\nparameter INIT_RAM_21 = 256'h0;\\nparameter INIT_RAM_22 = 256'h0;\\nparameter INIT_RAM_23 = 256'h0;\\nparameter INIT_RAM_24 = 256'h0;\\nparameter INIT_RAM_25 = 256'h0;\\nparameter INIT_RAM_26 = 256'h0;\\nparameter INIT_RAM_27 = 256'h0;\\nparameter INIT_RAM_28 = 256'h0;\\nparameter INIT_RAM_29 = 256'h0;\\nparameter INIT_RAM_2A = 256'h0;\\nparameter INIT_RAM_2B = 256'h0;\\nparameter INIT_RAM_2C = 256'h0;\\nparameter INIT_RAM_2D = 256'h0;\\nparameter INIT_RAM_2E = 256'h0;\\nparameter INIT_RAM_2F = 256'h0;\\nparameter INIT_RAM_30 = 256'h0;\\nparameter INIT_RAM_31 = 256'h0;\\nparameter INIT_RAM_32 = 256'h0;\\nparameter INIT_RAM_33 = 256'h0;\\nparameter INIT_RAM_34 = 256'h0;\\nparameter INIT_RAM_35 = 256'h0;\\nparameter INIT_RAM_36 = 256'h0;\\nparameter INIT_RAM_37 = 256'h0;\\nparameter INIT_RAM_38 = 256'h0;\\nparameter INIT_RAM_39 = 256'h0;\\nparameter INIT_RAM_3A = 256'h0;\\nparameter INIT_RAM_3B = 256'h0;\\nparameter INIT_RAM_3C = 256'h0;\\nparameter INIT_RAM_3D = 256'h0;\\nparameter INIT_RAM_3E = 256'h0;\\nparameter INIT_RAM_3F = 256'h0;\\n\\noutput [15:0] DOA, DOB;\\ninput [15:0] DIA, DIB;\\ninput [2:0] BLKSEL;\\ninput [13:0] ADA, ADB;\\ninput WREA, WREB;\\ninput CLKA, CLKB;\\ninput CEA, CEB;\\ninput OCEA, OCEB;\\ninput RESETA, RESETB;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule DPX9 (DOA, DOB, DIA, DIB, BLKSEL, ADA, ADB, WREA, WREB, CLKA, CLKB, CEA, CEB, OCEA, OCEB, RESETA, RESETB);\\n\\nparameter READ_MODE0 = 1'b0;\\nparameter READ_MODE1 = 1'b0;\\nparameter WRITE_MODE0 = 2'b00;\\nparameter WRITE_MODE1 = 2'b00;\\nparameter BIT_WIDTH_0 = 18; // 9, 18\\nparameter BIT_WIDTH_1 = 18; // 9, 18\\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\";\\nparameter INIT_RAM_00 = 288'h0;\\nparameter INIT_RAM_01 = 288'h0;\\nparameter INIT_RAM_02 = 288'h0;\\nparameter INIT_RAM_03 = 288'h0;\\nparameter INIT_RAM_04 = 288'h0;\\nparameter INIT_RAM_05 = 288'h0;\\nparameter INIT_RAM_06 = 288'h0;\\nparameter INIT_RAM_07 = 288'h0;\\nparameter INIT_RAM_08 = 288'h0;\\nparameter INIT_RAM_09 = 288'h0;\\nparameter INIT_RAM_0A = 288'h0;\\nparameter INIT_RAM_0B = 288'h0;\\nparameter INIT_RAM_0C = 288'h0;\\nparameter INIT_RAM_0D = 288'h0;\\nparameter INIT_RAM_0E = 288'h0;\\nparameter INIT_RAM_0F = 288'h0;\\nparameter INIT_RAM_10 = 288'h0;\\nparameter INIT_RAM_11 = 288'h0;\\nparameter INIT_RAM_12 = 288'h0;\\nparameter INIT_RAM_13 = 288'h0;\\nparameter INIT_RAM_14 = 288'h0;\\nparameter INIT_RAM_15 = 288'h0;\\nparameter INIT_RAM_16 = 288'h0;\\nparameter INIT_RAM_17 = 288'h0;\\nparameter INIT_RAM_18 = 288'h0;\\nparameter INIT_RAM_19 = 288'h0;\\nparameter INIT_RAM_1A = 288'h0;\\nparameter INIT_RAM_1B = 288'h0;\\nparameter INIT_RAM_1C = 288'h0;\\nparameter INIT_RAM_1D = 288'h0;\\nparameter INIT_RAM_1E = 288'h0;\\nparameter INIT_RAM_1F = 288'h0;\\nparameter INIT_RAM_20 = 288'h0;\\nparameter INIT_RAM_21 = 288'h0;\\nparameter INIT_RAM_22 = 288'h0;\\nparameter INIT_RAM_23 = 288'h0;\\nparameter INIT_RAM_24 = 288'h0;\\nparameter INIT_RAM_25 = 288'h0;\\nparameter INIT_RAM_26 = 288'h0;\\nparameter INIT_RAM_27 = 288'h0;\\nparameter INIT_RAM_28 = 288'h0;\\nparameter INIT_RAM_29 = 288'h0;\\nparameter INIT_RAM_2A = 288'h0;\\nparameter INIT_RAM_2B = 288'h0;\\nparameter INIT_RAM_2C = 288'h0;\\nparameter INIT_RAM_2D = 288'h0;\\nparameter INIT_RAM_2E = 288'h0;\\nparameter INIT_RAM_2F = 288'h0;\\nparameter INIT_RAM_30 = 288'h0;\\nparameter INIT_RAM_31 = 288'h0;\\nparameter INIT_RAM_32 = 288'h0;\\nparameter INIT_RAM_33 = 288'h0;\\nparameter INIT_RAM_34 = 288'h0;\\nparameter INIT_RAM_35 = 288'h0;\\nparameter INIT_RAM_36 = 288'h0;\\nparameter INIT_RAM_37 = 288'h0;\\nparameter INIT_RAM_38 = 288'h0;\\nparameter INIT_RAM_39 = 288'h0;\\nparameter INIT_RAM_3A = 288'h0;\\nparameter INIT_RAM_3B = 288'h0;\\nparameter INIT_RAM_3C = 288'h0;\\nparameter INIT_RAM_3D = 288'h0;\\nparameter INIT_RAM_3E = 288'h0;\\nparameter INIT_RAM_3F = 288'h0;\\n\\noutput [17:0] DOA, DOB;\\ninput [17:0] DIA, DIB;\\ninput [2:0] BLKSEL;\\ninput [13:0] ADA, ADB;\\ninput WREA, WREB;\\ninput CLKA, CLKB;\\ninput CEA, CEB;\\ninput OCEA, OCEB;\\ninput RESETA, RESETB;\\n\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule rPLL (CLKOUT, CLKOUTP, CLKOUTD, CLKOUTD3, LOCK, CLKIN, CLKFB, FBDSEL, IDSEL, ODSEL, DUTYDA, PSDA, FDLY, RESET, RESET_P);\\ninput CLKIN;\\ninput CLKFB;\\ninput RESET;\\ninput RESET_P;\\ninput [5:0] FBDSEL;\\ninput [5:0] IDSEL;\\ninput [5:0] ODSEL;\\ninput [3:0] PSDA,FDLY;\\ninput [3:0] DUTYDA;\\n\\noutput CLKOUT;\\noutput LOCK;\\noutput CLKOUTP;\\noutput CLKOUTD;\\noutput CLKOUTD3;\\n\\nparameter FCLKIN = \\\"100.0\\\";         // frequency of CLKIN\\nparameter DYN_IDIV_SEL= \\\"false\\\";    // true:IDSEL, false:IDIV_SEL\\nparameter IDIV_SEL = 0;             // 0:1, 1:2 ... 63:64\\nparameter DYN_FBDIV_SEL= \\\"false\\\";   // true:FBDSEL, false:FBDIV_SEL\\nparameter FBDIV_SEL = 0;            // 0:1, 1:2 ... 63:64\\nparameter DYN_ODIV_SEL= \\\"false\\\";    // true:ODSEL, false:ODIV_SEL\\nparameter ODIV_SEL = 8;             // 2/4/8/16/32/48/64/80/96/112/128\\n\\nparameter PSDA_SEL= \\\"0000\\\";\\nparameter DYN_DA_EN = \\\"false\\\";      // true:PSDA or DUTYDA or FDA, false: DA_SEL\\nparameter DUTYDA_SEL= \\\"1000\\\";\\n\\nparameter CLKOUT_FT_DIR = 1'b1;     // CLKOUT fine tuning direction. 1'b1 only\\nparameter CLKOUTP_FT_DIR = 1'b1;    // 1'b1 only\\nparameter CLKOUT_DLY_STEP = 0;      // 0, 1, 2, 4\\nparameter CLKOUTP_DLY_STEP = 0;     // 0, 1, 2\\n\\nparameter CLKFB_SEL = \\\"internal\\\";   // \\\"internal\\\", \\\"external\\\"\\nparameter CLKOUT_BYPASS = \\\"false\\\";  // \\\"true\\\", \\\"false\\\"\\nparameter CLKOUTP_BYPASS = \\\"false\\\"; // \\\"true\\\", \\\"false\\\"\\nparameter CLKOUTD_BYPASS = \\\"false\\\"; // \\\"true\\\", \\\"false\\\"\\nparameter DYN_SDIV_SEL = 2;         // 2~128, only even numbers\\nparameter CLKOUTD_SRC =  \\\"CLKOUT\\\";  // CLKOUT, CLKOUTP\\nparameter CLKOUTD3_SRC = \\\"CLKOUT\\\";  // CLKOUT, CLKOUTP\\nparameter DEVICE = \\\"GW1N-1\\\";        // \\\"GW1N-1\\\", \\\"GW1N-4\\\", \\\"GW1N-9\\\", \\\"GW1NR-4\\\", \\\"GW1NR-9\\\", \\\"GW1N-4B\\\", \\\"GW1NR-4B\\\", \\\"GW1NS-2\\\", \\\"GW1NS-2C\\\", \\\"GW1NZ-1\\\", \\\"GW1NSR-2\\\", \\\"GW1NSR-2C\\\", \\\"GW1N-1S\\\", \\\"GW1NSE-2C\\\", \\\"GW1NRF-4B\\\", \\\"GW1N-9C\\\", \\\"GW1NR-9C\\\", \\\"GW1N-4C\\\", \\\"GW1NR-4C\\\"\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule PLLVR (CLKOUT, CLKOUTP, CLKOUTD, CLKOUTD3, LOCK, CLKIN, CLKFB, FBDSEL, IDSEL, ODSEL, DUTYDA, PSDA, FDLY, RESET, RESET_P, VREN);\\ninput CLKIN;\\ninput CLKFB;\\ninput RESET;\\ninput RESET_P;\\ninput [5:0] FBDSEL;\\ninput [5:0] IDSEL;\\ninput [5:0] ODSEL;\\ninput [3:0] PSDA,FDLY;\\ninput [3:0] DUTYDA;\\ninput VREN;\\n\\noutput CLKOUT;\\noutput LOCK;\\noutput CLKOUTP;\\noutput CLKOUTD;\\noutput CLKOUTD3;\\n\\nparameter FCLKIN = \\\"100.0\\\";         // frequency of CLKIN\\nparameter DYN_IDIV_SEL= \\\"false\\\";    // true:IDSEL, false:IDIV_SEL\\nparameter IDIV_SEL = 0;             // 0:1, 1:2 ... 63:64\\nparameter DYN_FBDIV_SEL= \\\"false\\\";   // true:FBDSEL, false:FBDIV_SEL\\nparameter FBDIV_SEL = 0;            // 0:1, 1:2 ... 63:64\\nparameter DYN_ODIV_SEL= \\\"false\\\";    // true:ODSEL, false:ODIV_SEL\\nparameter ODIV_SEL = 8;             // 2/4/8/16/32/48/64/80/96/112/128\\n\\nparameter PSDA_SEL= \\\"0000\\\";\\nparameter DYN_DA_EN = \\\"false\\\";      // true:PSDA or DUTYDA or FDA, false: DA_SEL\\nparameter DUTYDA_SEL= \\\"1000\\\";\\n\\nparameter CLKOUT_FT_DIR = 1'b1;     // CLKOUT fine tuning direction. 1'b1 only\\nparameter CLKOUTP_FT_DIR = 1'b1;    // 1'b1 only\\nparameter CLKOUT_DLY_STEP = 0;      // 0, 1, 2, 4\\nparameter CLKOUTP_DLY_STEP = 0;     // 0, 1, 2\\n\\nparameter CLKFB_SEL = \\\"internal\\\";   // \\\"internal\\\", \\\"external\\\"\\nparameter CLKOUT_BYPASS = \\\"false\\\";  // \\\"true\\\", \\\"false\\\"\\nparameter CLKOUTP_BYPASS = \\\"false\\\"; // \\\"true\\\", \\\"false\\\"\\nparameter CLKOUTD_BYPASS = \\\"false\\\"; // \\\"true\\\", \\\"false\\\"\\nparameter DYN_SDIV_SEL = 2;         // 2~128, only even numbers\\nparameter CLKOUTD_SRC =  \\\"CLKOUT\\\";  // CLKOUT, CLKOUTP\\nparameter CLKOUTD3_SRC = \\\"CLKOUT\\\";  // CLKOUT, CLKOUTP\\nparameter DEVICE = \\\"GW1NS-4\\\";       // \\\"GW1NS-4\\\", \\\"GW1NS-4C\\\", \\\"GW1NSR-4\\\", \\\"GW1NSR-4C\\\", \\\"GW1NSER-4C\\\"\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule OSC(OSCOUT);\\noutput OSCOUT;\\n\\nparameter FREQ_DIV = 100;\\nparameter DEVICE = \\\"GW1N-4\\\";\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCZ(OSCOUT, OSCEN);\\ninput OSCEN;\\n\\noutput OSCOUT;\\n\\nparameter FREQ_DIV = 100;\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCF(OSCOUT, OSCOUT30M, OSCEN);\\ninput OSCEN;\\n\\noutput OSCOUT;\\noutput OSCOUT30M;\\n\\nparameter FREQ_DIV = 100;\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCH(OSCOUT);\\noutput OSCOUT;\\n\\nparameter FREQ_DIV = 96;\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCW(OSCOUT);\\noutput OSCOUT;\\n\\nparameter FREQ_DIV = 80;\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCO(OSCOUT, OSCEN);\\ninput OSCEN;\\n\\noutput OSCOUT;\\n\\nparameter FREQ_DIV = 100;\\nparameter REGULATOR_EN = 1'b0;\\nendmodule\\n\",\n            \"cells_xtra.v\": \"// Created by cells_xtra.py\\n\\n\\nmodule MUX2_MUX8 (...);\\ninput I0,I1;\\ninput S0;\\noutput O;\\nendmodule\\n\\n\\nmodule MUX2_MUX16 (...);\\ninput I0,I1;\\ninput S0;\\noutput O;\\nendmodule\\n\\n\\nmodule MUX2_MUX32 (...);\\ninput I0,I1;\\ninput S0;\\noutput O;\\nendmodule\\n\\n\\nmodule MUX4 (...);\\ninput I0, I1, I2, I3;\\ninput S0, S1;\\noutput O;\\nendmodule\\n\\n\\nmodule MUX8 (...);\\ninput I0, I1, I2, I3, I4, I5, I6, I7;\\ninput S0, S1, S2;\\noutput O;\\nendmodule\\n\\n\\nmodule MUX16 (...);\\ninput I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15;\\ninput S0, S1, S2, S3;\\noutput O;\\nendmodule\\n\\nmodule MUX32 (...);\\ninput I0, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, I17, I18, I19, I20, I21, I22, I23, I24, I25, I26, I27, I28, I29, I30, I31;\\ninput S0, S1, S2, S3, S4;\\noutput O;\\nendmodule\\n\\nmodule LUT5 (...);\\nparameter INIT = 32'h00000000;\\ninput I0, I1, I2, I3, I4;\\noutput F;\\nendmodule\\n\\n\\nmodule LUT6 (...);\\nparameter INIT = 64'h0000_0000_0000_0000;\\ninput I0, I1, I2, I3, I4, I5;\\noutput F;\\nendmodule\\n\\n\\nmodule LUT7 (...);\\nparameter INIT = 128'h0000_0000_0000_0000_0000_0000_0000_0000;\\ninput I0, I1, I2, I3, I4, I5, I6;\\noutput F;\\nendmodule\\n\\n\\nmodule LUT8 (...);\\nparameter INIT = 256'h0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000;\\ninput I0, I1, I2, I3, I4, I5, I6, I7;\\noutput F;\\nendmodule\\n\\n\\nmodule DL (...);\\ninput D, G;\\noutput Q;\\nparameter INIT = 1'b0;\\nendmodule\\n\\n\\nmodule DLE (...);\\ninput D, G, CE;\\noutput Q;\\nparameter INIT = 1'b0;\\nendmodule\\n\\n\\nmodule DLC (...);\\ninput D, G, CLEAR;\\noutput Q;\\nparameter INIT = 1'b0;\\nendmodule\\n\\n\\nmodule DLCE (...);\\ninput D, G, CLEAR, CE;\\noutput Q;\\nparameter INIT = 1'b0;\\nendmodule\\n\\n\\nmodule DLP (...);\\ninput D, G, PRESET;\\noutput Q;\\nparameter INIT = 1'b1;\\nendmodule\\n\\n\\nmodule DLPE (...);\\ninput D, G, PRESET, CE;\\noutput Q;\\nparameter INIT = 1'b1;\\nendmodule\\n\\n\\nmodule DLN (...);\\ninput D, G;\\noutput Q;\\nparameter INIT = 1'b0;\\nendmodule\\n\\n\\nmodule DLNE (...);\\ninput D, G, CE;\\noutput Q;\\nparameter INIT = 1'b0;\\nendmodule\\n\\n\\nmodule DLNC (...);\\ninput D, G, CLEAR;\\noutput Q;\\nparameter INIT = 1'b0;\\nendmodule\\n\\n\\nmodule DLNCE (...);\\ninput D, G, CLEAR, CE;\\noutput Q;\\nparameter INIT = 1'b0;\\nendmodule\\n\\n\\nmodule DLNP (...);\\ninput D, G, PRESET;\\noutput Q;\\nparameter INIT = 1'b1;\\nendmodule\\n\\n\\nmodule DLNPE (...);\\ninput D, G, PRESET, CE;\\noutput Q;\\nparameter INIT = 1'b1;\\nendmodule\\n\\n\\nmodule INV (...);\\ninput  I;\\noutput O;\\nendmodule\\n\\n\\nmodule IODELAY (...);\\nparameter C_STATIC_DLY = 0; \\ninput DI;\\ninput  SDTAP;\\ninput  SETN;\\ninput  VALUE;\\noutput DF;\\noutput DO;\\nendmodule\\n\\n\\nmodule IEM (...);\\nparameter WINSIZE = \\\"SMALL\\\"; \\nparameter GSREN = \\\"false\\\"; \\nparameter LSREN = \\\"true\\\";    \\ninput D, CLK, RESET, MCLK;\\noutput LAG, LEAD;\\nendmodule\\n\\n\\nmodule ROM16 (...);\\nparameter INIT_0 = 16'h0000;\\ninput [3:0] AD;\\noutput DO;\\nendmodule\\n\\n\\nmodule ROM (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH = 32; \\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\ninput CLK, CE;\\ninput OCE; \\ninput RESET; \\ninput WRE; \\ninput [13:0] AD;\\ninput [2:0] BLKSEL;\\noutput [31:0] DO;\\nendmodule\\n\\n\\nmodule ROMX9 (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH = 36; \\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; \\nparameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\ninput CLK, CE;\\ninput OCE; \\ninput RESET; \\ninput WRE; \\ninput [13:0] AD;\\ninput [2:0] BLKSEL;\\noutput [35:0] DO;\\nendmodule\\n\\n\\nmodule rSDP (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH_0 = 32; \\nparameter BIT_WIDTH_1 = 32; \\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\ninput CLKA, CEA, CLKB, CEB;\\ninput OCE; \\ninput RESETA, RESETB; \\ninput [13:0] ADA, ADB;\\ninput [31:0] DI;\\ninput [2:0] BLKSEL;\\noutput [31:0] DO;\\nendmodule\\n\\n\\nmodule rSDPX9 (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH_0 = 36; \\nparameter BIT_WIDTH_1 = 36; \\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; \\nparameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\ninput CLKA, CEA, CLKB, CEB;\\ninput OCE; \\ninput RESETA, RESETB; \\ninput [13:0] ADA, ADB;\\ninput [2:0] BLKSEL;\\ninput [35:0] DI;\\noutput [35:0] DO;\\nendmodule\\n\\n\\nmodule rROM (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH = 32; \\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\ninput CLK, CE;\\ninput OCE; \\ninput RESET; \\ninput [13:0] AD;\\ninput [2:0] BLKSEL;\\noutput [31:0] DO;\\nendmodule\\n\\n\\nmodule rROMX9 (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH = 36; \\nparameter BLK_SEL = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; \\nparameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\ninput CLK, CE;\\ninput OCE; \\ninput RESET; \\ninput [13:0] AD;\\ninput [2:0] BLKSEL;\\noutput [35:0] DO;\\nendmodule\\n\\n\\nmodule pROM (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH = 32; \\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\ninput CLK, CE;\\ninput OCE; \\ninput RESET; \\ninput [13:0] AD;\\noutput [31:0] DO;\\nendmodule\\n\\n\\nmodule pROMX9 (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH = 36; \\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; \\nparameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\ninput CLK, CE;\\ninput OCE; \\ninput RESET; \\ninput [13:0] AD;\\noutput [35:0] DO;\\nendmodule\\n\\n\\nmodule SDPB (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH_0 = 32; \\nparameter BIT_WIDTH_1 = 32; \\nparameter BLK_SEL_0 = 3'b000;\\nparameter BLK_SEL_1 = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\ninput CLKA, CEA, CLKB, CEB;\\ninput OCE; \\ninput RESETA, RESETB; \\ninput [13:0] ADA, ADB;\\ninput [31:0] DI;\\ninput [2:0] BLKSELA, BLKSELB;\\noutput [31:0] DO;\\nendmodule\\n\\n\\nmodule SDPX9B (...);\\nparameter READ_MODE = 1'b0; \\nparameter BIT_WIDTH_0 = 36; \\nparameter BIT_WIDTH_1 = 36; \\nparameter BLK_SEL_0 = 3'b000;\\nparameter BLK_SEL_1 = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; \\nparameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\ninput CLKA, CEA, CLKB, CEB;\\ninput OCE; \\ninput RESETA, RESETB; \\ninput [13:0] ADA, ADB;\\ninput [2:0] BLKSELA, BLKSELB;\\ninput [35:0] DI;\\noutput [35:0] DO;\\nendmodule\\n\\n\\nmodule DPB (...);\\nparameter READ_MODE0 = 1'b0; \\nparameter READ_MODE1 = 1'b0; \\nparameter WRITE_MODE0 = 2'b00; \\nparameter WRITE_MODE1 = 2'b00; \\nparameter BIT_WIDTH_0 = 16; \\nparameter BIT_WIDTH_1 = 16; \\nparameter BLK_SEL_0 = 3'b000;\\nparameter BLK_SEL_1 = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_01 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\\ninput CLKA, CEA, CLKB, CEB;\\ninput OCEA, OCEB; \\ninput RESETA, RESETB; \\ninput WREA, WREB; \\ninput [13:0] ADA, ADB;\\ninput [2:0] BLKSELA, BLKSELB;\\ninput [15:0] DIA, DIB;\\noutput [15:0] DOA, DOB;\\nendmodule\\n\\n\\nmodule DPX9B (...);\\nparameter READ_MODE0 = 1'b0; \\nparameter READ_MODE1 = 1'b0; \\nparameter WRITE_MODE0 = 2'b00; \\nparameter WRITE_MODE1 = 2'b00; \\nparameter BIT_WIDTH_0 = 18; \\nparameter BIT_WIDTH_1 = 18; \\nparameter BLK_SEL_0 = 3'b000;\\nparameter BLK_SEL_1 = 3'b000;\\nparameter RESET_MODE = \\\"SYNC\\\"; \\nparameter INIT_RAM_00 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000; \\nparameter INIT_RAM_01 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_02 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_03 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_04 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_05 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_06 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_07 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_08 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_09 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_0F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_10 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_11 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_12 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_13 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_14 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_15 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_16 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_17 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_18 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_19 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_1F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_20 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_21 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_22 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_23 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_24 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_25 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_26 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_27 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_28 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_29 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_2F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_30 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_31 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_32 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_33 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_34 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_35 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_36 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_37 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_38 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_39 = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3A = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3B = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3C = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3D = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3E = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\nparameter INIT_RAM_3F = 288'h000000000000000000000000000000000000000000000000000000000000000000000000;\\ninput CLKA, CEA, CLKB, CEB;\\ninput OCEA, OCEB; \\ninput RESETA, RESETB; \\ninput WREA, WREB; \\ninput [13:0] ADA, ADB;\\ninput [17:0] DIA, DIB;\\ninput [2:0] BLKSELA, BLKSELB;\\noutput [17:0] DOA, DOB;\\nendmodule\\n\\n\\nmodule PADD18 (...);\\ninput  [17:0] A;\\ninput  [17:0] B;\\ninput  ASEL;\\ninput  CE,CLK,RESET;\\ninput  [17:0] SI,SBI;\\noutput [17:0] SO,SBO;\\noutput [17:0] DOUT;\\nparameter AREG = 1'b0; \\nparameter BREG = 1'b0;\\nparameter ADD_SUB = 1'b0; \\nparameter PADD_RESET_MODE = \\\"SYNC\\\"; \\nparameter BSEL_MODE = 1'b1; \\nparameter SOREG = 1'b0;\\nendmodule\\n\\nmodule PADD9 (...);\\ninput  [8:0] A;\\ninput  [8:0] B;\\ninput  ASEL;\\ninput  CE,CLK,RESET;\\ninput  [8:0] SI,SBI;\\noutput [8:0] SO,SBO;\\noutput [8:0] DOUT;\\nparameter AREG = 1'b0; \\nparameter BREG = 1'b0; \\nparameter ADD_SUB = 1'b0; \\nparameter PADD_RESET_MODE = \\\"SYNC\\\"; \\nparameter BSEL_MODE = 1'b1; \\nparameter SOREG = 1'b0;\\nendmodule\\n\\nmodule MULT9X9 (...);\\ninput  [8:0] A,SIA;\\ninput  [8:0] B,SIB;\\ninput  ASIGN,BSIGN;\\ninput  ASEL,BSEL;\\ninput  CE;\\ninput  CLK;\\ninput  RESET;\\noutput [17:0] DOUT;\\noutput [8:0] SOA,SOB;\\nparameter AREG = 1'b0;\\nparameter BREG = 1'b0;\\nparameter OUT_REG = 1'b0;\\nparameter PIPE_REG = 1'b0;\\nparameter ASIGN_REG = 1'b0;\\nparameter BSIGN_REG = 1'b0;\\nparameter SOA_REG = 1'b0; \\nparameter MULT_RESET_MODE = \\\"SYNC\\\"; \\nendmodule\\n\\nmodule MULT18X18 (...);\\ninput  [17:0] A,SIA;\\ninput  [17:0] B,SIB;\\ninput  ASIGN,BSIGN;\\ninput  ASEL,BSEL;\\ninput  CE;\\ninput  CLK;\\ninput  RESET;\\noutput [35:0] DOUT;\\noutput [17:0] SOA,SOB;\\nparameter AREG = 1'b0;\\nparameter BREG = 1'b0;\\nparameter OUT_REG = 1'b0;\\nparameter PIPE_REG = 1'b0;\\nparameter ASIGN_REG = 1'b0;\\nparameter BSIGN_REG = 1'b0;\\nparameter SOA_REG = 1'b0;\\nparameter MULT_RESET_MODE = \\\"SYNC\\\"; \\nendmodule\\n\\nmodule MULT36X36 (...);\\ninput  [35:0] A;\\ninput  [35:0] B;\\ninput  ASIGN,BSIGN;\\ninput  CE;\\ninput  CLK;\\ninput  RESET;\\noutput [71:0] DOUT;\\nparameter AREG = 1'b0;\\nparameter BREG = 1'b0;\\nparameter OUT0_REG = 1'b0;\\nparameter OUT1_REG = 1'b0;\\nparameter PIPE_REG = 1'b0;\\nparameter ASIGN_REG = 1'b0;\\nparameter BSIGN_REG = 1'b0;\\nparameter MULT_RESET_MODE = \\\"SYNC\\\"; \\nendmodule\\n\\nmodule MULTALU36X18 (...);\\ninput  [17:0] A;\\ninput  [35:0] B;\\ninput  [53:0] C;\\ninput  ASIGN,BSIGN,ACCLOAD;\\ninput  CE;\\ninput  CLK;\\ninput  RESET;\\ninput  [54:0] CASI;\\noutput [53:0] DOUT;\\noutput [54:0] CASO;\\nparameter AREG = 1'b0;\\nparameter BREG = 1'b0;\\nparameter CREG = 1'b0;\\nparameter OUT_REG = 1'b0;\\nparameter PIPE_REG = 1'b0;\\nparameter ASIGN_REG = 1'b0;\\nparameter BSIGN_REG = 1'b0;\\nparameter ACCLOAD_REG0 = 1'b0;\\nparameter ACCLOAD_REG1 = 1'b0;\\nparameter MULT_RESET_MODE = \\\"SYNC\\\"; \\nparameter MULTALU36X18_MODE = 0; \\nparameter C_ADD_SUB = 1'b0; \\nendmodule\\n\\nmodule MULTADDALU18X18 (...);\\ninput [17:0] A0;\\ninput [17:0] B0;\\ninput [17:0] A1;\\ninput [17:0] B1;\\ninput [53:0] C;\\ninput [17:0] SIA, SIB;\\ninput [1:0] ASIGN, BSIGN;\\ninput [1:0] ASEL, BSEL;\\ninput [54:0] CASI;\\ninput CE;\\ninput CLK;\\ninput RESET;\\ninput ACCLOAD;\\noutput [53:0] DOUT;\\noutput [54:0] CASO;\\noutput [17:0] SOA, SOB;\\nparameter A0REG = 1'b0; \\nparameter A1REG = 1'b0;\\nparameter B0REG = 1'b0;\\nparameter B1REG = 1'b0;\\nparameter CREG = 1'b0;\\nparameter PIPE0_REG = 1'b0;\\nparameter PIPE1_REG = 1'b0;\\nparameter OUT_REG = 1'b0;\\nparameter ASIGN0_REG = 1'b0;\\nparameter ASIGN1_REG = 1'b0;\\nparameter ACCLOAD_REG0 = 1'b0;\\nparameter ACCLOAD_REG1 = 1'b0;\\nparameter BSIGN0_REG = 1'b0;\\nparameter BSIGN1_REG = 1'b0;\\nparameter SOA_REG = 1'b0;\\nparameter B_ADD_SUB = 1'b0; \\nparameter C_ADD_SUB = 1'b0;\\nparameter MULTADDALU18X18_MODE = 0;\\nparameter MULT_RESET_MODE = \\\"SYNC\\\";\\nendmodule\\n\\nmodule MULTALU18X18 (...);\\ninput [17:0] A, B;\\ninput CLK,CE,RESET;\\ninput ASIGN, BSIGN;\\ninput ACCLOAD,DSIGN;\\ninput [53:0] C,D;\\ninput [54:0] CASI;\\noutput [53:0] DOUT;\\noutput [54:0] CASO;\\nparameter AREG = 1'b0;\\nparameter BREG = 1'b0;\\nparameter CREG = 1'b0;\\nparameter DREG = 1'b0;\\nparameter DSIGN_REG = 1'b0;\\nparameter ASIGN_REG = 1'b0;\\nparameter BSIGN_REG = 1'b0;\\nparameter ACCLOAD_REG0 = 1'b0;\\nparameter ACCLOAD_REG1 = 1'b0;\\nparameter MULT_RESET_MODE = \\\"SYNC\\\"; \\nparameter PIPE_REG = 1'b0;\\nparameter OUT_REG = 1'b0;\\nparameter B_ADD_SUB = 1'b0; \\nparameter C_ADD_SUB = 1'b0;\\nparameter MULTALU18X18_MODE = 0; \\nendmodule\\n\\nmodule ALU54D (...);\\ninput [53:0] A, B;\\ninput ASIGN,BSIGN;\\ninput ACCLOAD;\\ninput [54:0] CASI;\\ninput CLK, CE, RESET;\\noutput [53:0] DOUT;\\noutput [54:0] CASO;\\nparameter AREG = 1'b0; \\nparameter BREG = 1'b0;\\nparameter ASIGN_REG = 1'b0;\\nparameter BSIGN_REG = 1'b0;\\nparameter ACCLOAD_REG = 1'b0;\\nparameter OUT_REG = 1'b0;\\nparameter B_ADD_SUB = 1'b0; \\nparameter C_ADD_SUB = 1'b0;\\nparameter ALUD_MODE = 0;\\nparameter ALU_RESET_MODE = \\\"SYNC\\\";\\nendmodule\\n\\nmodule BUFG (...);\\noutput O;\\ninput I;\\nendmodule\\n\\n\\nmodule BUFS (...);\\noutput O;\\ninput I;\\nendmodule\\n\\n\\nmodule PLL (...);\\ninput CLKIN;\\ninput CLKFB;\\ninput RESET; \\ninput RESET_P; \\ninput RESET_I;\\ninput RESET_S;\\ninput [5:0] FBDSEL; \\ninput [5:0] IDSEL;\\ninput [5:0] ODSEL;\\ninput [3:0] PSDA,FDLY; \\ninput [3:0] DUTYDA;\\noutput CLKOUT;\\noutput LOCK;\\noutput CLKOUTP;\\noutput CLKOUTD;\\noutput CLKOUTD3;\\nparameter FCLKIN = \\\"100.0\\\"; \\nparameter DYN_IDIV_SEL= \\\"false\\\";\\nparameter IDIV_SEL = 0; \\nparameter DYN_FBDIV_SEL= \\\"false\\\";\\nparameter FBDIV_SEL = 0; \\nparameter DYN_ODIV_SEL= \\\"false\\\";\\nparameter ODIV_SEL = 8; \\nparameter PSDA_SEL= \\\"0000\\\";\\nparameter DYN_DA_EN = \\\"false\\\";\\nparameter DUTYDA_SEL= \\\"1000\\\";\\nparameter CLKOUT_FT_DIR = 1'b1; \\nparameter CLKOUTP_FT_DIR = 1'b1; \\nparameter CLKOUT_DLY_STEP = 0; \\nparameter CLKOUTP_DLY_STEP = 0; \\nparameter CLKFB_SEL = \\\"internal\\\"; \\nparameter CLKOUT_BYPASS = \\\"false\\\";  \\nparameter CLKOUTP_BYPASS = \\\"false\\\";   \\nparameter CLKOUTD_BYPASS = \\\"false\\\";  \\nparameter DYN_SDIV_SEL = 2; \\nparameter CLKOUTD_SRC =  \\\"CLKOUT\\\";  \\nparameter CLKOUTD3_SRC = \\\"CLKOUT\\\"; \\nparameter DEVICE = \\\"GW1N-4\\\";\\nendmodule\\n\\nmodule TLVDS_IBUF (...);\\noutput O;\\ninput  I, IB;\\nendmodule\\n\\nmodule TLVDS_TBUF (...);\\noutput O, OB;\\ninput  I, OEN;\\nendmodule\\n\\nmodule TLVDS_IOBUF (...);\\noutput   O;\\ninout IO, IOB;\\ninput I, OEN;\\nendmodule\\n\\nmodule ELVDS_IBUF (...);\\noutput O;\\ninput  I, IB;\\nendmodule\\n\\nmodule ELVDS_TBUF (...);\\noutput O, OB;\\ninput  I, OEN;\\nendmodule\\n\\nmodule ELVDS_IOBUF (...);\\noutput   O;\\ninout IO, IOB;\\ninput I, OEN;\\nendmodule\\n\\nmodule MIPI_IBUF (...);\\noutput OH, OL, OB;\\ninout IO, IOB;\\ninput  I, IB;\\ninput OEN, OENB;\\ninput HSREN;\\nendmodule\\n\\nmodule MIPI_IBUF_HS (...);\\noutput OH;\\ninput  I, IB;\\nendmodule\\n\\nmodule MIPI_IBUF_LP (...);\\noutput OL;\\noutput OB;\\ninput  I;\\ninput IB;\\nendmodule\\n\\nmodule MIPI_OBUF (...);\\noutput O, OB;\\ninput  I, IB, MODESEL;\\nendmodule\\n\\nmodule MIPI_OBUF_A (...);\\noutput O, OB;\\ninput  I, IB, IL, MODESEL;\\nendmodule\\n\\nmodule I3C_IOBUF (...);\\noutput O;\\ninout IO;\\ninput  I, MODESEL;\\nendmodule\\n\\nmodule CLKDIV (...);\\ninput HCLKIN;\\ninput RESETN;\\ninput CALIB;\\noutput CLKOUT;\\nparameter DIV_MODE = \\\"2\\\"; \\nparameter GSREN = \\\"false\\\"; \\nendmodule\\n\\nmodule DHCEN (...);\\ninput CLKIN,CE;\\noutput CLKOUT;\\nendmodule\\n\\nmodule DLL (...);\\ninput CLKIN;\\ninput STOP;\\ninput UPDNCNTL;\\ninput RESET;\\noutput [7:0]STEP;\\noutput LOCK;\\nparameter DLL_FORCE = 0;\\nparameter CODESCAL=\\\"000\\\";\\nparameter SCAL_EN=\\\"true\\\";\\nparameter DIV_SEL = 1'b0; \\nendmodule\\n\\nmodule DLLDLY (...);\\ninput CLKIN;\\ninput [7:0] DLLSTEP;\\ninput DIR,LOADN,MOVE;\\noutput CLKOUT;\\noutput FLAG;\\nparameter DLL_INSEL = 1'b1; \\nparameter DLY_SIGN = 1'b0; \\nparameter DLY_ADJ = 0; \\nendmodule\\n\\nmodule FLASH96K (...);\\ninput [5:0] RA,CA,PA;\\ninput [3:0] MODE;\\ninput [1:0] SEQ;\\ninput ACLK,PW,RESET,PE,OE;\\ninput [1:0] RMODE,WMODE;\\ninput [1:0] RBYTESEL,WBYTESEL;\\ninput [31:0] DIN;\\noutput [31:0] DOUT;\\nendmodule\\n\\nmodule FLASH256K (...);\\ninput[6:0]XADR;\\ninput[5:0]YADR;\\ninput XE,YE,SE;\\ninput ERASE,PROG,NVSTR;\\ninput [31:0] DIN;\\noutput reg [31:0] DOUT;\\nparameter IDLE    =  4'd0,\\n          ERA_S1  =  4'd1,\\n\\t\\t  ERA_S2  =  4'd2,\\n\\t\\t  ERA_S3  =  4'd3,\\n\\t\\t  ERA_S4  =  4'd4,\\n\\t\\t  ERA_S5  =  4'd5,\\n\\t\\t  PRO_S1  =  4'd6,\\n\\t\\t  PRO_S2  =  4'd7,\\n\\t\\t  PRO_S3  =  4'd8,\\n\\t\\t  PRO_S4  =  4'd9,\\n\\t\\t  PRO_S5  =  4'd10,\\n\\t\\t  RD_S1   =  4'd11,\\n\\t\\t  RD_S2   =  4'd12;\\t\\t  \\nendmodule\\n\\nmodule FLASH608K (...);\\ninput[8:0]XADR;\\ninput[5:0]YADR;\\ninput XE,YE,SE;\\ninput ERASE,PROG,NVSTR;\\ninput [31:0] DIN;\\noutput reg [31:0] DOUT;\\nparameter IDLE    =  4'd0,\\n          ERA_S1  =  4'd1,\\n\\t\\t  ERA_S2  =  4'd2,\\n\\t\\t  ERA_S3  =  4'd3,\\n\\t\\t  ERA_S4  =  4'd4,\\n   \\t\\t  ERA_S5  =  4'd5,\\n\\t\\t  PRO_S1  =  4'd6,\\n\\t\\t  PRO_S2  =  4'd7,\\n\\t\\t  PRO_S3  =  4'd8,\\n\\t\\t  PRO_S4  =  4'd9,\\n\\t\\t  PRO_S5  =  4'd10,\\n\\t\\t  RD_S1   =  4'd11,\\n\\t\\t  RD_S2   =  4'd12;\\nendmodule\\n\\nmodule DCS (...);\\ninput CLK0, CLK1, CLK2, CLK3, SELFORCE;\\ninput [3:0] CLKSEL;\\noutput CLKOUT;\\nendmodule\\n\\nmodule DQCE (...);\\ninput CLKIN;\\ninput CE;\\noutput CLKOUT;\\nendmodule\\n\\nmodule FLASH128K (...);\\ninput [31:0] DIN;\\ninput [14:0] ADDR;\\ninput CS,AE,OE;\\ninput PCLK;\\ninput PROG, SERA, MASE;\\ninput NVSTR;\\ninput IFREN;\\ninput RESETN;\\noutput [31:0] DOUT;\\noutput TBIT;\\nparameter IDLE  = 4'd0,\\n          READ_S1 = 4'd1,\\n          READ_S2 = 4'd2,\\n          PROG_S1 = 4'd3,\\n          PROG_S2 = 4'd4,\\n          PROG_S3 = 4'd5,\\n          PROG_S4 = 4'd6,\\n          SERA_S1 = 4'd7,\\n          SERA_S2 = 4'd8,\\n          SERA_S3 = 4'd9,\\n          SERA_S4 = 4'd10,\\n          MASE_S1 = 4'd11,\\n          MASE_S2 = 4'd12,\\n          MASE_S3 = 4'd13,\\n          MASE_S4 = 4'd14;\\nendmodule\\n\\nmodule MCU (...);\\nendmodule\\n\\nmodule USB20_PHY (...);\\nparameter DATABUS16_8 = 1'b0;\\nparameter ADP_PRBEN = 1'b0;\\nparameter TEST_MODE = 5'b00000;\\nparameter HSDRV1 = 1'b0; \\nparameter HSDRV0 = 1'b0; \\nparameter CLK_SEL = 1'b0;\\nparameter M = 4'b0000; \\nparameter N = 6'b101000; \\nparameter C = 2'b01; \\nparameter FOC_LOCK = 1'b0;\\ninput   [15:0]  DATAIN;\\ninput   TXVLD;\\ninput   TXVLDH;\\ninput   RESET;\\ninput   SUSPENDM;\\ninput   [1:0]   XCVRSEL;\\ninput   TERMSEL;\\ninput   [1:0]   OPMODE;\\noutput  [15:0]  DATAOUT;\\noutput  TXREADY;\\noutput  RXACTIVE;\\noutput  RXVLD;\\noutput  RXVLDH;\\noutput  CLK;      \\noutput  RXERROR;\\ninout   DP;\\ninout   DM;\\noutput  [1:0]   LINESTATE;\\ninput   IDPULLUP;\\ninput   DPPD;\\ninput   DMPD;\\ninput   CHARGVBUS;\\ninput   DISCHARGVBUS;\\ninput   TXBITSTUFFEN;\\ninput   TXBITSTUFFENH;\\ninput   TXENN;\\ninput   TXDAT;\\ninput   TXSE0;\\ninput   FSLSSERIAL;\\noutput  HOSTDIS;\\noutput  IDDIG;\\noutput  ADPPRB;\\noutput  ADPSNS;\\noutput  SESSVLD;\\noutput  VBUSVLD;\\noutput  RXDP;\\noutput  RXDM;\\noutput  RXRCV;\\noutput  LBKERR;\\noutput  CLKRDY;\\ninput   INTCLK;\\ninout   ID;\\ninout   VBUS;\\ninout   REXT;\\ninput   XIN;\\ninout   XOUT;\\ninput\\tTEST;\\noutput\\tCLK480PAD;\\ninput        SCANCLK; \\ninput        SCANEN; \\ninput        SCANMODE; \\ninput        TRESETN; \\ninput        SCANIN1; \\noutput       SCANOUT1; \\ninput        SCANIN2; \\noutput       SCANOUT2; \\ninput        SCANIN3; \\noutput       SCANOUT3; \\ninput        SCANIN4; \\noutput       SCANOUT4; \\ninput        SCANIN5; \\noutput       SCANOUT5; \\ninput        SCANIN6; \\noutput       SCANOUT6; \\nendmodule\\n\\nmodule ADC (...);\\nendmodule\\n\\nmodule BANDGAP (...);\\ninput BGEN;\\nendmodule\\n\\nmodule CLKDIV2 (...);\\nparameter GSREN = \\\"false\\\"; \\ninput HCLKIN, RESETN;\\noutput CLKOUT;\\nendmodule\\n\\nmodule DCC (...);\\noutput CLKOUT;\\ninput CLKIN;\\nparameter DCC_EN = 1'b1; \\nparameter FCLKIN = 50.0;\\nendmodule\\n\\nmodule DHCENC (...);\\ninput CLKIN, CE;\\noutput CLKOUT, CLKOUTN;\\nendmodule\\n\\nmodule EMCU (...);\\nendmodule\\n\\nmodule FLASH64K (...);\\ninput[4:0]XADR;\\ninput[5:0]YADR;\\ninput XE,YE,SE;\\ninput ERASE,PROG,NVSTR;\\ninput SLEEP;\\ninput [31:0] DIN;\\noutput reg [31:0] DOUT;\\nparameter IDLE    =  4'd0,\\n          ERA_S1  =  4'd1,\\n\\t\\t  ERA_S2  =  4'd2,\\n\\t\\t  ERA_S3  =  4'd3,\\n\\t\\t  ERA_S4  =  4'd4,\\n\\t\\t  ERA_S5  =  4'd5,\\n\\t\\t  PRO_S1  =  4'd6,\\n\\t\\t  PRO_S2  =  4'd7,\\n\\t\\t  PRO_S3  =  4'd8,\\n\\t\\t  PRO_S4  =  4'd9,\\n\\t\\t  PRO_S5  =  4'd10,\\n\\t\\t  RD_S1   =  4'd11,\\n\\t\\t  RD_S2   =  4'd12;\\t\\t  \\nendmodule\\n\\nmodule FLASH64KZ (...);\\ninput[4:0]XADR;\\ninput[5:0]YADR;\\ninput XE,YE,SE;\\ninput ERASE,PROG,NVSTR;\\ninput [31:0] DIN;\\noutput reg [31:0] DOUT;\\nparameter IDLE    =  4'd0,\\n          ERA_S1  =  4'd1,\\n\\t\\t  ERA_S2  =  4'd2,\\n\\t\\t  ERA_S3  =  4'd3,\\n\\t\\t  ERA_S4  =  4'd4,\\n\\t\\t  ERA_S5  =  4'd5,\\n\\t\\t  PRO_S1  =  4'd6,\\n\\t\\t  PRO_S2  =  4'd7,\\n\\t\\t  PRO_S3  =  4'd8,\\n\\t\\t  PRO_S4  =  4'd9,\\n\\t\\t  PRO_S5  =  4'd10,\\n\\t\\t  RD_S1   =  4'd11,\\n\\t\\t  RD_S2   =  4'd12;\\t\\t  \\nendmodule\\n\\nmodule I3C (...);\\nparameter ADDRESS = 7'b0000000;\\ninput \\tLGYS, CMS, ACS, AAS, STOPS, STRTS;\\noutput \\tLGYO, CMO, ACO, AAO, SIO, STOPO, STRTO;\\ninput \\tLGYC, CMC, ACC, AAC, SIC, STOPC, STRTC;\\ninput\\tSTRTHDS, SENDAHS, SENDALS, ACKHS;\\ninput\\tACKLS, STOPSUS, STOPHDS, SENDDHS;\\ninput\\tSENDDLS, RECVDHS, RECVDLS, ADDRS;\\noutput\\tPARITYERROR;\\ninput \\t[7:0] DI;\\noutput \\t[7:0] DOBUF;\\noutput \\t[7:0] DO;\\noutput \\t[7:0] STATE;\\ninput\\tSDAI, SCLI;\\noutput\\tSDAO, SCLO;\\noutput\\tSDAOEN, SCLOEN;\\noutput\\tSDAPULLO, SCLPULLO;\\noutput\\tSDAPULLOEN, SCLPULLOEN;\\ninput \\tCE, RESET, CLK;\\nendmodule\\n\\nmodule IODELAYA (...);\\nparameter C_STATIC_DLY = 0; \\ninput DI;\\ninput  SDTAP;\\ninput  SETN;\\ninput  VALUE;\\noutput DF;\\noutput DO;\\nendmodule\\n\\nmodule IODELAYC (...);\\nparameter C_STATIC_DLY = 0; \\nparameter DYN_DA_SEL = \\\"false\\\"; \\nparameter DA_SEL = 2'b00;\\ninput DI;\\ninput  SDTAP;\\ninput  SETN;\\ninput  VALUE;\\ninput [1:0] DASEL;\\ninput [1:0] DAADJ;\\noutput DF;\\noutput DO;\\noutput DAO;\\nendmodule\\n\\n\\nmodule SPMI (...);\\nparameter FUNCTION_CTRL = 7'b0000000; \\nparameter MSID_CLKSEL = 7'b0000000;\\nparameter RESPOND_DELAY = 4'b0000;\\nparameter SCLK_NORMAL_PERIOD = 7'b0000000;\\nparameter SCLK_LOW_PERIOD = 7'b0000000;\\nparameter CLK_FREQ = 7'b0000000;\\nparameter SHUTDOWN_BY_ENABLE = 1'b0; \\ninput\\tCLKEXT, ENEXT;\\ninout\\tSDATA, \\tSCLK;\\ninput \\tCLK, CE, RESETN, LOCRESET;\\ninput \\tPA, SA, CA;\\ninput\\t[3:0] \\tADDRI;\\ninput\\t[7:0] \\tDATAI;\\noutput \\t[3:0] \\tADDRO;\\noutput \\t[7:0] \\tDATAO;\\noutput \\t[15:0] \\tSTATE;\\noutput\\t[3:0]\\tCMD;\\nendmodule\\n\\nmodule IODELAYB (...);\\nparameter C_STATIC_DLY = 0; \\nparameter DELAY_MUX = 2'b00; \\nparameter DA_SEL = 2'b00;\\ninput DI;\\ninput  SDTAP;\\ninput  SETN;\\ninput  VALUE;\\ninput [1:0] DAADJ;\\noutput DF;\\noutput DO;\\noutput DAO;\\nendmodule\\n\\n\\nmodule PLLO (...);\\ninput CLKIN;\\ninput CLKFB;\\ninput RESET;\\ninput RESET_P;\\ninput RESET_I;\\ninput RESET_S;\\ninput [5:0] FBDSEL;\\ninput [5:0] IDSEL;\\ninput [6:0] ODSELA;\\ninput [6:0] ODSELB;\\ninput [6:0] ODSELC;\\ninput [6:0] ODSELD;\\ninput [3:0] DTA;\\ninput [3:0] DTB;\\ninput [4:0] ICPSEL;\\ninput [2:0] LPFRES;\\ninput [1:0] PSSEL;\\ninput PSDIR;\\ninput PSPULSE;\\ninput ENCLKA;\\ninput ENCLKB;\\ninput ENCLKC;\\ninput ENCLKD;\\noutput LOCK;\\noutput CLKOUTA;\\noutput CLKOUTB;\\noutput CLKOUTC;\\noutput CLKOUTD;\\nparameter FCLKIN = \\\"100.0\\\"; \\nparameter DYN_IDIV_SEL= \\\"FALSE\\\";\\nparameter IDIV_SEL = 0; \\nparameter DYN_FBDIV_SEL= \\\"FALSE\\\";\\nparameter FBDIV_SEL = 0; \\nparameter DYN_ODIVA_SEL= \\\"FALSE\\\";\\nparameter ODIVA_SEL = 6; \\nparameter DYN_ODIVB_SEL= \\\"FALSE\\\";\\nparameter ODIVB_SEL = 6; \\nparameter DYN_ODIVC_SEL= \\\"FALSE\\\";\\nparameter ODIVC_SEL = 6; \\nparameter DYN_ODIVD_SEL= \\\"FALSE\\\";\\nparameter ODIVD_SEL = 6; \\nparameter CLKOUTA_EN = \\\"TRUE\\\";\\nparameter CLKOUTB_EN = \\\"TRUE\\\";\\nparameter CLKOUTC_EN = \\\"TRUE\\\";\\nparameter CLKOUTD_EN = \\\"TRUE\\\";\\nparameter DYN_DTA_SEL = \\\"FALSE\\\"; \\nparameter DYN_DTB_SEL = \\\"FALSE\\\"; \\nparameter CLKOUTA_DT_DIR = 1'b1; \\nparameter CLKOUTB_DT_DIR = 1'b1; \\nparameter CLKOUTA_DT_STEP = 0; \\nparameter CLKOUTB_DT_STEP = 0; \\nparameter CLKA_IN_SEL = 2'b00;\\nparameter CLKA_OUT_SEL = 1'b0;\\nparameter CLKB_IN_SEL = 2'b00;\\nparameter CLKB_OUT_SEL = 1'b0;\\nparameter CLKC_IN_SEL = 2'b00;\\nparameter CLKC_OUT_SEL = 1'b0;\\nparameter CLKD_IN_SEL = 2'b00;\\nparameter CLKD_OUT_SEL = 1'b0;\\nparameter CLKFB_SEL = \\\"INTERNAL\\\"; \\nparameter DYN_DPA_EN = \\\"FALSE\\\";\\nparameter DYN_PSB_SEL = \\\"FALSE\\\";\\nparameter DYN_PSC_SEL = \\\"FALSE\\\";\\nparameter DYN_PSD_SEL = \\\"FALSE\\\";\\nparameter PSB_COARSE = 1;\\nparameter PSB_FINE = 0;\\nparameter PSC_COARSE = 1;\\nparameter PSC_FINE = 0;\\nparameter PSD_COARSE = 1;\\nparameter PSD_FINE = 0;\\nparameter DTMS_ENB = \\\"FALSE\\\";\\nparameter DTMS_ENC = \\\"FALSE\\\";\\nparameter DTMS_END = \\\"FALSE\\\";\\nparameter RESET_I_EN = \\\"FALSE\\\";\\nparameter RESET_S_EN =  \\\"FALSE\\\";\\nparameter DYN_ICP_SEL= \\\"FALSE\\\";\\nparameter ICP_SEL = 5'bXXXXX;\\nparameter DYN_RES_SEL= \\\"FALSE\\\";\\nparameter LPR_REF = 7'bXXXXXXX;\\nendmodule\\n\\nmodule DCCG (...);\\noutput CLKOUT;\\ninput CLKIN;\\nparameter DCC_MODE = 2'b00; \\nparameter FCLKIN = 50.0;\\nendmodule\\n\\nmodule FLASH96KA (...);\\ninput[5:0]XADR;\\ninput[5:0]YADR;\\ninput XE,YE,SE;\\ninput ERASE,PROG,NVSTR;\\ninput [31:0] DIN;\\ninput SLEEP;\\noutput reg [31:0] DOUT;\\nparameter IDLE    =  4'd0,\\n          ERA_S1  =  4'd1,\\n\\t\\t  ERA_S2  =  4'd2,\\n\\t\\t  ERA_S3  =  4'd3,\\n\\t\\t  ERA_S4  =  4'd4,\\n\\t\\t  ERA_S5  =  4'd5,\\n\\t\\t  PRO_S1  =  4'd6,\\n\\t\\t  PRO_S2  =  4'd7,\\n\\t\\t  PRO_S3  =  4'd8,\\n\\t\\t  PRO_S4  =  4'd9,\\n\\t\\t  PRO_S5  =  4'd10,\\n\\t\\t  RD_S1   =  4'd11,\\n\\t\\t  RD_S2   =  4'd12;\\t\\t  \\nendmodule\\n\\nmodule MIPI_DPHY_RX (...);\\noutput [15:0] D0LN_HSRXD, D1LN_HSRXD, D2LN_HSRXD, D3LN_HSRXD;\\noutput D0LN_HSRXD_VLD,D1LN_HSRXD_VLD,D2LN_HSRXD_VLD,D3LN_HSRXD_VLD;\\noutput DI_LPRX0_N, DI_LPRX0_P, DI_LPRX1_N, DI_LPRX1_P, DI_LPRX2_N, DI_LPRX2_P, DI_LPRX3_N, DI_LPRX3_P;\\noutput DI_LPRXCK_N, DI_LPRXCK_P;\\noutput RX_CLK_O;          \\noutput DESKEW_ERROR;      \\ninout  CK_N, CK_P, RX0_N, RX0_P, RX1_N, RX1_P, RX2_N, RX2_P, RX3_N, RX3_P;\\ninput LPRX_EN_CK, LPRX_EN_D0, LPRX_EN_D1, LPRX_EN_D2, LPRX_EN_D3;\\ninput HSRX_ODTEN_CK, HSRX_ODTEN_D0,  HSRX_ODTEN_D1, HSRX_ODTEN_D2, HSRX_ODTEN_D3;\\ninput D0LN_HSRX_DREN,  D1LN_HSRX_DREN, D2LN_HSRX_DREN, D3LN_HSRX_DREN;\\ninput HSRX_EN_CK;         \\ninput HS_8BIT_MODE;       \\ninput RX_CLK_1X;          \\ninput RX_INVERT;          \\ninput LALIGN_EN;          \\ninput WALIGN_BY;          \\ninput DO_LPTX0_N, DO_LPTX0_P, DO_LPTX1_N, DO_LPTX1_P, DO_LPTX2_N, DO_LPTX2_P, DO_LPTX3_N, DO_LPTX3_P;\\ninput DO_LPTXCK_N, DO_LPTXCK_P;\\ninput LPTX_EN_CK, LPTX_EN_D0, LPTX_EN_D1, LPTX_EN_D2, LPTX_EN_D3;\\ninput BYTE_LENDIAN;       \\ninput HSRX_STOP;          \\ninput LPRX_ULP_LN0, LPRX_ULP_LN1, LPRX_ULP_LN2, LPRX_ULP_LN3, LPRX_ULP_CK;\\ninput PWRON;              \\ninput RESET;              \\ninput [2:0] DESKEW_LNSEL; \\ninput [7:0] DESKEW_MTH;   \\ninput [6:0] DESKEW_OWVAL; \\ninput DESKEW_REQ;         \\ninput DRST_N;             \\ninput ONE_BYTE0_MATCH;    \\ninput WORD_LENDIAN;       \\ninput [2:0] FIFO_RD_STD;  \\nparameter ALIGN_BYTE = 8'b10111000;\\nparameter MIPI_LANE0_EN = 1'b0;\\nparameter MIPI_LANE1_EN = 1'b0;\\nparameter MIPI_LANE2_EN = 1'b0;\\nparameter MIPI_LANE3_EN = 1'b0;\\nparameter MIPI_CK_EN = 1'b1;\\nparameter SYNC_CLK_SEL = 1'b1;\\nendmodule\\n\\nmodule CLKDIVG (...);\\ninput CLKIN;\\ninput RESETN;\\ninput CALIB;\\noutput CLKOUT;\\nparameter DIV_MODE = \\\"2\\\"; \\nparameter GSREN = \\\"false\\\"; \\nendmodule\\n\",\n            \"lutrams.txt\": \"ram distributed $__GOWIN_LUTRAM_ {\\n\\tabits 4;\\n\\twidth 4;\\n\\tcost 4;\\n\\twidthscale;\\n\\tinit no_undef;\\n\\tprune_rom;\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\",\n            \"lutrams_map.v\": \"module $__GOWIN_LUTRAM_(...);\\n\\nparameter INIT = 64'bx;\\nparameter BITS_USED = 0;\\n\\ninput PORT_W_CLK;\\ninput [3:0] PORT_W_ADDR;\\ninput PORT_W_WR_EN;\\ninput [3:0] PORT_W_WR_DATA;\\n\\ninput [3:0] PORT_R_ADDR;\\noutput [3:0] PORT_R_RD_DATA;\\n\\nfunction [15:0] init_slice;\\ninput integer idx;\\ninteger i;\\nfor (i = 0; i < 16; i = i + 1)\\n\\tinit_slice[i] = INIT[4*i+idx];\\nendfunction\\n\\ngenerate\\n\\ncasez(BITS_USED)\\n4'b000z:\\nRAM16SDP1 #(\\n\\t.INIT_0(init_slice(0)),\\n) _TECHMAP_REPLACE_ (\\n\\t.WAD(PORT_W_ADDR),\\n\\t.RAD(PORT_R_ADDR),\\n\\t.DI(PORT_W_WR_DATA[0]),\\n\\t.DO(PORT_R_RD_DATA[0]),\\n\\t.CLK(PORT_W_CLK),\\n\\t.WRE(PORT_W_WR_EN)\\n);\\n4'b00zz:\\nRAM16SDP2 #(\\n\\t.INIT_0(init_slice(0)),\\n\\t.INIT_1(init_slice(1)),\\n) _TECHMAP_REPLACE_ (\\n\\t.WAD(PORT_W_ADDR),\\n\\t.RAD(PORT_R_ADDR),\\n\\t.DI(PORT_W_WR_DATA[1:0]),\\n\\t.DO(PORT_R_RD_DATA[1:0]),\\n\\t.CLK(PORT_W_CLK),\\n\\t.WRE(PORT_W_WR_EN)\\n);\\ndefault:\\nRAM16SDP4 #(\\n\\t.INIT_0(init_slice(0)),\\n\\t.INIT_1(init_slice(1)),\\n\\t.INIT_2(init_slice(2)),\\n\\t.INIT_3(init_slice(3)),\\n) _TECHMAP_REPLACE_ (\\n\\t.WAD(PORT_W_ADDR),\\n\\t.RAD(PORT_R_ADDR),\\n\\t.DI(PORT_W_WR_DATA),\\n\\t.DO(PORT_R_RD_DATA),\\n\\t.CLK(PORT_W_CLK),\\n\\t.WRE(PORT_W_WR_EN)\\n);\\nendcase\\n\\nendgenerate\\n\\nendmodule\\n\",\n        },\n        \"greenpak4\": {\n            \"cells_blackbox.v\": \"module \\\\$__COUNT_ (CE, CLK, OUT, POUT, RST, UP);\\n\\n\\tinput wire CE;\\n\\tinput wire CLK;\\n\\toutput reg OUT;\\n\\toutput reg[WIDTH-1:0] POUT;\\n\\tinput wire RST;\\n\\tinput wire UP;\\n\\n\\tparameter COUNT_TO = 1;\\n\\tparameter RESET_MODE = \\\"RISING\\\";\\n\\tparameter RESET_TO_MAX = \\\"1\\\";\\n\\tparameter HAS_POUT = 0;\\n\\tparameter HAS_CE = 0;\\n\\tparameter WIDTH = 8;\\n\\tparameter DIRECTION = \\\"DOWN\\\";\\n\\nendmodule\\n\",\n            \"cells_latch.v\": \"module $_DLATCH_P_(input E, input D, output Q);\\n\\tGP_DLATCH _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.nCLK(!E),\\n\\t\\t.Q(Q)\\n\\t\\t);\\nendmodule\\n\\nmodule $_DLATCH_N_(input E, input D, output Q);\\n\\tGP_DLATCH _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.nCLK(E),\\n\\t\\t.Q(Q)\\n\\t\\t);\\nendmodule\\n\",\n            \"cells_map.v\": \"module GP_DFFS(input D, CLK, nSET, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tGP_DFFSR #(\\n\\t\\t.INIT(INIT),\\n\\t\\t.SRMODE(1'b1),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.CLK(CLK),\\n\\t\\t.nSR(nSET),\\n\\t\\t.Q(Q)\\n\\t);\\nendmodule\\n\\nmodule GP_DFFR(input D, CLK, nRST, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tGP_DFFSR #(\\n\\t\\t.INIT(INIT),\\n\\t\\t.SRMODE(1'b0),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.CLK(CLK),\\n\\t\\t.nSR(nRST),\\n\\t\\t.Q(Q)\\n\\t);\\nendmodule\\n\\nmodule GP_DFFSI(input D, CLK, nSET, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tGP_DFFSRI #(\\n\\t\\t.INIT(INIT),\\n\\t\\t.SRMODE(1'b1),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.CLK(CLK),\\n\\t\\t.nSR(nSET),\\n\\t\\t.nQ(nQ)\\n\\t);\\nendmodule\\n\\nmodule GP_DFFRI(input D, CLK, nRST, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tGP_DFFSRI #(\\n\\t\\t.INIT(INIT),\\n\\t\\t.SRMODE(1'b0),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.CLK(CLK),\\n\\t\\t.nSR(nRST),\\n\\t\\t.nQ(nQ)\\n\\t);\\nendmodule\\n\\nmodule GP_DLATCHS(input D, nCLK, nSET, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tGP_DLATCHSR #(\\n\\t\\t.INIT(INIT),\\n\\t\\t.SRMODE(1'b1),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.nCLK(nCLK),\\n\\t\\t.nSR(nSET),\\n\\t\\t.Q(Q)\\n\\t);\\nendmodule\\n\\nmodule GP_DLATCHR(input D, nCLK, nRST, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tGP_DLATCHSR #(\\n\\t\\t.INIT(INIT),\\n\\t\\t.SRMODE(1'b0),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.nCLK(nCLK),\\n\\t\\t.nSR(nRST),\\n\\t\\t.Q(Q)\\n\\t);\\nendmodule\\n\\nmodule GP_DLATCHSI(input D, nCLK, nSET, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tGP_DLATCHSRI #(\\n\\t\\t.INIT(INIT),\\n\\t\\t.SRMODE(1'b1),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.nCLK(nCLK),\\n\\t\\t.nSR(nSET),\\n\\t\\t.nQ(nQ)\\n\\t);\\nendmodule\\n\\nmodule GP_DLATCHRI(input D, nCLK, nRST, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tGP_DLATCHSRI #(\\n\\t\\t.INIT(INIT),\\n\\t\\t.SRMODE(1'b0),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.D(D),\\n\\t\\t.nCLK(nCLK),\\n\\t\\t.nSR(nRST),\\n\\t\\t.nQ(nQ)\\n\\t);\\nendmodule\\n\\nmodule GP_OBUFT(input IN, input OE, output OUT);\\n\\tGP_IOBUF _TECHMAP_REPLACE_ (\\n\\t\\t.IN(IN),\\n\\t\\t.OE(OE),\\n\\t\\t.IO(OUT),\\n\\t\\t.OUT()\\n\\t);\\nendmodule\\n\\nmodule \\\\$lut (A, Y);\\n\\tparameter WIDTH = 0;\\n\\tparameter LUT = 0;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] A;\\n\\toutput Y;\\n\\n\\tgenerate\\n\\t\\tif (WIDTH == 1) begin\\n\\t\\tif(LUT == 2'b01) begin\\n\\t\\t\\tGP_INV _TECHMAP_REPLACE_ (.OUT(Y), .IN(A[0]) );\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\tGP_2LUT #(.INIT({2'b00, LUT})) _TECHMAP_REPLACE_ (.OUT(Y),\\n\\t\\t\\t\\t.IN0(A[0]), .IN1(1'b0));\\n\\t\\tend\\n\\t\\tend else\\n\\t\\tif (WIDTH == 2) begin\\n\\t\\t\\tGP_2LUT #(.INIT(LUT)) _TECHMAP_REPLACE_ (.OUT(Y),\\n\\t\\t\\t\\t.IN0(A[0]), .IN1(A[1]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 3) begin\\n\\t\\t\\tGP_3LUT #(.INIT(LUT)) _TECHMAP_REPLACE_ (.OUT(Y),\\n\\t\\t\\t\\t.IN0(A[0]), .IN1(A[1]), .IN2(A[2]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 4) begin\\n\\t\\t\\tGP_4LUT #(.INIT(LUT)) _TECHMAP_REPLACE_ (.OUT(Y),\\n\\t\\t\\t\\t.IN0(A[0]), .IN1(A[1]), .IN2(A[2]), .IN3(A[3]));\\n\\t\\tend else begin\\n\\t\\t\\twire _TECHMAP_FAIL_ = 1;\\n\\t\\tend\\n\\tendgenerate\\nendmodule\\n\\nmodule \\\\$__COUNT_ (CE, CLK, OUT, POUT, RST, UP);\\n\\n\\tinput wire CE;\\n\\tinput wire CLK;\\n\\toutput reg OUT;\\n\\t(* force_downto *)\\n\\toutput reg[WIDTH-1:0] POUT;\\n\\tinput wire RST;\\n\\tinput wire UP;\\n\\n\\tparameter COUNT_TO = 1;\\n\\tparameter RESET_MODE = \\\"RISING\\\";\\n\\tparameter RESET_TO_MAX = 0;\\n\\tparameter HAS_POUT = 0;\\n\\tparameter HAS_CE = 0;\\n\\tparameter WIDTH = 8;\\n\\tparameter DIRECTION = \\\"DOWN\\\";\\n\\n\\t//If we have a DIRECTION other than DOWN fail... GP_COUNTx_ADV is not supported yet\\n\\tif(DIRECTION != \\\"DOWN\\\") begin\\n\\t\\tinitial begin\\n\\t\\t\\t$display(\\\"ERROR: \\\\$__COUNT_ support for GP_COUNTx_ADV is not yet implemented. This counter should never have been extracted (bug in extract_counter pass?).\\\");\\n\\t\\t\\t$finish;\\n\\t\\tend\\n\\tend\\n\\n\\t//If counter is more than 14 bits wide, complain (also shouldn't happen)\\n\\telse if(WIDTH > 14) begin\\n\\t\\tinitial begin\\n\\t\\t\\t$display(\\\"ERROR: \\\\$__COUNT_ support for cascaded counters is not yet implemented. This counter should never have been extracted (bug in extract_counter pass?).\\\");\\n\\t\\t\\t$finish;\\n\\t\\tend\\n\\tend\\n\\n\\t//If counter is more than 8 bits wide and has parallel output, we have a problem\\n\\telse if(WIDTH > 8 && HAS_POUT) begin\\n\\t\\tinitial begin\\n\\t\\t\\t$display(\\\"ERROR: \\\\$__COUNT_ support for 9-14 bit counters with parallel output is not yet implemented. This counter should never have been extracted (bug in extract_counter pass?).\\\");\\n\\t\\t\\t$finish;\\n\\t\\tend\\n\\tend\\n\\n\\t//Looks like a legal counter! Do something with it\\n\\telse if(WIDTH <= 8) begin\\n\\t\\tif(HAS_CE) begin\\n\\t\\t\\twire ce_not;\\n\\t\\t\\tGP_INV ceinv(\\n\\t\\t\\t\\t.IN(CE),\\n\\t\\t\\t\\t.OUT(ce_not)\\n\\t\\t\\t);\\n\\t\\t\\tGP_COUNT8_ADV #(\\n\\t\\t\\t\\t.COUNT_TO(COUNT_TO),\\n\\t\\t\\t\\t.RESET_MODE(RESET_MODE),\\n\\t\\t\\t\\t.RESET_VALUE(RESET_TO_MAX ? \\\"COUNT_TO\\\" : \\\"ZERO\\\"),\\n\\t\\t\\t\\t.CLKIN_DIVIDE(1)\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t.CLK(CLK),\\n\\t\\t\\t\\t.RST(RST),\\n\\t\\t\\t\\t.OUT(OUT),\\n\\t\\t\\t\\t.UP(1'b0),\\t\\t//always count down for now\\n\\t\\t\\t\\t.KEEP(ce_not),\\n\\t\\t\\t\\t.POUT(POUT)\\n\\t\\t\\t);\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\tGP_COUNT8 #(\\n\\t\\t\\t\\t.COUNT_TO(COUNT_TO),\\n\\t\\t\\t\\t.RESET_MODE(RESET_MODE),\\n\\t\\t\\t\\t.CLKIN_DIVIDE(1)\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t.CLK(CLK),\\n\\t\\t\\t\\t.RST(RST),\\n\\t\\t\\t\\t.OUT(OUT),\\n\\t\\t\\t\\t.POUT(POUT)\\n\\t\\t\\t);\\n\\t\\tend\\n\\tend\\n\\n\\telse begin\\n\\t\\tif(HAS_CE) begin\\n\\t\\t\\twire ce_not;\\n\\t\\t\\tGP_INV ceinv(\\n\\t\\t\\t\\t.IN(CE),\\n\\t\\t\\t\\t.OUT(ce_not)\\n\\t\\t\\t);\\n\\t\\t\\tGP_COUNT14_ADV #(\\n\\t\\t\\t\\t.COUNT_TO(COUNT_TO),\\n\\t\\t\\t\\t.RESET_MODE(RESET_TO_MAX ? \\\"COUNT_TO\\\" : \\\"ZERO\\\"),\\n\\t\\t\\t\\t.RESET_VALUE(\\\"COUNT_TO\\\"),\\n\\t\\t\\t\\t.CLKIN_DIVIDE(1)\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t.CLK(CLK),\\n\\t\\t\\t\\t.RST(RST),\\n\\t\\t\\t\\t.OUT(OUT),\\n\\t\\t\\t\\t.UP(1'b0),\\t\\t//always count down for now\\n\\t\\t\\t\\t.KEEP(ce_not),\\n\\t\\t\\t\\t.POUT(POUT)\\n\\t\\t\\t);\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\tGP_COUNT14 #(\\n\\t\\t\\t\\t.COUNT_TO(COUNT_TO),\\n\\t\\t\\t\\t.RESET_MODE(RESET_MODE),\\n\\t\\t\\t\\t.CLKIN_DIVIDE(1)\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t.CLK(CLK),\\n\\t\\t\\t\\t.RST(RST),\\n\\t\\t\\t\\t.OUT(OUT)\\n\\t\\t\\t);\\n\\t\\tend\\n\\tend\\n\\nendmodule\\n\",\n            \"cells_sim.v\": \"`timescale 1ns/1ps\\n\\n`include \\\"cells_sim_ams.v\\\"\\n`include \\\"cells_sim_digital.v\\\"\\n`include \\\"cells_sim_wip.v\\\"\\n\",\n            \"cells_sim_ams.v\": \"`timescale 1ns/1ps\\n\\n/*\\n This file contains analog / mixed signal cells, or other things that are not possible to fully model\\n in behavioral Verilog.\\n\\n It also contains some stuff like oscillators that use non-synthesizeable constructs such as delays.\\n TODO: do we want a third file for those cells?\\n */\\n\\nmodule GP_ABUF(input wire IN, output wire OUT);\\n\\n\\tassign OUT = IN;\\n\\n\\t//must be 1, 5, 20, 50\\n\\t//values >1 only available with Vdd > 2.7V\\n\\tparameter BANDWIDTH_KHZ = 1;\\n\\nendmodule\\n\\nmodule GP_ACMP(input wire PWREN, input wire VIN, input wire VREF, output reg OUT);\\n\\n\\tparameter BANDWIDTH = \\\"HIGH\\\";\\n\\tparameter VIN_ATTEN = 1;\\n\\tparameter VIN_ISRC_EN = 0;\\n\\tparameter HYSTERESIS = 0;\\n\\n\\tinitial OUT = 0;\\n\\nendmodule\\n\\nmodule GP_BANDGAP(output reg OK);\\n\\tparameter AUTO_PWRDN = 1;\\n\\tparameter CHOPPER_EN = 1;\\n\\tparameter OUT_DELAY = 100;\\n\\nendmodule\\n\\nmodule GP_DAC(input[7:0] DIN, input wire VREF, output reg VOUT);\\n\\n\\tinitial VOUT = 0;\\n\\n\\t//analog hard IP is not supported for simulation\\n\\nendmodule\\n\\nmodule GP_LFOSC(input PWRDN, output reg CLKOUT);\\n\\n\\tparameter PWRDN_EN = 0;\\n\\tparameter AUTO_PWRDN = 0;\\n\\tparameter OUT_DIV = 1;\\n\\n\\tinitial CLKOUT = 0;\\n\\n\\t//auto powerdown not implemented for simulation\\n\\t//output dividers not implemented for simulation\\n\\n\\talways begin\\n\\t\\tif(PWRDN)\\n\\t\\t\\tCLKOUT = 0;\\n\\t\\telse begin\\n\\t\\t\\t//half period of 1730 Hz\\n\\t\\t\\t#289017;\\n\\t\\t\\tCLKOUT = ~CLKOUT;\\n\\t\\tend\\n\\tend\\n\\nendmodule\\n\\nmodule GP_PGA(input wire VIN_P, input wire VIN_N, input wire VIN_SEL, output reg VOUT);\\n\\n\\tparameter GAIN = 1;\\n\\tparameter INPUT_MODE = \\\"SINGLE\\\";\\n\\n\\tinitial VOUT = 0;\\n\\n\\t//cannot simulate mixed signal IP\\n\\nendmodule\\n\\nmodule GP_PWRDET(output reg VDD_LOW);\\n\\tinitial VDD_LOW = 0;\\nendmodule\\n\\nmodule GP_VREF(input VIN, output reg VOUT);\\n\\tparameter VIN_DIV = 1;\\n\\tparameter VREF = 0;\\n\\t//cannot simulate mixed signal IP\\nendmodule\\n\\nmodule GP_POR(output reg RST_DONE);\\n\\tparameter POR_TIME = 500;\\n\\n\\tinitial begin\\n\\t\\tRST_DONE = 0;\\n\\n\\t\\tif(POR_TIME == 4)\\n\\t\\t\\t#4000;\\n\\t\\telse if(POR_TIME == 500)\\n\\t\\t\\t#500000;\\n\\t\\telse begin\\n\\t\\t\\t$display(\\\"ERROR: bad POR_TIME for GP_POR cell\\\");\\n\\t\\t\\t$finish;\\n\\t\\tend\\n\\n\\t\\tRST_DONE = 1;\\n\\n\\tend\\n\\nendmodule\\n\",\n            \"cells_sim_digital.v\": \"`timescale 1ns/1ps\\n\\n/*\\n This file contains simulation models for GreenPAK cells which are possible to fully model using synthesizeable\\n behavioral Verilog constructs only.\\n */\\n\\nmodule GP_2LUT(input IN0, IN1, output OUT);\\n\\tparameter [3:0] INIT = 0;\\n\\tassign OUT = INIT[{IN1, IN0}];\\nendmodule\\n\\nmodule GP_3LUT(input IN0, IN1, IN2, output OUT);\\n\\tparameter [7:0] INIT = 0;\\n\\tassign OUT = INIT[{IN2, IN1, IN0}];\\nendmodule\\n\\nmodule GP_4LUT(\\n\\tinput wire IN0,\\n\\tinput wire IN1,\\n\\tinput wire IN2,\\n\\tinput wire IN3,\\n\\toutput wire OUT);\\n\\n\\tparameter [15:0] INIT = 0;\\n\\tassign OUT = INIT[{IN3, IN2, IN1, IN0}];\\nendmodule\\n\\nmodule GP_CLKBUF(input wire IN, output wire OUT);\\n\\tassign OUT = IN;\\nendmodule\\n\\nmodule GP_COUNT14(input CLK, input wire RST, output reg OUT);\\n\\n\\tparameter RESET_MODE \\t= \\\"RISING\\\";\\n\\n\\tparameter COUNT_TO\\t\\t= 14'h1;\\n\\tparameter CLKIN_DIVIDE\\t= 1;\\n\\n\\treg[13:0] count = COUNT_TO;\\n\\n\\tinitial begin\\n\\t\\tif(CLKIN_DIVIDE != 1) begin\\n\\t\\t\\t$display(\\\"ERROR: CLKIN_DIVIDE values other than 1 not implemented\\\");\\n\\t\\t\\t$finish;\\n\\t\\tend\\n\\tend\\n\\n\\t//Combinatorially output underflow flag whenever we wrap low\\n\\talways @(*) begin\\n\\t\\tOUT <= (count == 14'h0);\\n\\tend\\n\\n\\t//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.\\n\\t//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.\\n\\tgenerate\\n\\t\\tcase(RESET_MODE)\\n\\n\\t\\t\\t\\\"RISING\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, posedge RST) begin\\n\\t\\t\\t\\t\\tif(RST)\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= 0;\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"FALLING\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, negedge RST) begin\\n\\t\\t\\t\\t\\tif(!RST)\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= 0;\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"BOTH\\\": begin\\n\\t\\t\\t\\tinitial begin\\n\\t\\t\\t\\t\\t$display(\\\"Both-edge reset mode for GP_COUNT14 not implemented\\\");\\n\\t\\t\\t\\t\\t$finish;\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"LEVEL\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, posedge RST) begin\\n\\t\\t\\t\\t\\tif(RST)\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= 0;\\n\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\tdefault: begin\\n\\t\\t\\t\\tinitial begin\\n\\t\\t\\t\\t\\t$display(\\\"Invalid RESET_MODE on GP_COUNT14\\\");\\n\\t\\t\\t\\t\\t$finish;\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\tendcase\\n\\tendgenerate\\n\\nendmodule\\n\\nmodule GP_COUNT14_ADV(input CLK, input RST, output reg OUT,\\n                     input UP, input KEEP, output reg[7:0] POUT);\\n\\n\\tparameter RESET_MODE \\t= \\\"RISING\\\";\\n\\tparameter RESET_VALUE   = \\\"ZERO\\\";\\n\\n\\tparameter COUNT_TO\\t\\t= 14'h1;\\n\\tparameter CLKIN_DIVIDE\\t= 1;\\n\\n\\tinitial begin\\n\\t\\tif(CLKIN_DIVIDE != 1) begin\\n\\t\\t\\t$display(\\\"ERROR: CLKIN_DIVIDE values other than 1 not implemented\\\");\\n\\t\\t\\t$finish;\\n\\t\\tend\\n\\tend\\n\\n\\treg[13:0] count = COUNT_TO;\\n\\n\\t//Combinatorially output underflow flag whenever we wrap low\\n\\talways @(*) begin\\n\\t\\tif(UP)\\n\\t\\t\\tOUT <= (count == 14'h3fff);\\n\\t\\telse\\n\\t\\t\\tOUT <= (count == 14'h0);\\n\\t\\tPOUT <= count[7:0];\\n\\tend\\n\\n\\t//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.\\n\\t//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.\\n\\tgenerate\\n\\t\\tcase(RESET_MODE)\\n\\n\\t\\t\\t\\\"RISING\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, posedge RST) begin\\n\\n\\t\\t\\t\\t\\t//Resets\\n\\t\\t\\t\\t\\tif(RST) begin\\n\\t\\t\\t\\t\\t\\tif(RESET_VALUE == \\\"ZERO\\\")\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= 0;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\t\\telse if(KEEP) begin\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\telse if(UP) begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count + 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 14'h3fff)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"FALLING\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, negedge RST) begin\\n\\n\\t\\t\\t\\t\\t//Resets\\n\\t\\t\\t\\t\\tif(!RST) begin\\n\\t\\t\\t\\t\\t\\tif(RESET_VALUE == \\\"ZERO\\\")\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= 0;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\t\\telse if(KEEP) begin\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\telse if(UP) begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count + 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 14'h3fff)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"BOTH\\\": begin\\n\\t\\t\\t\\tinitial begin\\n\\t\\t\\t\\t\\t$display(\\\"Both-edge reset mode for GP_COUNT14_ADV not implemented\\\");\\n\\t\\t\\t\\t\\t$finish;\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"LEVEL\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, posedge RST) begin\\n\\n\\t\\t\\t\\t\\t//Resets\\n\\t\\t\\t\\t\\tif(RST) begin\\n\\t\\t\\t\\t\\t\\tif(RESET_VALUE == \\\"ZERO\\\")\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= 0;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\t\\telse begin\\n\\n\\t\\t\\t\\t\\t\\tif(KEEP) begin\\n\\t\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t\\telse if(UP) begin\\n\\t\\t\\t\\t\\t\\t\\tcount\\t\\t<= count + 1'd1;\\n\\t\\t\\t\\t\\t\\t\\tif(count == 14'h3fff)\\n\\t\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\n\\t\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\tdefault: begin\\n\\t\\t\\t\\tinitial begin\\n\\t\\t\\t\\t\\t$display(\\\"Invalid RESET_MODE on GP_COUNT14_ADV\\\");\\n\\t\\t\\t\\t\\t$finish;\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\tendcase\\n\\tendgenerate\\n\\nendmodule\\n\\nmodule GP_COUNT8_ADV(input CLK, input RST, output reg OUT,\\n                     input UP, input KEEP, output reg[7:0] POUT);\\n\\n\\tparameter RESET_MODE \\t= \\\"RISING\\\";\\n\\tparameter RESET_VALUE   = \\\"ZERO\\\";\\n\\n\\tparameter COUNT_TO\\t\\t= 8'h1;\\n\\tparameter CLKIN_DIVIDE\\t= 1;\\n\\n\\treg[7:0] count = COUNT_TO;\\n\\n\\tinitial begin\\n\\t\\tif(CLKIN_DIVIDE != 1) begin\\n\\t\\t\\t$display(\\\"ERROR: CLKIN_DIVIDE values other than 1 not implemented\\\");\\n\\t\\t\\t$finish;\\n\\t\\tend\\n\\tend\\n\\n\\t//Combinatorially output underflow flag whenever we wrap low\\n\\talways @(*) begin\\n\\t\\tif(UP)\\n\\t\\t\\tOUT <= (count == 8'hff);\\n\\t\\telse\\n\\t\\t\\tOUT <= (count == 8'h0);\\n\\t\\tPOUT <= count;\\n\\tend\\n\\n\\t//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.\\n\\t//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.\\n\\tgenerate\\n\\t\\tcase(RESET_MODE)\\n\\n\\t\\t\\t\\\"RISING\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, posedge RST) begin\\n\\n\\t\\t\\t\\t\\t//Resets\\n\\t\\t\\t\\t\\tif(RST) begin\\n\\t\\t\\t\\t\\t\\tif(RESET_VALUE == \\\"ZERO\\\")\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= 0;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\t\\t//Main counter\\n\\t\\t\\t\\t\\telse if(KEEP) begin\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\telse if(UP) begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count + 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 8'hff)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"FALLING\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, negedge RST) begin\\n\\n\\t\\t\\t\\t\\t//Resets\\n\\t\\t\\t\\t\\tif(!RST) begin\\n\\t\\t\\t\\t\\t\\tif(RESET_VALUE == \\\"ZERO\\\")\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= 0;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\t\\t//Main counter\\n\\t\\t\\t\\t\\telse if(KEEP) begin\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\telse if(UP) begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count + 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 8'hff)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"BOTH\\\": begin\\n\\t\\t\\t\\tinitial begin\\n\\t\\t\\t\\t\\t$display(\\\"Both-edge reset mode for GP_COUNT8_ADV not implemented\\\");\\n\\t\\t\\t\\t\\t$finish;\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"LEVEL\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, posedge RST) begin\\n\\n\\t\\t\\t\\t\\t//Resets\\n\\t\\t\\t\\t\\tif(RST) begin\\n\\t\\t\\t\\t\\t\\tif(RESET_VALUE == \\\"ZERO\\\")\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= 0;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\t\\telse begin\\n\\n\\t\\t\\t\\t\\t\\tif(KEEP) begin\\n\\t\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t\\telse if(UP) begin\\n\\t\\t\\t\\t\\t\\t\\tcount\\t\\t<= count + 1'd1;\\n\\t\\t\\t\\t\\t\\t\\tif(count == 8'hff)\\n\\t\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\n\\t\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\tdefault: begin\\n\\t\\t\\t\\tinitial begin\\n\\t\\t\\t\\t\\t$display(\\\"Invalid RESET_MODE on GP_COUNT8_ADV\\\");\\n\\t\\t\\t\\t\\t$finish;\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\tendcase\\n\\tendgenerate\\n\\nendmodule\\n\\nmodule GP_COUNT8(\\n\\tinput wire CLK,\\n\\tinput wire RST,\\n\\toutput reg OUT,\\n\\toutput reg[7:0] POUT);\\n\\n\\tparameter RESET_MODE \\t= \\\"RISING\\\";\\n\\n\\tparameter COUNT_TO\\t\\t= 8'h1;\\n\\tparameter CLKIN_DIVIDE\\t= 1;\\n\\n\\tinitial begin\\n\\t\\tif(CLKIN_DIVIDE != 1) begin\\n\\t\\t\\t$display(\\\"ERROR: CLKIN_DIVIDE values other than 1 not implemented\\\");\\n\\t\\t\\t$finish;\\n\\t\\tend\\n\\tend\\n\\n\\treg[7:0] count = COUNT_TO;\\n\\n\\t//Combinatorially output underflow flag whenever we wrap low\\n\\talways @(*) begin\\n\\t\\tOUT <= (count == 8'h0);\\n\\t\\tPOUT <= count;\\n\\tend\\n\\n\\t//POR or SYSRST reset value is COUNT_TO. Datasheet is unclear but conversations w/ Silego confirm.\\n\\t//Runtime reset value is clearly 0 except in count/FSM cells where it's configurable but we leave at 0 for now.\\n\\tgenerate\\n\\t\\tcase(RESET_MODE)\\n\\n\\t\\t\\t\\\"RISING\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, posedge RST) begin\\n\\t\\t\\t\\t\\tif(RST)\\n\\t\\t\\t\\t\\t\\tcount\\t<= 0;\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"FALLING\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, negedge RST) begin\\n\\t\\t\\t\\t\\tif(!RST)\\n\\t\\t\\t\\t\\t\\tcount\\t<= 0;\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"BOTH\\\": begin\\n\\t\\t\\t\\tinitial begin\\n\\t\\t\\t\\t\\t$display(\\\"Both-edge reset mode for GP_COUNT8 not implemented\\\");\\n\\t\\t\\t\\t\\t$finish;\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\"LEVEL\\\": begin\\n\\t\\t\\t\\talways @(posedge CLK, posedge RST) begin\\n\\t\\t\\t\\t\\tif(RST)\\n\\t\\t\\t\\t\\t\\tcount\\t<= 0;\\n\\n\\t\\t\\t\\t\\telse begin\\n\\t\\t\\t\\t\\t\\tcount\\t\\t<= count - 1'd1;\\n\\t\\t\\t\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\t\\t\\t\\tcount\\t<= COUNT_TO;\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\t\\tdefault: begin\\n\\t\\t\\t\\tinitial begin\\n\\t\\t\\t\\t\\t$display(\\\"Invalid RESET_MODE on GP_COUNT8\\\");\\n\\t\\t\\t\\t\\t$finish;\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\n\\t\\tendcase\\n\\tendgenerate\\n\\nendmodule\\n\\nmodule GP_DCMPREF(output reg[7:0]OUT);\\n\\tparameter[7:0] REF_VAL = 8'h00;\\n\\tinitial OUT = REF_VAL;\\nendmodule\\n\\nmodule GP_DCMPMUX(input[1:0] SEL, input[7:0] IN0, input[7:0] IN1, input[7:0] IN2, input[7:0] IN3, output reg[7:0] OUTA, output reg[7:0] OUTB);\\n\\n\\talways @(*) begin\\n\\t\\tcase(SEL)\\n\\t\\t\\t2'd00: begin\\n\\t\\t\\t\\tOUTA <= IN0;\\n\\t\\t\\t\\tOUTB <= IN3;\\n\\t\\t\\tend\\n\\n\\t\\t\\t2'd01: begin\\n\\t\\t\\t\\tOUTA <= IN1;\\n\\t\\t\\t\\tOUTB <= IN2;\\n\\t\\t\\tend\\n\\n\\t\\t\\t2'd02: begin\\n\\t\\t\\t\\tOUTA <= IN2;\\n\\t\\t\\t\\tOUTB <= IN1;\\n\\t\\t\\tend\\n\\n\\t\\t\\t2'd03: begin\\n\\t\\t\\t\\tOUTA <= IN3;\\n\\t\\t\\t\\tOUTB <= IN0;\\n\\t\\t\\tend\\n\\n\\t\\tendcase\\n\\tend\\nendmodule\\n\\nmodule GP_DELAY(input IN, output reg OUT);\\n\\n\\tparameter DELAY_STEPS = 1;\\n\\tparameter GLITCH_FILTER = 0;\\n\\n\\tinitial OUT = 0;\\n\\n\\tgenerate\\n\\n\\t\\tif(GLITCH_FILTER) begin\\n\\t\\t\\tinitial begin\\n\\t\\t\\t\\t$display(\\\"ERROR: GP_DELAY glitch filter mode not implemented\\\");\\n\\t\\t\\t\\t$finish;\\n\\t\\t\\tend\\n\\t\\tend\\n\\n\\t\\t//TODO: These delays are PTV dependent! For now, hard code 3v3 timing\\n\\t\\t//Change simulation-mode delay depending on global Vdd range (how to specify this?)\\n\\t\\talways @(*) begin\\n\\t\\t\\tcase(DELAY_STEPS)\\n\\t\\t\\t\\t1: #166 OUT = IN;\\n\\t\\t\\t\\t2: #318 OUT = IN;\\n\\t\\t\\t\\t2: #471 OUT = IN;\\n\\t\\t\\t\\t3: #622 OUT = IN;\\n\\t\\t\\t\\tdefault: begin\\n\\t\\t\\t\\t\\t$display(\\\"ERROR: GP_DELAY must have DELAY_STEPS in range [1,4]\\\");\\n\\t\\t\\t\\t\\t$finish;\\n\\t\\t\\t\\tend\\n\\t\\t\\tendcase\\n\\t\\tend\\n\\n\\tendgenerate\\n\\nendmodule\\n\\nmodule GP_DFF(input D, CLK, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial Q = INIT;\\n\\talways @(posedge CLK) begin\\n\\t\\tQ <= D;\\n\\tend\\nendmodule\\n\\nmodule GP_DFFI(input D, CLK, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial nQ = INIT;\\n\\talways @(posedge CLK) begin\\n\\t\\tnQ <= ~D;\\n\\tend\\nendmodule\\n\\nmodule GP_DFFR(input D, CLK, nRST, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial Q = INIT;\\n\\talways @(posedge CLK, negedge nRST) begin\\n\\t\\tif (!nRST)\\n\\t\\t\\tQ <= 1'b0;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nendmodule\\n\\nmodule GP_DFFRI(input D, CLK, nRST, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial nQ = INIT;\\n\\talways @(posedge CLK, negedge nRST) begin\\n\\t\\tif (!nRST)\\n\\t\\t\\tnQ <= 1'b1;\\n\\t\\telse\\n\\t\\t\\tnQ <= ~D;\\n\\tend\\nendmodule\\n\\nmodule GP_DFFS(input D, CLK, nSET, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial Q = INIT;\\n\\talways @(posedge CLK, negedge nSET) begin\\n\\t\\tif (!nSET)\\n\\t\\t\\tQ <= 1'b1;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nendmodule\\n\\nmodule GP_DFFSI(input D, CLK, nSET, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial nQ = INIT;\\n\\talways @(posedge CLK, negedge nSET) begin\\n\\t\\tif (!nSET)\\n\\t\\t\\tnQ <= 1'b0;\\n\\t\\telse\\n\\t\\t\\tnQ <= ~D;\\n\\tend\\nendmodule\\n\\nmodule GP_DFFSR(input D, CLK, nSR, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tparameter [0:0] SRMODE = 1'bx;\\n\\tinitial Q = INIT;\\n\\talways @(posedge CLK, negedge nSR) begin\\n\\t\\tif (!nSR)\\n\\t\\t\\tQ <= SRMODE;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nendmodule\\n\\nmodule GP_DFFSRI(input D, CLK, nSR, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tparameter [0:0] SRMODE = 1'bx;\\n\\tinitial nQ = INIT;\\n\\talways @(posedge CLK, negedge nSR) begin\\n\\t\\tif (!nSR)\\n\\t\\t\\tnQ <= ~SRMODE;\\n\\t\\telse\\n\\t\\t\\tnQ <= ~D;\\n\\tend\\nendmodule\\n\\nmodule GP_DLATCH(input D, input nCLK, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial Q = INIT;\\n\\talways @(*) begin\\n\\t\\tif(!nCLK)\\n\\t\\t\\tQ <= D;\\n\\tend\\nendmodule\\n\\nmodule GP_DLATCHI(input D, input nCLK, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial nQ = INIT;\\n\\talways @(*) begin\\n\\t\\tif(!nCLK)\\n\\t\\t\\tnQ <= ~D;\\n\\tend\\nendmodule\\n\\nmodule GP_DLATCHR(input D, input nCLK, input nRST, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial Q = INIT;\\n\\talways @(*) begin\\n\\t\\tif(!nRST)\\n\\t\\t\\tQ <= 1'b0;\\n\\t\\telse if(!nCLK)\\n\\t\\t\\tQ <= D;\\n\\tend\\nendmodule\\n\\nmodule GP_DLATCHRI(input D, input nCLK, input nRST, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial nQ = INIT;\\n\\talways @(*) begin\\n\\t\\tif(!nRST)\\n\\t\\t\\tnQ <= 1'b1;\\n\\t\\telse if(!nCLK)\\n\\t\\t\\tnQ <= ~D;\\n\\tend\\nendmodule\\n\\nmodule GP_DLATCHS(input D, input nCLK, input nSET, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial Q = INIT;\\n\\talways @(*) begin\\n\\t\\tif(!nSET)\\n\\t\\t\\tQ <= 1'b1;\\n\\t\\telse if(!nCLK)\\n\\t\\t\\tQ <= D;\\n\\tend\\nendmodule\\n\\nmodule GP_DLATCHSI(input D, input nCLK, input nSET, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tinitial nQ = INIT;\\n\\talways @(*) begin\\n\\t\\tif(!nSET)\\n\\t\\t\\tnQ <= 1'b0;\\n\\t\\telse if(!nCLK)\\n\\t\\t\\tnQ <= ~D;\\n\\tend\\nendmodule\\n\\nmodule GP_DLATCHSR(input D, input nCLK, input nSR, output reg Q);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tparameter[0:0] SRMODE = 1'bx;\\n\\tinitial Q = INIT;\\n\\talways @(*) begin\\n\\t\\tif(!nSR)\\n\\t\\t\\tQ <= SRMODE;\\n\\t\\telse if(!nCLK)\\n\\t\\t\\tQ <= D;\\n\\tend\\nendmodule\\n\\nmodule GP_DLATCHSRI(input D, input nCLK, input nSR, output reg nQ);\\n\\tparameter [0:0] INIT = 1'bx;\\n\\tparameter[0:0] SRMODE = 1'bx;\\n\\tinitial nQ = INIT;\\n\\talways @(*) begin\\n\\t\\tif(!nSR)\\n\\t\\t\\tnQ <= ~SRMODE;\\n\\t\\telse if(!nCLK)\\n\\t\\t\\tnQ <= ~D;\\n\\tend\\nendmodule\\n\\nmodule GP_IBUF(input IN, output OUT);\\n\\tassign OUT = IN;\\nendmodule\\n\\nmodule GP_IOBUF(input IN, input OE, output OUT, inout IO);\\n\\tassign OUT = IO;\\n\\tassign IO = OE ? IN : 1'bz;\\nendmodule\\n\\nmodule GP_INV(input IN, output OUT);\\n\\tassign OUT = ~IN;\\nendmodule\\n\\nmodule GP_OBUF(input IN, output OUT);\\n\\tassign OUT = IN;\\nendmodule\\n\\nmodule GP_OBUFT(input IN, input OE, output OUT);\\n\\tassign OUT = OE ? IN : 1'bz;\\nendmodule\\n\\nmodule GP_PGEN(input wire nRST, input wire CLK, output reg OUT);\\n\\tinitial OUT = 0;\\n\\tparameter PATTERN_DATA = 16'h0;\\n\\tparameter PATTERN_LEN = 5'd16;\\n\\n\\tlocalparam COUNT_MAX =  PATTERN_LEN - 1'h1;\\n\\n\\treg[3:0] count = 0;\\n\\talways @(posedge CLK, negedge nRST) begin\\n\\n\\t\\tif(!nRST)\\n\\t\\t\\tcount\\t<= 0;\\n\\n\\t\\telse begin\\n\\t\\t\\tcount\\t<= count - 1'h1;\\n\\t\\t\\tif(count == 0)\\n\\t\\t\\t\\tcount <= COUNT_MAX;\\n\\t\\tend\\n\\tend\\n\\n\\talways @(*)\\n\\t\\tOUT\\t= PATTERN_DATA[count];\\n\\nendmodule\\n\\nmodule GP_SHREG(input nRST, input CLK, input IN, output OUTA, output OUTB);\\n\\n\\tparameter OUTA_TAP = 1;\\n\\tparameter OUTA_INVERT = 0;\\n\\tparameter OUTB_TAP = 1;\\n\\n\\treg[15:0] shreg = 0;\\n\\n\\talways @(posedge CLK, negedge nRST) begin\\n\\n\\t\\tif(!nRST)\\n\\t\\t\\tshreg = 0;\\n\\n\\t\\telse\\n\\t\\t\\tshreg <= {shreg[14:0], IN};\\n\\n\\tend\\n\\n\\tassign OUTA = (OUTA_INVERT) ? ~shreg[OUTA_TAP - 1] : shreg[OUTA_TAP - 1];\\n\\tassign OUTB = shreg[OUTB_TAP - 1];\\n\\nendmodule\\n\\nmodule GP_VDD(output OUT);\\n       assign OUT = 1;\\nendmodule\\n\\nmodule GP_VSS(output OUT);\\n       assign OUT = 0;\\nendmodule\\n\",\n            \"cells_sim_wip.v\": \"\\n//Cells still in this file have INCOMPLETE simulation models, need to finish them\\n\\nmodule GP_DCMP(input[7:0] INP, input[7:0] INN, input CLK, input PWRDN, output reg GREATER, output reg EQUAL);\\n\\tparameter PWRDN_SYNC = 1'b0;\\n\\tparameter CLK_EDGE = \\\"RISING\\\";\\n\\tparameter GREATER_OR_EQUAL = 1'b0;\\n\\n\\t//TODO implement power-down mode\\n\\n\\tinitial GREATER = 0;\\n\\tinitial EQUAL = 0;\\n\\n\\twire clk_minv = (CLK_EDGE == \\\"RISING\\\") ? CLK : ~CLK;\\n\\talways @(posedge clk_minv) begin\\n\\t\\tif(GREATER_OR_EQUAL)\\n\\t\\t\\tGREATER <= (INP >= INN);\\n\\t\\telse\\n\\t\\t\\tGREATER <= (INP > INN);\\n\\n\\t\\tEQUAL <= (INP == INN);\\n\\tend\\n\\nendmodule\\n\\nmodule GP_EDGEDET(input IN, output reg OUT);\\n\\n\\tparameter EDGE_DIRECTION = \\\"RISING\\\";\\n\\tparameter DELAY_STEPS = 1;\\n\\tparameter GLITCH_FILTER = 0;\\n\\n\\t//not implemented for simulation\\n\\nendmodule\\n\\nmodule GP_RCOSC(input PWRDN, output reg CLKOUT_HARDIP, output reg CLKOUT_FABRIC);\\n\\n\\tparameter PWRDN_EN = 0;\\n\\tparameter AUTO_PWRDN = 0;\\n\\tparameter HARDIP_DIV = 1;\\n\\tparameter FABRIC_DIV = 1;\\n\\tparameter OSC_FREQ = \\\"25k\\\";\\n\\n\\tinitial CLKOUT_HARDIP = 0;\\n\\tinitial CLKOUT_FABRIC = 0;\\n\\n\\t//output dividers not implemented for simulation\\n\\t//auto powerdown not implemented for simulation\\n\\n\\talways begin\\n\\t\\tif(PWRDN) begin\\n\\t\\t\\tCLKOUT_HARDIP = 0;\\n\\t\\t\\tCLKOUT_FABRIC = 0;\\n\\t\\tend\\n\\t\\telse begin\\n\\n\\t\\t\\tif(OSC_FREQ == \\\"25k\\\") begin\\n\\t\\t\\t\\t//half period of 25 kHz\\n\\t\\t\\t\\t#20000;\\n\\t\\t\\tend\\n\\n\\t\\t\\telse begin\\n\\t\\t\\t\\t//half period of 2 MHz\\n\\t\\t\\t\\t#250;\\n\\t\\t\\tend\\n\\n\\t\\t\\tCLKOUT_HARDIP = ~CLKOUT_HARDIP;\\n\\t\\t\\tCLKOUT_FABRIC = ~CLKOUT_FABRIC;\\n\\t\\tend\\n\\tend\\n\\nendmodule\\n\\nmodule GP_RINGOSC(input PWRDN, output reg CLKOUT_HARDIP, output reg CLKOUT_FABRIC);\\n\\n\\tparameter PWRDN_EN = 0;\\n\\tparameter AUTO_PWRDN = 0;\\n\\tparameter HARDIP_DIV = 1;\\n\\tparameter FABRIC_DIV = 1;\\n\\n\\tinitial CLKOUT_HARDIP = 0;\\n\\tinitial CLKOUT_FABRIC = 0;\\n\\n\\t//output dividers not implemented for simulation\\n\\t//auto powerdown not implemented for simulation\\n\\n\\talways begin\\n\\t\\tif(PWRDN) begin\\n\\t\\t\\tCLKOUT_HARDIP = 0;\\n\\t\\t\\tCLKOUT_FABRIC = 0;\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\t//half period of 27 MHz\\n\\t\\t\\t#18.518;\\n\\t\\t\\tCLKOUT_HARDIP = ~CLKOUT_HARDIP;\\n\\t\\t\\tCLKOUT_FABRIC = ~CLKOUT_FABRIC;\\n\\t\\tend\\n\\tend\\n\\nendmodule\\n\\nmodule GP_SPI(\\n\\tinput SCK,\\n\\tinout SDAT,\\n\\tinput CSN,\\n\\tinput[7:0] TXD_HIGH,\\n\\tinput[7:0] TXD_LOW,\\n\\toutput reg[7:0] RXD_HIGH,\\n\\toutput reg[7:0] RXD_LOW,\\n\\toutput reg INT);\\n\\n\\tinitial RXD_HIGH = 0;\\n\\tinitial RXD_LOW = 0;\\n\\tinitial INT = 0;\\n\\n\\tparameter DATA_WIDTH = 8;\\t\\t//byte or word width\\n\\tparameter SPI_CPHA = 0;\\t\\t\\t//SPI clock phase\\n\\tparameter SPI_CPOL = 0;\\t\\t\\t//SPI clock polarity\\n\\tparameter DIRECTION = \\\"INPUT\\\";\\t//SPI data direction (either input to chip or output to host)\\n\\t//parallel output to fabric not yet implemented\\n\\n\\t//TODO: write sim model\\n\\t//TODO: SPI SDIO control... can we use ADC output while SPI is input??\\n\\t//TODO: clock sync\\n\\nendmodule\\n\\n//keep constraint needed to prevent optimization since we have no outputs\\n(* keep *)\\nmodule GP_SYSRESET(input RST);\\n\\tparameter RESET_MODE = \\\"EDGE\\\";\\n\\tparameter EDGE_SPEED = 4;\\n\\n\\t//cannot simulate whole system reset\\n\\nendmodule\\n\",\n            \"gp_dff.lib\": \"library(gp_dff) {\\n  cell(GP_DFF) {\\n    area: 1;\\n    ff(\\\"IQ\\\", \\\"IQN\\\") { clocked_on: CLK;\\n                      next_state: D; }\\n    pin(CLK) { direction: input;\\n                   clock: true; }\\n    pin(D) { direction: input; }\\n    pin(Q) { direction: output;\\n              function: \\\"IQ\\\"; }\\n  }\\n  cell(GP_DFFS) {\\n    area: 1;\\n    ff(\\\"IQ\\\", \\\"IQN\\\") { clocked_on: CLK;\\n                  next_state: D;\\n                      preset: \\\"nSET'\\\"; }\\n    pin(CLK) { direction: input;\\n                 clock: true; }\\n    pin(D) { direction: input; }\\n    pin(Q) { direction: output;\\n              function: \\\"IQ\\\"; }\\n    pin(nSET) { direction: input; }\\n  }\\n  cell(GP_DFFR) {\\n    area: 1;\\n    ff(\\\"IQ\\\", \\\"IQN\\\") { clocked_on: CLK;\\n                      next_state: D;\\n                           clear: \\\"nRST'\\\"; }\\n    pin(CLK) { direction: input;\\n                   clock: true; }\\n    pin(D) { direction: input; }\\n    pin(Q) { direction: output;\\n              function: \\\"IQ\\\"; }\\n    pin(nRST) { direction: input; }\\n  }\\n}\\n\",\n        },\n        \"ice40\": {\n            \"abc9_model.v\": \"(* abc9_box, lib_whitebox *)\\nmodule \\\\$__ICE40_CARRY_WRAPPER (\\n\\t(* abc9_carry *)\\n\\toutput CO,\\n\\toutput O,\\n\\tinput A, B,\\n\\t(* abc9_carry *)\\n\\tinput CI,\\n\\tinput I0, I3\\n);\\n\\tparameter LUT = 0;\\n\\tparameter I3_IS_CI = 0;\\n\\twire I3_OR_CI = I3_IS_CI ? CI : I3;\\n\\tSB_CARRY carry (\\n\\t\\t.I0(A),\\n\\t\\t.I1(B),\\n\\t\\t.CI(CI),\\n\\t\\t.CO(CO)\\n\\t);\\n\\tSB_LUT4 #(\\n\\t\\t.LUT_INIT(LUT)\\n\\t) adder (\\n\\t\\t.I0(I0),\\n\\t\\t.I1(A),\\n\\t\\t.I2(B),\\n\\t\\t.I3(I3_OR_CI),\\n\\t\\t.O(O)\\n\\t);\\n`ifdef ICE40_HX\\n\\tspecify\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L79\\n\\t\\t(CI => CO) = (126, 105);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L80\\n\\t\\t(I0 => O) = (449, 386);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L82\\n\\t\\t(A => CO) = (259, 245);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L83\\n\\t\\t(A => O) = (400, 379);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L85\\n\\t\\t(B => CO) = (231, 133);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L86\\n\\t\\t(B => O) = (379, 351);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_hx1k.txt#L88\\n\\t\\t(I3 => O) = (316, 288);\\n\\t\\t(CI => O) = (316, 288);\\n\\tendspecify\\n`endif\\n`ifdef ICE40_LP\\n\\tspecify\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L79\\n\\t\\t(CI => CO) = (186, 155);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L80\\n\\t\\t(I0 => O) = (662, 569);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L82\\n\\t\\t(A => CO) = (382, 362);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L83\\n\\t\\t(A => O) = (589, 558);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L85\\n\\t\\t(B => CO) = (341, 196);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L86\\n\\t\\t(B => O) = (558, 517);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_lp1k.txt#L88\\n\\t\\t(I3 => O) = (465, 423);\\n\\t\\t(CI => O) = (465, 423);\\n\\tendspecify\\n`endif\\n`ifdef ICE40_U\\n\\tspecify\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L91\\n\\t\\t(CI => CO) = (278, 278);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L92\\n\\t\\t(I0 => O) = (1245, 1285);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L94\\n\\t\\t(A => CO) = (675, 662);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L95\\n\\t\\t(A => O) = (1179, 1232);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L97\\n\\t\\t(B => CO) = (609, 358);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L98\\n\\t\\t(B => O) = (1179, 1205);\\n\\t\\t// https://github.com/YosysHQ/icestorm/blob/be0bca0230d6fe1102e0a360b953fbb0d273a39f/icefuzz/timings_up5k.txt#L100\\n\\t\\t(I3 => O) = (861, 874);\\n\\t\\t(CI => O) = (861, 874);\\n\\tendspecify\\n`endif\\nendmodule\\n\",\n            \"arith_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_ice40_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 2;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] C = {CO, CI};\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice\\n\\t\\t\\\\$__ICE40_CARRY_WRAPPER #(\\n\\t\\t\\t//    A[0]: 1010 1010 1010 1010\\n\\t\\t\\t//    A[1]: 1100 1100 1100 1100\\n\\t\\t\\t//    A[2]: 1111 0000 1111 0000\\n\\t\\t\\t//    A[3]: 1111 1111 0000 0000\\n\\t\\t\\t.LUT(16'b 0110_1001_1001_0110),\\n\\t\\t\\t.I3_IS_CI(1'b1)\\n\\t\\t) carry (\\n\\t\\t\\t.A(AA[i]),\\n\\t\\t\\t.B(BB[i]),\\n\\t\\t\\t.CI(C[i]),\\n\\t\\t\\t.I0(1'b0),\\n\\t\\t\\t.I3(1'bx),\\n\\t\\t\\t.CO(CO[i]),\\n\\t\\t\\t.O(Y[i])\\n\\t\\t);\\n\\tend endgenerate\\n\\n\\tassign X = AA ^ BB;\\nendmodule\\n\\n\",\n            \"brams.txt\": \"ram block $__ICE40_RAM4K_ {\\n\\tabits 11;\\n\\twidths 2 4 8 16 per_port;\\n\\tcost 64;\\n\\toption \\\"HAS_BE\\\" 1 {\\n\\t\\tbyte 1;\\n\\t}\\n\\tinit any;\\n\\tport sw \\\"W\\\" {\\n\\t\\toption \\\"HAS_BE\\\" 0 {\\n\\t\\t\\twidth 2 4 8;\\n\\t\\t}\\n\\t\\toption \\\"HAS_BE\\\" 1 {\\n\\t\\t\\twidth 16;\\n\\t\\t\\twrbe_separate;\\n\\t\\t}\\n\\t\\tclock anyedge;\\n\\t}\\n\\tport sr \\\"R\\\" {\\n\\t\\tclock anyedge;\\n\\t\\trden;\\n\\t}\\n}\\n\",\n            \"brams_map.v\": \"module $__ICE40_RAM4K_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_HAS_BE = 1;\\nparameter PORT_R_WIDTH = 16;\\nparameter PORT_W_WIDTH = 16;\\nparameter PORT_W_WR_BE_WIDTH = 16;\\nparameter PORT_R_CLK_POL = 1;\\nparameter PORT_W_CLK_POL = 1;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_RD_EN;\\ninput [10:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_WR_EN;\\ninput [15:0] PORT_W_WR_BE;\\ninput [10:0] PORT_W_ADDR;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\n\\nwire [15:0] RDATA;\\nwire [15:0] WDATA;\\nwire [15:0] MASK;\\nwire [10:0] RADDR = {PORT_R_ADDR[0], PORT_R_ADDR[1], PORT_R_ADDR[2], PORT_R_ADDR[10:3]};\\nwire [10:0] WADDR = {PORT_W_ADDR[0], PORT_W_ADDR[1], PORT_W_ADDR[2], PORT_W_ADDR[10:3]};\\n\\nfunction [1:0] mode;\\n\\tinput integer width;\\n\\tcase (width)\\n\\t16: mode = 0;\\n\\t8: mode = 1;\\n\\t4: mode = 2;\\n\\t2: mode = 3;\\n\\tendcase\\nendfunction\\n\\nfunction [255:0] slice_init;\\n\\tinput [3:0] idx;\\n\\tinteger i;\\n\\treg [7:0] ri;\\n\\treg [11:0] a;\\n\\tfor (i = 0; i < 256; i = i + 1) begin\\n\\t\\tri = i;\\n\\t\\ta = {idx, ri[7:4], ri[0], ri[1], ri[2], ri[3]};\\n\\t\\tslice_init[i] = INIT[a];\\n\\tend\\nendfunction\\n\\n`define INSTANCE(type, rclk, wclk) \\\\\\n\\ttype #( \\\\\\n\\t\\t.INIT_0(slice_init(0)), \\\\\\n\\t\\t.INIT_1(slice_init(1)), \\\\\\n\\t\\t.INIT_2(slice_init(2)), \\\\\\n\\t\\t.INIT_3(slice_init(3)), \\\\\\n\\t\\t.INIT_4(slice_init(4)), \\\\\\n\\t\\t.INIT_5(slice_init(5)), \\\\\\n\\t\\t.INIT_6(slice_init(6)), \\\\\\n\\t\\t.INIT_7(slice_init(7)), \\\\\\n\\t\\t.INIT_8(slice_init(8)), \\\\\\n\\t\\t.INIT_9(slice_init(9)), \\\\\\n\\t\\t.INIT_A(slice_init(10)), \\\\\\n\\t\\t.INIT_B(slice_init(11)), \\\\\\n\\t\\t.INIT_C(slice_init(12)), \\\\\\n\\t\\t.INIT_D(slice_init(13)), \\\\\\n\\t\\t.INIT_E(slice_init(14)), \\\\\\n\\t\\t.INIT_F(slice_init(15)), \\\\\\n\\t\\t.READ_MODE(mode(PORT_R_WIDTH)), \\\\\\n\\t\\t.WRITE_MODE(mode(PORT_W_WIDTH)) \\\\\\n\\t) _TECHMAP_REPLACE_ ( \\\\\\n\\t\\t.RDATA(RDATA), \\\\\\n\\t\\t.rclk(PORT_R_CLK), \\\\\\n\\t\\t.RCLKE(PORT_R_RD_EN), \\\\\\n\\t\\t.RE(1'b1), \\\\\\n\\t\\t.RADDR(RADDR), \\\\\\n\\t\\t.WDATA(WDATA), \\\\\\n\\t\\t.wclk(PORT_W_CLK), \\\\\\n\\t\\t.WCLKE(PORT_W_WR_EN), \\\\\\n\\t\\t.WE(1'b1), \\\\\\n\\t\\t.WADDR(WADDR), \\\\\\n\\t\\t.MASK(MASK), \\\\\\n\\t);\\n\\ngenerate\\n\\ncase(PORT_R_WIDTH)\\n\\t2: begin\\n\\t\\tassign PORT_R_RD_DATA = {\\n\\t\\t\\tRDATA[11],\\n\\t\\t\\tRDATA[3]\\n\\t\\t};\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_R_RD_DATA = {\\n\\t\\t\\tRDATA[13],\\n\\t\\t\\tRDATA[5],\\n\\t\\t\\tRDATA[9],\\n\\t\\t\\tRDATA[1]\\n\\t\\t};\\n\\tend\\n\\t8: begin\\n\\t\\tassign PORT_R_RD_DATA = {\\n\\t\\t\\tRDATA[14],\\n\\t\\t\\tRDATA[6],\\n\\t\\t\\tRDATA[10],\\n\\t\\t\\tRDATA[2],\\n\\t\\t\\tRDATA[12],\\n\\t\\t\\tRDATA[4],\\n\\t\\t\\tRDATA[8],\\n\\t\\t\\tRDATA[0]\\n\\t\\t};\\n\\tend\\n\\t16: begin\\n\\t\\tassign PORT_R_RD_DATA = {\\n\\t\\t\\tRDATA[15],\\n\\t\\t\\tRDATA[7],\\n\\t\\t\\tRDATA[11],\\n\\t\\t\\tRDATA[3],\\n\\t\\t\\tRDATA[13],\\n\\t\\t\\tRDATA[5],\\n\\t\\t\\tRDATA[9],\\n\\t\\t\\tRDATA[1],\\n\\t\\t\\tRDATA[14],\\n\\t\\t\\tRDATA[6],\\n\\t\\t\\tRDATA[10],\\n\\t\\t\\tRDATA[2],\\n\\t\\t\\tRDATA[12],\\n\\t\\t\\tRDATA[4],\\n\\t\\t\\tRDATA[8],\\n\\t\\t\\tRDATA[0]\\n\\t\\t};\\n\\tend\\nendcase\\n\\ncase(PORT_W_WIDTH)\\n\\t2: begin\\n\\t\\tassign {\\n\\t\\t\\tWDATA[11],\\n\\t\\t\\tWDATA[3]\\n\\t\\t} = PORT_W_WR_DATA;\\n\\tend\\n\\t4: begin\\n\\t\\tassign {\\n\\t\\t\\tWDATA[13],\\n\\t\\t\\tWDATA[5],\\n\\t\\t\\tWDATA[9],\\n\\t\\t\\tWDATA[1]\\n\\t\\t} = PORT_W_WR_DATA;\\n\\tend\\n\\t8: begin\\n\\t\\tassign {\\n\\t\\t\\tWDATA[14],\\n\\t\\t\\tWDATA[6],\\n\\t\\t\\tWDATA[10],\\n\\t\\t\\tWDATA[2],\\n\\t\\t\\tWDATA[12],\\n\\t\\t\\tWDATA[4],\\n\\t\\t\\tWDATA[8],\\n\\t\\t\\tWDATA[0]\\n\\t\\t} = PORT_W_WR_DATA;\\n\\tend\\n\\t16: begin\\n\\t\\tassign WDATA = {\\n\\t\\t\\tPORT_W_WR_DATA[15],\\n\\t\\t\\tPORT_W_WR_DATA[7],\\n\\t\\t\\tPORT_W_WR_DATA[11],\\n\\t\\t\\tPORT_W_WR_DATA[3],\\n\\t\\t\\tPORT_W_WR_DATA[13],\\n\\t\\t\\tPORT_W_WR_DATA[5],\\n\\t\\t\\tPORT_W_WR_DATA[9],\\n\\t\\t\\tPORT_W_WR_DATA[1],\\n\\t\\t\\tPORT_W_WR_DATA[14],\\n\\t\\t\\tPORT_W_WR_DATA[6],\\n\\t\\t\\tPORT_W_WR_DATA[10],\\n\\t\\t\\tPORT_W_WR_DATA[2],\\n\\t\\t\\tPORT_W_WR_DATA[12],\\n\\t\\t\\tPORT_W_WR_DATA[4],\\n\\t\\t\\tPORT_W_WR_DATA[8],\\n\\t\\t\\tPORT_W_WR_DATA[0]\\n\\t\\t};\\n\\t\\tassign MASK = ~{\\n\\t\\t\\tPORT_W_WR_BE[15],\\n\\t\\t\\tPORT_W_WR_BE[7],\\n\\t\\t\\tPORT_W_WR_BE[11],\\n\\t\\t\\tPORT_W_WR_BE[3],\\n\\t\\t\\tPORT_W_WR_BE[13],\\n\\t\\t\\tPORT_W_WR_BE[5],\\n\\t\\t\\tPORT_W_WR_BE[9],\\n\\t\\t\\tPORT_W_WR_BE[1],\\n\\t\\t\\tPORT_W_WR_BE[14],\\n\\t\\t\\tPORT_W_WR_BE[6],\\n\\t\\t\\tPORT_W_WR_BE[10],\\n\\t\\t\\tPORT_W_WR_BE[2],\\n\\t\\t\\tPORT_W_WR_BE[12],\\n\\t\\t\\tPORT_W_WR_BE[4],\\n\\t\\t\\tPORT_W_WR_BE[8],\\n\\t\\t\\tPORT_W_WR_BE[0]\\n\\t\\t};\\n\\tend\\nendcase\\n\\nif (PORT_R_CLK_POL) begin\\n\\tif (PORT_W_CLK_POL) begin\\n\\t\\t`INSTANCE(SB_RAM40_4K, RCLK, WCLK)\\n\\tend else begin\\n\\t\\t`INSTANCE(SB_RAM40_4KNW, RCLK, WCLKN)\\n\\tend\\nend else begin\\n\\tif (PORT_W_CLK_POL) begin\\n\\t\\t`INSTANCE(SB_RAM40_4KNR, RCLKN, WCLK)\\n\\tend else begin\\n\\t\\t`INSTANCE(SB_RAM40_4KNRNW, RCLKN, WCLKN)\\n\\tend\\nend\\n\\nendgenerate\\n\\nendmodule\\n\",\n            \"cells_map.v\": \"module \\\\$lut (A, Y);\\n  parameter WIDTH = 0;\\n  parameter LUT = 0;\\n\\n  (* force_downto *)\\n  input [WIDTH-1:0] A;\\n  output Y;\\n\\n  generate\\n    if (WIDTH == 1) begin\\n      localparam [15:0] INIT = {{8{LUT[1]}}, {8{LUT[0]}}};\\n      SB_LUT4 #(.LUT_INIT(INIT)) _TECHMAP_REPLACE_ (.O(Y),\\n        .I0(1'b0), .I1(1'b0), .I2(1'b0), .I3(A[0]));\\n    end else\\n    if (WIDTH == 2) begin\\n      localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};\\n      SB_LUT4 #(.LUT_INIT(INIT)) _TECHMAP_REPLACE_ (.O(Y),\\n        .I0(1'b0), .I1(1'b0), .I2(A[0]), .I3(A[1]));\\n    end else\\n    if (WIDTH == 3) begin\\n      localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};\\n      SB_LUT4 #(.LUT_INIT(INIT)) _TECHMAP_REPLACE_ (.O(Y),\\n        .I0(1'b0), .I1(A[0]), .I2(A[1]), .I3(A[2]));\\n    end else\\n    if (WIDTH == 4) begin\\n      SB_LUT4 #(.LUT_INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),\\n        .I0(A[0]), .I1(A[1]), .I2(A[2]), .I3(A[3]));\\n    end else begin\\n      wire _TECHMAP_FAIL_ = 1;\\n    end\\n  endgenerate\\nendmodule\\n\",\n            \"cells_sim.v\": new URL(/* asset import */ __webpack_require__(/*! ./share/ice40/cells_sim.v */ \"./node_modules/@yowasp/yosys/gen/share/ice40/cells_sim.v\"), __webpack_require__.b),\n            \"dsp_map.v\": \"module \\\\$__MUL16X16 (input [15:0] A, input [15:0] B, output [31:0] Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 0;\\n\\tparameter B_WIDTH = 0;\\n\\tparameter Y_WIDTH = 0;\\n\\n\\tSB_MAC16 #(\\n\\t\\t.NEG_TRIGGER(1'b0),\\n\\t\\t.C_REG(1'b0),\\n\\t\\t.A_REG(1'b0),\\n\\t\\t.B_REG(1'b0),\\n\\t\\t.D_REG(1'b0),\\n\\t\\t.TOP_8x8_MULT_REG(1'b0),\\n\\t\\t.BOT_8x8_MULT_REG(1'b0),\\n\\t\\t.PIPELINE_16x16_MULT_REG1(1'b0),\\n\\t\\t.PIPELINE_16x16_MULT_REG2(1'b0),\\n\\t\\t.TOPOUTPUT_SELECT(2'b11),\\n\\t\\t.TOPADDSUB_LOWERINPUT(2'b0),\\n\\t\\t.TOPADDSUB_UPPERINPUT(1'b0),\\n\\t\\t.TOPADDSUB_CARRYSELECT(2'b0),\\n\\t\\t.BOTOUTPUT_SELECT(2'b11),\\n\\t\\t.BOTADDSUB_LOWERINPUT(2'b0),\\n\\t\\t.BOTADDSUB_UPPERINPUT(1'b0),\\n\\t\\t.BOTADDSUB_CARRYSELECT(2'b0),\\n\\t\\t.MODE_8x8(1'b0),\\n\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t.B_SIGNED(B_SIGNED)\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.A(A),\\n\\t\\t.B(B),\\n\\t\\t.O(Y),\\n\\t);\\nendmodule\\n\",\n            \"ff_map.v\": \"module  \\\\$_DFF_N_ (input D, C, output Q); SB_DFFN _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_DFF_P_ (input D, C, output Q); SB_DFF  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\n\\nmodule  \\\\$_DFFE_NP_ (input D, C, E, output Q); SB_DFFNE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_DFFE_PP_ (input D, C, E, output Q); SB_DFFE  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\n\\nmodule  \\\\$_DFF_NP0_ (input D, C, R, output Q); SB_DFFNR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_DFF_NP1_ (input D, C, R, output Q); SB_DFFNS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_DFF_PP0_ (input D, C, R, output Q); SB_DFFR  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_DFF_PP1_ (input D, C, R, output Q); SB_DFFS  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\n\\nmodule  \\\\$_DFFE_NP0P_ (input D, C, E, R, output Q); SB_DFFNER _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_DFFE_NP1P_ (input D, C, E, R, output Q); SB_DFFNES _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_DFFE_PP0P_ (input D, C, E, R, output Q); SB_DFFER  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_DFFE_PP1P_ (input D, C, E, R, output Q); SB_DFFES  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\n\\nmodule  \\\\$_SDFF_NP0_ (input D, C, R, output Q); SB_DFFNSR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_SDFF_NP1_ (input D, C, R, output Q); SB_DFFNSS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_SDFF_PP0_ (input D, C, R, output Q); SB_DFFSR  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_SDFF_PP1_ (input D, C, R, output Q); SB_DFFSS  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\n\\nmodule  \\\\$_SDFFCE_NP0P_ (input D, C, E, R, output Q); SB_DFFNESR _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_SDFFCE_NP1P_ (input D, C, E, R, output Q); SB_DFFNESS _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_SDFFCE_PP0P_ (input D, C, E, R, output Q); SB_DFFESR  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .R(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\nmodule  \\\\$_SDFFCE_PP1P_ (input D, C, E, R, output Q); SB_DFFESS  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .E(E), .S(R)); wire _TECHMAP_REMOVEINIT_Q_ = 1; endmodule\\n\",\n            \"latches_map.v\": \"module \\\\$_DLATCH_N_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = !E ? D : Q;\\nendmodule\\n\\nmodule \\\\$_DLATCH_P_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = E ? D : Q;\\nendmodule\\n\",\n            \"spram.txt\": \"ram huge $__ICE40_SPRAM_ {\\n\\tabits 14;\\n\\twidth 16;\\n\\tcost 2048;\\n\\tbyte 4;\\n\\tport srsw \\\"A\\\" {\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t\\twrbe_separate;\\n\\t\\trdwr no_change;\\n\\t}\\n}\\n\",\n            \"spram_map.v\": \"module $__ICE40_SPRAM_ (...);\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput PORT_A_WR_EN;\\ninput [3:0] PORT_A_WR_BE;\\ninput [13:0] PORT_A_ADDR;\\ninput [15:0] PORT_A_WR_DATA;\\noutput [15:0] PORT_A_RD_DATA;\\n\\nSB_SPRAM256KA _TECHMAP_REPLACE_ (\\n\\t.ADDRESS(PORT_A_ADDR),\\n\\t.DATAIN(PORT_A_WR_DATA),\\n\\t.MASKWREN(PORT_A_WR_BE),\\n\\t.WREN(PORT_A_WR_EN),\\n\\t.CHIPSELECT(PORT_A_CLK_EN),\\n\\t.CLOCK(PORT_A_CLK),\\n\\t.STANDBY(1'b0),\\n\\t.SLEEP(1'b0),\\n\\t.POWEROFF(1'b1),\\n\\t.DATAOUT(PORT_A_RD_DATA),\\n);\\n\\nendmodule\\n\",\n        },\n        \"include\": {\n            \"backends\": {\n                \"cxxrtl\": {\n                    \"runtime\": {\n                        \"cxxrtl\": {\n                            \"capi\": {\n                                \"cxxrtl_capi.cc\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n// This file is a part of the CXXRTL C API. It should be used together with `cxxrtl/capi/cxxrtl_capi.h`.\\n\\n#include <cxxrtl/capi/cxxrtl_capi.h>\\n#include <cxxrtl/cxxrtl.h>\\n\\nstruct _cxxrtl_handle {\\n\\tstd::unique_ptr<cxxrtl::module> module;\\n\\tcxxrtl::debug_items objects;\\n};\\n\\n// Private function for use by other units of the C API.\\nconst cxxrtl::debug_items &cxxrtl_debug_items_from_handle(cxxrtl_handle handle) {\\n\\treturn handle->objects;\\n}\\n\\ncxxrtl_handle cxxrtl_create(cxxrtl_toplevel design) {\\n\\treturn cxxrtl_create_at(design, \\\"\\\");\\n}\\n\\ncxxrtl_handle cxxrtl_create_at(cxxrtl_toplevel design, const char *top_path_) {\\n\\tstd::string top_path = top_path_;\\n\\tif (!top_path.empty()) {\\n\\t\\t// module::debug_info() accepts either an empty path, or a path ending in space to simplify\\n\\t\\t// the logic in generated code. While this is sketchy at best to expose in the C++ API, this\\n\\t\\t// would be a lot worse in the C API, so don't expose it here.\\n\\t\\tassert(top_path.back() != ' ');\\n\\t\\ttop_path += ' ';\\n\\t}\\n\\n\\tcxxrtl_handle handle = new _cxxrtl_handle;\\n\\thandle->module = std::move(design->module);\\n\\thandle->module->debug_info(handle->objects, top_path);\\n\\tdelete design;\\n\\treturn handle;\\n}\\n\\nvoid cxxrtl_destroy(cxxrtl_handle handle) {\\n\\tdelete handle;\\n}\\n\\nvoid cxxrtl_reset(cxxrtl_handle handle) {\\n\\thandle->module->reset();\\n}\\n\\nint cxxrtl_eval(cxxrtl_handle handle) {\\n\\treturn handle->module->eval();\\n}\\n\\nint cxxrtl_commit(cxxrtl_handle handle) {\\n\\treturn handle->module->commit();\\n}\\n\\nsize_t cxxrtl_step(cxxrtl_handle handle) {\\n\\treturn handle->module->step();\\n}\\n\\nstruct cxxrtl_object *cxxrtl_get_parts(cxxrtl_handle handle, const char *name, size_t *parts) {\\n\\tauto it = handle->objects.table.find(name);\\n\\tif (it == handle->objects.table.end())\\n\\t\\treturn nullptr;\\n\\t*parts = it->second.size();\\n\\treturn static_cast<cxxrtl_object*>(&it->second[0]);\\n}\\n\\nvoid cxxrtl_enum(cxxrtl_handle handle, void *data,\\n                 void (*callback)(void *data, const char *name,\\n                                  cxxrtl_object *object, size_t parts)) {\\n\\tfor (auto &it : handle->objects.table)\\n\\t\\tcallback(data, it.first.c_str(), static_cast<cxxrtl_object*>(&it.second[0]), it.second.size());\\n}\\n\\nvoid cxxrtl_outline_eval(cxxrtl_outline outline) {\\n\\toutline->eval();\\n}\\n\\nint cxxrtl_attr_type(cxxrtl_attr_set attrs_, const char *name) {\\n\\tauto attrs = (cxxrtl::metadata_map*)attrs_;\\n\\tif (!attrs->count(name))\\n\\t\\treturn CXXRTL_ATTR_NONE;\\n\\tswitch (attrs->at(name).value_type) {\\n\\t\\tcase cxxrtl::metadata::UINT:\\n\\t\\t\\treturn CXXRTL_ATTR_UNSIGNED_INT;\\n\\t\\tcase cxxrtl::metadata::SINT:\\n\\t\\t\\treturn CXXRTL_ATTR_SIGNED_INT;\\n\\t\\tcase cxxrtl::metadata::STRING:\\n\\t\\t\\treturn CXXRTL_ATTR_STRING;\\n\\t\\tcase cxxrtl::metadata::DOUBLE:\\n\\t\\t\\treturn CXXRTL_ATTR_DOUBLE;\\n\\t\\tdefault:\\n\\t\\t\\t// Present unsupported attribute type the same way as no attribute at all.\\n\\t\\t\\treturn CXXRTL_ATTR_NONE;\\n\\t}\\n}\\n\\nuint64_t cxxrtl_attr_get_unsigned_int(cxxrtl_attr_set attrs_, const char *name) {\\n\\tauto &attrs = *(cxxrtl::metadata_map*)attrs_;\\n\\tassert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::UINT);\\n\\treturn attrs[name].as_uint();\\n}\\n\\nint64_t cxxrtl_attr_get_signed_int(cxxrtl_attr_set attrs_, const char *name) {\\n\\tauto &attrs = *(cxxrtl::metadata_map*)attrs_;\\n\\tassert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::SINT);\\n\\treturn attrs[name].as_sint();\\n}\\n\\nconst char *cxxrtl_attr_get_string(cxxrtl_attr_set attrs_, const char *name) {\\n\\tauto &attrs = *(cxxrtl::metadata_map*)attrs_;\\n\\tassert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::STRING);\\n\\treturn attrs[name].as_string().c_str();\\n}\\n\\ndouble cxxrtl_attr_get_double(cxxrtl_attr_set attrs_, const char *name) {\\n\\tauto &attrs = *(cxxrtl::metadata_map*)attrs_;\\n\\tassert(attrs.count(name) && attrs.at(name).value_type == cxxrtl::metadata::DOUBLE);\\n\\treturn attrs[name].as_double();\\n}\\n\",\n                                \"cxxrtl_capi.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef CXXRTL_CAPI_H\\n#define CXXRTL_CAPI_H\\n\\n// This file is a part of the CXXRTL C API. It should be used together with `cxxrtl_capi.cc`.\\n//\\n// The CXXRTL C API makes it possible to drive CXXRTL designs using C or any other language that\\n// supports the C ABI, for example, Python. It does not provide a way to implement black boxes.\\n\\n#include <stddef.h>\\n#include <stdint.h>\\n#include <assert.h>\\n\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n// Opaque reference to a design toplevel.\\n//\\n// A design toplevel can only be used to create a design handle.\\ntypedef struct _cxxrtl_toplevel *cxxrtl_toplevel;\\n\\n// The constructor for a design toplevel is provided as a part of generated code for that design.\\n// Its prototype matches:\\n//\\n// cxxrtl_toplevel <design-name>_create();\\n\\n// Opaque reference to a design handle.\\n//\\n// A design handle is required by all operations in the C API.\\ntypedef struct _cxxrtl_handle *cxxrtl_handle;\\n\\n// Create a design handle from a design toplevel.\\n//\\n// The `design` is consumed by this operation and cannot be used afterwards.\\ncxxrtl_handle cxxrtl_create(cxxrtl_toplevel design);\\n\\n// Create a design handle at a given hierarchy position from a design toplevel.\\n//\\n// This operation is similar to `cxxrtl_create`, except the full hierarchical name of every object\\n// is prepended with `top_path`.\\ncxxrtl_handle cxxrtl_create_at(cxxrtl_toplevel design, const char *top_path);\\n\\n// Release all resources used by a design and its handle.\\nvoid cxxrtl_destroy(cxxrtl_handle handle);\\n\\n// Reinitialize the design, replacing the internal state with the reset values while preserving\\n// black boxes.\\n//\\n// This operation is essentially equivalent to a power-on reset. Values, wires, and memories are\\n// returned to their reset state while preserving the state of black boxes and keeping all of\\n// the interior pointers obtained with e.g. `cxxrtl_get` valid.\\nvoid cxxrtl_reset(cxxrtl_handle handle);\\n\\n// Evaluate the design, propagating changes on inputs to the `next` value of internal state and\\n// output wires.\\n//\\n// Returns 1 if the design is known to immediately converge, 0 otherwise.\\nint cxxrtl_eval(cxxrtl_handle handle);\\n\\n// Commit the design, replacing the `curr` value of internal state and output wires with the `next`\\n// value.\\n//\\n// Return 1 if any of the `curr` values were updated, 0 otherwise.\\nint cxxrtl_commit(cxxrtl_handle handle);\\n\\n// Simulate the design to a fixed point.\\n//\\n// Returns the number of delta cycles.\\nsize_t cxxrtl_step(cxxrtl_handle handle);\\n\\n// Type of a simulated object.\\n//\\n// The type of a simulated object indicates the way it is stored and the operations that are legal\\n// to perform on it (i.e. won't crash the simulation). It says very little about object semantics,\\n// which is specified through flags.\\nenum cxxrtl_type {\\n\\t// Values correspond to singly buffered netlist nodes, i.e. nodes driven exclusively by\\n\\t// combinatorial cells, or toplevel input nodes.\\n\\t//\\n\\t// Values can be inspected via the `curr` pointer. If the `next` pointer is NULL, the value is\\n\\t// driven by a constant and can never be modified. Otherwise, the value can be modified through\\n\\t// the `next` pointer (which is equal to `curr` if not NULL). Note that changes to the bits\\n\\t// driven by combinatorial cells will be ignored.\\n\\t//\\n\\t// Values always have depth 1.\\n\\tCXXRTL_VALUE = 0,\\n\\n\\t// Wires correspond to doubly buffered netlist nodes, i.e. nodes driven, at least in part, by\\n\\t// storage cells, or by combinatorial cells that are a part of a feedback path. They are also\\n\\t// present in non-optimized builds.\\n\\t//\\n\\t// Wires can be inspected via the `curr` pointer and modified via the `next` pointer (which are\\n\\t// distinct for wires). Note that changes to the bits driven by combinatorial cells will be\\n\\t// ignored.\\n\\t//\\n\\t// Wires always have depth 1.\\n\\tCXXRTL_WIRE = 1,\\n\\n\\t// Memories correspond to memory cells.\\n\\t//\\n\\t// Memories can be inspected and modified via the `curr` pointer. Due to a limitation of this\\n\\t// API, memories cannot yet be modified in a guaranteed race-free way, and the `next` pointer is\\n\\t// always NULL.\\n\\tCXXRTL_MEMORY = 2,\\n\\n\\t// Aliases correspond to netlist nodes driven by another node such that their value is always\\n\\t// exactly equal.\\n\\t//\\n\\t// Aliases can be inspected via the `curr` pointer. They cannot be modified, and the `next`\\n\\t// pointer is always NULL.\\n\\tCXXRTL_ALIAS = 3,\\n\\n\\t// Outlines correspond to netlist nodes that were optimized in a way that makes them inaccessible\\n\\t// outside of a module's `eval()` function. At the highest debug information level, every inlined\\n\\t// node has a corresponding outline object.\\n\\t//\\n\\t// Outlines can be inspected via the `curr` pointer and can never be modified; the `next` pointer\\n\\t// is always NULL. Unlike all other objects, the bits of an outline object are meaningful only\\n\\t// after a call to `cxxrtl_outline_eval` and until any subsequent modification to the netlist.\\n\\t// Observing this requirement is the responsibility of the caller; it is not enforced.\\n\\t//\\n\\t// Outlines always correspond to combinatorial netlist nodes that are not ports.\\n\\tCXXRTL_OUTLINE = 4,\\n\\n\\t// More object types may be added in the future, but the existing ones will never change.\\n};\\n\\n// Flags of a simulated object.\\n//\\n// The flags of a simulated object indicate its role in the netlist:\\n//  * The flags `CXXRTL_INPUT` and `CXXRTL_OUTPUT` designate module ports.\\n//  * The flags `CXXRTL_DRIVEN_SYNC`, `CXXRTL_DRIVEN_COMB`, and `CXXRTL_UNDRIVEN` specify\\n//    the semantics of node state. An object with several of these flags set has different bits\\n//    follow different semantics.\\nenum cxxrtl_flag {\\n\\t// Node is a module input port.\\n\\t//\\n\\t// This flag can be set on objects of type `CXXRTL_VALUE` and `CXXRTL_WIRE`. It may be combined\\n\\t// with `CXXRTL_OUTPUT`, as well as other flags.\\n\\tCXXRTL_INPUT = 1 << 0,\\n\\n\\t// Node is a module output port.\\n\\t//\\n\\t// This flag can be set on objects of type `CXXRTL_WIRE`. It may be combined with `CXXRTL_INPUT`,\\n\\t// as well as other flags.\\n\\tCXXRTL_OUTPUT = 1 << 1,\\n\\n\\t// Node is a module inout port.\\n\\t//\\n\\t// This flag can be set on objects of type `CXXRTL_WIRE`. It may be combined with other flags.\\n\\tCXXRTL_INOUT = (CXXRTL_INPUT|CXXRTL_OUTPUT),\\n\\n\\t// Node has bits that are driven by a storage cell.\\n\\t//\\n\\t// This flag can be set on objects of type `CXXRTL_WIRE`. It may be combined with\\n\\t// `CXXRTL_DRIVEN_COMB` and `CXXRTL_UNDRIVEN`, as well as other flags.\\n\\t//\\n\\t// This flag is set on wires that have bits connected directly to the output of a flip-flop or\\n\\t// a latch, and hold its state. Many `CXXRTL_WIRE` objects may not have the `CXXRTL_DRIVEN_SYNC`\\n\\t// flag set; for example, output ports and feedback wires generally won't. Writing to the `next`\\n\\t// pointer of these wires updates stored state, and for designs without combinatorial loops,\\n\\t// capturing the value from every of these wires through the `curr` pointer creates a complete\\n\\t// snapshot of the design state.\\n\\tCXXRTL_DRIVEN_SYNC = 1 << 2,\\n\\n\\t// Node has bits that are driven by a combinatorial cell or another node.\\n\\t//\\n\\t// This flag can be set on objects of type `CXXRTL_VALUE`, `CXXRTL_WIRE`, and `CXXRTL_OUTLINE`.\\n\\t// It may be combined with `CXXRTL_DRIVEN_SYNC` and `CXXRTL_UNDRIVEN`, as well as other flags.\\n\\t//\\n\\t// This flag is set on objects that have bits connected to the output of a combinatorial cell,\\n\\t// or directly to another node. For designs without combinatorial loops, writing to such bits\\n\\t// through the `next` pointer (if it is not NULL) has no effect.\\n\\tCXXRTL_DRIVEN_COMB = 1 << 3,\\n\\n\\t// Node has bits that are not driven.\\n\\t//\\n\\t// This flag can be set on objects of type `CXXRTL_VALUE` and `CXXRTL_WIRE`. It may be combined\\n\\t// with `CXXRTL_DRIVEN_SYNC` and `CXXRTL_DRIVEN_COMB`, as well as other flags.\\n\\t//\\n\\t// This flag is set on objects that have bits not driven by an output of any cell or by another\\n\\t// node, such as inputs and dangling wires.\\n\\tCXXRTL_UNDRIVEN = 1 << 4,\\n\\n\\t// More object flags may be added in the future, but the existing ones will never change.\\n};\\n\\n// Description of a simulated object.\\n//\\n// The `curr` and `next` arrays can be accessed directly to inspect and, if applicable, modify\\n// the bits stored in the object.\\nstruct cxxrtl_object {\\n\\t// Type of the object.\\n\\t//\\n\\t// All objects have the same memory layout determined by `width` and `depth`, but the type\\n\\t// determines all other properties of the object.\\n\\tuint32_t type; // actually `enum cxxrtl_type`\\n\\n\\t// Flags of the object.\\n\\tuint32_t flags; // actually bit mask of `enum cxxrtl_flags`\\n\\n\\t// Width of the object in bits.\\n\\tsize_t width;\\n\\n\\t// Index of the least significant bit.\\n\\tsize_t lsb_at;\\n\\n\\t// Depth of the object. Only meaningful for memories; for other objects, always 1.\\n\\tsize_t depth;\\n\\n\\t// Index of the first word. Only meaningful for memories; for other objects, always 0;\\n\\tsize_t zero_at;\\n\\n\\t// Bits stored in the object, as 32-bit chunks, least significant bits first.\\n\\t//\\n\\t// The width is rounded up to a multiple of 32; the padding bits are always set to 0 by\\n\\t// the simulation code, and must be always written as 0 when modified by user code.\\n\\t// In memories, every element is stored contiguously. Therefore, the total number of chunks\\n\\t// in any object is `((width + 31) / 32) * depth`.\\n\\t//\\n\\t// To allow the simulation to be partitioned into multiple independent units communicating\\n\\t// through wires, the bits are double buffered. To avoid race conditions, user code should\\n\\t// always read from `curr` and write to `next`. The `curr` pointer is always valid; for objects\\n\\t// that cannot be modified, or cannot be modified in a race-free way, `next` is NULL.\\n\\t//\\n\\t// In case where `width == 0`, `curr` is a non-NULL pointer unique for the wire. That is,\\n\\t// there is a 1-to-1 correspondence between simulation objects and `curr` pointers, regardless\\n\\t// of whether they have storage or not. (Aliases' `curr` pointer equals that of some other\\n\\t// simulated object.)\\n\\tuint32_t *curr;\\n\\tuint32_t *next;\\n\\n\\t// Opaque reference to an outline. Only meaningful for outline objects.\\n\\t//\\n\\t// See the documentation of `cxxrtl_outline` for details. When creating a `cxxrtl_object`, set\\n\\t// this field to NULL.\\n\\tstruct _cxxrtl_outline *outline;\\n\\n\\t// Opaque reference to an attribute set.\\n\\t//\\n\\t// See the documentation of `cxxrtl_attr_set` for details. When creating a `cxxrtl_object`, set\\n\\t// this field to NULL.\\n\\t//\\n\\t// The lifetime of the pointers returned by `cxxrtl_attr_*` family of functions is the same as\\n\\t// the lifetime of this structure.\\n\\tstruct _cxxrtl_attr_set *attrs;\\n\\n\\t// More description fields may be added in the future, but the existing ones will never change.\\n};\\n\\n// Retrieve description of a simulated object.\\n//\\n// The `name` is the full hierarchical name of the object in the Yosys notation, where public names\\n// have a `\\\\` prefix and hierarchy levels are separated by single spaces. For example, if\\n// the top-level module instantiates a module `foo`, which in turn contains a wire `bar`, the full\\n// hierarchical name is `\\\\foo \\\\bar`.\\n//\\n// The storage of a single abstract object may be split (usually with the `splitnets` pass) into\\n// many physical parts, all of which correspond to the same hierarchical name. To handle such cases,\\n// this function returns an array and writes its length to `parts`. The array is sorted by `lsb_at`.\\n//\\n// Returns the object parts if it was found, NULL otherwise. The returned parts are valid until\\n// the design is destroyed.\\nstruct cxxrtl_object *cxxrtl_get_parts(cxxrtl_handle handle, const char *name, size_t *parts);\\n\\n// Retrieve description of a single part simulated object.\\n//\\n// This function is a shortcut for the most common use of `cxxrtl_get_parts`. It asserts that,\\n// if the object exists, it consists of a single part. If assertions are disabled, it returns NULL\\n// for multi-part objects.\\nstatic inline struct cxxrtl_object *cxxrtl_get(cxxrtl_handle handle, const char *name) {\\n\\tsize_t parts = 0;\\n\\tstruct cxxrtl_object *object = cxxrtl_get_parts(handle, name, &parts);\\n\\tassert(object == NULL || parts == 1);\\n\\tif (object == NULL || parts == 1)\\n\\t\\treturn object;\\n\\treturn NULL;\\n}\\n\\n// Enumerate simulated objects.\\n//\\n// For every object in the simulation, `callback` is called with the provided `data`, the full\\n// hierarchical name of the object (see `cxxrtl_get` for details), and the object parts.\\n// The provided `name` and `object` values are valid until the design is destroyed.\\nvoid cxxrtl_enum(cxxrtl_handle handle, void *data,\\n                 void (*callback)(void *data, const char *name,\\n                                  struct cxxrtl_object *object, size_t parts));\\n\\n// Opaque reference to an outline.\\n//\\n// An outline is a group of outline objects that are evaluated simultaneously. The identity of\\n// an outline can be compared to determine whether any two objects belong to the same outline.\\ntypedef struct _cxxrtl_outline *cxxrtl_outline;\\n\\n// Evaluate an outline.\\n//\\n// After evaluating an outline, the bits of every outline object contained in it are consistent\\n// with the current state of the netlist. In general, any further modification to the netlist\\n// causes every outline object to become stale, after which the corresponding outline must be\\n// re-evaluated, otherwise the bits read from that object are meaningless.\\nvoid cxxrtl_outline_eval(cxxrtl_outline outline);\\n\\n// Opaque reference to an attribute set.\\n//\\n// An attribute set is a map between attribute names (always strings) and values (which may have\\n// several different types). To find out the type of an attribute, use `cxxrtl_attr_type`, and\\n// to retrieve the value of an attribute, use `cxxrtl_attr_as_string`.\\ntypedef struct _cxxrtl_attr_set *cxxrtl_attr_set;\\n\\n// Type of an attribute.\\nenum cxxrtl_attr_type {\\n\\t// Attribute is not present.\\n\\tCXXRTL_ATTR_NONE = 0,\\n\\n\\t// Attribute has an unsigned integer value.\\n\\tCXXRTL_ATTR_UNSIGNED_INT = 1,\\n\\n\\t// Attribute has an unsigned integer value.\\n\\tCXXRTL_ATTR_SIGNED_INT = 2,\\n\\n\\t// Attribute has a string value.\\n\\tCXXRTL_ATTR_STRING = 3,\\n\\n\\t// Attribute has a double precision floating point value.\\n\\tCXXRTL_ATTR_DOUBLE = 4,\\n\\n\\t// More attribute types may be defined in the future, but the existing values will never change.\\n};\\n\\n// Determine the presence and type of an attribute in an attribute set.\\n//\\n// This function returns one of the possible `cxxrtl_attr_type` values.\\nint cxxrtl_attr_type(cxxrtl_attr_set attrs, const char *name);\\n\\n// Retrieve an unsigned integer valued attribute from an attribute set.\\n//\\n// This function asserts that `cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_UNSIGNED_INT`.\\n// If assertions are disabled, returns 0 if the attribute is missing or has an incorrect type.\\nuint64_t cxxrtl_attr_get_unsigned_int(cxxrtl_attr_set attrs, const char *name);\\n\\n// Retrieve a signed integer valued attribute from an attribute set.\\n//\\n// This function asserts that `cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_SIGNED_INT`.\\n// If assertions are disabled, returns 0 if the attribute is missing or has an incorrect type.\\nint64_t cxxrtl_attr_get_signed_int(cxxrtl_attr_set attrs, const char *name);\\n\\n// Retrieve a string valued attribute from an attribute set. The returned string is zero-terminated.\\n//\\n// This function asserts that `cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_STRING`. If assertions\\n// are disabled, returns NULL if the attribute is missing or has an incorrect type.\\nconst char *cxxrtl_attr_get_string(cxxrtl_attr_set attrs, const char *name);\\n\\n// Retrieve a double precision floating point valued attribute from an attribute set.\\n//\\n// This function asserts that `cxxrtl_attr_type(attrs, name) == CXXRTL_ATTR_DOUBLE`. If assertions\\n// are disabled, returns NULL if the attribute is missing or has an incorrect type.\\ndouble cxxrtl_attr_get_double(cxxrtl_attr_set attrs, const char *name);\\n\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n#endif\\n\",\n                                \"cxxrtl_capi_vcd.cc\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n// This file is a part of the CXXRTL C API. It should be used together with `cxxrtl/capi/cxxrtl_capi_vcd.h`.\\n\\n#include <cxxrtl/capi/cxxrtl_capi_vcd.h>\\n#include <cxxrtl/cxxrtl_vcd.h>\\n\\nextern const cxxrtl::debug_items &cxxrtl_debug_items_from_handle(cxxrtl_handle handle);\\n\\nstruct _cxxrtl_vcd {\\n\\tcxxrtl::vcd_writer writer;\\n\\tbool flush = false;\\n};\\n\\ncxxrtl_vcd cxxrtl_vcd_create() {\\n\\treturn new _cxxrtl_vcd;\\n}\\n\\nvoid cxxrtl_vcd_destroy(cxxrtl_vcd vcd) {\\n\\tdelete vcd;\\n}\\n\\nvoid cxxrtl_vcd_timescale(cxxrtl_vcd vcd, int number, const char *unit) {\\n\\tvcd->writer.timescale(number, unit);\\n}\\n\\nvoid cxxrtl_vcd_add(cxxrtl_vcd vcd, const char *name, cxxrtl_object *object) {\\n\\t// Note the copy. We don't know whether `object` came from a design (in which case it is\\n\\t// an instance of `debug_item`), or from user code (in which case it is an instance of\\n\\t// `cxxrtl_object`), so casting the pointer wouldn't be safe.\\n\\tvcd->writer.add(name, cxxrtl::debug_item(*object));\\n}\\n\\nvoid cxxrtl_vcd_add_from(cxxrtl_vcd vcd, cxxrtl_handle handle) {\\n\\tvcd->writer.add(cxxrtl_debug_items_from_handle(handle));\\n}\\n\\nvoid cxxrtl_vcd_add_from_if(cxxrtl_vcd vcd, cxxrtl_handle handle, void *data,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint (*filter)(void *data, const char *name,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t              const cxxrtl_object *object)) {\\n\\tvcd->writer.add(cxxrtl_debug_items_from_handle(handle),\\n\\t\\t[=](const std::string &name, const cxxrtl::debug_item &item) {\\n\\t\\t\\treturn filter(data, name.c_str(), static_cast<const cxxrtl_object*>(&item));\\n\\t\\t});\\n}\\n\\nvoid cxxrtl_vcd_add_from_without_memories(cxxrtl_vcd vcd, cxxrtl_handle handle) {\\n\\tvcd->writer.add_without_memories(cxxrtl_debug_items_from_handle(handle));\\n}\\n\\nvoid cxxrtl_vcd_sample(cxxrtl_vcd vcd, uint64_t time) {\\n\\tif (vcd->flush) {\\n\\t\\tvcd->writer.buffer.clear();\\n\\t\\tvcd->flush = false;\\n\\t}\\n\\tvcd->writer.sample(time);\\n}\\n\\nvoid cxxrtl_vcd_read(cxxrtl_vcd vcd, const char **data, size_t *size) {\\n\\tif (vcd->flush) {\\n\\t\\tvcd->writer.buffer.clear();\\n\\t\\tvcd->flush = false;\\n\\t}\\n\\t*data = vcd->writer.buffer.c_str();\\n\\t*size = vcd->writer.buffer.size();\\n\\tvcd->flush = true;\\n}\\n\",\n                                \"cxxrtl_capi_vcd.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef CXXRTL_CAPI_VCD_H\\n#define CXXRTL_CAPI_VCD_H\\n\\n// This file is a part of the CXXRTL C API. It should be used together with `cxxrtl_vcd_capi.cc`.\\n//\\n// The CXXRTL C API for VCD writing makes it possible to insert virtual probes into designs and\\n// dump waveforms to Value Change Dump files.\\n\\n#include <stddef.h>\\n#include <stdint.h>\\n\\n#include <cxxrtl/capi/cxxrtl_capi.h>\\n\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n// Opaque reference to a VCD writer.\\ntypedef struct _cxxrtl_vcd *cxxrtl_vcd;\\n\\n// Create a VCD writer.\\ncxxrtl_vcd cxxrtl_vcd_create();\\n\\n// Release all resources used by a VCD writer.\\nvoid cxxrtl_vcd_destroy(cxxrtl_vcd vcd);\\n\\n// Set VCD timescale.\\n//\\n// The `number` must be 1, 10, or 100, and the `unit` must be one of `\\\"s\\\"`, `\\\"ms\\\"`, `\\\"us\\\"`, `\\\"ns\\\"`,\\n// `\\\"ps\\\"`, or `\\\"fs\\\"`.\\n//\\n// Timescale can only be set before the first call to `cxxrtl_vcd_sample`.\\nvoid cxxrtl_vcd_timescale(cxxrtl_vcd vcd, int number, const char *unit);\\n\\n// Schedule a specific CXXRTL object to be sampled.\\n//\\n// The `name` is a full hierarchical name as described for `cxxrtl_get`; it does not need to match\\n// the original name of `object`, if any. The `object` must outlive the VCD writer, but there are\\n// no other requirements; if desired, it can be provided by user code, rather than come from\\n// a design.\\n//\\n// Objects can only be scheduled before the first call to `cxxrtl_vcd_sample`.\\nvoid cxxrtl_vcd_add(cxxrtl_vcd vcd, const char *name, struct cxxrtl_object *object);\\n\\n// Schedule all CXXRTL objects in a simulation.\\n//\\n// The design `handle` must outlive the VCD writer.\\n//\\n// Objects can only be scheduled before the first call to `cxxrtl_vcd_sample`.\\nvoid cxxrtl_vcd_add_from(cxxrtl_vcd vcd, cxxrtl_handle handle);\\n\\n// Schedule CXXRTL objects in a simulation that match a given predicate.\\n//\\n// For every object in the simulation, `filter` is called with the provided `data`, the full\\n// hierarchical name of the object (see `cxxrtl_get` for details), and the object description.\\n// The object will be sampled if the predicate returns a non-zero value.\\n//\\n// Objects can only be scheduled before the first call to `cxxrtl_vcd_sample`.\\nvoid cxxrtl_vcd_add_from_if(cxxrtl_vcd vcd, cxxrtl_handle handle, void *data,\\n                            int (*filter)(void *data, const char *name,\\n                                          const struct cxxrtl_object *object));\\n\\n// Schedule all CXXRTL objects in a simulation except for memories.\\n//\\n// The design `handle` must outlive the VCD writer.\\n//\\n// Objects can only be scheduled before the first call to `cxxrtl_vcd_sample`.\\nvoid cxxrtl_vcd_add_from_without_memories(cxxrtl_vcd vcd, cxxrtl_handle handle);\\n\\n// Sample all scheduled objects.\\n//\\n// First, `time` is written to the internal buffer. Second, the values of every signal changed since\\n// the previous call to `cxxrtl_vcd_sample` (all values if this is the first call) are written to\\n// the internal buffer. The contents of the buffer can be retrieved with `cxxrtl_vcd_read`.\\nvoid cxxrtl_vcd_sample(cxxrtl_vcd vcd, uint64_t time);\\n\\n// Retrieve buffered VCD data.\\n//\\n// The pointer to the start of the next chunk of VCD data is assigned to `*data`, and the length\\n// of that chunk is assigned to `*size`. The pointer to the data is valid until the next call to\\n// `cxxrtl_vcd_sample` or `cxxrtl_vcd_read`. Once all of the buffered data has been retrieved,\\n// this function will always return zero sized chunks.\\nvoid cxxrtl_vcd_read(cxxrtl_vcd vcd, const char **data, size_t *size);\\n\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n#endif\\n\",\n                            },\n                            \"cxxrtl.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2019-2020  whitequark <whitequark@whitequark.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n// This file is included by the designs generated with `write_cxxrtl`. It is not used in Yosys itself.\\n//\\n// The CXXRTL support library implements compile time specialized arbitrary width arithmetics, as well as provides\\n// composite lvalues made out of bit slices and concatenations of lvalues. This allows the `write_cxxrtl` pass\\n// to perform a straightforward translation of RTLIL structures to readable C++, relying on the C++ compiler\\n// to unwrap the abstraction and generate efficient code.\\n\\n#ifndef CXXRTL_H\\n#define CXXRTL_H\\n\\n#include <cstddef>\\n#include <cstdint>\\n#include <cstring>\\n#include <cassert>\\n#include <limits>\\n#include <type_traits>\\n#include <tuple>\\n#include <vector>\\n#include <map>\\n#include <algorithm>\\n#include <memory>\\n#include <functional>\\n#include <sstream>\\n#include <iostream>\\n\\n// `cxxrtl::debug_item` has to inherit from `cxxrtl_object` to satisfy strict aliasing requirements.\\n#include <cxxrtl/capi/cxxrtl_capi.h>\\n\\n#ifndef __has_attribute\\n#\\tdefine __has_attribute(x) 0\\n#endif\\n\\n// CXXRTL essentially uses the C++ compiler as a hygienic macro engine that feeds an instruction selector.\\n// It generates a lot of specialized template functions with relatively large bodies that, when inlined\\n// into the caller and (for those with loops) unrolled, often expose many new optimization opportunities.\\n// Because of this, most of the CXXRTL runtime must be always inlined for best performance.\\n#if __has_attribute(always_inline)\\n#define CXXRTL_ALWAYS_INLINE inline __attribute__((__always_inline__))\\n#else\\n#define CXXRTL_ALWAYS_INLINE inline\\n#endif\\n// Conversely, some functions in the generated code are extremely large yet very cold, with both of these\\n// properties being extreme enough to confuse C++ compilers into spending pathological amounts of time\\n// on a futile (the code becomes worse) attempt to optimize the least important parts of code.\\n#if __has_attribute(optnone)\\n#define CXXRTL_EXTREMELY_COLD __attribute__((__optnone__))\\n#elif __has_attribute(optimize)\\n#define CXXRTL_EXTREMELY_COLD __attribute__((__optimize__(0)))\\n#else\\n#define CXXRTL_EXTREMELY_COLD\\n#endif\\n\\n// CXXRTL uses assert() to check for C++ contract violations (which may result in e.g. undefined behavior\\n// of the simulation code itself), and CXXRTL_ASSERT to check for RTL contract violations (which may at\\n// most result in undefined simulation results).\\n//\\n// Though by default, CXXRTL_ASSERT() expands to assert(), it may be overridden e.g. when integrating\\n// the simulation into another process that should survive violating RTL contracts.\\n#ifndef CXXRTL_ASSERT\\n#ifndef CXXRTL_NDEBUG\\n#define CXXRTL_ASSERT(x) assert(x)\\n#else\\n#define CXXRTL_ASSERT(x)\\n#endif\\n#endif\\n\\nnamespace cxxrtl {\\n\\n// All arbitrary-width values in CXXRTL are backed by arrays of unsigned integers called chunks. The chunk size\\n// is the same regardless of the value width to simplify manipulating values via FFI interfaces, e.g. driving\\n// and introspecting the simulation in Python.\\n//\\n// It is practical to use chunk sizes between 32 bits and platform register size because when arithmetics on\\n// narrower integer types is legalized by the C++ compiler, it inserts code to clear the high bits of the register.\\n// However, (a) most of our operations do not change those bits in the first place because of invariants that are\\n// invisible to the compiler, (b) we often operate on non-power-of-2 values and have to clear the high bits anyway.\\n// Therefore, using relatively wide chunks and clearing the high bits explicitly and only when we know they may be\\n// clobbered results in simpler generated code.\\ntypedef uint32_t chunk_t;\\ntypedef uint64_t wide_chunk_t;\\n\\ntemplate<typename T>\\nstruct chunk_traits {\\n\\tstatic_assert(std::is_integral<T>::value && std::is_unsigned<T>::value,\\n\\t              \\\"chunk type must be an unsigned integral type\\\");\\n\\tusing type = T;\\n\\tstatic constexpr size_t bits = std::numeric_limits<T>::digits;\\n\\tstatic constexpr T mask = std::numeric_limits<T>::max();\\n};\\n\\ntemplate<class T>\\nstruct expr_base;\\n\\ntemplate<size_t Bits>\\nstruct value : public expr_base<value<Bits>> {\\n\\tstatic constexpr size_t bits = Bits;\\n\\n\\tusing chunk = chunk_traits<chunk_t>;\\n\\tstatic constexpr chunk::type msb_mask = (Bits % chunk::bits == 0) ? chunk::mask\\n\\t\\t: chunk::mask >> (chunk::bits - (Bits % chunk::bits));\\n\\n\\tstatic constexpr size_t chunks = (Bits + chunk::bits - 1) / chunk::bits;\\n\\tchunk::type data[chunks] = {};\\n\\n\\tvalue() = default;\\n\\ttemplate<typename... Init>\\n\\texplicit constexpr value(Init ...init) : data{init...} {}\\n\\n\\tvalue(const value<Bits> &) = default;\\n\\tvalue<Bits> &operator=(const value<Bits> &) = default;\\n\\n\\tvalue(value<Bits> &&) = default;\\n\\tvalue<Bits> &operator=(value<Bits> &&) = default;\\n\\n\\t// A (no-op) helper that forces the cast to value<>.\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tconst value<Bits> &val() const {\\n\\t\\treturn *this;\\n\\t}\\n\\n\\tstd::string str() const {\\n\\t\\tstd::stringstream ss;\\n\\t\\tss << *this;\\n\\t\\treturn ss.str();\\n\\t}\\n\\n\\t// Conversion operations.\\n\\t//\\n\\t// These functions ensure that a conversion is never out of range, and should be always used, if at all\\n\\t// possible, instead of direct manipulation of the `data` member. For very large types, .slice() and\\n\\t// .concat() can be used to split them into more manageable parts.\\n\\ttemplate<class IntegerT, typename std::enable_if<!std::is_signed<IntegerT>::value, int>::type = 0>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tIntegerT get() const {\\n\\t\\tstatic_assert(std::numeric_limits<IntegerT>::is_integer && !std::numeric_limits<IntegerT>::is_signed,\\n\\t\\t              \\\"get<T>() requires T to be an unsigned integral type\\\");\\n\\t\\tstatic_assert(std::numeric_limits<IntegerT>::digits >= Bits,\\n\\t\\t              \\\"get<T>() requires T to be at least as wide as the value is\\\");\\n\\t\\tIntegerT result = 0;\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tresult |= IntegerT(data[n]) << (n * chunk::bits);\\n\\t\\treturn result;\\n\\t}\\n\\n\\ttemplate<class IntegerT, typename std::enable_if<std::is_signed<IntegerT>::value, int>::type = 0>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tIntegerT get() const {\\n\\t\\tauto unsigned_result = get<typename std::make_unsigned<IntegerT>::type>();\\n\\t\\tIntegerT result;\\n\\t\\tmemcpy(&result, &unsigned_result, sizeof(IntegerT));\\n\\t\\treturn result;\\n\\t}\\n\\n\\ttemplate<class IntegerT, typename std::enable_if<!std::is_signed<IntegerT>::value, int>::type = 0>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvoid set(IntegerT value) {\\n\\t\\tstatic_assert(std::numeric_limits<IntegerT>::is_integer && !std::numeric_limits<IntegerT>::is_signed,\\n\\t\\t              \\\"set<T>() requires T to be an unsigned integral type\\\");\\n\\t\\tstatic_assert(std::numeric_limits<IntegerT>::digits >= Bits,\\n\\t\\t              \\\"set<T>() requires the value to be at least as wide as T is\\\");\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tdata[n] = (value >> (n * chunk::bits)) & chunk::mask;\\n\\t}\\n\\n\\ttemplate<class IntegerT, typename std::enable_if<std::is_signed<IntegerT>::value, int>::type = 0>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvoid set(IntegerT value) {\\n\\t\\ttypename std::make_unsigned<IntegerT>::type unsigned_value;\\n\\t\\tmemcpy(&unsigned_value, &value, sizeof(IntegerT));\\n\\t\\tset(unsigned_value);\\n\\t}\\n\\n\\t// Operations with compile-time parameters.\\n\\t//\\n\\t// These operations are used to implement slicing, concatenation, and blitting.\\n\\t// The trunc, zext and sext operations add or remove most significant bits (i.e. on the left);\\n\\t// the rtrunc and rzext operations add or remove least significant bits (i.e. on the right).\\n\\ttemplate<size_t NewBits>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<NewBits> trunc() const {\\n\\t\\tstatic_assert(NewBits <= Bits, \\\"trunc() may not increase width\\\");\\n\\t\\tvalue<NewBits> result;\\n\\t\\tfor (size_t n = 0; n < result.chunks; n++)\\n\\t\\t\\tresult.data[n] = data[n];\\n\\t\\tresult.data[result.chunks - 1] &= result.msb_mask;\\n\\t\\treturn result;\\n\\t}\\n\\n\\ttemplate<size_t NewBits>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<NewBits> zext() const {\\n\\t\\tstatic_assert(NewBits >= Bits, \\\"zext() may not decrease width\\\");\\n\\t\\tvalue<NewBits> result;\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tresult.data[n] = data[n];\\n\\t\\treturn result;\\n\\t}\\n\\n\\ttemplate<size_t NewBits>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<NewBits> sext() const {\\n\\t\\tstatic_assert(NewBits >= Bits, \\\"sext() may not decrease width\\\");\\n\\t\\tvalue<NewBits> result;\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tresult.data[n] = data[n];\\n\\t\\tif (is_neg()) {\\n\\t\\t\\tresult.data[chunks - 1] |= ~msb_mask;\\n\\t\\t\\tfor (size_t n = chunks; n < result.chunks; n++)\\n\\t\\t\\t\\tresult.data[n] = chunk::mask;\\n\\t\\t\\tresult.data[result.chunks - 1] &= result.msb_mask;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\ttemplate<size_t NewBits>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<NewBits> rtrunc() const {\\n\\t\\tstatic_assert(NewBits <= Bits, \\\"rtrunc() may not increase width\\\");\\n\\t\\tvalue<NewBits> result;\\n\\t\\tconstexpr size_t shift_chunks = (Bits - NewBits) / chunk::bits;\\n\\t\\tconstexpr size_t shift_bits   = (Bits - NewBits) % chunk::bits;\\n\\t\\tchunk::type carry = 0;\\n\\t\\tif (shift_chunks + result.chunks < chunks) {\\n\\t\\t\\tcarry = (shift_bits == 0) ? 0\\n\\t\\t\\t\\t: data[shift_chunks + result.chunks] << (chunk::bits - shift_bits);\\n\\t\\t}\\n\\t\\tfor (size_t n = result.chunks; n > 0; n--) {\\n\\t\\t\\tresult.data[n - 1] = carry | (data[shift_chunks + n - 1] >> shift_bits);\\n\\t\\t\\tcarry = (shift_bits == 0) ? 0\\n\\t\\t\\t\\t: data[shift_chunks + n - 1] << (chunk::bits - shift_bits);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\ttemplate<size_t NewBits>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<NewBits> rzext() const {\\n\\t\\tstatic_assert(NewBits >= Bits, \\\"rzext() may not decrease width\\\");\\n\\t\\tvalue<NewBits> result;\\n\\t\\tconstexpr size_t shift_chunks = (NewBits - Bits) / chunk::bits;\\n\\t\\tconstexpr size_t shift_bits   = (NewBits - Bits) % chunk::bits;\\n\\t\\tchunk::type carry = 0;\\n\\t\\tfor (size_t n = 0; n < chunks; n++) {\\n\\t\\t\\tresult.data[shift_chunks + n] = (data[n] << shift_bits) | carry;\\n\\t\\t\\tcarry = (shift_bits == 0) ? 0\\n\\t\\t\\t\\t: data[n] >> (chunk::bits - shift_bits);\\n\\t\\t}\\n\\t\\tif (shift_chunks + chunks < result.chunks)\\n\\t\\t\\tresult.data[shift_chunks + chunks] = carry;\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// Bit blit operation, i.e. a partial read-modify-write.\\n\\ttemplate<size_t Stop, size_t Start>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<Bits> blit(const value<Stop - Start + 1> &source) const {\\n\\t\\tstatic_assert(Stop >= Start, \\\"blit() may not reverse bit order\\\");\\n\\t\\tconstexpr chunk::type start_mask = ~(chunk::mask << (Start % chunk::bits));\\n\\t\\tconstexpr chunk::type stop_mask = (Stop % chunk::bits + 1 == chunk::bits) ? 0\\n\\t\\t\\t: (chunk::mask << (Stop % chunk::bits + 1));\\n\\t\\tvalue<Bits> masked = *this;\\n\\t\\tif (Start / chunk::bits == Stop / chunk::bits) {\\n\\t\\t\\tmasked.data[Start / chunk::bits] &= stop_mask | start_mask;\\n\\t\\t} else {\\n\\t\\t\\tmasked.data[Start / chunk::bits] &= start_mask;\\n\\t\\t\\tfor (size_t n = Start / chunk::bits + 1; n < Stop / chunk::bits; n++)\\n\\t\\t\\t\\tmasked.data[n] = 0;\\n\\t\\t\\tmasked.data[Stop / chunk::bits] &= stop_mask;\\n\\t\\t}\\n\\t\\tvalue<Bits> shifted = source\\n\\t\\t\\t.template rzext<Stop + 1>()\\n\\t\\t\\t.template zext<Bits>();\\n\\t\\treturn masked.bit_or(shifted);\\n\\t}\\n\\n\\t// Helpers for selecting extending or truncating operation depending on whether the result is wider or narrower\\n\\t// than the operand. In C++17 these can be replaced with `if constexpr`.\\n\\ttemplate<size_t NewBits, typename = void>\\n\\tstruct zext_cast {\\n\\t\\tCXXRTL_ALWAYS_INLINE\\n\\t\\tvalue<NewBits> operator()(const value<Bits> &val) {\\n\\t\\t\\treturn val.template zext<NewBits>();\\n\\t\\t}\\n\\t};\\n\\n\\ttemplate<size_t NewBits>\\n\\tstruct zext_cast<NewBits, typename std::enable_if<(NewBits < Bits)>::type> {\\n\\t\\tCXXRTL_ALWAYS_INLINE\\n\\t\\tvalue<NewBits> operator()(const value<Bits> &val) {\\n\\t\\t\\treturn val.template trunc<NewBits>();\\n\\t\\t}\\n\\t};\\n\\n\\ttemplate<size_t NewBits, typename = void>\\n\\tstruct sext_cast {\\n\\t\\tCXXRTL_ALWAYS_INLINE\\n\\t\\tvalue<NewBits> operator()(const value<Bits> &val) {\\n\\t\\t\\treturn val.template sext<NewBits>();\\n\\t\\t}\\n\\t};\\n\\n\\ttemplate<size_t NewBits>\\n\\tstruct sext_cast<NewBits, typename std::enable_if<(NewBits < Bits)>::type> {\\n\\t\\tCXXRTL_ALWAYS_INLINE\\n\\t\\tvalue<NewBits> operator()(const value<Bits> &val) {\\n\\t\\t\\treturn val.template trunc<NewBits>();\\n\\t\\t}\\n\\t};\\n\\n\\ttemplate<size_t NewBits>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<NewBits> zcast() const {\\n\\t\\treturn zext_cast<NewBits>()(*this);\\n\\t}\\n\\n\\ttemplate<size_t NewBits>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<NewBits> scast() const {\\n\\t\\treturn sext_cast<NewBits>()(*this);\\n\\t}\\n\\n\\t// Bit replication is far more efficient than the equivalent concatenation.\\n\\ttemplate<size_t Count>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<Bits * Count> repeat() const {\\n\\t\\tstatic_assert(Bits == 1, \\\"repeat() is implemented only for 1-bit values\\\");\\n\\t\\treturn *this ? value<Bits * Count>().bit_not() : value<Bits * Count>();\\n\\t}\\n\\n\\t// Operations with run-time parameters (offsets, amounts, etc).\\n\\t//\\n\\t// These operations are used for computations.\\n\\tbool bit(size_t offset) const {\\n\\t\\treturn data[offset / chunk::bits] & (1 << (offset % chunk::bits));\\n\\t}\\n\\n\\tvoid set_bit(size_t offset, bool value = true) {\\n\\t\\tsize_t offset_chunks = offset / chunk::bits;\\n\\t\\tsize_t offset_bits = offset % chunk::bits;\\n\\t\\tdata[offset_chunks] &= ~(1 << offset_bits);\\n\\t\\tdata[offset_chunks] |= value ? 1 << offset_bits : 0;\\n\\t}\\n\\n\\texplicit operator bool() const {\\n\\t\\treturn !is_zero();\\n\\t}\\n\\n\\tbool is_zero() const {\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tif (data[n] != 0)\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool is_neg() const {\\n\\t\\treturn data[chunks - 1] & (1 << ((Bits - 1) % chunk::bits));\\n\\t}\\n\\n\\tbool operator ==(const value<Bits> &other) const {\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tif (data[n] != other.data[n])\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool operator !=(const value<Bits> &other) const {\\n\\t\\treturn !(*this == other);\\n\\t}\\n\\n\\tvalue<Bits> bit_not() const {\\n\\t\\tvalue<Bits> result;\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tresult.data[n] = ~data[n];\\n\\t\\tresult.data[chunks - 1] &= msb_mask;\\n\\t\\treturn result;\\n\\t}\\n\\n\\tvalue<Bits> bit_and(const value<Bits> &other) const {\\n\\t\\tvalue<Bits> result;\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tresult.data[n] = data[n] & other.data[n];\\n\\t\\treturn result;\\n\\t}\\n\\n\\tvalue<Bits> bit_or(const value<Bits> &other) const {\\n\\t\\tvalue<Bits> result;\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tresult.data[n] = data[n] | other.data[n];\\n\\t\\treturn result;\\n\\t}\\n\\n\\tvalue<Bits> bit_xor(const value<Bits> &other) const {\\n\\t\\tvalue<Bits> result;\\n\\t\\tfor (size_t n = 0; n < chunks; n++)\\n\\t\\t\\tresult.data[n] = data[n] ^ other.data[n];\\n\\t\\treturn result;\\n\\t}\\n\\n\\tvalue<Bits> update(const value<Bits> &val, const value<Bits> &mask) const {\\n\\t\\treturn bit_and(mask.bit_not()).bit_or(val.bit_and(mask));\\n\\t}\\n\\n\\ttemplate<size_t AmountBits>\\n\\tvalue<Bits> shl(const value<AmountBits> &amount) const {\\n\\t\\t// Ensure our early return is correct by prohibiting values larger than 4 Gbit.\\n\\t\\tstatic_assert(Bits <= chunk::mask, \\\"shl() of unreasonably large values is not supported\\\");\\n\\t\\t// Detect shifts definitely large than Bits early.\\n\\t\\tfor (size_t n = 1; n < amount.chunks; n++)\\n\\t\\t\\tif (amount.data[n] != 0)\\n\\t\\t\\t\\treturn {};\\n\\t\\t// Past this point we can use the least significant chunk as the shift size.\\n\\t\\tsize_t shift_chunks = amount.data[0] / chunk::bits;\\n\\t\\tsize_t shift_bits   = amount.data[0] % chunk::bits;\\n\\t\\tif (shift_chunks >= chunks)\\n\\t\\t\\treturn {};\\n\\t\\tvalue<Bits> result;\\n\\t\\tchunk::type carry = 0;\\n\\t\\tfor (size_t n = 0; n < chunks - shift_chunks; n++) {\\n\\t\\t\\tresult.data[shift_chunks + n] = (data[n] << shift_bits) | carry;\\n\\t\\t\\tcarry = (shift_bits == 0) ? 0\\n\\t\\t\\t\\t: data[n] >> (chunk::bits - shift_bits);\\n\\t\\t}\\n\\t\\tresult.data[result.chunks - 1] &= result.msb_mask;\\n\\t\\treturn result;\\n\\t}\\n\\n\\ttemplate<size_t AmountBits, bool Signed = false>\\n\\tvalue<Bits> shr(const value<AmountBits> &amount) const {\\n\\t\\t// Ensure our early return is correct by prohibiting values larger than 4 Gbit.\\n\\t\\tstatic_assert(Bits <= chunk::mask, \\\"shr() of unreasonably large values is not supported\\\");\\n\\t\\t// Detect shifts definitely large than Bits early.\\n\\t\\tfor (size_t n = 1; n < amount.chunks; n++)\\n\\t\\t\\tif (amount.data[n] != 0)\\n\\t\\t\\t\\treturn (Signed && is_neg()) ? value<Bits>().bit_not() : value<Bits>();\\n\\t\\t// Past this point we can use the least significant chunk as the shift size.\\n\\t\\tsize_t shift_chunks = amount.data[0] / chunk::bits;\\n\\t\\tsize_t shift_bits   = amount.data[0] % chunk::bits;\\n\\t\\tif (shift_chunks >= chunks)\\n\\t\\t\\treturn (Signed && is_neg()) ? value<Bits>().bit_not() : value<Bits>();\\n\\t\\tvalue<Bits> result;\\n\\t\\tchunk::type carry = 0;\\n\\t\\tfor (size_t n = 0; n < chunks - shift_chunks; n++) {\\n\\t\\t\\tresult.data[chunks - shift_chunks - 1 - n] = carry | (data[chunks - 1 - n] >> shift_bits);\\n\\t\\t\\tcarry = (shift_bits == 0) ? 0\\n\\t\\t\\t\\t: data[chunks - 1 - n] << (chunk::bits - shift_bits);\\n\\t\\t}\\n\\t\\tif (Signed && is_neg()) {\\n\\t\\t\\tsize_t top_chunk_idx  = amount.data[0] > Bits ? 0 : (Bits - amount.data[0]) / chunk::bits;\\n\\t\\t\\tsize_t top_chunk_bits = amount.data[0] > Bits ? 0 : (Bits - amount.data[0]) % chunk::bits;\\n\\t\\t\\tfor (size_t n = top_chunk_idx + 1; n < chunks; n++)\\n\\t\\t\\t\\tresult.data[n] = chunk::mask;\\n\\t\\t\\tif (amount.data[0] != 0)\\n\\t\\t\\t\\tresult.data[top_chunk_idx] |= chunk::mask << top_chunk_bits;\\n\\t\\t\\tresult.data[result.chunks - 1] &= result.msb_mask;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\ttemplate<size_t AmountBits>\\n\\tvalue<Bits> sshr(const value<AmountBits> &amount) const {\\n\\t\\treturn shr<AmountBits, /*Signed=*/true>(amount);\\n\\t}\\n\\n\\ttemplate<size_t ResultBits, size_t SelBits>\\n\\tvalue<ResultBits> bmux(const value<SelBits> &sel) const {\\n\\t\\tstatic_assert(ResultBits << SelBits == Bits, \\\"invalid sizes used in bmux()\\\");\\n\\t\\tsize_t amount = sel.data[0] * ResultBits;\\n\\t\\tsize_t shift_chunks = amount / chunk::bits;\\n\\t\\tsize_t shift_bits   = amount % chunk::bits;\\n\\t\\tvalue<ResultBits> result;\\n\\t\\tchunk::type carry = 0;\\n\\t\\tif (ResultBits % chunk::bits + shift_bits > chunk::bits)\\n\\t\\t\\tcarry = data[result.chunks + shift_chunks] << (chunk::bits - shift_bits);\\n\\t\\tfor (size_t n = 0; n < result.chunks; n++) {\\n\\t\\t\\tresult.data[result.chunks - 1 - n] = carry | (data[result.chunks + shift_chunks - 1 - n] >> shift_bits);\\n\\t\\t\\tcarry = (shift_bits == 0) ? 0\\n\\t\\t\\t\\t: data[result.chunks + shift_chunks - 1 - n] << (chunk::bits - shift_bits);\\n\\t\\t}\\n\\t\\tresult.data[result.chunks - 1] &= result.msb_mask;\\n\\t\\treturn result;\\n\\t}\\n\\n\\ttemplate<size_t ResultBits, size_t SelBits>\\n\\tvalue<ResultBits> demux(const value<SelBits> &sel) const {\\n\\t\\tstatic_assert(Bits << SelBits == ResultBits, \\\"invalid sizes used in demux()\\\");\\n\\t\\tsize_t amount = sel.data[0] * Bits;\\n\\t\\tsize_t shift_chunks = amount / chunk::bits;\\n\\t\\tsize_t shift_bits   = amount % chunk::bits;\\n\\t\\tvalue<ResultBits> result;\\n\\t\\tchunk::type carry = 0;\\n\\t\\tfor (size_t n = 0; n < chunks; n++) {\\n\\t\\t\\tresult.data[shift_chunks + n] = (data[n] << shift_bits) | carry;\\n\\t\\t\\tcarry = (shift_bits == 0) ? 0\\n\\t\\t\\t\\t: data[n] >> (chunk::bits - shift_bits);\\n\\t\\t}\\n\\t\\tif (Bits % chunk::bits + shift_bits > chunk::bits)\\n\\t\\t\\tresult.data[shift_chunks + chunks] = carry;\\n\\t\\treturn result;\\n\\t}\\n\\n\\tsize_t ctpop() const {\\n\\t\\tsize_t count = 0;\\n\\t\\tfor (size_t n = 0; n < chunks; n++) {\\n\\t\\t\\t// This loop implements the population count idiom as recognized by LLVM and GCC.\\n\\t\\t\\tfor (chunk::type x = data[n]; x != 0; count++)\\n\\t\\t\\t\\tx = x & (x - 1);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\n\\tsize_t ctlz() const {\\n\\t\\tsize_t count = 0;\\n\\t\\tfor (size_t n = 0; n < chunks; n++) {\\n\\t\\t\\tchunk::type x = data[chunks - 1 - n];\\n\\t\\t\\t// First add to `count` as if the chunk is zero\\n\\t\\t\\tconstexpr size_t msb_chunk_bits = Bits % chunk::bits != 0 ? Bits % chunk::bits : chunk::bits;\\n\\t\\t\\tcount += (n == 0 ? msb_chunk_bits : chunk::bits);\\n\\t\\t\\t// If the chunk isn't zero, correct the `count` value and return\\n\\t\\t\\tif (x != 0) {\\n\\t\\t\\t\\tfor (; x != 0; count--)\\n\\t\\t\\t\\t\\tx >>= 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\n\\ttemplate<bool Invert, bool CarryIn>\\n\\tstd::pair<value<Bits>, bool /*CarryOut*/> alu(const value<Bits> &other) const {\\n\\t\\tvalue<Bits> result;\\n\\t\\tbool carry = CarryIn;\\n\\t\\tfor (size_t n = 0; n < result.chunks; n++) {\\n\\t\\t\\tresult.data[n] = data[n] + (Invert ? ~other.data[n] : other.data[n]) + carry;\\n\\t\\t\\tif (result.chunks - 1 == n)\\n\\t\\t\\t\\tresult.data[result.chunks - 1] &= result.msb_mask;\\n\\t\\t\\tcarry = (result.data[n] <  data[n]) ||\\n\\t\\t\\t        (result.data[n] == data[n] && carry);\\n\\t\\t}\\n\\t\\treturn {result, carry};\\n\\t}\\n\\n\\tvalue<Bits> add(const value<Bits> &other) const {\\n\\t\\treturn alu</*Invert=*/false, /*CarryIn=*/false>(other).first;\\n\\t}\\n\\n\\tvalue<Bits> sub(const value<Bits> &other) const {\\n\\t\\treturn alu</*Invert=*/true, /*CarryIn=*/true>(other).first;\\n\\t}\\n\\n\\tvalue<Bits> neg() const {\\n\\t\\treturn value<Bits>().sub(*this);\\n\\t}\\n\\n\\tbool ucmp(const value<Bits> &other) const {\\n\\t\\tbool carry;\\n\\t\\tstd::tie(std::ignore, carry) = alu</*Invert=*/true, /*CarryIn=*/true>(other);\\n\\t\\treturn !carry; // a.ucmp(b) ≡ a u< b\\n\\t}\\n\\n\\tbool scmp(const value<Bits> &other) const {\\n\\t\\tvalue<Bits> result;\\n\\t\\tbool carry;\\n\\t\\tstd::tie(result, carry) = alu</*Invert=*/true, /*CarryIn=*/true>(other);\\n\\t\\tbool overflow = (is_neg() == !other.is_neg()) && (is_neg() != result.is_neg());\\n\\t\\treturn result.is_neg() ^ overflow; // a.scmp(b) ≡ a s< b\\n\\t}\\n\\n\\ttemplate<size_t ResultBits>\\n\\tvalue<ResultBits> mul(const value<Bits> &other) const {\\n\\t\\tvalue<ResultBits> result;\\n\\t\\twide_chunk_t wide_result[result.chunks + 1] = {};\\n\\t\\tfor (size_t n = 0; n < chunks; n++) {\\n\\t\\t\\tfor (size_t m = 0; m < chunks && n + m < result.chunks; m++) {\\n\\t\\t\\t\\twide_result[n + m] += wide_chunk_t(data[n]) * wide_chunk_t(other.data[m]);\\n\\t\\t\\t\\twide_result[n + m + 1] += wide_result[n + m] >> chunk::bits;\\n\\t\\t\\t\\twide_result[n + m] &= chunk::mask;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (size_t n = 0; n < result.chunks; n++) {\\n\\t\\t\\tresult.data[n] = wide_result[n];\\n\\t\\t}\\n\\t\\tresult.data[result.chunks - 1] &= result.msb_mask;\\n\\t\\treturn result;\\n\\t}\\n\\n\\tstd::pair<value<Bits>, value<Bits>> udivmod(value<Bits> divisor) const {\\n\\t\\tvalue<Bits> quotient;\\n\\t\\tvalue<Bits> dividend = *this;\\n\\t\\tif (dividend.ucmp(divisor))\\n\\t\\t\\treturn {/*quotient=*/value<Bits>{0u}, /*remainder=*/dividend};\\n\\t\\tint64_t divisor_shift = divisor.ctlz() - dividend.ctlz();\\n\\t\\tassert(divisor_shift >= 0);\\n\\t\\tdivisor = divisor.shl(value<Bits>{(chunk::type) divisor_shift});\\n\\t\\tfor (size_t step = 0; step <= divisor_shift; step++) {\\n\\t\\t\\tquotient = quotient.shl(value<Bits>{1u});\\n\\t\\t\\tif (!dividend.ucmp(divisor)) {\\n\\t\\t\\t\\tdividend = dividend.sub(divisor);\\n\\t\\t\\t\\tquotient.set_bit(0, true);\\n\\t\\t\\t}\\n\\t\\t\\tdivisor = divisor.shr(value<Bits>{1u});\\n\\t\\t}\\n\\t\\treturn {quotient, /*remainder=*/dividend};\\n\\t}\\n\\n\\tstd::pair<value<Bits>, value<Bits>> sdivmod(const value<Bits> &other) const {\\n\\t\\tvalue<Bits + 1> quotient;\\n\\t\\tvalue<Bits + 1> remainder;\\n\\t\\tvalue<Bits + 1> dividend = sext<Bits + 1>();\\n\\t\\tvalue<Bits + 1> divisor = other.template sext<Bits + 1>();\\n\\t\\tif (is_neg()) dividend = dividend.neg();\\n\\t\\tif (other.is_neg()) divisor = divisor.neg();\\n\\t\\tstd::tie(quotient, remainder) = dividend.udivmod(divisor);\\n\\t\\tif (is_neg() != other.is_neg()) quotient = quotient.neg();\\n\\t\\tif (is_neg()) remainder = remainder.neg();\\n\\t\\treturn {quotient.template trunc<Bits>(), remainder.template trunc<Bits>()};\\n\\t}\\n};\\n\\n// Expression template for a slice, usable as lvalue or rvalue, and composable with other expression templates here.\\ntemplate<class T, size_t Stop, size_t Start>\\nstruct slice_expr : public expr_base<slice_expr<T, Stop, Start>> {\\n\\tstatic_assert(Stop >= Start, \\\"slice_expr() may not reverse bit order\\\");\\n\\tstatic_assert(Start < T::bits && Stop < T::bits, \\\"slice_expr() must be within bounds\\\");\\n\\tstatic constexpr size_t bits = Stop - Start + 1;\\n\\n\\tT &expr;\\n\\n\\tslice_expr(T &expr) : expr(expr) {}\\n\\tslice_expr(const slice_expr<T, Stop, Start> &) = delete;\\n\\n\\tCXXRTL_ALWAYS_INLINE\\n\\toperator value<bits>() const {\\n\\t\\treturn static_cast<const value<T::bits> &>(expr)\\n\\t\\t\\t.template rtrunc<T::bits - Start>()\\n\\t\\t\\t.template trunc<bits>();\\n\\t}\\n\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tslice_expr<T, Stop, Start> &operator=(const value<bits> &rhs) {\\n\\t\\t// Generic partial assignment implemented using a read-modify-write operation on the sliced expression.\\n\\t\\texpr = static_cast<const value<T::bits> &>(expr)\\n\\t\\t\\t.template blit<Stop, Start>(rhs);\\n\\t\\treturn *this;\\n\\t}\\n\\n\\t// A helper that forces the cast to value<>, which allows deduction to work.\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<bits> val() const {\\n\\t\\treturn static_cast<const value<bits> &>(*this);\\n\\t}\\n};\\n\\n// Expression template for a concatenation, usable as lvalue or rvalue, and composable with other expression templates here.\\ntemplate<class T, class U>\\nstruct concat_expr : public expr_base<concat_expr<T, U>> {\\n\\tstatic constexpr size_t bits = T::bits + U::bits;\\n\\n\\tT &ms_expr;\\n\\tU &ls_expr;\\n\\n\\tconcat_expr(T &ms_expr, U &ls_expr) : ms_expr(ms_expr), ls_expr(ls_expr) {}\\n\\tconcat_expr(const concat_expr<T, U> &) = delete;\\n\\n\\tCXXRTL_ALWAYS_INLINE\\n\\toperator value<bits>() const {\\n\\t\\tvalue<bits> ms_shifted = static_cast<const value<T::bits> &>(ms_expr)\\n\\t\\t\\t.template rzext<bits>();\\n\\t\\tvalue<bits> ls_extended = static_cast<const value<U::bits> &>(ls_expr)\\n\\t\\t\\t.template zext<bits>();\\n\\t\\treturn ms_shifted.bit_or(ls_extended);\\n\\t}\\n\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tconcat_expr<T, U> &operator=(const value<bits> &rhs) {\\n\\t\\tms_expr = rhs.template rtrunc<T::bits>();\\n\\t\\tls_expr = rhs.template trunc<U::bits>();\\n\\t\\treturn *this;\\n\\t}\\n\\n\\t// A helper that forces the cast to value<>, which allows deduction to work.\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvalue<bits> val() const {\\n\\t\\treturn static_cast<const value<bits> &>(*this);\\n\\t}\\n};\\n\\n// Base class for expression templates, providing helper methods for operations that are valid on both rvalues and lvalues.\\n//\\n// Note that expression objects (slices and concatenations) constructed in this way should NEVER be captured because\\n// they refer to temporaries that will, in general, only live until the end of the statement. For example, both of\\n// these snippets perform use-after-free:\\n//\\n//    const auto &a = val.slice<7,0>().slice<1>();\\n//    value<1> b = a;\\n//\\n//    auto &&c = val.slice<7,0>().slice<1>();\\n//    c = value<1>{1u};\\n//\\n// An easy way to write code using slices and concatenations safely is to follow two simple rules:\\n//   * Never explicitly name any type except `value<W>` or `const value<W> &`.\\n//   * Never use a `const auto &` or `auto &&` in any such expression.\\n// Then, any code that compiles will be well-defined.\\ntemplate<class T>\\nstruct expr_base {\\n\\ttemplate<size_t Stop, size_t Start = Stop>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tslice_expr<const T, Stop, Start> slice() const {\\n\\t\\treturn {*static_cast<const T *>(this)};\\n\\t}\\n\\n\\ttemplate<size_t Stop, size_t Start = Stop>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tslice_expr<T, Stop, Start> slice() {\\n\\t\\treturn {*static_cast<T *>(this)};\\n\\t}\\n\\n\\ttemplate<class U>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tconcat_expr<const T, typename std::remove_reference<const U>::type> concat(const U &other) const {\\n\\t\\treturn {*static_cast<const T *>(this), other};\\n\\t}\\n\\n\\ttemplate<class U>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tconcat_expr<T, typename std::remove_reference<U>::type> concat(U &&other) {\\n\\t\\treturn {*static_cast<T *>(this), other};\\n\\t}\\n};\\n\\ntemplate<size_t Bits>\\nstd::ostream &operator<<(std::ostream &os, const value<Bits> &val) {\\n\\tauto old_flags = os.flags(std::ios::right);\\n\\tauto old_width = os.width(0);\\n\\tauto old_fill  = os.fill('0');\\n\\tos << val.bits << '\\\\'' << std::hex;\\n\\tfor (size_t n = val.chunks - 1; n != (size_t)-1; n--) {\\n\\t\\tif (n == val.chunks - 1 && Bits % value<Bits>::chunk::bits != 0)\\n\\t\\t\\tos.width((Bits % value<Bits>::chunk::bits + 3) / 4);\\n\\t\\telse\\n\\t\\t\\tos.width((value<Bits>::chunk::bits + 3) / 4);\\n\\t\\tos << val.data[n];\\n\\t}\\n\\tos.fill(old_fill);\\n\\tos.width(old_width);\\n\\tos.flags(old_flags);\\n\\treturn os;\\n}\\n\\ntemplate<size_t Bits>\\nstruct wire {\\n\\tstatic constexpr size_t bits = Bits;\\n\\n\\tvalue<Bits> curr;\\n\\tvalue<Bits> next;\\n\\n\\twire() = default;\\n\\texplicit constexpr wire(const value<Bits> &init) : curr(init), next(init) {}\\n\\ttemplate<typename... Init>\\n\\texplicit constexpr wire(Init ...init) : curr{init...}, next{init...} {}\\n\\n\\t// Copying and copy-assigning values is natural. If, however, a value is replaced with a wire,\\n\\t// e.g. because a module is built with a different optimization level, then existing code could\\n\\t// unintentionally copy a wire instead, which would create a subtle but serious bug. To make sure\\n\\t// this doesn't happen, prohibit copying and copy-assigning wires.\\n\\twire(const wire<Bits> &) = delete;\\n\\twire<Bits> &operator=(const wire<Bits> &) = delete;\\n\\n\\twire(wire<Bits> &&) = default;\\n\\twire<Bits> &operator=(wire<Bits> &&) = default;\\n\\n\\ttemplate<class IntegerT>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tIntegerT get() const {\\n\\t\\treturn curr.template get<IntegerT>();\\n\\t}\\n\\n\\ttemplate<class IntegerT>\\n\\tCXXRTL_ALWAYS_INLINE\\n\\tvoid set(IntegerT other) {\\n\\t\\tnext.template set<IntegerT>(other);\\n\\t}\\n\\n\\t// This method intentionally takes a mandatory argument (to make it more difficult to misuse in\\n\\t// black box implementations, leading to missed observer events). It is generic over its argument\\n\\t// to allow the `on_update` method to be non-virtual.\\n\\ttemplate<class ObserverT>\\n\\tbool commit(ObserverT &observer) {\\n\\t\\tif (curr != next) {\\n\\t\\t\\tobserver.on_update(curr.chunks, curr.data, next.data);\\n\\t\\t\\tcurr = next;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n\\ntemplate<size_t Bits>\\nstd::ostream &operator<<(std::ostream &os, const wire<Bits> &val) {\\n\\tos << val.curr;\\n\\treturn os;\\n}\\n\\ntemplate<size_t Width>\\nstruct memory {\\n\\tconst size_t depth;\\n\\tstd::unique_ptr<value<Width>[]> data;\\n\\n\\texplicit memory(size_t depth) : depth(depth), data(new value<Width>[depth]) {}\\n\\n\\tmemory(const memory<Width> &) = delete;\\n\\tmemory<Width> &operator=(const memory<Width> &) = delete;\\n\\n\\tmemory(memory<Width> &&) = default;\\n\\tmemory<Width> &operator=(memory<Width> &&other) {\\n\\t\\tassert(depth == other.depth);\\n\\t\\tdata = std::move(other.data);\\n\\t\\twrite_queue = std::move(other.write_queue);\\n\\t\\treturn *this;\\n\\t}\\n\\n\\t// An operator for direct memory reads. May be used at any time during the simulation.\\n\\tconst value<Width> &operator [](size_t index) const {\\n\\t\\tassert(index < depth);\\n\\t\\treturn data[index];\\n\\t}\\n\\n\\t// An operator for direct memory writes. May only be used before the simulation is started. If used\\n\\t// after the simulation is started, the design may malfunction.\\n\\tvalue<Width> &operator [](size_t index) {\\n\\t\\tassert(index < depth);\\n\\t\\treturn data[index];\\n\\t}\\n\\n\\t// A simple way to make a writable memory would be to use an array of wires instead of an array of values.\\n\\t// However, there are two significant downsides to this approach: first, it has large overhead (2× space\\n\\t// overhead, and O(depth) time overhead during commit); second, it does not simplify handling write port\\n\\t// priorities. Although in principle write ports could be ordered or conditionally enabled in generated\\n\\t// code based on their priorities and selected addresses, the feedback arc set problem is computationally\\n\\t// expensive, and the heuristic based algorithms are not easily modified to guarantee (rather than prefer)\\n\\t// a particular write port evaluation order.\\n\\t//\\n\\t// The approach used here instead is to queue writes into a buffer during the eval phase, then perform\\n\\t// the writes during the commit phase in the priority order. This approach has low overhead, with both space\\n\\t// and time proportional to the amount of write ports. Because virtually every memory in a practical design\\n\\t// has at most two write ports, linear search is used on every write, being the fastest and simplest approach.\\n\\tstruct write {\\n\\t\\tsize_t index;\\n\\t\\tvalue<Width> val;\\n\\t\\tvalue<Width> mask;\\n\\t\\tint priority;\\n\\t};\\n\\tstd::vector<write> write_queue;\\n\\n\\tvoid update(size_t index, const value<Width> &val, const value<Width> &mask, int priority = 0) {\\n\\t\\tassert(index < depth);\\n\\t\\t// Queue up the write while keeping the queue sorted by priority.\\n\\t\\twrite_queue.insert(\\n\\t\\t\\tstd::upper_bound(write_queue.begin(), write_queue.end(), priority,\\n\\t\\t\\t\\t[](const int a, const write& b) { return a < b.priority; }),\\n\\t\\t\\twrite { index, val, mask, priority });\\n\\t}\\n\\n\\t// See the note for `wire::commit()`.\\n\\ttemplate<class ObserverT>\\n\\tbool commit(ObserverT &observer) {\\n\\t\\tbool changed = false;\\n\\t\\tfor (const write &entry : write_queue) {\\n\\t\\t\\tvalue<Width> elem = data[entry.index];\\n\\t\\t\\telem = elem.update(entry.val, entry.mask);\\n\\t\\t\\tif (data[entry.index] != elem) {\\n\\t\\t\\t\\tobserver.on_update(value<Width>::chunks, data[0].data, elem.data, entry.index);\\n\\t\\t\\t\\tchanged |= true;\\n\\t\\t\\t}\\n\\t\\t\\tdata[entry.index] = elem;\\n\\t\\t}\\n\\t\\twrite_queue.clear();\\n\\t\\treturn changed;\\n\\t}\\n};\\n\\nstruct metadata {\\n\\tconst enum {\\n\\t\\tMISSING = 0,\\n\\t\\tUINT   \\t= 1,\\n\\t\\tSINT   \\t= 2,\\n\\t\\tSTRING \\t= 3,\\n\\t\\tDOUBLE \\t= 4,\\n\\t} value_type;\\n\\n\\t// In debug mode, using the wrong .as_*() function will assert.\\n\\t// In release mode, using the wrong .as_*() function will safely return a default value.\\n\\tconst uint64_t    uint_value = 0;\\n\\tconst int64_t     sint_value = 0;\\n\\tconst std::string string_value = \\\"\\\";\\n\\tconst double      double_value = 0.0;\\n\\n\\tmetadata() : value_type(MISSING) {}\\n\\tmetadata(uint64_t value) : value_type(UINT), uint_value(value) {}\\n\\tmetadata(int64_t value) : value_type(SINT), sint_value(value) {}\\n\\tmetadata(const std::string &value) : value_type(STRING), string_value(value) {}\\n\\tmetadata(const char *value) : value_type(STRING), string_value(value) {}\\n\\tmetadata(double value) : value_type(DOUBLE), double_value(value) {}\\n\\n\\tmetadata(const metadata &) = default;\\n\\tmetadata &operator=(const metadata &) = delete;\\n\\n\\tuint64_t as_uint() const {\\n\\t\\tassert(value_type == UINT);\\n\\t\\treturn uint_value;\\n\\t}\\n\\n\\tint64_t as_sint() const {\\n\\t\\tassert(value_type == SINT);\\n\\t\\treturn sint_value;\\n\\t}\\n\\n\\tconst std::string &as_string() const {\\n\\t\\tassert(value_type == STRING);\\n\\t\\treturn string_value;\\n\\t}\\n\\n\\tdouble as_double() const {\\n\\t\\tassert(value_type == DOUBLE);\\n\\t\\treturn double_value;\\n\\t}\\n};\\n\\ntypedef std::map<std::string, metadata> metadata_map;\\n\\nstruct performer;\\n\\n// An object that allows formatting a string lazily.\\nstruct lazy_fmt {\\n\\tvirtual std::string operator() () const = 0;\\n};\\n\\n// Flavor of a `$check` cell.\\nenum class flavor {\\n\\t// Corresponds to a `$assert` cell in other flows, and a Verilog `assert ()` statement.\\n\\tASSERT,\\n\\t// Corresponds to a `$assume` cell in other flows, and a Verilog `assume ()` statement.\\n\\tASSUME,\\n\\t// Corresponds to a `$live` cell in other flows, and a Verilog `assert (eventually)` statement.\\n\\tASSERT_EVENTUALLY,\\n\\t// Corresponds to a `$fair` cell in other flows, and a Verilog `assume (eventually)` statement.\\n\\tASSUME_EVENTUALLY,\\n\\t// Corresponds to a `$cover` cell in other flows, and a Verilog `cover ()` statement.\\n\\tCOVER,\\n};\\n\\n// An object that can be passed to a `eval()` method in order to act on side effects. The default behavior implemented\\n// below is the same as the behavior of `eval(nullptr)`, except that `-print-output` option of `write_cxxrtl` is not\\n// taken into account.\\nstruct performer {\\n\\t// Called by generated formatting code to evaluate a Verilog `$time` expression.\\n\\tvirtual int64_t vlog_time() const { return 0; }\\n\\n\\t// Called by generated formatting code to evaluate a Verilog `$realtime` expression.\\n\\tvirtual double vlog_realtime() const { return vlog_time(); }\\n\\n\\t// Called when a `$print` cell is triggered.\\n\\tvirtual void on_print(const lazy_fmt &formatter, const metadata_map &attributes) {\\n\\t\\tstd::cout << formatter();\\n\\t}\\n\\n\\t// Called when a `$check` cell is triggered.\\n\\tvirtual void on_check(flavor type, bool condition, const lazy_fmt &formatter, const metadata_map &attributes) {\\n\\t\\tif (type == flavor::ASSERT || type == flavor::ASSUME) {\\n\\t\\t\\tif (!condition)\\n\\t\\t\\t\\tstd::cerr << formatter();\\n\\t\\t\\tCXXRTL_ASSERT(condition && \\\"Check failed\\\");\\n\\t\\t}\\n\\t}\\n};\\n\\n// An object that can be passed to a `commit()` method in order to produce a replay log of every state change in\\n// the simulation. Unlike `performer`, `observer` does not use virtual calls as their overhead is unacceptable, and\\n// a comparatively heavyweight template-based solution is justified.\\nstruct observer {\\n\\t// Called when the `commit()` method for a wire is about to update the `chunks` chunks at `base` with `chunks` chunks\\n\\t// at `value` that have a different bit pattern. It is guaranteed that `chunks` is equal to the wire chunk count and\\n\\t// `base` points to the first chunk.\\n\\tvoid on_update(size_t chunks, const chunk_t *base, const chunk_t *value) {}\\n\\n\\t// Called when the `commit()` method for a memory is about to update the `chunks` chunks at `&base[chunks * index]`\\n\\t// with `chunks` chunks at `value` that have a different bit pattern. It is guaranteed that `chunks` is equal to\\n\\t// the memory element chunk count and `base` points to the first chunk of the first element of the memory.\\n\\tvoid on_update(size_t chunks, const chunk_t *base, const chunk_t *value, size_t index) {}\\n};\\n\\n// Must be kept in sync with `struct FmtPart` in kernel/fmt.h!\\n// Default member initializers would make this a non-aggregate-type in C++11, so they are commented out.\\nstruct fmt_part {\\n\\tenum {\\n\\t\\tLITERAL   = 0,\\n\\t\\tINTEGER   = 1,\\n\\t\\tSTRING    = 2,\\n\\t\\tUNICHAR   = 3,\\n\\t\\tVLOG_TIME = 4,\\n\\t} type;\\n\\n\\t// LITERAL type\\n\\tstd::string str;\\n\\n\\t// INTEGER/STRING/UNICHAR types\\n\\t// + value<Bits> val;\\n\\n\\t// INTEGER/STRING/VLOG_TIME types\\n\\tenum {\\n\\t\\tRIGHT\\t= 0,\\n\\t\\tLEFT\\t= 1,\\n\\t\\tNUMERIC\\t= 2,\\n\\t} justify; // = RIGHT;\\n\\tchar padding; // = '\\\\0';\\n\\tsize_t width; // = 0;\\n\\n\\t// INTEGER type\\n\\tunsigned base; // = 10;\\n\\tbool signed_; // = false;\\n\\tenum {\\n\\t\\tMINUS\\t\\t= 0,\\n\\t\\tPLUS_MINUS\\t= 1,\\n\\t\\tSPACE_MINUS\\t= 2,\\n\\t} sign; // = MINUS;\\n\\tbool hex_upper; // = false;\\n\\tbool show_base; // = false;\\n\\tbool group; // = false;\\n\\n\\t// VLOG_TIME type\\n\\tbool realtime; // = false;\\n\\t// + int64_t itime;\\n\\t// + double ftime;\\n\\n\\t// Format the part as a string.\\n\\t//\\n\\t// The values of `vlog_time` and `vlog_realtime` are used for Verilog `$time` and `$realtime`, correspondingly.\\n\\ttemplate<size_t Bits>\\n\\tstd::string render(value<Bits> val, performer *performer = nullptr)\\n\\t{\\n\\t\\t// We might want to replace some of these bit() calls with direct\\n\\t\\t// chunk access if it turns out to be slow enough to matter.\\n\\t\\tstd::string buf;\\n\\t\\tstd::string prefix;\\n\\t\\tswitch (type) {\\n\\t\\t\\tcase LITERAL:\\n\\t\\t\\t\\treturn str;\\n\\n\\t\\t\\tcase STRING: {\\n\\t\\t\\t\\tbuf.reserve(Bits/8);\\n\\t\\t\\t\\tfor (int i = 0; i < Bits; i += 8) {\\n\\t\\t\\t\\t\\tchar ch = 0;\\n\\t\\t\\t\\t\\tfor (int j = 0; j < 8 && i + j < int(Bits); j++)\\n\\t\\t\\t\\t\\t\\tif (val.bit(i + j))\\n\\t\\t\\t\\t\\t\\t\\tch |= 1 << j;\\n\\t\\t\\t\\t\\tif (ch != 0)\\n\\t\\t\\t\\t\\t\\tbuf.append({ch});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstd::reverse(buf.begin(), buf.end());\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcase UNICHAR: {\\n\\t\\t\\t\\tuint32_t codepoint = val.template get<uint32_t>();\\n\\t\\t\\t\\tif (codepoint >= 0x10000)\\n\\t\\t\\t\\t\\tbuf += (char)(0xf0 |  (codepoint >> 18));\\n\\t\\t\\t\\telse if (codepoint >= 0x800)\\n\\t\\t\\t\\t\\tbuf += (char)(0xe0 |  (codepoint >> 12));\\n\\t\\t\\t\\telse if (codepoint >= 0x80)\\n\\t\\t\\t\\t\\tbuf += (char)(0xc0 |  (codepoint >>  6));\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuf += (char)codepoint;\\n\\t\\t\\t\\tif (codepoint >= 0x10000)\\n\\t\\t\\t\\t\\tbuf += (char)(0x80 | ((codepoint >> 12) & 0x3f));\\n\\t\\t\\t\\tif (codepoint >= 0x800)\\n\\t\\t\\t\\t\\tbuf += (char)(0x80 | ((codepoint >>  6) & 0x3f));\\n\\t\\t\\t\\tif (codepoint >= 0x80)\\n\\t\\t\\t\\t\\tbuf += (char)(0x80 | ((codepoint >>  0) & 0x3f));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcase INTEGER: {\\n\\t\\t\\t\\tbool negative = signed_ && val.is_neg();\\n\\t\\t\\t\\tif (negative) {\\n\\t\\t\\t\\t\\tprefix = \\\"-\\\";\\n\\t\\t\\t\\t\\tval = val.neg();\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tswitch (sign) {\\n\\t\\t\\t\\t\\t\\tcase MINUS:       break;\\n\\t\\t\\t\\t\\t\\tcase PLUS_MINUS:  prefix = \\\"+\\\"; break;\\n\\t\\t\\t\\t\\t\\tcase SPACE_MINUS: prefix = \\\" \\\"; break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tsize_t val_width = Bits;\\n\\t\\t\\t\\tif (base != 10) {\\n\\t\\t\\t\\t\\tval_width = 1;\\n\\t\\t\\t\\t\\tfor (size_t index = 0; index < Bits; index++)\\n\\t\\t\\t\\t\\t\\tif (val.bit(index))\\n\\t\\t\\t\\t\\t\\t\\tval_width = index + 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (base == 2) {\\n\\t\\t\\t\\t\\tif (show_base)\\n\\t\\t\\t\\t\\t\\tprefix += \\\"0b\\\";\\n\\t\\t\\t\\t\\tfor (size_t index = 0; index < val_width; index++) {\\n\\t\\t\\t\\t\\t\\tif (group && index > 0 && index % 4 == 0)\\n\\t\\t\\t\\t\\t\\t\\tbuf += '_';\\n\\t\\t\\t\\t\\t\\tbuf += (val.bit(index) ? '1' : '0');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (base == 8 || base == 16) {\\n\\t\\t\\t\\t\\tif (show_base)\\n\\t\\t\\t\\t\\t\\tprefix += (base == 16) ? (hex_upper ? \\\"0X\\\" : \\\"0x\\\") : \\\"0o\\\";\\n\\t\\t\\t\\t\\tsize_t step = (base == 16) ? 4 : 3;\\n\\t\\t\\t\\t\\tfor (size_t index = 0; index < val_width; index += step) {\\n\\t\\t\\t\\t\\t\\tif (group && index > 0 && index % (4 * step) == 0)\\n\\t\\t\\t\\t\\t\\t\\tbuf += '_';\\n\\t\\t\\t\\t\\t\\tuint8_t value = val.bit(index) | (val.bit(index + 1) << 1) | (val.bit(index + 2) << 2);\\n\\t\\t\\t\\t\\t\\tif (step == 4)\\n\\t\\t\\t\\t\\t\\t\\tvalue |= val.bit(index + 3) << 3;\\n\\t\\t\\t\\t\\t\\tbuf += (hex_upper ? \\\"0123456789ABCDEF\\\" : \\\"0123456789abcdef\\\")[value];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (base == 10) {\\n\\t\\t\\t\\t\\tif (show_base)\\n\\t\\t\\t\\t\\t\\tprefix += \\\"0d\\\";\\n\\t\\t\\t\\t\\tif (val.is_zero())\\n\\t\\t\\t\\t\\t\\tbuf += '0';\\n\\t\\t\\t\\t\\tvalue<(Bits > 4 ? Bits : 4)> xval = val.template zext<(Bits > 4 ? Bits : 4)>();\\n\\t\\t\\t\\t\\tsize_t index = 0;\\n\\t\\t\\t\\t\\twhile (!xval.is_zero()) {\\n\\t\\t\\t\\t\\t\\tif (group && index > 0 && index % 3 == 0)\\n\\t\\t\\t\\t\\t\\t\\tbuf += '_';\\n\\t\\t\\t\\t\\t\\tvalue<(Bits > 4 ? Bits : 4)> quotient, remainder;\\n\\t\\t\\t\\t\\t\\tif (Bits >= 4)\\n\\t\\t\\t\\t\\t\\t\\tstd::tie(quotient, remainder) = xval.udivmod(value<(Bits > 4 ? Bits : 4)>{10u});\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tstd::tie(quotient, remainder) = std::make_pair(value<(Bits > 4 ? Bits : 4)>{0u}, xval);\\n\\t\\t\\t\\t\\t\\tbuf += '0' + remainder.template trunc<4>().template get<uint8_t>();\\n\\t\\t\\t\\t\\t\\txval = quotient;\\n\\t\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else assert(false && \\\"Unsupported base for fmt_part\\\");\\n\\t\\t\\t\\tif (justify == NUMERIC && group && padding == '0') {\\n\\t\\t\\t\\t\\tint group_size = base == 10 ? 3 : 4;\\n\\t\\t\\t\\t\\twhile (prefix.size() + buf.size() < width) {\\n\\t\\t\\t\\t\\t\\tif (buf.size() % (group_size + 1) == group_size)\\n\\t\\t\\t\\t\\t\\t\\tbuf += '_';\\n\\t\\t\\t\\t\\t\\tbuf += '0';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstd::reverse(buf.begin(), buf.end());\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcase VLOG_TIME: {\\n\\t\\t\\t\\tif (performer) {\\n\\t\\t\\t\\t\\tbuf = realtime ? std::to_string(performer->vlog_realtime()) : std::to_string(performer->vlog_time());\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbuf = realtime ? std::to_string(0.0) : std::to_string(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstd::string str;\\n\\t\\tassert(width == 0 || padding != '\\\\0');\\n\\t\\tif (prefix.size() + buf.size() < width) {\\n\\t\\t\\tsize_t pad_width = width - prefix.size() - buf.size();\\n\\t\\t\\tswitch (justify) {\\n\\t\\t\\t\\tcase LEFT:\\n\\t\\t\\t\\t\\tstr += prefix;\\n\\t\\t\\t\\t\\tstr += buf;\\n\\t\\t\\t\\t\\tstr += std::string(pad_width, padding);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase RIGHT:\\n\\t\\t\\t\\t\\tstr += std::string(pad_width, padding);\\n\\t\\t\\t\\t\\tstr += prefix;\\n\\t\\t\\t\\t\\tstr += buf;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase NUMERIC:\\n\\t\\t\\t\\t\\tstr += prefix;\\n\\t\\t\\t\\t\\tstr += std::string(pad_width, padding);\\n\\t\\t\\t\\t\\tstr += buf;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tstr += prefix;\\n\\t\\t\\tstr += buf;\\n\\t\\t}\\n\\t\\treturn str;\\n\\t}\\n};\\n\\n// Tag class to disambiguate values/wires and their aliases.\\nstruct debug_alias {};\\n\\n// Tag declaration to disambiguate values and debug outlines.\\nusing debug_outline = ::_cxxrtl_outline;\\n\\n// This structure is intended for consumption via foreign function interfaces, like Python's ctypes.\\n// Because of this it uses a C-style layout that is easy to parse rather than more idiomatic C++.\\n//\\n// To avoid violating strict aliasing rules, this structure has to be a subclass of the one used\\n// in the C API, or it would not be possible to cast between the pointers to these.\\n//\\n// The `attrs` member cannot be owned by this structure because a `cxxrtl_object` can be created\\n// from external C code.\\nstruct debug_item : ::cxxrtl_object {\\n\\t// Object types.\\n\\tenum : uint32_t {\\n\\t\\tVALUE   = CXXRTL_VALUE,\\n\\t\\tWIRE    = CXXRTL_WIRE,\\n\\t\\tMEMORY  = CXXRTL_MEMORY,\\n\\t\\tALIAS   = CXXRTL_ALIAS,\\n\\t\\tOUTLINE = CXXRTL_OUTLINE,\\n\\t};\\n\\n\\t// Object flags.\\n\\tenum : uint32_t {\\n\\t\\tINPUT  = CXXRTL_INPUT,\\n\\t\\tOUTPUT = CXXRTL_OUTPUT,\\n\\t\\tINOUT  = CXXRTL_INOUT,\\n\\t\\tDRIVEN_SYNC = CXXRTL_DRIVEN_SYNC,\\n\\t\\tDRIVEN_COMB = CXXRTL_DRIVEN_COMB,\\n\\t\\tUNDRIVEN    = CXXRTL_UNDRIVEN,\\n\\t};\\n\\n\\tdebug_item(const ::cxxrtl_object &object) : cxxrtl_object(object) {}\\n\\n\\ttemplate<size_t Bits>\\n\\tdebug_item(value<Bits> &item, size_t lsb_offset = 0, uint32_t flags_ = 0) {\\n\\t\\tstatic_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),\\n\\t\\t              \\\"value<Bits> is not compatible with C layout\\\");\\n\\t\\ttype    = VALUE;\\n\\t\\tflags   = flags_;\\n\\t\\twidth   = Bits;\\n\\t\\tlsb_at  = lsb_offset;\\n\\t\\tdepth   = 1;\\n\\t\\tzero_at = 0;\\n\\t\\tcurr    = item.data;\\n\\t\\tnext    = item.data;\\n\\t\\toutline = nullptr;\\n\\t\\tattrs   = nullptr;\\n\\t}\\n\\n\\ttemplate<size_t Bits>\\n\\tdebug_item(const value<Bits> &item, size_t lsb_offset = 0) {\\n\\t\\tstatic_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),\\n\\t\\t              \\\"value<Bits> is not compatible with C layout\\\");\\n\\t\\ttype    = VALUE;\\n\\t\\tflags   = DRIVEN_COMB;\\n\\t\\twidth   = Bits;\\n\\t\\tlsb_at  = lsb_offset;\\n\\t\\tdepth   = 1;\\n\\t\\tzero_at = 0;\\n\\t\\tcurr    = const_cast<chunk_t*>(item.data);\\n\\t\\tnext    = nullptr;\\n\\t\\toutline = nullptr;\\n\\t\\tattrs   = nullptr;\\n\\t}\\n\\n\\ttemplate<size_t Bits>\\n\\tdebug_item(wire<Bits> &item, size_t lsb_offset = 0, uint32_t flags_ = 0) {\\n\\t\\tstatic_assert(Bits == 0 ||\\n\\t\\t              (sizeof(item.curr) == value<Bits>::chunks * sizeof(chunk_t) &&\\n\\t\\t               sizeof(item.next) == value<Bits>::chunks * sizeof(chunk_t)),\\n\\t\\t              \\\"wire<Bits> is not compatible with C layout\\\");\\n\\t\\ttype    = WIRE;\\n\\t\\tflags   = flags_;\\n\\t\\twidth   = Bits;\\n\\t\\tlsb_at  = lsb_offset;\\n\\t\\tdepth   = 1;\\n\\t\\tzero_at = 0;\\n\\t\\tcurr    = item.curr.data;\\n\\t\\tnext    = item.next.data;\\n\\t\\toutline = nullptr;\\n\\t\\tattrs   = nullptr;\\n\\t}\\n\\n\\ttemplate<size_t Width>\\n\\tdebug_item(memory<Width> &item, size_t zero_offset = 0) {\\n\\t\\tstatic_assert(Width == 0 || sizeof(item.data[0]) == value<Width>::chunks * sizeof(chunk_t),\\n\\t\\t              \\\"memory<Width> is not compatible with C layout\\\");\\n\\t\\ttype    = MEMORY;\\n\\t\\tflags   = 0;\\n\\t\\twidth   = Width;\\n\\t\\tlsb_at  = 0;\\n\\t\\tdepth   = item.depth;\\n\\t\\tzero_at = zero_offset;\\n\\t\\tcurr    = item.data ? item.data[0].data : nullptr;\\n\\t\\tnext    = nullptr;\\n\\t\\toutline = nullptr;\\n\\t\\tattrs   = nullptr;\\n\\t}\\n\\n\\ttemplate<size_t Bits>\\n\\tdebug_item(debug_alias, const value<Bits> &item, size_t lsb_offset = 0) {\\n\\t\\tstatic_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),\\n\\t\\t              \\\"value<Bits> is not compatible with C layout\\\");\\n\\t\\ttype    = ALIAS;\\n\\t\\tflags   = DRIVEN_COMB;\\n\\t\\twidth   = Bits;\\n\\t\\tlsb_at  = lsb_offset;\\n\\t\\tdepth   = 1;\\n\\t\\tzero_at = 0;\\n\\t\\tcurr    = const_cast<chunk_t*>(item.data);\\n\\t\\tnext    = nullptr;\\n\\t\\toutline = nullptr;\\n\\t\\tattrs   = nullptr;\\n\\t}\\n\\n\\ttemplate<size_t Bits>\\n\\tdebug_item(debug_alias, const wire<Bits> &item, size_t lsb_offset = 0) {\\n\\t\\tstatic_assert(Bits == 0 ||\\n\\t\\t              (sizeof(item.curr) == value<Bits>::chunks * sizeof(chunk_t) &&\\n\\t\\t               sizeof(item.next) == value<Bits>::chunks * sizeof(chunk_t)),\\n\\t\\t              \\\"wire<Bits> is not compatible with C layout\\\");\\n\\t\\ttype    = ALIAS;\\n\\t\\tflags   = DRIVEN_COMB;\\n\\t\\twidth   = Bits;\\n\\t\\tlsb_at  = lsb_offset;\\n\\t\\tdepth   = 1;\\n\\t\\tzero_at = 0;\\n\\t\\tcurr    = const_cast<chunk_t*>(item.curr.data);\\n\\t\\tnext    = nullptr;\\n\\t\\toutline = nullptr;\\n\\t\\tattrs   = nullptr;\\n\\t}\\n\\n\\ttemplate<size_t Bits>\\n\\tdebug_item(debug_outline &group, const value<Bits> &item, size_t lsb_offset = 0) {\\n\\t\\tstatic_assert(Bits == 0 || sizeof(item) == value<Bits>::chunks * sizeof(chunk_t),\\n\\t\\t              \\\"value<Bits> is not compatible with C layout\\\");\\n\\t\\ttype    = OUTLINE;\\n\\t\\tflags   = DRIVEN_COMB;\\n\\t\\twidth   = Bits;\\n\\t\\tlsb_at  = lsb_offset;\\n\\t\\tdepth   = 1;\\n\\t\\tzero_at = 0;\\n\\t\\tcurr    = const_cast<chunk_t*>(item.data);\\n\\t\\tnext    = nullptr;\\n\\t\\toutline = &group;\\n\\t\\tattrs   = nullptr;\\n\\t}\\n\\n\\ttemplate<size_t Bits, class IntegerT>\\n\\tIntegerT get() const {\\n\\t\\tassert(width == Bits && depth == 1);\\n\\t\\tvalue<Bits> item;\\n\\t\\tstd::copy(curr, curr + value<Bits>::chunks, item.data);\\n\\t\\treturn item.template get<IntegerT>();\\n\\t}\\n\\n\\ttemplate<size_t Bits, class IntegerT>\\n\\tvoid set(IntegerT other) const {\\n\\t\\tassert(width == Bits && depth == 1);\\n\\t\\tvalue<Bits> item;\\n\\t\\titem.template set<IntegerT>(other);\\n\\t\\tstd::copy(item.data, item.data + value<Bits>::chunks, next);\\n\\t}\\n};\\nstatic_assert(std::is_standard_layout<debug_item>::value, \\\"debug_item is not compatible with C layout\\\");\\n\\n} // namespace cxxrtl\\n\\ntypedef struct _cxxrtl_attr_set {\\n\\tcxxrtl::metadata_map map;\\n} *cxxrtl_attr_set;\\n\\nnamespace cxxrtl {\\n\\n// Representation of an attribute set in the C++ interface.\\nusing debug_attrs = ::_cxxrtl_attr_set;\\n\\nstruct debug_items {\\n\\t// Debug items may be composed of multiple parts, but the attributes are shared between all of them.\\n\\t// There are additional invariants, not all of which are not checked by this code:\\n\\t// - Memories and non-memories cannot be mixed together.\\n\\t// - Bit indices (considering `lsb_at` and `width`) must not overlap.\\n\\t// - Row indices (considering `depth` and `zero_at`) must be the same.\\n\\t// - The `INPUT` and `OUTPUT` flags must be the same for all parts.\\n\\t// Other than that, the parts can be quite different, e.g. it is OK to mix a value, a wire, an alias,\\n\\t// and an outline, in the debug information for a single name in four parts.\\n\\tstd::map<std::string, std::vector<debug_item>> table;\\n\\tstd::map<std::string, std::unique_ptr<debug_attrs>> attrs_table;\\n\\n\\tvoid add(const std::string &path, debug_item &&item, metadata_map &&item_attrs = {}) {\\n\\t\\tassert((path.empty() || path[path.size() - 1] != ' ') && path.find(\\\"  \\\") == std::string::npos);\\n\\t\\tstd::unique_ptr<debug_attrs> &attrs = attrs_table[path];\\n\\t\\tif (attrs.get() == nullptr)\\n\\t\\t\\tattrs = std::unique_ptr<debug_attrs>(new debug_attrs);\\n\\t\\tfor (auto attr : item_attrs)\\n\\t\\t\\tattrs->map.insert(attr);\\n\\t\\titem.attrs = attrs.get();\\n\\t\\tstd::vector<debug_item> &parts = table[path];\\n\\t\\tparts.emplace_back(item);\\n\\t\\tstd::sort(parts.begin(), parts.end(),\\n\\t\\t\\t[](const debug_item &a, const debug_item &b) {\\n\\t\\t\\t\\treturn a.lsb_at < b.lsb_at;\\n\\t\\t\\t});\\n\\t}\\n\\n\\tsize_t count(const std::string &path) const {\\n\\t\\tif (table.count(path) == 0)\\n\\t\\t\\treturn 0;\\n\\t\\treturn table.at(path).size();\\n\\t}\\n\\n\\tconst std::vector<debug_item> &at(const std::string &path) const {\\n\\t\\treturn table.at(path);\\n\\t}\\n\\n\\t// Like `at()`, but operates only on single-part debug items.\\n\\tconst debug_item &operator [](const std::string &path) const {\\n\\t\\tconst std::vector<debug_item> &parts = table.at(path);\\n\\t\\tassert(parts.size() == 1);\\n\\t\\treturn parts.at(0);\\n\\t}\\n\\n\\tbool is_memory(const std::string &path) const {\\n\\t\\treturn at(path).at(0).type == debug_item::MEMORY;\\n\\t}\\n\\n\\tconst metadata_map &attrs(const std::string &path) const {\\n\\t\\treturn attrs_table.at(path)->map;\\n\\t}\\n};\\n\\n// Only `module` scopes are defined. The type is implicit, since Yosys does not currently support\\n// any other scope types.\\nstruct debug_scope {\\n\\tstd::string module_name;\\n\\tstd::unique_ptr<debug_attrs> module_attrs;\\n\\tstd::unique_ptr<debug_attrs> cell_attrs;\\n};\\n\\nstruct debug_scopes {\\n\\tstd::map<std::string, debug_scope> table;\\n\\n\\tvoid add(const std::string &path, const std::string &module_name, metadata_map &&module_attrs, metadata_map &&cell_attrs) {\\n\\t\\tassert((path.empty() || path[path.size() - 1] != ' ') && path.find(\\\"  \\\") == std::string::npos);\\n\\t\\tassert(table.count(path) == 0);\\n\\t\\tdebug_scope &scope = table[path];\\n\\t\\tscope.module_name = module_name;\\n\\t\\tscope.module_attrs = std::unique_ptr<debug_attrs>(new debug_attrs { module_attrs });\\n\\t\\tscope.cell_attrs = std::unique_ptr<debug_attrs>(new debug_attrs { cell_attrs });\\n\\t}\\n\\n\\tsize_t contains(const std::string &path) const {\\n\\t\\treturn table.count(path);\\n\\t}\\n\\n\\tconst debug_scope &operator [](const std::string &path) const {\\n\\t\\treturn table.at(path);\\n\\t}\\n};\\n\\n// Tag class to disambiguate the default constructor used by the toplevel module that calls `reset()`,\\n// and the constructor of interior modules that should not call it.\\nstruct interior {};\\n\\n// The core API of the `module` class consists of only four virtual methods: `reset()`, `eval()`,\\n// `commit`, and `debug_info()`. (The virtual destructor is made necessary by C++.) Every other method\\n// is a convenience method, and exists solely to simplify some common pattern for C++ API consumers.\\n// No behavior may be added to such convenience methods that other parts of CXXRTL can rely on, since\\n// there is no guarantee they will be called (and, for example, other CXXRTL libraries will often call\\n// the `eval()` and `commit()` directly instead, as well as being exposed in the C API).\\nstruct module {\\n\\tmodule() {}\\n\\tvirtual ~module() {}\\n\\n\\t// Modules with black boxes cannot be copied. Although not all designs include black boxes,\\n\\t// delete the copy constructor and copy assignment operator to make sure that any downstream\\n\\t// code that manipulates modules doesn't accidentally depend on their availability.\\n\\tmodule(const module &) = delete;\\n\\tmodule &operator=(const module &) = delete;\\n\\n\\tmodule(module &&) = default;\\n\\tmodule &operator=(module &&) = default;\\n\\n\\tvirtual void reset() = 0;\\n\\n\\t// The `eval()` callback object, `performer`, is included in the virtual call signature since\\n\\t// the generated code has broadly identical performance properties.\\n\\tvirtual bool eval(performer *performer = nullptr) = 0;\\n\\n\\t// The `commit()` callback object, `observer`, is not included in the virtual call signature since\\n\\t// the generated code is severely pessimized by it. To observe commit events, the non-virtual\\n\\t// `commit(observer *)` overload must be called directly on a `module` subclass.\\n\\tvirtual bool commit() = 0;\\n\\n\\tsize_t step(performer *performer = nullptr) {\\n\\t\\tsize_t deltas = 0;\\n\\t\\tbool converged = false;\\n\\t\\tdo {\\n\\t\\t\\tconverged = eval(performer);\\n\\t\\t\\tdeltas++;\\n\\t\\t} while (commit() && !converged);\\n\\t\\treturn deltas;\\n\\t}\\n\\n\\tvirtual void debug_info(debug_items *items, debug_scopes *scopes, std::string path, metadata_map &&cell_attrs = {}) {\\n\\t\\t(void)items, (void)scopes, (void)path, (void)cell_attrs;\\n\\t}\\n\\n\\t// Compatibility method.\\n#if __has_attribute(deprecated)\\n\\t__attribute__((deprecated(\\\"Use `debug_info(path, &items, /*scopes=*/nullptr);` instead. (`path` could be \\\\\\\"top \\\\\\\".)\\\")))\\n#endif\\n\\tvoid debug_info(debug_items &items, std::string path) {\\n\\t\\tdebug_info(&items, /*scopes=*/nullptr, path);\\n\\t}\\n};\\n\\n} // namespace cxxrtl\\n\\n// Internal structures used to communicate with the implementation of the C interface.\\n\\ntypedef struct _cxxrtl_toplevel {\\n\\tstd::unique_ptr<cxxrtl::module> module;\\n} *cxxrtl_toplevel;\\n\\ntypedef struct _cxxrtl_outline {\\n\\tstd::function<void()> eval;\\n} *cxxrtl_outline;\\n\\n// Definitions of internal Yosys cells. Other than the functions in this namespace, CXXRTL is fully generic\\n// and indepenent of Yosys implementation details.\\n//\\n// The `write_cxxrtl` pass translates internal cells (cells with names that start with `$`) to calls of these\\n// functions. All of Yosys arithmetic and logical cells perform sign or zero extension on their operands,\\n// whereas basic operations on arbitrary width values require operands to be of the same width. These functions\\n// bridge the gap by performing the necessary casts. They are named similar to `cell_A[B]`, where A and B are `u`\\n// if the corresponding operand is unsigned, and `s` if it is signed.\\nnamespace cxxrtl_yosys {\\n\\nusing namespace cxxrtl;\\n\\n// std::max isn't constexpr until C++14 for no particular reason (it's an oversight), so we define our own.\\ntemplate<class T>\\nCXXRTL_ALWAYS_INLINE\\nconstexpr T max(const T &a, const T &b) {\\n\\treturn a > b ? a : b;\\n}\\n\\n// Logic operations\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> logic_not(const value<BitsA> &a) {\\n\\treturn value<BitsY> { a ? 0u : 1u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> logic_and(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn value<BitsY> { (bool(a) && bool(b)) ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> logic_or(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn value<BitsY> { (bool(a) || bool(b)) ? 1u : 0u };\\n}\\n\\n// Reduction operations\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> reduce_and(const value<BitsA> &a) {\\n\\treturn value<BitsY> { a.bit_not().is_zero() ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> reduce_or(const value<BitsA> &a) {\\n\\treturn value<BitsY> { a ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> reduce_xor(const value<BitsA> &a) {\\n\\treturn value<BitsY> { (a.ctpop() % 2) ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> reduce_xnor(const value<BitsA> &a) {\\n\\treturn value<BitsY> { (a.ctpop() % 2) ? 0u : 1u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> reduce_bool(const value<BitsA> &a) {\\n\\treturn value<BitsY> { a ? 1u : 0u };\\n}\\n\\n// Bitwise operations\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> not_u(const value<BitsA> &a) {\\n\\treturn a.template zcast<BitsY>().bit_not();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> not_s(const value<BitsA> &a) {\\n\\treturn a.template scast<BitsY>().bit_not();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> and_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template zcast<BitsY>().bit_and(b.template zcast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> and_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template scast<BitsY>().bit_and(b.template scast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> or_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template zcast<BitsY>().bit_or(b.template zcast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> or_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template scast<BitsY>().bit_or(b.template scast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> xor_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template zcast<BitsY>().bit_xor(b.template zcast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> xor_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template scast<BitsY>().bit_xor(b.template scast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> xnor_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template zcast<BitsY>().bit_xor(b.template zcast<BitsY>()).bit_not();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> xnor_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template scast<BitsY>().bit_xor(b.template scast<BitsY>()).bit_not();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shl_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template zcast<BitsY>().shl(b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shl_su(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template scast<BitsY>().shl(b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> sshl_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template zcast<BitsY>().shl(b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> sshl_su(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template scast<BitsY>().shl(b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shr_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.shr(b).template zcast<BitsY>();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shr_su(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.shr(b).template scast<BitsY>();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> sshr_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.shr(b).template zcast<BitsY>();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> sshr_su(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.sshr(b).template scast<BitsY>();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shift_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn shr_uu<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shift_su(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn shr_su<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shift_us(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn b.is_neg() ? shl_uu<BitsY>(a, b.template sext<BitsB + 1>().neg()) : shr_uu<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shift_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn b.is_neg() ? shl_su<BitsY>(a, b.template sext<BitsB + 1>().neg()) : shr_su<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shiftx_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn shift_uu<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shiftx_su(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn shift_su<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shiftx_us(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn shift_us<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> shiftx_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn shift_ss<BitsY>(a, b);\\n}\\n\\n// Comparison operations\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> eq_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY>{ a.template zext<BitsExt>() == b.template zext<BitsExt>() ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> eq_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY>{ a.template sext<BitsExt>() == b.template sext<BitsExt>() ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> ne_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY>{ a.template zext<BitsExt>() != b.template zext<BitsExt>() ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> ne_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY>{ a.template sext<BitsExt>() != b.template sext<BitsExt>() ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> eqx_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn eq_uu<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> eqx_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn eq_ss<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> nex_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn ne_uu<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> nex_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn ne_ss<BitsY>(a, b);\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> gt_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY> { b.template zext<BitsExt>().ucmp(a.template zext<BitsExt>()) ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> gt_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY> { b.template sext<BitsExt>().scmp(a.template sext<BitsExt>()) ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> ge_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY> { !a.template zext<BitsExt>().ucmp(b.template zext<BitsExt>()) ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> ge_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY> { !a.template sext<BitsExt>().scmp(b.template sext<BitsExt>()) ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> lt_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY> { a.template zext<BitsExt>().ucmp(b.template zext<BitsExt>()) ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> lt_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY> { a.template sext<BitsExt>().scmp(b.template sext<BitsExt>()) ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> le_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY> { !b.template zext<BitsExt>().ucmp(a.template zext<BitsExt>()) ? 1u : 0u };\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> le_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsExt = max(BitsA, BitsB);\\n\\treturn value<BitsY> { !b.template sext<BitsExt>().scmp(a.template sext<BitsExt>()) ? 1u : 0u };\\n}\\n\\n// Arithmetic operations\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> pos_u(const value<BitsA> &a) {\\n\\treturn a.template zcast<BitsY>();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> pos_s(const value<BitsA> &a) {\\n\\treturn a.template scast<BitsY>();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> neg_u(const value<BitsA> &a) {\\n\\treturn a.template zcast<BitsY>().neg();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> neg_s(const value<BitsA> &a) {\\n\\treturn a.template scast<BitsY>().neg();\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> add_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template zcast<BitsY>().add(b.template zcast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> add_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template scast<BitsY>().add(b.template scast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> sub_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template zcast<BitsY>().sub(b.template zcast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> sub_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template scast<BitsY>().sub(b.template scast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> mul_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t BitsM = BitsA >= BitsB ? BitsA : BitsB;\\n\\treturn a.template zcast<BitsM>().template mul<BitsY>(b.template zcast<BitsM>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> mul_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn a.template scast<BitsY>().template mul<BitsY>(b.template scast<BitsY>());\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nstd::pair<value<BitsY>, value<BitsY>> divmod_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t Bits = max(BitsY, max(BitsA, BitsB));\\n\\tvalue<Bits> quotient;\\n\\tvalue<Bits> remainder;\\n\\tvalue<Bits> dividend = a.template zext<Bits>();\\n\\tvalue<Bits> divisor = b.template zext<Bits>();\\n\\tstd::tie(quotient, remainder) = dividend.udivmod(divisor);\\n\\treturn {quotient.template trunc<BitsY>(), remainder.template trunc<BitsY>()};\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nstd::pair<value<BitsY>, value<BitsY>> divmod_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tconstexpr size_t Bits = max(BitsY, max(BitsA, BitsB));\\n\\tvalue<Bits> quotient;\\n\\tvalue<Bits> remainder;\\n\\tvalue<Bits> dividend = a.template sext<Bits>();\\n\\tvalue<Bits> divisor = b.template sext<Bits>();\\n\\tstd::tie(quotient, remainder) = dividend.sdivmod(divisor);\\n\\treturn {quotient.template trunc<BitsY>(), remainder.template trunc<BitsY>()};\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> div_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn divmod_uu<BitsY>(a, b).first;\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> div_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn divmod_ss<BitsY>(a, b).first;\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> mod_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn divmod_uu<BitsY>(a, b).second;\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> mod_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn divmod_ss<BitsY>(a, b).second;\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> modfloor_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn divmod_uu<BitsY>(a, b).second;\\n}\\n\\n// GHDL Modfloor operator. Returns r=a mod b, such that r has the same sign as b and\\n// a=b*N+r where N is some integer\\n// In practical terms, when a and b have different signs and the remainder returned by divmod_ss is not 0\\n// then return the remainder + b\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> modfloor_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tvalue<BitsY> r;\\n\\tr = divmod_ss<BitsY>(a, b).second;\\n\\tif((b.is_neg() != a.is_neg()) && !r.is_zero())\\n\\t\\treturn add_ss<BitsY>(b, r);\\n\\treturn r;\\n}\\n\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> divfloor_uu(const value<BitsA> &a, const value<BitsB> &b) {\\n\\treturn divmod_uu<BitsY>(a, b).first;\\n}\\n\\n// Divfloor. Similar to above: returns q=a//b, where q has the sign of a*b and a=b*q+N.\\n// In other words, returns (truncating) a/b, except if a and b have different signs\\n// and there's non-zero remainder, subtract one more towards floor.\\ntemplate<size_t BitsY, size_t BitsA, size_t BitsB>\\nCXXRTL_ALWAYS_INLINE\\nvalue<BitsY> divfloor_ss(const value<BitsA> &a, const value<BitsB> &b) {\\n\\tvalue<BitsY> q, r;\\n\\tstd::tie(q, r) = divmod_ss<BitsY>(a, b);\\n\\tif ((b.is_neg() != a.is_neg()) && !r.is_zero())\\n\\t\\treturn sub_uu<BitsY>(q, value<1> { 1u });\\n\\treturn q;\\n\\n}\\n\\n// Memory helper\\nstruct memory_index {\\n\\tbool valid;\\n\\tsize_t index;\\n\\n\\ttemplate<size_t BitsAddr>\\n\\tmemory_index(const value<BitsAddr> &addr, size_t offset, size_t depth) {\\n\\t\\tstatic_assert(value<BitsAddr>::chunks <= 1, \\\"memory address is too wide\\\");\\n\\t\\tsize_t offset_index = addr.data[0];\\n\\n\\t\\tvalid = (offset_index >= offset && offset_index < offset + depth);\\n\\t\\tindex = offset_index - offset;\\n\\t}\\n};\\n\\n} // namespace cxxrtl_yosys\\n\\n#endif\\n\",\n                            \"cxxrtl_replay.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2023  Catherine <whitequark@whitequark.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef CXXRTL_REPLAY_H\\n#define CXXRTL_REPLAY_H\\n\\n#if !defined(WIN32)\\n#include <unistd.h>\\n#define O_BINARY 0\\n#else\\n#include <io.h>\\n#endif\\n\\n#include <fcntl.h>\\n#include <cstring>\\n#include <cstdio>\\n#include <atomic>\\n#include <unordered_map>\\n\\n#include <cxxrtl/cxxrtl.h>\\n#include <cxxrtl/cxxrtl_time.h>\\n\\n// Theory of operation\\n// ===================\\n//\\n// Log format\\n// ----------\\n//\\n// The replay log is a simple data format based on a sequence of 32-bit words. The following BNF-like grammar describes\\n// enough detail to understand the overall structure of the log data and be able to read hex dumps. For a greater\\n// degree of detail see the source code. The format is considered fully internal to CXXRTL and is subject to change\\n// without notice.\\n//\\n// <file>           ::= <file-header> <definitions> <sample>+\\n// <file-header>    ::= 0x52585843 0x00004c54\\n// <definitions>    ::= <packet-define>* <packet-end>\\n// <sample>         ::= <packet-sample> (<packet-change> | <packet-diag>)* <packet-end>\\n// <packet-define>  ::= 0xc0000000 ...\\n// <packet-sample>  ::= 0xc0000001 ...\\n// <packet-change>  ::= 0x0??????? <chunk>+ | 0x1??????? <index> <chunk>+ | 0x2??????? | 0x3???????\\n// <chunk>, <index> ::= 0x????????\\n// <packet-diag>    ::= <packet-break> | <packet-print> | <packet-assert> | <packet-assume>\\n// <packet-break>   ::= 0xc0000010 <message> <source-location>\\n// <packet-print>   ::= 0xc0000011 <message> <source-location>\\n// <packet-assert>  ::= 0xc0000012 <message> <source-location>\\n// <packet-assume>  ::= 0xc0000013 <message> <source-location>\\n// <packet-end>     ::= 0xFFFFFFFF\\n//\\n// The replay log contains sample data, however, it does not cover the entire design. Rather, it only contains sample\\n// data for the subset of debug items containing _design state_: inputs and registers/latches. This keeps its size to\\n// a minimum, and recording speed to a maximum. The player samples any missing data by setting the design state items\\n// to the same values they had during recording, and re-evaluating the design.\\n//\\n// Packets for diagnostics (prints, breakpoints, assertions, and assumptions) are used solely for diagnostics emitted\\n// by the C++ testbench driving the simulation, and are not recorded while evaluating the design. (Diagnostics emitted\\n// by the RTL can be reconstructed at replay time, so recording them would be a waste of space.)\\n//\\n// Limits\\n// ------\\n//\\n// The log may contain:\\n//\\n// * Up to 2**28-1 debug items containing design state.\\n// * Up to 2**32 chunks per debug item.\\n// * Up to 2**32 rows per memory.\\n// * Up to 2**32 samples.\\n//\\n// Of these limits, the last two are most likely to be eventually exceeded by practical recordings. However, other\\n// performance considerations will likely limit the size of such practical recordings first, so the log data format\\n// will undergo a breaking change at that point.\\n//\\n// Operations\\n// ----------\\n//\\n// As suggested by the name \\\"replay log\\\", this format is designed for recording (writing) once and playing (reading)\\n// many times afterwards, such that reading the format can be done linearly and quickly. The log format is designed to\\n// support three primary read operations:\\n//\\n// 1. Initialization\\n// 2. Rewinding (to time T)\\n// 3. Replaying (for N samples)\\n//\\n// During initialization, the player establishes the mapping between debug item names and their 28-bit identifiers in\\n// the log. It is done once.\\n//\\n// During rewinding, the player begins reading at the latest non-incremental sample that still lies before the requested\\n// sample time. It continues reading incremental samples after that point until it reaches the requested sample time.\\n// This process is very cheap as the design is not evaluated; it is essentially a (convoluted) memory copy operation.\\n//\\n// During replaying, the player evaluates the design at the current time, which causes all debug items to assume\\n// the values they had before recording. This process is expensive. Once done, the player advances to the next state\\n// by reading the next (complete or incremental) sample, as above. Since a range of samples is replayed, this process\\n// is repeated several times in a row.\\n//\\n// In principle, when replaying, the player could only read the state of the inputs and the time delta and use a normal\\n// eval/commit loop to progress the simulation, which is fully deterministic so its calculated design state should be\\n// exactly the same as the recorded design state. In practice, it is both faster and more reliable (in presence of e.g.\\n// user-defined black boxes) to read the recorded values instead of calculating them.\\n//\\n// Note: The operations described above are conceptual and do not correspond exactly to methods on `cxxrtl::player`.\\n// The `cxxrtl::player::replay()` method does not evaluate the design. This is so that delta cycles could be ignored\\n// if they are not of interest while replaying.\\n\\nnamespace cxxrtl {\\n\\n// A single diagnostic that can be manipulated as an object (including being written to and read from a file).\\n// This differs from the base CXXRTL interface, where diagnostics can only be emitted via a procedure call, and are\\n// not materialized as objects.\\nstruct diagnostic {\\n\\t// The `BREAK` flavor corresponds to a breakpoint, which is a diagnostic type that can currently only be emitted\\n\\t// by the C++ testbench code.\\n\\tenum flavor {\\n\\t\\tBREAK  = 0,\\n\\t\\tPRINT  = 1,\\n\\t\\tASSERT = 2,\\n\\t\\tASSUME = 3,\\n\\t};\\n\\n\\tflavor type;\\n\\tstd::string message;\\n\\tstd::string location; // same format as the `src` attribute of `$print` or `$check` cell\\n\\n\\tdiagnostic()\\n\\t: type(BREAK) {}\\n\\n\\tdiagnostic(flavor type, const std::string &message, const std::string &location)\\n\\t: type(type), message(message), location(location) {}\\n\\n\\tdiagnostic(flavor type, const std::string &message, const char *file, unsigned line)\\n\\t: type(type), message(message), location(std::string(file) + ':' + std::to_string(line)) {}\\n};\\n\\n// A spool stores CXXRTL design state changes in a file.\\nclass spool {\\npublic:\\n\\t// Unique pointer to a specific sample within a replay log. (Timestamps are not unique.)\\n\\ttypedef uint32_t pointer_t;\\n\\n\\t// Numeric identifier assigned to a debug item within a replay log. Range limited to [1, MAXIMUM_IDENT].\\n\\ttypedef uint32_t ident_t;\\n\\n\\tstatic constexpr uint16_t VERSION = 0x0400;\\n\\n\\tstatic constexpr uint64_t HEADER_MAGIC = 0x00004c5452585843;\\n\\tstatic constexpr uint64_t VERSION_MASK = 0xffff000000000000;\\n\\n\\tstatic constexpr uint32_t PACKET_DEFINE  = 0xc0000000;\\n\\n\\tstatic constexpr uint32_t PACKET_SAMPLE  = 0xc0000001;\\n\\tenum sample_flag : uint32_t {\\n\\t\\tEMPTY       = 0,\\n\\t\\tINCREMENTAL = 1,\\n\\t};\\n\\n\\tstatic constexpr uint32_t MAXIMUM_IDENT  = 0x0fffffff;\\n\\tstatic constexpr uint32_t CHANGE_MASK    = 0x30000000;\\n\\n\\tstatic constexpr uint32_t PACKET_CHANGE  = 0x00000000/* | ident */;\\n\\tstatic constexpr uint32_t PACKET_CHANGEI = 0x10000000/* | ident */;\\n\\tstatic constexpr uint32_t PACKET_CHANGEL = 0x20000000/* | ident */;\\n\\tstatic constexpr uint32_t PACKET_CHANGEH = 0x30000000/* | ident */;\\n\\n\\tstatic constexpr uint32_t PACKET_DIAGNOSTIC = 0xc0000010/* | diagnostic::flavor */;\\n\\tstatic constexpr uint32_t DIAGNOSTIC_MASK   = 0x0000000f;\\n\\n\\tstatic constexpr uint32_t PACKET_END     = 0xffffffff;\\n\\n\\t// Writing spools.\\n\\n\\tclass writer {\\n\\t\\tint fd;\\n\\t\\tsize_t position;\\n\\t\\tstd::vector<uint32_t> buffer;\\n\\n\\t\\t// These functions aren't overloaded because of implicit numeric conversions.\\n\\n\\t\\tvoid emit_word(uint32_t word) {\\n\\t\\t\\tif (position + 1 == buffer.size())\\n\\t\\t\\t\\tflush();\\n\\t\\t\\tbuffer[position++] = word;\\n\\t\\t}\\n\\n\\t\\tvoid emit_dword(uint64_t dword) {\\n\\t\\t\\temit_word(dword >>  0);\\n\\t\\t\\temit_word(dword >> 32);\\n\\t\\t}\\n\\n\\t\\tvoid emit_ident(ident_t ident) {\\n\\t\\t\\tassert(ident <= MAXIMUM_IDENT);\\n\\t\\t\\temit_word(ident);\\n\\t\\t}\\n\\n\\t\\tvoid emit_size(size_t size) {\\n\\t\\t\\tassert(size <= std::numeric_limits<uint32_t>::max());\\n\\t\\t\\temit_word(size);\\n\\t\\t}\\n\\n\\t\\t// Same implementation as `emit_size()`, different declared intent.\\n\\t\\tvoid emit_index(size_t index) {\\n\\t\\t\\tassert(index <= std::numeric_limits<uint32_t>::max());\\n\\t\\t\\temit_word(index);\\n\\t\\t}\\n\\n\\t\\tvoid emit_string(std::string str) {\\n\\t\\t\\t// Align to a word boundary, and add at least one terminating \\\\0.\\n\\t\\t\\tstr.resize(str.size() + (sizeof(uint32_t) - (str.size() + sizeof(uint32_t)) % sizeof(uint32_t)));\\n\\t\\t\\tfor (size_t index = 0; index < str.size(); index += sizeof(uint32_t)) {\\n\\t\\t\\t\\tuint32_t word;\\n\\t\\t\\t\\tmemcpy(&word, &str[index], sizeof(uint32_t));\\n\\t\\t\\t\\temit_word(word);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid emit_time(const time &timestamp) {\\n\\t\\t\\tconst value<time::bits> &raw_timestamp(timestamp);\\n\\t\\t\\temit_word(raw_timestamp.data[0]);\\n\\t\\t\\temit_word(raw_timestamp.data[1]);\\n\\t\\t\\temit_word(raw_timestamp.data[2]);\\n\\t\\t}\\n\\n\\tpublic:\\n\\t\\t// Creates a writer, and transfers ownership of `fd`, which must be open for appending.\\n\\t\\t//\\n\\t\\t// The buffer size is currently fixed to a \\\"reasonably large\\\" size, determined empirically by measuring writer\\n\\t\\t// performance on a representative design; large but not so large it would e.g. cause address space exhaustion\\n\\t\\t// on 32-bit platforms.\\n\\t\\twriter(spool &spool) : fd(spool.take_write()), position(0), buffer(32 * 1024 * 1024) {\\n\\t\\t\\tassert(fd != -1);\\n#if !defined(WIN32)\\n\\t\\t\\tint result = ftruncate(fd, 0);\\n#else\\n\\t\\t\\tint result = _chsize_s(fd, 0);\\n#endif\\n\\t\\t\\tassert(result == 0);\\n\\t\\t}\\n\\n\\t\\twriter(writer &&moved) : fd(moved.fd), position(moved.position), buffer(moved.buffer) {\\n\\t\\t\\tmoved.fd = -1;\\n\\t\\t\\tmoved.position = 0;\\n\\t\\t}\\n\\n\\t\\twriter(const writer &) = delete;\\n\\t\\twriter &operator=(const writer &) = delete;\\n\\n\\t\\t// Both write() calls and fwrite() calls are too expensive to perform implicitly. The API consumer must determine\\n\\t\\t// the optimal time to flush the writer and do that explicitly for best performance.\\n\\t\\tvoid flush() {\\n\\t\\t\\tassert(fd != -1);\\n\\t\\t\\tsize_t data_size = position * sizeof(uint32_t);\\n\\t\\t\\tsize_t data_written = write(fd, buffer.data(), data_size);\\n\\t\\t\\tassert(data_size == data_written);\\n\\t\\t\\tposition = 0;\\n\\t\\t}\\n\\n\\t\\t~writer() {\\n\\t\\t\\tif (fd != -1) {\\n\\t\\t\\t\\tflush();\\n\\t\\t\\t\\tclose(fd);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid write_magic() {\\n\\t\\t\\t// `CXXRTL` followed by version in binary. This header will read backwards on big-endian machines, which allows\\n\\t\\t\\t// detection of this case, both visually and programmatically.\\n\\t\\t\\temit_dword(((uint64_t)VERSION << 48) | HEADER_MAGIC);\\n\\t\\t}\\n\\n\\t\\tvoid write_define(ident_t ident, const std::string &name, size_t part_index, size_t chunks, size_t depth) {\\n\\t\\t\\temit_word(PACKET_DEFINE);\\n\\t\\t\\temit_ident(ident);\\n\\t\\t\\temit_string(name);\\n\\t\\t\\temit_index(part_index);\\n\\t\\t\\temit_size(chunks);\\n\\t\\t\\temit_size(depth);\\n\\t\\t}\\n\\n\\t\\tvoid write_sample(bool incremental, pointer_t pointer, const time &timestamp) {\\n\\t\\t\\tuint32_t flags = (incremental ? sample_flag::INCREMENTAL : 0);\\n\\t\\t\\temit_word(PACKET_SAMPLE);\\n\\t\\t\\temit_word(flags);\\n\\t\\t\\temit_word(pointer);\\n\\t\\t\\temit_time(timestamp);\\n\\t\\t}\\n\\n\\t\\tvoid write_change(ident_t ident, size_t chunks, const chunk_t *data) {\\n\\t\\t\\tassert(ident <= MAXIMUM_IDENT);\\n\\n\\t\\t\\tif (chunks == 1 && *data == 0) {\\n\\t\\t\\t\\temit_word(PACKET_CHANGEL | ident);\\n\\t\\t\\t} else if (chunks == 1 && *data == 1) {\\n\\t\\t\\t\\temit_word(PACKET_CHANGEH | ident);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\temit_word(PACKET_CHANGE | ident);\\n\\t\\t\\t\\tfor (size_t offset = 0; offset < chunks; offset++)\\n\\t\\t\\t\\t\\temit_word(data[offset]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid write_change(ident_t ident, size_t chunks, const chunk_t *data, size_t index) {\\n\\t\\t\\tassert(ident <= MAXIMUM_IDENT);\\n\\n\\t\\t\\temit_word(PACKET_CHANGEI | ident);\\n\\t\\t\\temit_index(index);\\n\\t\\t\\tfor (size_t offset = 0; offset < chunks; offset++)\\n\\t\\t\\t\\temit_word(data[offset]);\\n\\t\\t}\\n\\n\\t\\tvoid write_diagnostic(const diagnostic &diagnostic) {\\n\\t\\t\\temit_word(PACKET_DIAGNOSTIC | diagnostic.type);\\n\\t\\t\\temit_string(diagnostic.message);\\n\\t\\t\\temit_string(diagnostic.location);\\n\\t\\t}\\n\\n\\t\\tvoid write_end() {\\n\\t\\t\\temit_word(PACKET_END);\\n\\t\\t}\\n\\t};\\n\\n\\t// Reading spools.\\n\\n\\tclass reader {\\n\\t\\tFILE *f;\\n\\n\\t\\tuint32_t absorb_word() {\\n\\t\\t\\t// If we're at end of file, `fread` will not write to `word`, and `PACKET_END` will be returned.\\n\\t\\t\\tuint32_t word = PACKET_END;\\n\\t\\t\\tfread(&word, sizeof(word), 1, f);\\n\\t\\t\\treturn word;\\n\\t\\t}\\n\\n\\t\\tuint64_t absorb_dword() {\\n\\t\\t\\tuint32_t lo = absorb_word();\\n\\t\\t\\tuint32_t hi = absorb_word();\\n\\t\\t\\treturn ((uint64_t)hi << 32) | lo;\\n\\t\\t}\\n\\n\\t\\tident_t absorb_ident() {\\n\\t\\t\\tident_t ident = absorb_word();\\n\\t\\t\\tassert(ident <= MAXIMUM_IDENT);\\n\\t\\t\\treturn ident;\\n\\t\\t}\\n\\n\\t\\tsize_t absorb_size() {\\n\\t\\t\\treturn absorb_word();\\n\\t\\t}\\n\\n\\t\\tsize_t absorb_index() {\\n\\t\\t\\treturn absorb_word();\\n\\t\\t}\\n\\n\\t\\tstd::string absorb_string() {\\n\\t\\t\\tstd::string str;\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tsize_t end = str.size();\\n\\t\\t\\t\\tstr.resize(end + 4);\\n\\t\\t\\t\\tuint32_t word = absorb_word();\\n\\t\\t\\t\\tmemcpy(&str[end], &word, sizeof(uint32_t));\\n\\t\\t\\t} while (str.back() != '\\\\0');\\n\\t\\t\\t// Strings have no embedded zeroes besides the terminating one(s).\\n\\t\\t\\treturn str.substr(0, str.find('\\\\0'));\\n\\t\\t}\\n\\n\\t\\ttime absorb_time() {\\n\\t\\t\\tvalue<time::bits> raw_timestamp;\\n\\t\\t\\traw_timestamp.data[0] = absorb_word();\\n\\t\\t\\traw_timestamp.data[1] = absorb_word();\\n\\t\\t\\traw_timestamp.data[2] = absorb_word();\\n\\t\\t\\treturn time(raw_timestamp);\\n\\t\\t}\\n\\n\\tpublic:\\n\\t\\ttypedef uint64_t pos_t;\\n\\n\\t\\t// Creates a reader, and transfers ownership of `fd`, which must be open for reading.\\n\\t\\treader(spool &spool) : f(fdopen(spool.take_read(), \\\"r\\\")) {\\n\\t\\t\\tassert(f != nullptr);\\n\\t\\t}\\n\\n\\t\\treader(reader &&moved) : f(moved.f) {\\n\\t\\t\\tmoved.f = nullptr;\\n\\t\\t}\\n\\n\\t\\treader(const reader &) = delete;\\n\\t\\treader &operator=(const reader &) = delete;\\n\\n\\t\\t~reader() {\\n\\t\\t\\tif (f != nullptr)\\n\\t\\t\\t\\tfclose(f);\\n\\t\\t}\\n\\n\\t\\tpos_t position() {\\n\\t\\t\\treturn ftell(f);\\n\\t\\t}\\n\\n\\t\\tvoid rewind(pos_t position) {\\n\\t\\t\\tfseek(f, position, SEEK_SET);\\n\\t\\t}\\n\\n\\t\\tvoid read_magic() {\\n\\t\\t\\tuint64_t magic = absorb_dword();\\n\\t\\t\\tassert((magic & ~VERSION_MASK) == HEADER_MAGIC);\\n\\t\\t\\tassert((magic >> 48) == VERSION);\\n\\t\\t}\\n\\n\\t\\tbool read_define(ident_t &ident, std::string &name, size_t &part_index, size_t &chunks, size_t &depth) {\\n\\t\\t\\tuint32_t header = absorb_word();\\n\\t\\t\\tif (header == PACKET_END)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tassert(header == PACKET_DEFINE);\\n\\t\\t\\tident = absorb_ident();\\n\\t\\t\\tname = absorb_string();\\n\\t\\t\\tpart_index = absorb_index();\\n\\t\\t\\tchunks = absorb_size();\\n\\t\\t\\tdepth = absorb_size();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tbool read_sample(bool &incremental, pointer_t &pointer, time &timestamp) {\\n\\t\\t\\tuint32_t header = absorb_word();\\n\\t\\t\\tif (header == PACKET_END)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tassert(header == PACKET_SAMPLE);\\n\\t\\t\\tuint32_t flags = absorb_word();\\n\\t\\t\\tincremental = (flags & sample_flag::INCREMENTAL);\\n\\t\\t\\tpointer = absorb_word();\\n\\t\\t\\ttimestamp = absorb_time();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tbool read_header(uint32_t &header) {\\n\\t\\t\\theader = absorb_word();\\n\\t\\t\\treturn header != PACKET_END;\\n\\t\\t}\\n\\n\\t\\t// This method must be separate from `read_change_data` because `chunks` and `depth` can only be looked up\\n\\t\\t// if `ident` is known.\\n\\t\\tbool read_change_ident(uint32_t header, ident_t &ident) {\\n\\t\\t\\tif ((header & ~(CHANGE_MASK | MAXIMUM_IDENT)) != 0)\\n\\t\\t\\t\\treturn false; // some other packet\\n\\t\\t\\tident = header & MAXIMUM_IDENT;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tvoid read_change_data(uint32_t header, size_t chunks, size_t depth, chunk_t *data) {\\n\\t\\t\\tuint32_t index = 0;\\n\\t\\t\\tswitch (header & CHANGE_MASK) {\\n\\t\\t\\t\\tcase PACKET_CHANGEL:\\n\\t\\t\\t\\t\\t*data = 0;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tcase PACKET_CHANGEH:\\n\\t\\t\\t\\t\\t*data = 1;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tcase PACKET_CHANGE:\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase PACKET_CHANGEI:\\n\\t\\t\\t\\t\\tindex = absorb_word();\\n\\t\\t\\t\\t\\tassert(index < depth);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tassert(false && \\\"Unrecognized change packet\\\");\\n\\t\\t\\t}\\n\\t\\t\\tfor (size_t offset = 0; offset < chunks; offset++)\\n\\t\\t\\t\\tdata[chunks * index + offset] = absorb_word();\\n\\t\\t}\\n\\n\\t\\tbool read_diagnostic(uint32_t header, diagnostic &diagnostic) {\\n\\t\\t\\tif ((header & ~DIAGNOSTIC_MASK) != PACKET_DIAGNOSTIC)\\n\\t\\t\\t\\treturn false; // some other packet\\n\\t\\t\\tuint32_t type = header & DIAGNOSTIC_MASK;\\n\\t\\t\\tassert(type == diagnostic::BREAK  || type == diagnostic::PRINT ||\\n\\t\\t\\t       type == diagnostic::ASSERT || type == diagnostic::ASSUME);\\n\\t\\t\\tdiagnostic.type = (diagnostic::flavor)type;\\n\\t\\t\\tdiagnostic.message = absorb_string();\\n\\t\\t\\tdiagnostic.location = absorb_string();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n\\n\\t// Opening spools. For certain uses of the record/replay mechanism, two distinct open files (two open files, i.e.\\n\\t// two distinct file pointers, and not just file descriptors, which share the file pointer if duplicated) are used,\\n\\t// for a reader and writer thread. This class manages the lifetime of the descriptors for these files. When only\\n\\t// one of them is used, the other is closed harmlessly when the spool is destroyed.\\nprivate:\\n\\tstd::atomic<int> writefd;\\n\\tstd::atomic<int> readfd;\\n\\npublic:\\n\\tspool(const std::string &filename)\\n\\t\\t: writefd(open(filename.c_str(), O_CREAT|O_BINARY|O_WRONLY|O_APPEND, 0644)),\\n\\t\\t  readfd(open(filename.c_str(), O_BINARY|O_RDONLY)) {\\n\\t\\tassert(writefd.load() != -1 && readfd.load() != -1);\\n\\t}\\n\\n\\tspool(spool &&moved) : writefd(moved.writefd.exchange(-1)), readfd(moved.readfd.exchange(-1)) {}\\n\\n\\tspool(const spool &) = delete;\\n\\tspool &operator=(const spool &) = delete;\\n\\n\\t~spool() {\\n\\t\\tif (int fd = writefd.exchange(-1))\\n\\t\\t\\tclose(fd);\\n\\t\\tif (int fd = readfd.exchange(-1))\\n\\t\\t\\tclose(fd);\\n\\t}\\n\\n\\t// Atomically acquire a write file descriptor for the spool. Can be called once, and will return -1 the next time\\n\\t// it is called. Thread-safe.\\n\\tint take_write() {\\n\\t\\treturn writefd.exchange(-1);\\n\\t}\\n\\n\\t// Atomically acquire a read file descriptor for the spool. Can be called once, and will return -1 the next time\\n\\t// it is called. Thread-safe.\\n\\tint take_read() {\\n\\t\\treturn readfd.exchange(-1);\\n\\t}\\n};\\n\\n// A CXXRTL recorder samples design state, producing complete or incremental updates, and writes them to a spool.\\nclass recorder {\\n\\tstruct variable {\\n\\t\\tspool::ident_t ident; /* <= spool::MAXIMUM_IDENT */\\n\\t\\tsize_t chunks;\\n\\t\\tsize_t depth; /* == 1 for wires */\\n\\t\\tchunk_t *curr;\\n\\t\\tbool memory;\\n\\t};\\n\\n\\tspool::writer writer;\\n\\tstd::vector<variable> variables;\\n\\tstd::vector<size_t> inputs; // values of inputs must be recorded explicitly, as their changes are not observed\\n\\tstd::unordered_map<const chunk_t*, spool::ident_t> ident_lookup;\\n\\tbool streaming = false; // whether variable definitions have been written\\n\\tspool::pointer_t pointer = 0;\\n\\ttime timestamp;\\n\\npublic:\\n\\ttemplate<typename ...Args>\\n\\trecorder(Args &&...args) : writer(std::forward<Args>(args)...) {}\\n\\n\\tvoid start(module &module, std::string top_path = \\\"\\\") {\\n\\t\\tdebug_items items;\\n\\t\\tmodule.debug_info(&items, /*scopes=*/nullptr, top_path);\\n\\t\\tstart(items);\\n\\t}\\n\\n\\tvoid start(const debug_items &items) {\\n\\t\\tassert(!streaming);\\n\\n\\t\\twriter.write_magic();\\n\\t\\tfor (auto item : items.table)\\n\\t\\t\\tfor (size_t part_index = 0; part_index < item.second.size(); part_index++) {\\n\\t\\t\\t\\tauto &part = item.second[part_index];\\n\\t\\t\\t\\tif ((part.flags & debug_item::INPUT) || (part.flags & debug_item::DRIVEN_SYNC) ||\\n\\t\\t\\t\\t\\t\\t(part.type == debug_item::MEMORY)) {\\n\\t\\t\\t\\t\\tvariable var;\\n\\t\\t\\t\\t\\tvar.ident = variables.size() + 1;\\n\\t\\t\\t\\t\\tvar.chunks = (part.width + sizeof(chunk_t) * 8 - 1) / (sizeof(chunk_t) * 8);\\n\\t\\t\\t\\t\\tvar.depth = part.depth;\\n\\t\\t\\t\\t\\tvar.curr = part.curr;\\n\\t\\t\\t\\t\\tvar.memory = (part.type == debug_item::MEMORY);\\n\\t\\t\\t\\t\\tident_lookup[var.curr] = var.ident;\\n\\n\\t\\t\\t\\t\\tassert(variables.size() < spool::MAXIMUM_IDENT);\\n\\t\\t\\t\\t\\tif (part.flags & debug_item::INPUT)\\n\\t\\t\\t\\t\\t\\tinputs.push_back(variables.size());\\n\\t\\t\\t\\t\\tvariables.push_back(var);\\n\\n\\t\\t\\t\\t\\twriter.write_define(var.ident, item.first, part_index, var.chunks, var.depth);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\twriter.write_end();\\n\\t\\tstreaming = true;\\n\\t}\\n\\n\\tconst time &latest_time() {\\n\\t\\treturn timestamp;\\n\\t}\\n\\n\\tconst time &advance_time(const time &delta) {\\n\\t\\tassert(!delta.is_negative());\\n\\t\\ttimestamp += delta;\\n\\t\\treturn timestamp;\\n\\t}\\n\\n\\tvoid record_complete() {\\n\\t\\tassert(streaming);\\n\\n\\t\\twriter.write_sample(/*incremental=*/false, pointer++, timestamp);\\n\\t\\tfor (auto var : variables) {\\n\\t\\t\\tassert(var.ident != 0);\\n\\t\\t\\tif (!var.memory)\\n\\t\\t\\t\\twriter.write_change(var.ident, var.chunks, var.curr);\\n\\t\\t\\telse\\n\\t\\t\\t\\tfor (size_t index = 0; index < var.depth; index++)\\n\\t\\t\\t\\t\\twriter.write_change(var.ident, var.chunks, &var.curr[var.chunks * index], index);\\n\\t\\t}\\n\\t\\twriter.write_end();\\n\\t}\\n\\n\\t// This function is generic over ModuleT to encourage observer callbacks to be inlined into the commit function.\\n\\ttemplate<class ModuleT>\\n\\tbool record_incremental(ModuleT &module) {\\n\\t\\tassert(streaming);\\n\\n\\t\\tstruct : observer {\\n\\t\\t\\tstd::unordered_map<const chunk_t*, spool::ident_t> *ident_lookup;\\n\\t\\t\\tspool::writer *writer;\\n\\n\\t\\t\\tCXXRTL_ALWAYS_INLINE\\n\\t\\t\\tvoid on_update(size_t chunks, const chunk_t *base, const chunk_t *value) {\\n\\t\\t\\t\\twriter->write_change(ident_lookup->at(base), chunks, value);\\n\\t\\t\\t}\\n\\n\\t\\t\\tCXXRTL_ALWAYS_INLINE\\n\\t\\t\\tvoid on_update(size_t chunks, const chunk_t *base, const chunk_t *value, size_t index) {\\n\\t\\t\\t\\twriter->write_change(ident_lookup->at(base), chunks, value, index);\\n\\t\\t\\t}\\n\\t\\t} record_observer;\\n\\t\\trecord_observer.ident_lookup = &ident_lookup;\\n\\t\\trecord_observer.writer = &writer;\\n\\n\\t\\twriter.write_sample(/*incremental=*/true, pointer++, timestamp);\\n\\t\\tfor (auto input_index : inputs) {\\n\\t\\t\\tvariable &var = variables.at(input_index);\\n\\t\\t\\tassert(!var.memory);\\n\\t\\t\\twriter.write_change(var.ident, var.chunks, var.curr);\\n\\t\\t}\\n\\t\\tbool changed = module.commit(record_observer);\\n\\t\\twriter.write_end();\\n\\t\\treturn changed;\\n\\t}\\n\\n\\tvoid record_diagnostic(const diagnostic &diagnostic) {\\n\\t\\tassert(streaming);\\n\\n\\t\\t// Emit an incremental delta cycle per diagnostic to simplify the logic of the recorder. This is inefficient, but\\n\\t\\t// diagnostics should be rare enough that this inefficiency does not matter. If it turns out to be an issue, this\\n\\t\\t// code should be changed to accumulate diagnostics to a buffer that is flushed in `record_{complete,incremental}`\\n\\t\\t// and also in `advance_time` before the timestamp is changed. (Right now `advance_time` never writes to the spool.)\\n\\t\\twriter.write_sample(/*incremental=*/true, pointer++, timestamp);\\n\\t\\twriter.write_diagnostic(diagnostic);\\n\\t\\twriter.write_end();\\n\\t}\\n\\n\\tvoid flush() {\\n\\t\\twriter.flush();\\n\\t}\\n};\\n\\n// A CXXRTL player reads samples from a spool, and changes the design state accordingly. To start reading samples,\\n// a spool must have been initialized: the recorder must have been started and an initial complete sample must have\\n// been written.\\nclass player {\\n\\tstruct variable {\\n\\t\\tsize_t chunks;\\n\\t\\tsize_t depth; /* == 1 for wires */\\n\\t\\tchunk_t *curr;\\n\\t};\\n\\n\\tspool::reader reader;\\n\\tstd::unordered_map<spool::ident_t, variable> variables;\\n\\tbool streaming = false; // whether variable definitions have been read\\n\\tbool initialized = false; // whether a sample has ever been read\\n\\tspool::pointer_t pointer = 0;\\n\\ttime timestamp;\\n\\n\\tstd::map<spool::pointer_t, spool::reader::pos_t, std::greater<spool::pointer_t>> index_by_pointer;\\n\\tstd::map<time, spool::reader::pos_t, std::greater<time>> index_by_timestamp;\\n\\n\\tbool peek_sample(spool::pointer_t &pointer, time &timestamp) {\\n\\t\\tbool incremental;\\n\\t\\tauto position = reader.position();\\n\\t\\tbool success = reader.read_sample(incremental, pointer, timestamp);\\n\\t\\treader.rewind(position);\\n\\t\\treturn success;\\n\\t}\\n\\npublic:\\n\\ttemplate<typename ...Args>\\n\\tplayer(Args &&...args) : reader(std::forward<Args>(args)...) {}\\n\\n\\t// The `top_path` must match the one given to the recorder.\\n\\tvoid start(module &module, std::string top_path = \\\"\\\") {\\n\\t\\tdebug_items items;\\n\\t\\tmodule.debug_info(&items, /*scopes=*/nullptr, top_path);\\n\\t\\tstart(items);\\n\\t}\\n\\n\\tvoid start(const debug_items &items) {\\n\\t\\tassert(!streaming);\\n\\n\\t\\treader.read_magic();\\n\\t\\twhile (true) {\\n\\t\\t\\tspool::ident_t ident;\\n\\t\\t\\tstd::string name;\\n\\t\\t\\tsize_t part_index;\\n\\t\\t\\tsize_t chunks;\\n\\t\\t\\tsize_t depth;\\n\\t\\t\\tif (!reader.read_define(ident, name, part_index, chunks, depth))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tassert(variables.count(ident) == 0);\\n\\t\\t\\tassert(items.count(name) != 0);\\n\\t\\t\\tassert(part_index < items.count(name));\\n\\n\\t\\t\\tconst debug_item &part = items.at(name).at(part_index);\\n\\t\\t\\tassert(chunks == (part.width + sizeof(chunk_t) * 8 - 1) / (sizeof(chunk_t) * 8));\\n\\t\\t\\tassert(depth == part.depth);\\n\\n\\t\\t\\tvariable &var = variables[ident];\\n\\t\\t\\tvar.chunks = chunks;\\n\\t\\t\\tvar.depth = depth;\\n\\t\\t\\tvar.curr = part.curr;\\n\\t\\t}\\n\\t\\tassert(variables.size() > 0);\\n\\t\\tstreaming = true;\\n\\n\\t\\t// Establish the initial state of the design.\\n\\t\\tstd::vector<diagnostic> diagnostics;\\n\\t\\tinitialized = replay(&diagnostics);\\n\\t\\tassert(initialized && diagnostics.empty());\\n\\t}\\n\\n\\t// Returns the pointer of the current sample.\\n\\tspool::pointer_t current_pointer() {\\n\\t\\tassert(initialized);\\n\\t\\treturn pointer;\\n\\t}\\n\\n\\t// Returns the time of the current sample.\\n\\tconst time &current_time() {\\n\\t\\tassert(initialized);\\n\\t\\treturn timestamp;\\n\\t}\\n\\n\\t// Returns `true` if there is a next sample to read, and sets `pointer` to its pointer if there is.\\n\\tbool get_next_pointer(spool::pointer_t &pointer) {\\n\\t\\tassert(streaming);\\n\\t\\ttime timestamp;\\n\\t\\treturn peek_sample(pointer, timestamp);\\n\\t}\\n\\n\\t// Returns `true` if there is a next sample to read, and sets `timestamp` to its time if there is.\\n\\tbool get_next_time(time &timestamp) {\\n\\t\\tassert(streaming);\\n\\t\\tuint32_t pointer;\\n\\t\\treturn peek_sample(pointer, timestamp);\\n\\t}\\n\\n\\t// If this function returns `true`, then `current_pointer() == at_pointer`, and the module contains values that\\n\\t// correspond to this pointer in the replay log. To obtain a valid pointer, call `current_pointer()`; while pointers\\n\\t// are monotonically increasing for each consecutive sample, using arithmetic operations to create a new pointer is\\n\\t// not allowed. The `diagnostics` argument, if not `nullptr`, receives the diagnostics recorded in this sample.\\n\\tbool rewind_to(spool::pointer_t at_pointer, std::vector<diagnostic> *diagnostics) {\\n\\t\\tassert(initialized);\\n\\n\\t\\t// The pointers in the replay log start from one that is greater than `at_pointer`. In this case the pointer will\\n\\t\\t// never be reached.\\n\\t\\tassert(index_by_pointer.size() > 0);\\n\\t\\tif (at_pointer < index_by_pointer.rbegin()->first)\\n\\t\\t\\treturn false;\\n\\n\\t\\t// Find the last complete sample whose pointer is less than or equal to `at_pointer`. Note that the comparison\\n\\t\\t// function used here is `std::greater`, inverting the direction of `lower_bound`.\\n\\t\\tauto position_it = index_by_pointer.lower_bound(at_pointer);\\n\\t\\tassert(position_it != index_by_pointer.end());\\n\\t\\treader.rewind(position_it->second);\\n\\n\\t\\t// Replay samples until eventually arriving to `at_pointer` or encountering end of file.\\n\\t\\twhile(replay(diagnostics)) {\\n\\t\\t\\tif (pointer == at_pointer)\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tif (diagnostics)\\n\\t\\t\\t\\tdiagnostics->clear();\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// If this function returns `true`, then `current_time() <= at_or_before_timestamp`, and the module contains values\\n\\t// that correspond to `current_time()` in the replay log. If `current_time() == at_or_before_timestamp` and there\\n\\t// are several consecutive samples with the same time, the module contains values that correspond to the first of\\n\\t// these samples. The `diagnostics` argument, if not `nullptr`, receives the diagnostics recorded in this sample.\\n\\tbool rewind_to_or_before(const time &at_or_before_timestamp, std::vector<diagnostic> *diagnostics) {\\n\\t\\tassert(initialized);\\n\\n\\t\\t// The timestamps in the replay log start from one that is greater than `at_or_before_timestamp`. In this case\\n\\t\\t// the timestamp will never be reached. Otherwise, this function will always succeed.\\n\\t\\tassert(index_by_timestamp.size() > 0);\\n\\t\\tif (at_or_before_timestamp < index_by_timestamp.rbegin()->first)\\n\\t\\t\\treturn false;\\n\\n\\t\\t// Find the last complete sample whose timestamp is less than or equal to `at_or_before_timestamp`. Note that\\n\\t\\t// the comparison function used here is `std::greater`, inverting the direction of `lower_bound`.\\n\\t\\tauto position_it = index_by_timestamp.lower_bound(at_or_before_timestamp);\\n\\t\\tassert(position_it != index_by_timestamp.end());\\n\\t\\treader.rewind(position_it->second);\\n\\n\\t\\t// Replay samples until eventually arriving to or past `at_or_before_timestamp` or encountering end of file.\\n\\t\\twhile (replay(diagnostics)) {\\n\\t\\t\\tif (timestamp == at_or_before_timestamp)\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\ttime next_timestamp;\\n\\t\\t\\tif (!get_next_time(next_timestamp))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif (next_timestamp > at_or_before_timestamp)\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tif (diagnostics)\\n\\t\\t\\t\\tdiagnostics->clear();\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// If this function returns `true`, then `current_pointer()` and `current_time()` are updated for the next sample\\n\\t// and the module now contains values that correspond to that sample. If it returns `false`, there was no next sample\\n\\t// to read. The `diagnostics` argument, if not `nullptr`, receives the diagnostics recorded in the next sample.\\n\\tbool replay(std::vector<diagnostic> *diagnostics) {\\n\\t\\tassert(streaming);\\n\\n\\t\\tbool incremental;\\n\\t\\tauto position = reader.position();\\n\\t\\tif (!reader.read_sample(incremental, pointer, timestamp))\\n\\t\\t\\treturn false;\\n\\n\\t\\t// The very first sample that is read must be a complete sample. This is required for the rewind functions to work.\\n\\t\\tassert(initialized || !incremental);\\n\\n\\t\\t// It is possible (though not very useful) to have several complete samples with the same timestamp in a row.\\n\\t\\t// Ensure that we associate the timestamp with the position of the first such complete sample. (This condition\\n\\t\\t// works because the player never jumps over a sample.)\\n\\t\\tif (!incremental && !index_by_pointer.count(pointer)) {\\n\\t\\t\\tassert(!index_by_timestamp.count(timestamp));\\n\\t\\t\\tindex_by_pointer[pointer] = position;\\n\\t\\t\\tindex_by_timestamp[timestamp] = position;\\n\\t\\t}\\n\\n\\t\\tuint32_t header;\\n\\t\\twhile (reader.read_header(header)) {\\n\\t\\t\\tspool::ident_t ident;\\n\\t\\t\\tdiagnostic diag;\\n\\t\\t\\tif (reader.read_change_ident(header, ident)) {\\n\\t\\t\\t\\tvariable &var = variables.at(ident);\\n\\t\\t\\t\\treader.read_change_data(header, var.chunks, var.depth, var.curr);\\n\\t\\t\\t} else if (reader.read_diagnostic(header, diag)) {\\n\\t\\t\\t\\tif (diagnostics)\\n\\t\\t\\t\\t\\tdiagnostics->push_back(diag);\\n\\t\\t\\t} else assert(false && \\\"Unrecognized packet header\\\");\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n}\\n\\n#endif\\n\",\n                            \"cxxrtl_time.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2023  Catherine <whitequark@whitequark.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef CXXRTL_TIME_H\\n#define CXXRTL_TIME_H\\n\\n#include <cinttypes>\\n#include <string>\\n\\n#include <cxxrtl/cxxrtl.h>\\n\\nnamespace cxxrtl {\\n\\n// A timestamp or a difference in time, stored as a 96-bit number of femtoseconds (10e-15 s). The range and resolution\\n// of this format can represent any VCD timestamp within approx. ±1255321.2 years, without the need for a timescale.\\nclass time {\\npublic:\\n\\tstatic constexpr size_t bits = 96; // 3 chunks\\n\\nprivate:\\n\\tstatic constexpr size_t resolution_digits = 15;\\n\\n\\tstatic_assert(sizeof(chunk_t) == 4, \\\"a chunk is expected to be 32-bit\\\");\\n\\tstatic constexpr value<bits> resolution = value<bits> {\\n\\t\\tchunk_t(1000000000000000ull & 0xffffffffull), chunk_t(1000000000000000ull >> 32), 0u\\n\\t};\\n\\n\\t// Signed number of femtoseconds from the beginning of time.\\n\\tvalue<bits> raw;\\n\\npublic:\\n\\tconstexpr time() {}\\n\\n\\texplicit constexpr time(const value<bits> &raw) : raw(raw) {}\\n\\texplicit operator const value<bits> &() const { return raw; }\\n\\n\\tstatic constexpr time maximum() {\\n\\t\\treturn time(value<bits> { 0xffffffffu, 0xffffffffu, 0x7fffffffu });\\n\\t}\\n\\n\\ttime(int64_t secs, int64_t femtos) {\\n\\t\\tvalue<64> secs_val;\\n\\t\\tsecs_val.set(secs);\\n\\t\\tvalue<64> femtos_val;\\n\\t\\tfemtos_val.set(femtos);\\n\\t\\traw = secs_val.sext<bits>().mul<bits>(resolution).add(femtos_val.sext<bits>());\\n\\t}\\n\\n\\tbool is_zero() const {\\n\\t\\treturn raw.is_zero();\\n\\t}\\n\\n\\t// Extracts the sign of the value.\\n\\tbool is_negative() const {\\n\\t\\treturn raw.is_neg();\\n\\t}\\n\\n\\t// Extracts the number of whole seconds. Negative if the value is negative.\\n\\tint64_t secs() const {\\n\\t\\treturn raw.sdivmod(resolution).first.trunc<64>().get<int64_t>();\\n\\t}\\n\\n\\t// Extracts the number of femtoseconds in the fractional second. Negative if the value is negative.\\n\\tint64_t femtos() const {\\n\\t\\treturn raw.sdivmod(resolution).second.trunc<64>().get<int64_t>();\\n\\t}\\n\\n\\tbool operator==(const time &other) const {\\n\\t\\treturn raw == other.raw;\\n\\t}\\n\\n\\tbool operator!=(const time &other) const {\\n\\t\\treturn raw != other.raw;\\n\\t}\\n\\n\\tbool operator>(const time &other) const {\\n\\t\\treturn other.raw.scmp(raw);\\n\\t}\\n\\n\\tbool operator>=(const time &other) const {\\n\\t\\treturn !raw.scmp(other.raw);\\n\\t}\\n\\n\\tbool operator<(const time &other) const {\\n\\t\\treturn raw.scmp(other.raw);\\n\\t}\\n\\n\\tbool operator<=(const time &other) const {\\n\\t\\treturn !other.raw.scmp(raw);\\n\\t}\\n\\n\\ttime operator+(const time &other) const {\\n\\t\\treturn time(raw.add(other.raw));\\n\\t}\\n\\n\\ttime &operator+=(const time &other) {\\n\\t\\t*this = *this + other;\\n\\t\\treturn *this;\\n\\t}\\n\\n\\ttime operator-() const {\\n\\t\\treturn time(raw.neg());\\n\\t}\\n\\n\\ttime operator-(const time &other) const {\\n\\t\\treturn *this + (-other);\\n\\t}\\n\\n\\ttime &operator-=(const time &other) {\\n\\t\\t*this = *this - other;\\n\\t\\treturn *this;\\n\\t}\\n\\n\\toperator std::string() const {\\n\\t\\tchar buf[48]; // x=2**95; len(f\\\"-{x/1_000_000_000_000_000}.{x^1_000_000_000_000_000}\\\") == 48\\n\\t\\tint64_t secs = this->secs();\\n\\t\\tint64_t femtos = this->femtos();\\n\\t\\tsnprintf(buf, sizeof(buf), \\\"%s%\\\" PRIi64 \\\".%015\\\" PRIi64,\\n\\t\\t\\tis_negative() ? \\\"-\\\" : \\\"\\\", secs >= 0 ? secs : -secs, femtos >= 0 ? femtos : -femtos);\\n\\t\\treturn buf;\\n\\t}\\n\\n#if __cplusplus >= 201603L\\n\\t[[nodiscard(\\\"ignoring parse errors\\\")]]\\n#endif\\n\\tbool parse(const std::string &str) {\\n\\t\\tenum {\\n\\t\\t\\tparse_sign_opt,\\n\\t\\t\\tparse_integral,\\n\\t\\t\\tparse_fractional,\\n\\t\\t} state = parse_sign_opt;\\n\\t\\tbool negative = false;\\n\\t\\tint64_t integral = 0;\\n\\t\\tint64_t fractional = 0;\\n\\t\\tsize_t frac_digits = 0;\\n\\t\\tfor (auto chr : str) {\\n\\t\\t\\tswitch (state) {\\n\\t\\t\\t\\tcase parse_sign_opt:\\n\\t\\t\\t\\t\\tstate = parse_integral;\\n\\t\\t\\t\\t\\tif (chr == '+' || chr == '-') {\\n\\t\\t\\t\\t\\t\\tnegative = (chr == '-');\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t/* fallthrough */\\n\\t\\t\\t\\tcase parse_integral:\\n\\t\\t\\t\\t\\tif (chr >= '0' && chr <= '9') {\\n\\t\\t\\t\\t\\t\\tintegral *= 10;\\n\\t\\t\\t\\t\\t\\tintegral += chr - '0';\\n\\t\\t\\t\\t\\t} else if (chr == '.') {\\n\\t\\t\\t\\t\\t\\tstate = parse_fractional;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase parse_fractional:\\n\\t\\t\\t\\t\\tif (chr >= '0' && chr <= '9' && frac_digits < resolution_digits) {\\n\\t\\t\\t\\t\\t\\tfractional *= 10;\\n\\t\\t\\t\\t\\t\\tfractional += chr - '0';\\n\\t\\t\\t\\t\\t\\tfrac_digits++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (frac_digits == 0)\\n\\t\\t\\treturn false;\\n\\t\\twhile (frac_digits++ < resolution_digits)\\n\\t\\t\\tfractional *= 10;\\n\\t\\t*this = negative ? -time { integral, fractional} : time { integral, fractional };\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n// Out-of-line definition required until C++17.\\nconstexpr value<time::bits> time::resolution;\\n\\nstd::ostream &operator<<(std::ostream &os, const time &val) {\\n\\tos << (std::string)val;\\n\\treturn os;\\n}\\n\\n// These literals are (confusingly) compatible with the ones from `std::chrono`: the `std::chrono` literals do not\\n// have an underscore (e.g. 1ms) and the `cxxrtl::time` literals do (e.g. 1_ms). This syntactic difference is\\n// a requirement of the C++ standard. Despite being compatible the literals should not be mixed in the same namespace.\\nnamespace time_literals {\\n\\ntime operator\\\"\\\"_s(unsigned long long seconds) {\\n\\treturn time { (int64_t)seconds, 0 };\\n}\\n\\ntime operator\\\"\\\"_ms(unsigned long long milliseconds) {\\n\\treturn time { 0, (int64_t)milliseconds * 1000000000000 };\\n}\\n\\ntime operator\\\"\\\"_us(unsigned long long microseconds) {\\n\\treturn time { 0, (int64_t)microseconds * 1000000000 };\\n}\\n\\ntime operator\\\"\\\"_ns(unsigned long long nanoseconds) {\\n\\treturn time { 0, (int64_t)nanoseconds * 1000000 };\\n}\\n\\ntime operator\\\"\\\"_ps(unsigned long long picoseconds) {\\n\\treturn time { 0, (int64_t)picoseconds * 1000 };\\n}\\n\\ntime operator\\\"\\\"_fs(unsigned long long femtoseconds) {\\n\\treturn time { 0, (int64_t)femtoseconds };\\n}\\n\\n};\\n\\n};\\n\\n#endif\\n\",\n                            \"cxxrtl_vcd.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef CXXRTL_VCD_H\\n#define CXXRTL_VCD_H\\n\\n#include <cxxrtl/cxxrtl.h>\\n\\nnamespace cxxrtl {\\n\\nclass vcd_writer {\\n\\tstruct variable {\\n\\t\\tsize_t ident;\\n\\t\\tsize_t width;\\n\\t\\tchunk_t *curr;\\n\\t\\tsize_t cache_offset;\\n\\t\\tdebug_outline *outline;\\n\\t\\tbool *outline_warm;\\n\\t};\\n\\n\\tstd::vector<std::string> current_scope;\\n\\tstd::map<debug_outline*, bool> outlines;\\n\\tstd::vector<variable> variables;\\n\\tstd::vector<chunk_t> cache;\\n\\tstd::map<chunk_t*, size_t> aliases;\\n\\tbool streaming = false;\\n\\n\\tvoid emit_timescale(unsigned number, const std::string &unit) {\\n\\t\\tassert(!streaming);\\n\\t\\tassert(number == 1 || number == 10 || number == 100);\\n\\t\\tassert(unit == \\\"s\\\" || unit == \\\"ms\\\" || unit == \\\"us\\\" ||\\n\\t\\t       unit == \\\"ns\\\" || unit == \\\"ps\\\" || unit == \\\"fs\\\");\\n\\t\\tbuffer += \\\"$timescale \\\" + std::to_string(number) + \\\" \\\" + unit + \\\" $end\\\\n\\\";\\n\\t}\\n\\n\\tvoid emit_scope(const std::vector<std::string> &scope) {\\n\\t\\tassert(!streaming);\\n\\t\\twhile (current_scope.size() > scope.size() ||\\n\\t\\t       (current_scope.size() > 0 &&\\n\\t\\t\\tcurrent_scope[current_scope.size() - 1] != scope[current_scope.size() - 1])) {\\n\\t\\t\\tbuffer += \\\"$upscope $end\\\\n\\\";\\n\\t\\t\\tcurrent_scope.pop_back();\\n\\t\\t}\\n\\t\\twhile (current_scope.size() < scope.size()) {\\n\\t\\t\\tbuffer += \\\"$scope module \\\" + scope[current_scope.size()] + \\\" $end\\\\n\\\";\\n\\t\\t\\tcurrent_scope.push_back(scope[current_scope.size()]);\\n\\t\\t}\\n\\t}\\n\\n\\tvoid emit_ident(size_t ident) {\\n\\t\\tdo {\\n\\t\\t\\tbuffer += '!' + ident % 94; // \\\"base94\\\"\\n\\t\\t\\tident /= 94;\\n\\t\\t} while (ident != 0);\\n\\t}\\n\\n\\tvoid emit_name(const std::string &name) {\\n\\t\\tfor (char c : name) {\\n\\t\\t\\tif (c == ':') {\\n\\t\\t\\t\\t// Due to a bug, GTKWave cannot parse a colon in the variable name, causing the VCD file\\n\\t\\t\\t\\t// to be unreadable. It cannot be escaped either, so replace it with the sideways colon.\\n\\t\\t\\t\\tbuffer += \\\"..\\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbuffer += c;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvoid emit_var(const variable &var, const std::string &type, const std::string &name,\\n\\t              size_t lsb_at, bool multipart) {\\n\\t\\tassert(!streaming);\\n\\t\\tbuffer += \\\"$var \\\" + type + \\\" \\\" + std::to_string(var.width) + \\\" \\\";\\n\\t\\temit_ident(var.ident);\\n\\t\\tbuffer += \\\" \\\";\\n\\t\\temit_name(name);\\n\\t\\tif (multipart || name.back() == ']' || lsb_at != 0) {\\n\\t\\t\\tif (var.width == 1)\\n\\t\\t\\t\\tbuffer += \\\" [\\\" + std::to_string(lsb_at) + \\\"]\\\";\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuffer += \\\" [\\\" + std::to_string(lsb_at + var.width - 1) + \\\":\\\" + std::to_string(lsb_at) + \\\"]\\\";\\n\\t\\t}\\n\\t\\tbuffer += \\\" $end\\\\n\\\";\\n\\t}\\n\\n\\tvoid emit_enddefinitions() {\\n\\t\\tassert(!streaming);\\n\\t\\tbuffer += \\\"$enddefinitions $end\\\\n\\\";\\n\\t\\tstreaming = true;\\n\\t}\\n\\n\\tvoid emit_time(uint64_t timestamp) {\\n\\t\\tassert(streaming);\\n\\t\\tbuffer += \\\"#\\\" + std::to_string(timestamp) + \\\"\\\\n\\\";\\n\\t}\\n\\n\\tvoid emit_scalar(const variable &var) {\\n\\t\\tassert(streaming);\\n\\t\\tassert(var.width == 1);\\n\\t\\tbuffer += (*var.curr ? '1' : '0');\\n\\t\\temit_ident(var.ident);\\n\\t\\tbuffer += '\\\\n';\\n\\t}\\n\\n\\tvoid emit_vector(const variable &var) {\\n\\t\\tassert(streaming);\\n\\t\\tbuffer += 'b';\\n\\t\\tfor (size_t bit = var.width - 1; bit != (size_t)-1; bit--) {\\n\\t\\t\\tbool bit_curr = var.curr[bit / (8 * sizeof(chunk_t))] & (1 << (bit % (8 * sizeof(chunk_t))));\\n\\t\\t\\tbuffer += (bit_curr ? '1' : '0');\\n\\t\\t}\\n\\t\\tbuffer += ' ';\\n\\t\\temit_ident(var.ident);\\n\\t\\tbuffer += '\\\\n';\\n\\t}\\n\\n\\tvoid reset_outlines() {\\n\\t\\tfor (auto &outline_it : outlines)\\n\\t\\t\\toutline_it.second = /*warm=*/(outline_it.first == nullptr);\\n\\t}\\n\\n\\tvariable &register_variable(size_t width, chunk_t *curr, bool constant = false, debug_outline *outline = nullptr) {\\n\\t\\tif (aliases.count(curr)) {\\n\\t\\t\\treturn variables[aliases[curr]];\\n\\t\\t} else {\\n\\t\\t\\tauto outline_it = outlines.emplace(outline, /*warm=*/(outline == nullptr)).first;\\n\\t\\t\\tconst size_t chunks = (width + (sizeof(chunk_t) * 8 - 1)) / (sizeof(chunk_t) * 8);\\n\\t\\t\\taliases[curr] = variables.size();\\n\\t\\t\\tif (constant) {\\n\\t\\t\\t\\tvariables.emplace_back(variable { variables.size(), width, curr, (size_t)-1, outline_it->first, &outline_it->second });\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvariables.emplace_back(variable { variables.size(), width, curr, cache.size(), outline_it->first, &outline_it->second });\\n\\t\\t\\t\\tcache.insert(cache.end(), &curr[0], &curr[chunks]);\\n\\t\\t\\t}\\n\\t\\t\\treturn variables.back();\\n\\t\\t}\\n\\t}\\n\\n\\tbool test_variable(const variable &var) {\\n\\t\\tif (var.cache_offset == (size_t)-1)\\n\\t\\t\\treturn false; // constant\\n\\t\\tif (!*var.outline_warm) {\\n\\t\\t\\tvar.outline->eval();\\n\\t\\t\\t*var.outline_warm = true;\\n\\t\\t}\\n\\t\\tconst size_t chunks = (var.width + (sizeof(chunk_t) * 8 - 1)) / (sizeof(chunk_t) * 8);\\n\\t\\tif (std::equal(&var.curr[0], &var.curr[chunks], &cache[var.cache_offset])) {\\n\\t\\t\\treturn false;\\n\\t\\t} else {\\n\\t\\t\\tstd::copy(&var.curr[0], &var.curr[chunks], &cache[var.cache_offset]);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\tstatic std::vector<std::string> split_hierarchy(const std::string &hier_name) {\\n\\t\\tstd::vector<std::string> hierarchy;\\n\\t\\tsize_t prev = 0;\\n\\t\\twhile (true) {\\n\\t\\t\\tsize_t curr = hier_name.find_first_of(' ', prev);\\n\\t\\t\\tif (curr == std::string::npos) {\\n\\t\\t\\t\\thierarchy.push_back(hier_name.substr(prev));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thierarchy.push_back(hier_name.substr(prev, curr - prev));\\n\\t\\t\\t\\tprev = curr + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn hierarchy;\\n\\t}\\n\\npublic:\\n\\tstd::string buffer;\\n\\n\\tvoid timescale(unsigned number, const std::string &unit) {\\n\\t\\temit_timescale(number, unit);\\n\\t}\\n\\n\\tvoid add(const std::string &hier_name, const debug_item &item, bool multipart = false) {\\n\\t\\tstd::vector<std::string> scope = split_hierarchy(hier_name);\\n\\t\\tstd::string name = scope.back();\\n\\t\\tscope.pop_back();\\n\\n\\t\\temit_scope(scope);\\n\\t\\tswitch (item.type) {\\n\\t\\t\\t// Not the best naming but oh well...\\n\\t\\t\\tcase debug_item::VALUE:\\n\\t\\t\\t\\temit_var(register_variable(item.width, item.curr, /*constant=*/item.next == nullptr),\\n\\t\\t\\t\\t         \\\"wire\\\", name, item.lsb_at, multipart);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase debug_item::WIRE:\\n\\t\\t\\t\\temit_var(register_variable(item.width, item.curr),\\n\\t\\t\\t\\t         \\\"reg\\\", name, item.lsb_at, multipart);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase debug_item::MEMORY: {\\n\\t\\t\\t\\tconst size_t stride = (item.width + (sizeof(chunk_t) * 8 - 1)) / (sizeof(chunk_t) * 8);\\n\\t\\t\\t\\tfor (size_t index = 0; index < item.depth; index++) {\\n\\t\\t\\t\\t\\tchunk_t *nth_curr = &item.curr[stride * index];\\n\\t\\t\\t\\t\\tstd::string nth_name = name + '[' + std::to_string(index) + ']';\\n\\t\\t\\t\\t\\temit_var(register_variable(item.width, nth_curr),\\n\\t\\t\\t\\t\\t         \\\"reg\\\", nth_name, item.lsb_at, multipart);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcase debug_item::ALIAS:\\n\\t\\t\\t\\t// Like VALUE, but, even though `item.next == nullptr` always holds, the underlying value\\n\\t\\t\\t\\t// can actually change, and must be tracked. In most cases the VCD identifier will be\\n\\t\\t\\t\\t// unified with the aliased reg, but we should handle the case where only the alias is\\n\\t\\t\\t\\t// added to the VCD writer, too.\\n\\t\\t\\t\\temit_var(register_variable(item.width, item.curr),\\n\\t\\t\\t\\t         \\\"wire\\\", name, item.lsb_at, multipart);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase debug_item::OUTLINE:\\n\\t\\t\\t\\temit_var(register_variable(item.width, item.curr, /*constant=*/false, item.outline),\\n\\t\\t\\t\\t         \\\"wire\\\", name, item.lsb_at, multipart);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\ttemplate<class Filter>\\n\\tvoid add(const debug_items &items, const Filter &filter) {\\n\\t\\t// `debug_items` is a map, so the items are already sorted in an order optimal for emitting\\n\\t\\t// VCD scope sections.\\n\\t\\tfor (auto &it : items.table)\\n\\t\\t\\tfor (auto &part : it.second)\\n\\t\\t\\t\\tif (filter(it.first, part))\\n\\t\\t\\t\\t\\tadd(it.first, part, it.second.size() > 1);\\n\\t}\\n\\n\\tvoid add(const debug_items &items) {\\n\\t\\tthis->add(items, [](const std::string &, const debug_item &) {\\n\\t\\t\\treturn true;\\n\\t\\t});\\n\\t}\\n\\n\\tvoid add_without_memories(const debug_items &items) {\\n\\t\\tthis->add(items, [](const std::string &, const debug_item &item) {\\n\\t\\t\\treturn item.type != debug_item::MEMORY;\\n\\t\\t});\\n\\t}\\n\\n\\tvoid sample(uint64_t timestamp) {\\n\\t\\tbool first_sample = !streaming;\\n\\t\\tif (first_sample) {\\n\\t\\t\\temit_scope({});\\n\\t\\t\\temit_enddefinitions();\\n\\t\\t}\\n\\t\\treset_outlines();\\n\\t\\temit_time(timestamp);\\n\\t\\tfor (auto var : variables)\\n\\t\\t\\tif (test_variable(var) || first_sample) {\\n\\t\\t\\t\\tif (var.width == 1)\\n\\t\\t\\t\\t\\temit_scalar(var);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\temit_vector(var);\\n\\t\\t\\t}\\n\\t}\\n};\\n\\n}\\n\\n#endif\\n\",\n                        },\n                    },\n                },\n                \"rtlil\": {\n                    \"rtlil_backend.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n *  ---\\n *\\n *  A very simple and straightforward backend for the RTLIL text\\n *  representation.\\n *\\n */\\n\\n#ifndef RTLIL_BACKEND_H\\n#define RTLIL_BACKEND_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n#include <stdio.h>\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nnamespace RTLIL_BACKEND {\\n\\tvoid dump_const(std::ostream &f, const RTLIL::Const &data, int width = -1, int offset = 0, bool autoint = true);\\n\\tvoid dump_sigchunk(std::ostream &f, const RTLIL::SigChunk &chunk, bool autoint = true);\\n\\tvoid dump_sigspec(std::ostream &f, const RTLIL::SigSpec &sig, bool autoint = true);\\n\\tvoid dump_wire(std::ostream &f, std::string indent, const RTLIL::Wire *wire);\\n\\tvoid dump_memory(std::ostream &f, std::string indent, const RTLIL::Memory *memory);\\n\\tvoid dump_cell(std::ostream &f, std::string indent, const RTLIL::Cell *cell);\\n\\tvoid dump_proc_case_body(std::ostream &f, std::string indent, const RTLIL::CaseRule *cs);\\n\\tvoid dump_proc_switch(std::ostream &f, std::string indent, const RTLIL::SwitchRule *sw);\\n\\tvoid dump_proc_sync(std::ostream &f, std::string indent, const RTLIL::SyncRule *sy);\\n\\tvoid dump_proc(std::ostream &f, std::string indent, const RTLIL::Process *proc);\\n\\tvoid dump_conn(std::ostream &f, std::string indent, const RTLIL::SigSpec &left, const RTLIL::SigSpec &right);\\n\\tvoid dump_module(std::ostream &f, std::string indent, RTLIL::Module *module, RTLIL::Design *design, bool only_selected, bool flag_m = true, bool flag_n = false);\\n\\tvoid dump_design(std::ostream &f, RTLIL::Design *design, bool only_selected, bool flag_m = true, bool flag_n = false);\\n}\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                },\n            },\n            \"frontends\": {\n                \"ast\": {\n                    \"ast.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n *  ---\\n *\\n *  This is the AST frontend library.\\n *\\n *  The AST frontend library is not a frontend on it's own but provides a\\n *  generic abstract syntax tree (AST) abstraction for HDL code and can be\\n *  used by HDL frontends. See \\\"ast.h\\\" for an overview of the API and the\\n *  Verilog frontend for an usage example.\\n *\\n */\\n\\n#ifndef AST_H\\n#define AST_H\\n\\n#include \\\"kernel/rtlil.h\\\"\\n#include \\\"kernel/fmt.h\\\"\\n#include <stdint.h>\\n#include <set>\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nnamespace AST\\n{\\n\\t// all node types, type2str() must be extended\\n\\t// whenever a new node type is added here\\n\\tenum AstNodeType\\n\\t{\\n\\t\\tAST_NONE,\\n\\t\\tAST_DESIGN,\\n\\t\\tAST_MODULE,\\n\\t\\tAST_TASK,\\n\\t\\tAST_FUNCTION,\\n\\t\\tAST_DPI_FUNCTION,\\n\\n\\t\\tAST_WIRE,\\n\\t\\tAST_MEMORY,\\n\\t\\tAST_AUTOWIRE,\\n\\t\\tAST_PARAMETER,\\n\\t\\tAST_LOCALPARAM,\\n\\t\\tAST_DEFPARAM,\\n\\t\\tAST_PARASET,\\n\\t\\tAST_ARGUMENT,\\n\\t\\tAST_RANGE,\\n\\t\\tAST_MULTIRANGE,\\n\\t\\tAST_CONSTANT,\\n\\t\\tAST_REALVALUE,\\n\\t\\tAST_CELLTYPE,\\n\\t\\tAST_IDENTIFIER,\\n\\t\\tAST_PREFIX,\\n\\t\\tAST_ASSERT,\\n\\t\\tAST_ASSUME,\\n\\t\\tAST_LIVE,\\n\\t\\tAST_FAIR,\\n\\t\\tAST_COVER,\\n\\t\\tAST_ENUM,\\n\\t\\tAST_ENUM_ITEM,\\n\\n\\t\\tAST_FCALL,\\n\\t\\tAST_TO_BITS,\\n\\t\\tAST_TO_SIGNED,\\n\\t\\tAST_TO_UNSIGNED,\\n\\t\\tAST_SELFSZ,\\n\\t\\tAST_CAST_SIZE,\\n\\t\\tAST_CONCAT,\\n\\t\\tAST_REPLICATE,\\n\\t\\tAST_BIT_NOT,\\n\\t\\tAST_BIT_AND,\\n\\t\\tAST_BIT_OR,\\n\\t\\tAST_BIT_XOR,\\n\\t\\tAST_BIT_XNOR,\\n\\t\\tAST_REDUCE_AND,\\n\\t\\tAST_REDUCE_OR,\\n\\t\\tAST_REDUCE_XOR,\\n\\t\\tAST_REDUCE_XNOR,\\n\\t\\tAST_REDUCE_BOOL,\\n\\t\\tAST_SHIFT_LEFT,\\n\\t\\tAST_SHIFT_RIGHT,\\n\\t\\tAST_SHIFT_SLEFT,\\n\\t\\tAST_SHIFT_SRIGHT,\\n\\t\\tAST_SHIFTX,\\n\\t\\tAST_SHIFT,\\n\\t\\tAST_LT,\\n\\t\\tAST_LE,\\n\\t\\tAST_EQ,\\n\\t\\tAST_NE,\\n\\t\\tAST_EQX,\\n\\t\\tAST_NEX,\\n\\t\\tAST_GE,\\n\\t\\tAST_GT,\\n\\t\\tAST_ADD,\\n\\t\\tAST_SUB,\\n\\t\\tAST_MUL,\\n\\t\\tAST_DIV,\\n\\t\\tAST_MOD,\\n\\t\\tAST_POW,\\n\\t\\tAST_POS,\\n\\t\\tAST_NEG,\\n\\t\\tAST_LOGIC_AND,\\n\\t\\tAST_LOGIC_OR,\\n\\t\\tAST_LOGIC_NOT,\\n\\t\\tAST_TERNARY,\\n\\t\\tAST_MEMRD,\\n\\t\\tAST_MEMWR,\\n\\t\\tAST_MEMINIT,\\n\\n\\t\\tAST_TCALL,\\n\\t\\tAST_ASSIGN,\\n\\t\\tAST_CELL,\\n\\t\\tAST_PRIMITIVE,\\n\\t\\tAST_CELLARRAY,\\n\\t\\tAST_ALWAYS,\\n\\t\\tAST_INITIAL,\\n\\t\\tAST_BLOCK,\\n\\t\\tAST_ASSIGN_EQ,\\n\\t\\tAST_ASSIGN_LE,\\n\\t\\tAST_CASE,\\n\\t\\tAST_COND,\\n\\t\\tAST_CONDX,\\n\\t\\tAST_CONDZ,\\n\\t\\tAST_DEFAULT,\\n\\t\\tAST_FOR,\\n\\t\\tAST_WHILE,\\n\\t\\tAST_REPEAT,\\n\\n\\t\\tAST_GENVAR,\\n\\t\\tAST_GENFOR,\\n\\t\\tAST_GENIF,\\n\\t\\tAST_GENCASE,\\n\\t\\tAST_GENBLOCK,\\n\\t\\tAST_TECALL,\\n\\n\\t\\tAST_POSEDGE,\\n\\t\\tAST_NEGEDGE,\\n\\t\\tAST_EDGE,\\n\\n\\t\\tAST_INTERFACE,\\n\\t\\tAST_INTERFACEPORT,\\n\\t\\tAST_INTERFACEPORTTYPE,\\n\\t\\tAST_MODPORT,\\n\\t\\tAST_MODPORTMEMBER,\\n\\t\\tAST_PACKAGE,\\n\\n\\t\\tAST_WIRETYPE,\\n\\t\\tAST_TYPEDEF,\\n\\t\\tAST_STRUCT,\\n\\t\\tAST_UNION,\\n\\t\\tAST_STRUCT_ITEM,\\n\\t\\tAST_BIND\\n\\t};\\n\\n\\tstruct AstSrcLocType {\\n\\t\\tunsigned int first_line, last_line;\\n\\t\\tunsigned int first_column, last_column;\\n\\t\\tAstSrcLocType() : first_line(0), last_line(0), first_column(0), last_column(0) {}\\n\\t\\tAstSrcLocType(int _first_line, int _first_column, int _last_line, int _last_column) : first_line(_first_line), last_line(_last_line), first_column(_first_column), last_column(_last_column) {}\\n\\t};\\n\\n\\t// convert an node type to a string (e.g. for debug output)\\n\\tstd::string type2str(AstNodeType type);\\n\\n\\t// The AST is built using instances of this struct\\n\\tstruct AstNode\\n\\t{\\n\\t\\t// for dict<> and pool<>\\n\\t\\tunsigned int hashidx_;\\n\\t\\tunsigned int hash() const { return hashidx_; }\\n\\n\\t\\t// this nodes type\\n\\t\\tAstNodeType type;\\n\\n\\t\\t// the list of child nodes for this node\\n\\t\\tstd::vector<AstNode*> children;\\n\\n\\t\\t// the list of attributes assigned to this node\\n\\t\\tstd::map<RTLIL::IdString, AstNode*> attributes;\\n\\t\\tbool get_bool_attribute(RTLIL::IdString id);\\n\\n\\t\\t// node content - most of it is unused in most node types\\n\\t\\tstd::string str;\\n\\t\\tstd::vector<RTLIL::State> bits;\\n\\t\\tbool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid, range_swapped, was_checked, is_unsized, is_custom_type;\\n\\t\\tint port_id, range_left, range_right;\\n\\t\\tuint32_t integer;\\n\\t\\tdouble realvalue;\\n\\t\\t// set for IDs typed to an enumeration, not used\\n\\t\\tbool is_enum;\\n\\n\\t\\t// Declared range for array dimension.\\n\\t\\tstruct dimension_t {\\n\\t\\t\\tint range_right;     // lsb in [msb:lsb]\\n\\t\\t\\tint range_width;     // msb - lsb + 1\\n\\t\\t\\tbool range_swapped;  // if the declared msb < lsb, msb and lsb above are swapped\\n\\t\\t};\\n\\t\\t// Packed and unpacked dimensions for arrays.\\n\\t\\t// Unpacked dimensions go first, to follow the order of indexing.\\n\\t\\tstd::vector<dimension_t> dimensions;\\n\\t\\t// Number of unpacked dimensions.\\n\\t\\tint unpacked_dimensions;\\n\\n\\t\\t// this is set by simplify and used during RTLIL generation\\n\\t\\tAstNode *id2ast;\\n\\n\\t\\t// this is used by simplify to detect if basic analysis has been performed already on the node\\n\\t\\tbool basic_prep;\\n\\n\\t\\t// this is used for ID references in RHS expressions that should use the \\\"new\\\" value for non-blocking assignments\\n\\t\\tbool lookahead;\\n\\n\\t\\t// this is the original sourcecode location that resulted in this AST node\\n\\t\\t// it is automatically set by the constructor using AST::current_filename and\\n\\t\\t// the AST::get_line_num() callback function.\\n\\t\\tstd::string filename;\\n\\t\\tAstSrcLocType location;\\n\\n\\t\\t// are we embedded in an lvalue, param?\\n\\t\\t// (see fixup_hierarchy_flags)\\n\\t\\tbool in_lvalue;\\n\\t\\tbool in_param;\\n\\t\\tbool in_lvalue_from_above;\\n\\t\\tbool in_param_from_above;\\n\\n\\t\\t// creating and deleting nodes\\n\\t\\tAstNode(AstNodeType type = AST_NONE, AstNode *child1 = nullptr, AstNode *child2 = nullptr, AstNode *child3 = nullptr, AstNode *child4 = nullptr);\\n\\t\\tAstNode *clone() const;\\n\\t\\tvoid cloneInto(AstNode *other) const;\\n\\t\\tvoid delete_children();\\n\\t\\t~AstNode();\\n\\n\\t\\tenum mem2reg_flags\\n\\t\\t{\\n\\t\\t\\t/* status flags */\\n\\t\\t\\tMEM2REG_FL_ALL       = 0x00000001,\\n\\t\\t\\tMEM2REG_FL_ASYNC     = 0x00000002,\\n\\t\\t\\tMEM2REG_FL_INIT      = 0x00000004,\\n\\n\\t\\t\\t/* candidate flags */\\n\\t\\t\\tMEM2REG_FL_FORCED    = 0x00000100,\\n\\t\\t\\tMEM2REG_FL_SET_INIT  = 0x00000200,\\n\\t\\t\\tMEM2REG_FL_SET_ELSE  = 0x00000400,\\n\\t\\t\\tMEM2REG_FL_SET_ASYNC = 0x00000800,\\n\\t\\t\\tMEM2REG_FL_EQ2       = 0x00001000,\\n\\t\\t\\tMEM2REG_FL_CMPLX_LHS = 0x00002000,\\n\\t\\t\\tMEM2REG_FL_CONST_LHS = 0x00004000,\\n\\t\\t\\tMEM2REG_FL_VAR_LHS   = 0x00008000,\\n\\n\\t\\t\\t/* proc flags */\\n\\t\\t\\tMEM2REG_FL_EQ1       = 0x01000000,\\n\\t\\t};\\n\\n\\t\\t// simplify() creates a simpler AST by unrolling for-loops, expanding generate blocks, etc.\\n\\t\\t// it also sets the id2ast pointers so that identifier lookups are fast in genRTLIL()\\n\\t\\tbool simplify(bool const_fold, int stage, int width_hint, bool sign_hint);\\n\\t\\tvoid replace_result_wire_name_in_function(const std::string &from, const std::string &to);\\n\\t\\tAstNode *readmem(bool is_readmemh, std::string mem_filename, AstNode *memory, int start_addr, int finish_addr, bool unconditional_init);\\n\\t\\tvoid expand_genblock(const std::string &prefix);\\n\\t\\tvoid label_genblks(std::set<std::string>& existing, int &counter);\\n\\t\\tvoid mem2reg_as_needed_pass1(dict<AstNode*, pool<std::string>> &mem2reg_places,\\n\\t\\t\\t\\tdict<AstNode*, uint32_t> &mem2reg_flags, dict<AstNode*, uint32_t> &proc_flags, uint32_t &status_flags);\\n\\t\\tbool mem2reg_as_needed_pass2(pool<AstNode*> &mem2reg_set, AstNode *mod, AstNode *block, AstNode *&async_block);\\n\\t\\tbool mem2reg_check(pool<AstNode*> &mem2reg_set);\\n\\t\\tvoid mem2reg_remove(pool<AstNode*> &mem2reg_set, vector<AstNode*> &delnodes);\\n\\t\\tvoid meminfo(int &mem_width, int &mem_size, int &addr_bits);\\n\\t\\tbool detect_latch(const std::string &var);\\n\\t\\tconst RTLIL::Module* lookup_cell_module();\\n\\n\\t\\t// additional functionality for evaluating constant functions\\n\\t\\tstruct varinfo_t {\\n\\t\\t\\tRTLIL::Const val;\\n\\t\\t\\tint offset;\\n\\t\\t\\tbool range_swapped;\\n\\t\\t\\tbool is_signed;\\n\\t\\t\\tAstNode *arg = nullptr;\\n\\t\\t\\tbool explicitly_sized;\\n\\t\\t};\\n\\t\\tbool has_const_only_constructs();\\n\\t\\tbool replace_variables(std::map<std::string, varinfo_t> &variables, AstNode *fcall, bool must_succeed);\\n\\t\\tAstNode *eval_const_function(AstNode *fcall, bool must_succeed);\\n\\t\\tbool is_simple_const_expr();\\n\\n\\t\\t// helper for parsing format strings\\n\\t\\tFmt processFormat(int stage, bool sformat_like, int default_base = 10, size_t first_arg_at = 0, bool may_fail = false);\\n\\n\\t\\tbool is_recursive_function() const;\\n\\t\\tstd::pair<AstNode*, AstNode*> get_tern_choice();\\n\\n\\t\\t// create a human-readable text representation of the AST (for debugging)\\n\\t\\tvoid dumpAst(FILE *f, std::string indent) const;\\n\\t\\tvoid dumpVlog(FILE *f, std::string indent) const;\\n\\n\\t\\t// Generate RTLIL for a bind construct\\n\\t\\tstd::vector<RTLIL::Binding *> genBindings() const;\\n\\n\\t\\t// used by genRTLIL() for detecting expression width and sign\\n\\t\\tvoid detectSignWidthWorker(int &width_hint, bool &sign_hint, bool *found_real = NULL);\\n\\t\\tvoid detectSignWidth(int &width_hint, bool &sign_hint, bool *found_real = NULL);\\n\\n\\t\\t// create RTLIL code for this AST node\\n\\t\\t// for expressions the resulting signal vector is returned\\n\\t\\t// all generated cell instances, etc. are written to the RTLIL::Module pointed to by AST_INTERNAL::current_module\\n\\t\\tRTLIL::SigSpec genRTLIL(int width_hint = -1, bool sign_hint = false);\\n\\t\\tRTLIL::SigSpec genWidthRTLIL(int width, bool sgn, const dict<RTLIL::SigBit, RTLIL::SigBit> *new_subst_ptr = NULL);\\n\\n\\t\\t// compare AST nodes\\n\\t\\tbool operator==(const AstNode &other) const;\\n\\t\\tbool operator!=(const AstNode &other) const;\\n\\t\\tbool contains(const AstNode *other) const;\\n\\n\\t\\t// helper functions for creating AST nodes for constants\\n\\t\\tstatic AstNode *mkconst_int(uint32_t v, bool is_signed, int width = 32);\\n\\t\\tstatic AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed, bool is_unsized);\\n\\t\\tstatic AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed);\\n\\t\\tstatic AstNode *mkconst_str(const std::vector<RTLIL::State> &v);\\n\\t\\tstatic AstNode *mkconst_str(const std::string &str);\\n\\n\\t\\t// helper function to create an AST node for a temporary register\\n\\t\\tAstNode *mktemp_logic(const std::string &name, AstNode *mod, bool nosync, int range_left, int range_right, bool is_signed);\\n\\n\\t\\t// helper function for creating sign-extended const objects\\n\\t\\tRTLIL::Const bitsAsConst(int width, bool is_signed);\\n\\t\\tRTLIL::Const bitsAsConst(int width = -1);\\n\\t\\tRTLIL::Const bitsAsUnsizedConst(int width);\\n\\t\\tRTLIL::Const asAttrConst() const;\\n\\t\\tRTLIL::Const asParaConst() const;\\n\\t\\tuint64_t asInt(bool is_signed);\\n\\t\\tbool bits_only_01() const;\\n\\t\\tbool asBool() const;\\n\\n\\t\\t// helper functions for real valued const eval\\n\\t\\tint isConst() const; // return '1' for AST_CONSTANT and '2' for AST_REALVALUE\\n\\t\\tdouble asReal(bool is_signed);\\n\\t\\tRTLIL::Const realAsConst(int width);\\n\\n\\t\\t// helpers for enum\\n\\t\\tvoid allocateDefaultEnumValues();\\n\\t\\tvoid annotateTypedEnums(AstNode *template_node);\\n\\n\\t\\t// helpers for locations\\n\\t\\tstd::string loc_string() const;\\n\\n\\t\\t// Helper for looking up identifiers which are prefixed with the current module name\\n\\t\\tstd::string try_pop_module_prefix() const;\\n\\n\\t\\t// helper to clone the node with some of its subexpressions replaced with zero (this is used\\n\\t\\t// to evaluate widths of dynamic ranges)\\n\\t\\tAstNode *clone_at_zero();\\n\\n\\t\\tvoid set_attribute(RTLIL::IdString key, AstNode *node)\\n\\t\\t{\\n\\t\\t\\tattributes[key] = node;\\n\\t\\t\\tnode->set_in_param_flag(true);\\n\\t\\t}\\n\\n\\t\\t// helper to set in_lvalue/in_param flags from the hierarchy context (the actual flag\\n\\t\\t// can be overridden based on the intrinsic properties of this node, i.e. based on its type)\\n\\t\\tvoid set_in_lvalue_flag(bool flag, bool no_descend = false);\\n\\t\\tvoid set_in_param_flag(bool flag, bool no_descend = false);\\n\\n\\t\\t// fix up the hierarchy flags (in_lvalue/in_param) of this node and its children\\n\\t\\t//\\n\\t\\t// to keep the flags in sync, fixup_hierarchy_flags(true) needs to be called once after\\n\\t\\t// parsing the AST to walk the full tree, then plain fixup_hierarchy_flags() performs\\n\\t\\t// localized fixups after modifying children/attributes of a particular node\\n\\t\\tvoid fixup_hierarchy_flags(bool force_descend = false);\\n\\n\\t\\t// helpers for indexing\\n\\t\\tAstNode *make_index_range(AstNode *node, bool unpacked_range = false);\\n\\t\\tAstNode *get_struct_member() const;\\n\\n\\t\\t// helper to print errors from simplify/genrtlil code\\n\\t\\t[[noreturn]] void input_error(const char *format, ...) const YS_ATTRIBUTE(format(printf, 2, 3));\\n\\t};\\n\\n\\t// process an AST tree (ast must point to an AST_DESIGN node) and generate RTLIL code\\n\\tvoid process(RTLIL::Design *design, AstNode *ast, bool nodisplay, bool dump_ast1, bool dump_ast2, bool no_dump_ptr, bool dump_vlog1, bool dump_vlog2, bool dump_rtlil, bool nolatches, bool nomeminit,\\n\\t\\t\\tbool nomem2reg, bool mem2reg, bool noblackbox, bool lib, bool nowb, bool noopt, bool icells, bool pwires, bool nooverwrite, bool overwrite, bool defer, bool autowire);\\n\\n\\t// parametric modules are supported directly by the AST library\\n\\t// therefore we need our own derivate of RTLIL::Module with overloaded virtual functions\\n\\tstruct AstModule : RTLIL::Module {\\n\\t\\tAstNode *ast;\\n\\t\\tbool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, autowire;\\n\\t\\t~AstModule() override;\\n\\t\\tRTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, bool mayfail) override;\\n\\t\\tRTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, const dict<RTLIL::IdString, RTLIL::Module*> &interfaces, const dict<RTLIL::IdString, RTLIL::IdString> &modports, bool mayfail) override;\\n\\t\\tstd::string derive_common(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, AstNode **new_ast_out, bool quiet = false);\\n\\t\\tvoid expand_interfaces(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Module *> &local_interfaces) override;\\n\\t\\tbool reprocess_if_necessary(RTLIL::Design *design) override;\\n\\t\\tRTLIL::Module *clone() const override;\\n\\t\\tvoid loadconfig() const;\\n\\t};\\n\\n\\t// this must be set by the language frontend before parsing the sources\\n\\t// the AstNode constructor then uses current_filename and get_line_num()\\n\\t// to initialize the filename and linenum properties of new nodes\\n\\textern std::string current_filename;\\n\\textern void (*set_line_num)(int);\\n\\textern int (*get_line_num)();\\n\\n\\t// set set_line_num and get_line_num to internal dummy functions (done by simplify() and AstModule::derive\\n\\t// to control the filename and linenum properties of new nodes not generated by a frontend parser)\\n\\tvoid use_internal_line_num();\\n\\n\\t// call a DPI function\\n\\tAstNode *dpi_call(const std::string &rtype, const std::string &fname, const std::vector<std::string> &argtypes, const std::vector<AstNode*> &args);\\n\\n\\t// Helper functions related to handling SystemVerilog interfaces\\n\\tstd::pair<std::string,std::string> split_modport_from_type(std::string name_type);\\n\\tAstNode * find_modport(AstNode *intf, std::string name);\\n\\tvoid explode_interface_port(AstNode *module_ast, RTLIL::Module * intfmodule, std::string intfname, AstNode *modport);\\n\\n\\t// Helper for setting the src attribute.\\n\\tvoid set_src_attr(RTLIL::AttrObject *obj, const AstNode *ast);\\n\\n\\t// generate standard $paramod... derived module name; parameters should be\\n\\t// in the order they are declared in the instantiated module\\n\\tstd::string derived_module_name(std::string stripped_name, const std::vector<std::pair<RTLIL::IdString, RTLIL::Const>> &parameters);\\n\\n\\t// used to provide simplify() access to the current design for looking up\\n\\t// modules, ports, wires, etc.\\n\\tvoid set_simplify_design_context(const RTLIL::Design *design);\\n}\\n\\nnamespace AST_INTERNAL\\n{\\n\\t// internal state variables\\n\\textern bool flag_nodisplay, flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_rtlil, flag_nolatches, flag_nomeminit;\\n\\textern bool flag_nomem2reg, flag_mem2reg, flag_lib, flag_noopt, flag_icells, flag_pwires, flag_autowire;\\n\\textern AST::AstNode *current_ast, *current_ast_mod;\\n\\textern std::map<std::string, AST::AstNode*> current_scope;\\n\\textern const dict<RTLIL::SigBit, RTLIL::SigBit> *genRTLIL_subst_ptr;\\n\\textern RTLIL::SigSpec ignoreThisSignalsInInitial;\\n\\textern AST::AstNode *current_always, *current_top_block, *current_block, *current_block_child;\\n\\textern RTLIL::Module *current_module;\\n\\textern bool current_always_clocked;\\n\\textern dict<std::string, int> current_memwr_count;\\n\\textern dict<std::string, pool<int>> current_memwr_visible;\\n\\tstruct LookaheadRewriter;\\n\\tstruct ProcessGenerator;\\n\\n\\t// Create and add a new AstModule from new_ast, then use it to replace\\n\\t// old_module in design, renaming old_module to move it out of the way.\\n\\t// Return the new module.\\n\\t//\\n\\t// If original_ast is not null, it will be used as the AST node for the\\n\\t// new module. Otherwise, new_ast will be used.\\n\\tRTLIL::Module *\\n\\tprocess_and_replace_module(RTLIL::Design *design,\\n\\t                           RTLIL::Module *old_module,\\n\\t                           AST::AstNode *new_ast,\\n\\t                           AST::AstNode *original_ast = nullptr);\\n}\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                    \"ast_binding.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n *  ---\\n *\\n *  This header declares the AST::Binding class\\n *\\n *  This is used to support the bind directive and is to RTLIL::Binding as\\n *  AST::AstModule is to RTLIL::Module, holding a syntax-level representation of\\n *  cells until we get to a stage where they make sense. In the case of a bind\\n *  directive, this is when we elaborate the design in the hierarchy pass.\\n *\\n */\\n\\n#ifndef AST_BINDING_H\\n#define AST_BINDING_H\\n\\n#include \\\"kernel/rtlil.h\\\"\\n#include \\\"kernel/binding.h\\\"\\n\\n#include <memory>\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nnamespace AST\\n{\\n\\tclass Binding : public RTLIL::Binding\\n\\t{\\n\\tpublic:\\n\\t\\tBinding(RTLIL::IdString  target_type,\\n\\t\\t        RTLIL::IdString  target_name,\\n\\t\\t        const AstNode   &cell);\\n\\n\\t\\tstd::string describe() const override;\\n\\n\\tprivate:\\n\\t\\t// The syntax-level representation of the cell to be bound.\\n\\t\\tstd::unique_ptr<AstNode> ast_node;\\n\\t};\\n}\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                },\n                \"blif\": {\n                    \"blifparse.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef ABC_BLIFPARSE\\n#define ABC_BLIFPARSE\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nextern void parse_blif(RTLIL::Design *design, std::istream &f, IdString dff_name,\\n\\t\\tbool run_clean = false, bool sop_mode = false, bool wideports = false);\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                },\n            },\n            \"kernel\": {\n                \"binding.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef BINDING_H\\n#define BINDING_H\\n\\n#include \\\"kernel/rtlil.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct RTLIL::Binding\\n{\\n\\t// Represents a bind construct.\\n\\t//\\n\\t// The target of the binding is represented by target_type and\\n\\t// target_name (see comments above the fields).\\n\\n\\tBinding(RTLIL::IdString target_type,\\n\\t        RTLIL::IdString target_name);\\n\\n\\tvirtual ~Binding() {}\\n\\n\\t// Return a string describing the binding\\n\\tvirtual std::string describe() const = 0;\\n\\nprotected:\\n\\t// May be empty. If not, it's the name of the module or interface to\\n\\t// bind to.\\n\\tRTLIL::IdString target_type;\\n\\n\\t// If target_type is nonempty (the usual case), this is a hierarchical\\n\\t// reference to the bind target. If target_type is empty, we have to\\n\\t// wait until the hierarchy pass to figure out whether this was the name\\n\\t// of a module/interface type or an instance.\\n\\tRTLIL::IdString target_name;\\n\\n\\t// An attribute name which contains an ID that's unique across binding\\n\\t// instances (used to ensure we don't apply a binding twice to a module)\\n\\tRTLIL::IdString attr_name;\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"cellaigs.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef CELLAIGS_H\\n#define CELLAIGS_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct AigNode\\n{\\n\\tIdString portname;\\n\\tint portbit;\\n\\tbool inverter;\\n\\tint left_parent, right_parent;\\n\\tvector<pair<IdString, int>> outports;\\n\\n\\tAigNode();\\n\\tbool operator==(const AigNode &other) const;\\n\\tunsigned int hash() const;\\n};\\n\\nstruct Aig\\n{\\n\\tstring name;\\n\\tvector<AigNode> nodes;\\n\\tAig(Cell *cell);\\n\\n\\tbool operator==(const Aig &other) const;\\n\\tunsigned int hash() const;\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"celledges.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef CELLEDGES_H\\n#define CELLEDGES_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n#include \\\"kernel/sigtools.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct AbstractCellEdgesDatabase\\n{\\n\\tvirtual ~AbstractCellEdgesDatabase() { }\\n\\tvirtual void add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_port, int to_bit, int delay) = 0;\\n\\tbool add_edges_from_cell(RTLIL::Cell *cell);\\n};\\n\\nstruct FwdCellEdgesDatabase : AbstractCellEdgesDatabase\\n{\\n\\tSigMap &sigmap;\\n\\tdict<SigBit, pool<SigBit>> db;\\n\\tFwdCellEdgesDatabase(SigMap &sigmap) : sigmap(sigmap) { }\\n\\n\\tvoid add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_port, int to_bit, int) override {\\n\\t\\tSigBit from_sigbit = sigmap(cell->getPort(from_port)[from_bit]);\\n\\t\\tSigBit to_sigbit = sigmap(cell->getPort(to_port)[to_bit]);\\n\\t\\tdb[from_sigbit].insert(to_sigbit);\\n\\t}\\n};\\n\\nstruct RevCellEdgesDatabase : AbstractCellEdgesDatabase\\n{\\n\\tSigMap &sigmap;\\n\\tdict<SigBit, pool<SigBit>> db;\\n\\tRevCellEdgesDatabase(SigMap &sigmap) : sigmap(sigmap) { }\\n\\n\\tvoid add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_port, int to_bit, int) override {\\n\\t\\tSigBit from_sigbit = sigmap(cell->getPort(from_port)[from_bit]);\\n\\t\\tSigBit to_sigbit = sigmap(cell->getPort(to_port)[to_bit]);\\n\\t\\tdb[to_sigbit].insert(from_sigbit);\\n\\t}\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"celltypes.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef CELLTYPES_H\\n#define CELLTYPES_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct CellType\\n{\\n\\tRTLIL::IdString type;\\n\\tpool<RTLIL::IdString> inputs, outputs;\\n\\tbool is_evaluable;\\n};\\n\\nstruct CellTypes\\n{\\n\\tdict<RTLIL::IdString, CellType> cell_types;\\n\\n\\tCellTypes()\\n\\t{\\n\\t}\\n\\n\\tCellTypes(RTLIL::Design *design)\\n\\t{\\n\\t\\tsetup(design);\\n\\t}\\n\\n\\tvoid setup(RTLIL::Design *design = NULL)\\n\\t{\\n\\t\\tif (design)\\n\\t\\t\\tsetup_design(design);\\n\\n\\t\\tsetup_internals();\\n\\t\\tsetup_internals_mem();\\n\\t\\tsetup_internals_anyinit();\\n\\t\\tsetup_stdcells();\\n\\t\\tsetup_stdcells_mem();\\n\\t}\\n\\n\\tvoid setup_type(RTLIL::IdString type, const pool<RTLIL::IdString> &inputs, const pool<RTLIL::IdString> &outputs, bool is_evaluable = false)\\n\\t{\\n\\t\\tCellType ct = {type, inputs, outputs, is_evaluable};\\n\\t\\tcell_types[ct.type] = ct;\\n\\t}\\n\\n\\tvoid setup_module(RTLIL::Module *module)\\n\\t{\\n\\t\\tpool<RTLIL::IdString> inputs, outputs;\\n\\t\\tfor (RTLIL::IdString wire_name : module->ports) {\\n\\t\\t\\tRTLIL::Wire *wire = module->wire(wire_name);\\n\\t\\t\\tif (wire->port_input)\\n\\t\\t\\t\\tinputs.insert(wire->name);\\n\\t\\t\\tif (wire->port_output)\\n\\t\\t\\t\\toutputs.insert(wire->name);\\n\\t\\t}\\n\\t\\tsetup_type(module->name, inputs, outputs);\\n\\t}\\n\\n\\tvoid setup_design(RTLIL::Design *design)\\n\\t{\\n\\t\\tfor (auto module : design->modules())\\n\\t\\t\\tsetup_module(module);\\n\\t}\\n\\n\\tvoid setup_internals()\\n\\t{\\n\\t\\tsetup_internals_eval();\\n\\n\\t\\tsetup_type(ID($tribuf), {ID::A, ID::EN}, {ID::Y}, true);\\n\\n\\t\\tsetup_type(ID($assert), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);\\n\\t\\tsetup_type(ID($assume), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);\\n\\t\\tsetup_type(ID($live), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);\\n\\t\\tsetup_type(ID($fair), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);\\n\\t\\tsetup_type(ID($cover), {ID::A, ID::EN}, pool<RTLIL::IdString>(), true);\\n\\t\\tsetup_type(ID($initstate), pool<RTLIL::IdString>(), {ID::Y}, true);\\n\\t\\tsetup_type(ID($anyconst), pool<RTLIL::IdString>(), {ID::Y}, true);\\n\\t\\tsetup_type(ID($anyseq), pool<RTLIL::IdString>(), {ID::Y}, true);\\n\\t\\tsetup_type(ID($allconst), pool<RTLIL::IdString>(), {ID::Y}, true);\\n\\t\\tsetup_type(ID($allseq), pool<RTLIL::IdString>(), {ID::Y}, true);\\n\\t\\tsetup_type(ID($equiv), {ID::A, ID::B}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($specify2), {ID::EN, ID::SRC, ID::DST}, pool<RTLIL::IdString>(), true);\\n\\t\\tsetup_type(ID($specify3), {ID::EN, ID::SRC, ID::DST, ID::DAT}, pool<RTLIL::IdString>(), true);\\n\\t\\tsetup_type(ID($specrule), {ID::EN_SRC, ID::EN_DST, ID::SRC, ID::DST}, pool<RTLIL::IdString>(), true);\\n\\t\\tsetup_type(ID($print), {ID::EN, ID::ARGS, ID::TRG}, pool<RTLIL::IdString>());\\n\\t\\tsetup_type(ID($check), {ID::A, ID::EN, ID::ARGS, ID::TRG}, pool<RTLIL::IdString>());\\n\\t\\tsetup_type(ID($set_tag), {ID::A, ID::SET, ID::CLR}, {ID::Y});\\n\\t\\tsetup_type(ID($get_tag), {ID::A}, {ID::Y});\\n\\t\\tsetup_type(ID($overwrite_tag), {ID::A, ID::SET, ID::CLR}, pool<RTLIL::IdString>());\\n\\t\\tsetup_type(ID($original_tag), {ID::A}, {ID::Y});\\n\\t\\tsetup_type(ID($future_ff), {ID::A}, {ID::Y});\\n\\t\\tsetup_type(ID($scopeinfo), {}, {});\\n\\t}\\n\\n\\tvoid setup_internals_eval()\\n\\t{\\n\\t\\tstd::vector<RTLIL::IdString> unary_ops = {\\n\\t\\t\\tID($not), ID($pos), ID($neg),\\n\\t\\t\\tID($reduce_and), ID($reduce_or), ID($reduce_xor), ID($reduce_xnor), ID($reduce_bool),\\n\\t\\t\\tID($logic_not), ID($slice), ID($lut), ID($sop)\\n\\t\\t};\\n\\n\\t\\tstd::vector<RTLIL::IdString> binary_ops = {\\n\\t\\t\\tID($and), ID($or), ID($xor), ID($xnor),\\n\\t\\t\\tID($shl), ID($shr), ID($sshl), ID($sshr), ID($shift), ID($shiftx),\\n\\t\\t\\tID($lt), ID($le), ID($eq), ID($ne), ID($eqx), ID($nex), ID($ge), ID($gt),\\n\\t\\t\\tID($add), ID($sub), ID($mul), ID($div), ID($mod), ID($divfloor), ID($modfloor), ID($pow),\\n\\t\\t\\tID($logic_and), ID($logic_or), ID($concat), ID($macc),\\n\\t\\t\\tID($bweqx)\\n\\t\\t};\\n\\n\\t\\tfor (auto type : unary_ops)\\n\\t\\t\\tsetup_type(type, {ID::A}, {ID::Y}, true);\\n\\n\\t\\tfor (auto type : binary_ops)\\n\\t\\t\\tsetup_type(type, {ID::A, ID::B}, {ID::Y}, true);\\n\\n\\t\\tfor (auto type : std::vector<RTLIL::IdString>({ID($mux), ID($pmux), ID($bwmux)}))\\n\\t\\t\\tsetup_type(type, {ID::A, ID::B, ID::S}, {ID::Y}, true);\\n\\n\\t\\tfor (auto type : std::vector<RTLIL::IdString>({ID($bmux), ID($demux)}))\\n\\t\\t\\tsetup_type(type, {ID::A, ID::S}, {ID::Y}, true);\\n\\n\\t\\tsetup_type(ID($lcu), {ID::P, ID::G, ID::CI}, {ID::CO}, true);\\n\\t\\tsetup_type(ID($alu), {ID::A, ID::B, ID::CI, ID::BI}, {ID::X, ID::Y, ID::CO}, true);\\n\\t\\tsetup_type(ID($fa), {ID::A, ID::B, ID::C}, {ID::X, ID::Y}, true);\\n\\t}\\n\\n\\tvoid setup_internals_ff()\\n\\t{\\n\\t\\tsetup_type(ID($sr), {ID::SET, ID::CLR}, {ID::Q});\\n\\t\\tsetup_type(ID($ff), {ID::D}, {ID::Q});\\n\\t\\tsetup_type(ID($dff), {ID::CLK, ID::D}, {ID::Q});\\n\\t\\tsetup_type(ID($dffe), {ID::CLK, ID::EN, ID::D}, {ID::Q});\\n\\t\\tsetup_type(ID($dffsr), {ID::CLK, ID::SET, ID::CLR, ID::D}, {ID::Q});\\n\\t\\tsetup_type(ID($dffsre), {ID::CLK, ID::SET, ID::CLR, ID::D, ID::EN}, {ID::Q});\\n\\t\\tsetup_type(ID($adff), {ID::CLK, ID::ARST, ID::D}, {ID::Q});\\n\\t\\tsetup_type(ID($adffe), {ID::CLK, ID::ARST, ID::D, ID::EN}, {ID::Q});\\n\\t\\tsetup_type(ID($aldff), {ID::CLK, ID::ALOAD, ID::AD, ID::D}, {ID::Q});\\n\\t\\tsetup_type(ID($aldffe), {ID::CLK, ID::ALOAD, ID::AD, ID::D, ID::EN}, {ID::Q});\\n\\t\\tsetup_type(ID($sdff), {ID::CLK, ID::SRST, ID::D}, {ID::Q});\\n\\t\\tsetup_type(ID($sdffe), {ID::CLK, ID::SRST, ID::D, ID::EN}, {ID::Q});\\n\\t\\tsetup_type(ID($sdffce), {ID::CLK, ID::SRST, ID::D, ID::EN}, {ID::Q});\\n\\t\\tsetup_type(ID($dlatch), {ID::EN, ID::D}, {ID::Q});\\n\\t\\tsetup_type(ID($adlatch), {ID::EN, ID::D, ID::ARST}, {ID::Q});\\n\\t\\tsetup_type(ID($dlatchsr), {ID::EN, ID::SET, ID::CLR, ID::D}, {ID::Q});\\n\\t}\\n\\n\\tvoid setup_internals_anyinit()\\n\\t{\\n\\t\\tsetup_type(ID($anyinit), {ID::D}, {ID::Q});\\n\\t}\\n\\n\\tvoid setup_internals_mem()\\n\\t{\\n\\t\\tsetup_internals_ff();\\n\\n\\t\\tsetup_type(ID($memrd), {ID::CLK, ID::EN, ID::ADDR}, {ID::DATA});\\n\\t\\tsetup_type(ID($memrd_v2), {ID::CLK, ID::EN, ID::ARST, ID::SRST, ID::ADDR}, {ID::DATA});\\n\\t\\tsetup_type(ID($memwr), {ID::CLK, ID::EN, ID::ADDR, ID::DATA}, pool<RTLIL::IdString>());\\n\\t\\tsetup_type(ID($memwr_v2), {ID::CLK, ID::EN, ID::ADDR, ID::DATA}, pool<RTLIL::IdString>());\\n\\t\\tsetup_type(ID($meminit), {ID::ADDR, ID::DATA}, pool<RTLIL::IdString>());\\n\\t\\tsetup_type(ID($meminit_v2), {ID::ADDR, ID::DATA, ID::EN}, pool<RTLIL::IdString>());\\n\\t\\tsetup_type(ID($mem), {ID::RD_CLK, ID::RD_EN, ID::RD_ADDR, ID::WR_CLK, ID::WR_EN, ID::WR_ADDR, ID::WR_DATA}, {ID::RD_DATA});\\n\\t\\tsetup_type(ID($mem_v2), {ID::RD_CLK, ID::RD_EN, ID::RD_ARST, ID::RD_SRST, ID::RD_ADDR, ID::WR_CLK, ID::WR_EN, ID::WR_ADDR, ID::WR_DATA}, {ID::RD_DATA});\\n\\n\\t\\tsetup_type(ID($fsm), {ID::CLK, ID::ARST, ID::CTRL_IN}, {ID::CTRL_OUT});\\n\\t}\\n\\n\\tvoid setup_stdcells()\\n\\t{\\n\\t\\tsetup_stdcells_eval();\\n\\n\\t\\tsetup_type(ID($_TBUF_), {ID::A, ID::E}, {ID::Y}, true);\\n\\t}\\n\\n\\tvoid setup_stdcells_eval()\\n\\t{\\n\\t\\tsetup_type(ID($_BUF_), {ID::A}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_NOT_), {ID::A}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_AND_), {ID::A, ID::B}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_NAND_), {ID::A, ID::B}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_OR_),  {ID::A, ID::B}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_NOR_),  {ID::A, ID::B}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_XOR_), {ID::A, ID::B}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_XNOR_), {ID::A, ID::B}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_ANDNOT_), {ID::A, ID::B}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_ORNOT_), {ID::A, ID::B}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_MUX_), {ID::A, ID::B, ID::S}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_NMUX_), {ID::A, ID::B, ID::S}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_MUX4_), {ID::A, ID::B, ID::C, ID::D, ID::S, ID::T}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_MUX8_), {ID::A, ID::B, ID::C, ID::D, ID::E, ID::F, ID::G, ID::H, ID::S, ID::T, ID::U}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_MUX16_), {ID::A, ID::B, ID::C, ID::D, ID::E, ID::F, ID::G, ID::H, ID::I, ID::J, ID::K, ID::L, ID::M, ID::N, ID::O, ID::P, ID::S, ID::T, ID::U, ID::V}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_AOI3_), {ID::A, ID::B, ID::C}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_OAI3_), {ID::A, ID::B, ID::C}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_AOI4_), {ID::A, ID::B, ID::C, ID::D}, {ID::Y}, true);\\n\\t\\tsetup_type(ID($_OAI4_), {ID::A, ID::B, ID::C, ID::D}, {ID::Y}, true);\\n\\t}\\n\\n\\tvoid setup_stdcells_mem()\\n\\t{\\n\\t\\tstd::vector<char> list_np = {'N', 'P'}, list_01 = {'0', '1'};\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_SR_%c%c_\\\", c1, c2), {ID::S, ID::R}, {ID::Q});\\n\\n\\t\\tsetup_type(ID($_FF_), {ID::D}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_DFF_%c_\\\", c1), {ID::C, ID::D}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_DFFE_%c%c_\\\", c1, c2), {ID::C, ID::D, ID::E}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_01)\\n\\t\\t\\tsetup_type(stringf(\\\"$_DFF_%c%c%c_\\\", c1, c2, c3), {ID::C, ID::R, ID::D}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_01)\\n\\t\\tfor (auto c4 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_DFFE_%c%c%c%c_\\\", c1, c2, c3, c4), {ID::C, ID::R, ID::D, ID::E}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_ALDFF_%c%c_\\\", c1, c2), {ID::C, ID::L, ID::AD, ID::D}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_ALDFFE_%c%c%c_\\\", c1, c2, c3), {ID::C, ID::L, ID::AD, ID::D, ID::E}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_DFFSR_%c%c%c_\\\", c1, c2, c3), {ID::C, ID::S, ID::R, ID::D}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_np)\\n\\t\\tfor (auto c4 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_DFFSRE_%c%c%c%c_\\\", c1, c2, c3, c4), {ID::C, ID::S, ID::R, ID::D, ID::E}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_01)\\n\\t\\t\\tsetup_type(stringf(\\\"$_SDFF_%c%c%c_\\\", c1, c2, c3), {ID::C, ID::R, ID::D}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_01)\\n\\t\\tfor (auto c4 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_SDFFE_%c%c%c%c_\\\", c1, c2, c3, c4), {ID::C, ID::R, ID::D, ID::E}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_01)\\n\\t\\tfor (auto c4 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_SDFFCE_%c%c%c%c_\\\", c1, c2, c3, c4), {ID::C, ID::R, ID::D, ID::E}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_DLATCH_%c_\\\", c1), {ID::E, ID::D}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_01)\\n\\t\\t\\tsetup_type(stringf(\\\"$_DLATCH_%c%c%c_\\\", c1, c2, c3), {ID::E, ID::R, ID::D}, {ID::Q});\\n\\n\\t\\tfor (auto c1 : list_np)\\n\\t\\tfor (auto c2 : list_np)\\n\\t\\tfor (auto c3 : list_np)\\n\\t\\t\\tsetup_type(stringf(\\\"$_DLATCHSR_%c%c%c_\\\", c1, c2, c3), {ID::E, ID::S, ID::R, ID::D}, {ID::Q});\\n\\t}\\n\\n\\tvoid clear()\\n\\t{\\n\\t\\tcell_types.clear();\\n\\t}\\n\\n\\tbool cell_known(RTLIL::IdString type) const\\n\\t{\\n\\t\\treturn cell_types.count(type) != 0;\\n\\t}\\n\\n\\tbool cell_output(RTLIL::IdString type, RTLIL::IdString port) const\\n\\t{\\n\\t\\tauto it = cell_types.find(type);\\n\\t\\treturn it != cell_types.end() && it->second.outputs.count(port) != 0;\\n\\t}\\n\\n\\tbool cell_input(RTLIL::IdString type, RTLIL::IdString port) const\\n\\t{\\n\\t\\tauto it = cell_types.find(type);\\n\\t\\treturn it != cell_types.end() && it->second.inputs.count(port) != 0;\\n\\t}\\n\\n\\tbool cell_evaluable(RTLIL::IdString type) const\\n\\t{\\n\\t\\tauto it = cell_types.find(type);\\n\\t\\treturn it != cell_types.end() && it->second.is_evaluable;\\n\\t}\\n\\n\\tstatic RTLIL::Const eval_not(RTLIL::Const v)\\n\\t{\\n\\t\\tfor (auto &bit : v.bits)\\n\\t\\t\\tif (bit == State::S0) bit = State::S1;\\n\\t\\t\\telse if (bit == State::S1) bit = State::S0;\\n\\t\\treturn v;\\n\\t}\\n\\n\\tstatic RTLIL::Const eval(RTLIL::IdString type, const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len, bool *errp = nullptr)\\n\\t{\\n\\t\\tif (type == ID($sshr) && !signed1)\\n\\t\\t\\ttype = ID($shr);\\n\\t\\tif (type == ID($sshl) && !signed1)\\n\\t\\t\\ttype = ID($shl);\\n\\n\\t\\tif (type != ID($sshr) && type != ID($sshl) && type != ID($shr) && type != ID($shl) && type != ID($shift) && type != ID($shiftx) &&\\n\\t\\t\\t\\ttype != ID($pos) && type != ID($neg) && type != ID($not)) {\\n\\t\\t\\tif (!signed1 || !signed2)\\n\\t\\t\\t\\tsigned1 = false, signed2 = false;\\n\\t\\t}\\n\\n#define HANDLE_CELL_TYPE(_t) if (type == ID($##_t)) return const_ ## _t(arg1, arg2, signed1, signed2, result_len);\\n\\t\\tHANDLE_CELL_TYPE(not)\\n\\t\\tHANDLE_CELL_TYPE(and)\\n\\t\\tHANDLE_CELL_TYPE(or)\\n\\t\\tHANDLE_CELL_TYPE(xor)\\n\\t\\tHANDLE_CELL_TYPE(xnor)\\n\\t\\tHANDLE_CELL_TYPE(reduce_and)\\n\\t\\tHANDLE_CELL_TYPE(reduce_or)\\n\\t\\tHANDLE_CELL_TYPE(reduce_xor)\\n\\t\\tHANDLE_CELL_TYPE(reduce_xnor)\\n\\t\\tHANDLE_CELL_TYPE(reduce_bool)\\n\\t\\tHANDLE_CELL_TYPE(logic_not)\\n\\t\\tHANDLE_CELL_TYPE(logic_and)\\n\\t\\tHANDLE_CELL_TYPE(logic_or)\\n\\t\\tHANDLE_CELL_TYPE(shl)\\n\\t\\tHANDLE_CELL_TYPE(shr)\\n\\t\\tHANDLE_CELL_TYPE(sshl)\\n\\t\\tHANDLE_CELL_TYPE(sshr)\\n\\t\\tHANDLE_CELL_TYPE(shift)\\n\\t\\tHANDLE_CELL_TYPE(shiftx)\\n\\t\\tHANDLE_CELL_TYPE(lt)\\n\\t\\tHANDLE_CELL_TYPE(le)\\n\\t\\tHANDLE_CELL_TYPE(eq)\\n\\t\\tHANDLE_CELL_TYPE(ne)\\n\\t\\tHANDLE_CELL_TYPE(eqx)\\n\\t\\tHANDLE_CELL_TYPE(nex)\\n\\t\\tHANDLE_CELL_TYPE(ge)\\n\\t\\tHANDLE_CELL_TYPE(gt)\\n\\t\\tHANDLE_CELL_TYPE(add)\\n\\t\\tHANDLE_CELL_TYPE(sub)\\n\\t\\tHANDLE_CELL_TYPE(mul)\\n\\t\\tHANDLE_CELL_TYPE(div)\\n\\t\\tHANDLE_CELL_TYPE(mod)\\n\\t\\tHANDLE_CELL_TYPE(divfloor)\\n\\t\\tHANDLE_CELL_TYPE(modfloor)\\n\\t\\tHANDLE_CELL_TYPE(pow)\\n\\t\\tHANDLE_CELL_TYPE(pos)\\n\\t\\tHANDLE_CELL_TYPE(neg)\\n#undef HANDLE_CELL_TYPE\\n\\n\\t\\tif (type == ID($_BUF_))\\n\\t\\t\\treturn arg1;\\n\\t\\tif (type == ID($_NOT_))\\n\\t\\t\\treturn eval_not(arg1);\\n\\t\\tif (type == ID($_AND_))\\n\\t\\t\\treturn const_and(arg1, arg2, false, false, 1);\\n\\t\\tif (type == ID($_NAND_))\\n\\t\\t\\treturn eval_not(const_and(arg1, arg2, false, false, 1));\\n\\t\\tif (type == ID($_OR_))\\n\\t\\t\\treturn const_or(arg1, arg2, false, false, 1);\\n\\t\\tif (type == ID($_NOR_))\\n\\t\\t\\treturn eval_not(const_or(arg1, arg2, false, false, 1));\\n\\t\\tif (type == ID($_XOR_))\\n\\t\\t\\treturn const_xor(arg1, arg2, false, false, 1);\\n\\t\\tif (type == ID($_XNOR_))\\n\\t\\t\\treturn const_xnor(arg1, arg2, false, false, 1);\\n\\t\\tif (type == ID($_ANDNOT_))\\n\\t\\t\\treturn const_and(arg1, eval_not(arg2), false, false, 1);\\n\\t\\tif (type == ID($_ORNOT_))\\n\\t\\t\\treturn const_or(arg1, eval_not(arg2), false, false, 1);\\n\\n\\t\\tif (errp != nullptr) {\\n\\t\\t\\t*errp = true;\\n\\t\\t\\treturn State::Sm;\\n\\t\\t}\\n\\n\\t\\tlog_abort();\\n\\t}\\n\\n\\tstatic RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool *errp = nullptr)\\n\\t{\\n\\t\\tif (cell->type == ID($slice)) {\\n\\t\\t\\tRTLIL::Const ret;\\n\\t\\t\\tint width = cell->parameters.at(ID::Y_WIDTH).as_int();\\n\\t\\t\\tint offset = cell->parameters.at(ID::OFFSET).as_int();\\n\\t\\t\\tret.bits.insert(ret.bits.end(), arg1.bits.begin()+offset, arg1.bits.begin()+offset+width);\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tif (cell->type == ID($concat)) {\\n\\t\\t\\tRTLIL::Const ret = arg1;\\n\\t\\t\\tret.bits.insert(ret.bits.end(), arg2.bits.begin(), arg2.bits.end());\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tif (cell->type == ID($bmux))\\n\\t\\t{\\n\\t\\t\\treturn const_bmux(arg1, arg2);\\n\\t\\t}\\n\\n\\t\\tif (cell->type == ID($demux))\\n\\t\\t{\\n\\t\\t\\treturn const_demux(arg1, arg2);\\n\\t\\t}\\n\\n\\t\\tif (cell->type == ID($bweqx))\\n\\t\\t{\\n\\t\\t\\treturn const_bweqx(arg1, arg2);\\n\\t\\t}\\n\\n\\t\\tif (cell->type == ID($lut))\\n\\t\\t{\\n\\t\\t\\tint width = cell->parameters.at(ID::WIDTH).as_int();\\n\\n\\t\\t\\tstd::vector<RTLIL::State> t = cell->parameters.at(ID::LUT).bits;\\n\\t\\t\\twhile (GetSize(t) < (1 << width))\\n\\t\\t\\t\\tt.push_back(State::S0);\\n\\t\\t\\tt.resize(1 << width);\\n\\n\\t\\t\\treturn const_bmux(t, arg1);\\n\\t\\t}\\n\\n\\t\\tif (cell->type == ID($sop))\\n\\t\\t{\\n\\t\\t\\tint width = cell->parameters.at(ID::WIDTH).as_int();\\n\\t\\t\\tint depth = cell->parameters.at(ID::DEPTH).as_int();\\n\\t\\t\\tstd::vector<RTLIL::State> t = cell->parameters.at(ID::TABLE).bits;\\n\\n\\t\\t\\twhile (GetSize(t) < width*depth*2)\\n\\t\\t\\t\\tt.push_back(State::S0);\\n\\n\\t\\t\\tRTLIL::State default_ret = State::S0;\\n\\n\\t\\t\\tfor (int i = 0; i < depth; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbool match = true;\\n\\t\\t\\t\\tbool match_x = true;\\n\\n\\t\\t\\t\\tfor (int j = 0; j < width; j++) {\\n\\t\\t\\t\\t\\tRTLIL::State a = arg1.bits.at(j);\\n\\t\\t\\t\\t\\tif (t.at(2*width*i + 2*j + 0) == State::S1) {\\n\\t\\t\\t\\t\\t\\tif (a == State::S1) match_x = false;\\n\\t\\t\\t\\t\\t\\tif (a != State::S0) match = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (t.at(2*width*i + 2*j + 1) == State::S1) {\\n\\t\\t\\t\\t\\t\\tif (a == State::S0) match_x = false;\\n\\t\\t\\t\\t\\t\\tif (a != State::S1) match = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (match)\\n\\t\\t\\t\\t\\treturn State::S1;\\n\\n\\t\\t\\t\\tif (match_x)\\n\\t\\t\\t\\t\\tdefault_ret = State::Sx;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn default_ret;\\n\\t\\t}\\n\\n\\t\\tbool signed_a = cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters[ID::A_SIGNED].as_bool();\\n\\t\\tbool signed_b = cell->parameters.count(ID::B_SIGNED) > 0 && cell->parameters[ID::B_SIGNED].as_bool();\\n\\t\\tint result_len = cell->parameters.count(ID::Y_WIDTH) > 0 ? cell->parameters[ID::Y_WIDTH].as_int() : -1;\\n\\t\\treturn eval(cell->type, arg1, arg2, signed_a, signed_b, result_len, errp);\\n\\t}\\n\\n\\tstatic RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3, bool *errp = nullptr)\\n\\t{\\n\\t\\tif (cell->type.in(ID($mux), ID($_MUX_)))\\n\\t\\t\\treturn const_mux(arg1, arg2, arg3);\\n\\t\\tif (cell->type == ID($bwmux))\\n\\t\\t\\treturn const_bwmux(arg1, arg2, arg3);\\n\\t\\tif (cell->type == ID($pmux))\\n\\t\\t\\treturn const_pmux(arg1, arg2, arg3);\\n\\t\\tif (cell->type == ID($_AOI3_))\\n\\t\\t\\treturn eval_not(const_or(const_and(arg1, arg2, false, false, 1), arg3, false, false, 1));\\n\\t\\tif (cell->type == ID($_OAI3_))\\n\\t\\t\\treturn eval_not(const_and(const_or(arg1, arg2, false, false, 1), arg3, false, false, 1));\\n\\n\\t\\tlog_assert(arg3.bits.size() == 0);\\n\\t\\treturn eval(cell, arg1, arg2, errp);\\n\\t}\\n\\n\\tstatic RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3, const RTLIL::Const &arg4, bool *errp = nullptr)\\n\\t{\\n\\t\\tif (cell->type == ID($_AOI4_))\\n\\t\\t\\treturn eval_not(const_or(const_and(arg1, arg2, false, false, 1), const_and(arg3, arg4, false, false, 1), false, false, 1));\\n\\t\\tif (cell->type == ID($_OAI4_))\\n\\t\\t\\treturn eval_not(const_and(const_or(arg1, arg2, false, false, 1), const_or(arg3, arg4, false, false, 1), false, false, 1));\\n\\n\\t\\tlog_assert(arg4.bits.size() == 0);\\n\\t\\treturn eval(cell, arg1, arg2, arg3, errp);\\n\\t}\\n};\\n\\n// initialized by yosys_setup()\\nextern CellTypes yosys_celltypes;\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"consteval.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef CONSTEVAL_H\\n#define CONSTEVAL_H\\n\\n#include \\\"kernel/rtlil.h\\\"\\n#include \\\"kernel/sigtools.h\\\"\\n#include \\\"kernel/celltypes.h\\\"\\n#include \\\"kernel/macc.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct ConstEval\\n{\\n\\tRTLIL::Module *module;\\n\\tSigMap assign_map;\\n\\tSigMap values_map;\\n\\tSigPool stop_signals;\\n\\tSigSet<RTLIL::Cell*> sig2driver;\\n\\tstd::set<RTLIL::Cell*> busy;\\n\\tstd::vector<SigMap> stack;\\n\\tRTLIL::State defaultval;\\n\\n\\tConstEval(RTLIL::Module *module, RTLIL::State defaultval = RTLIL::State::Sm) : module(module), assign_map(module), defaultval(defaultval)\\n\\t{\\n\\t\\tCellTypes ct;\\n\\t\\tct.setup_internals();\\n\\t\\tct.setup_stdcells();\\n\\n\\t\\tfor (auto &it : module->cells_) {\\n\\t\\t\\tif (!ct.cell_known(it.second->type))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tfor (auto &it2 : it.second->connections())\\n\\t\\t\\t\\tif (ct.cell_output(it.second->type, it2.first))\\n\\t\\t\\t\\t\\tsig2driver.insert(assign_map(it2.second), it.second);\\n\\t\\t}\\n\\t}\\n\\n\\tvoid clear()\\n\\t{\\n\\t\\tvalues_map.clear();\\n\\t\\tstop_signals.clear();\\n\\t}\\n\\n\\tvoid push()\\n\\t{\\n\\t\\tstack.push_back(values_map);\\n\\t}\\n\\n\\tvoid pop()\\n\\t{\\n\\t\\tvalues_map.swap(stack.back());\\n\\t\\tstack.pop_back();\\n\\t}\\n\\n\\tvoid set(RTLIL::SigSpec sig, RTLIL::Const value)\\n\\t{\\n\\t\\tassign_map.apply(sig);\\n#ifndef NDEBUG\\n\\t\\tRTLIL::SigSpec current_val = values_map(sig);\\n\\t\\tfor (int i = 0; i < GetSize(current_val); i++)\\n\\t\\t\\tlog_assert(current_val[i].wire != NULL || current_val[i] == value.bits[i]);\\n#endif\\n\\t\\tvalues_map.add(sig, RTLIL::SigSpec(value));\\n\\t}\\n\\n\\tvoid stop(RTLIL::SigSpec sig)\\n\\t{\\n\\t\\tassign_map.apply(sig);\\n\\t\\tstop_signals.add(sig);\\n\\t}\\n\\n\\tbool eval(RTLIL::Cell *cell, RTLIL::SigSpec &undef)\\n\\t{\\n\\t\\tif (cell->type == ID($lcu))\\n\\t\\t{\\n\\t\\t\\tRTLIL::SigSpec sig_p = cell->getPort(ID::P);\\n\\t\\t\\tRTLIL::SigSpec sig_g = cell->getPort(ID::G);\\n\\t\\t\\tRTLIL::SigSpec sig_ci = cell->getPort(ID::CI);\\n\\t\\t\\tRTLIL::SigSpec sig_co = values_map(assign_map(cell->getPort(ID::CO)));\\n\\n\\t\\t\\tif (sig_co.is_fully_const())\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tif (!eval(sig_p, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (!eval(sig_g, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (!eval(sig_ci, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (sig_p.is_fully_def() && sig_g.is_fully_def() && sig_ci.is_fully_def())\\n\\t\\t\\t{\\n\\t\\t\\t\\tRTLIL::Const coval(RTLIL::Sx, GetSize(sig_co));\\n\\t\\t\\t\\tbool carry = sig_ci.as_bool();\\n\\n\\t\\t\\t\\tfor (int i = 0; i < GetSize(coval); i++) {\\n\\t\\t\\t\\t\\tcarry = (sig_g[i] == State::S1) || (sig_p[i] == RTLIL::S1 && carry);\\n\\t\\t\\t\\t\\tcoval.bits[i] = carry ? State::S1 : State::S0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tset(sig_co, coval);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tset(sig_co, RTLIL::Const(RTLIL::Sx, GetSize(sig_co)));\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tRTLIL::SigSpec sig_a, sig_b, sig_s, sig_y;\\n\\n\\t\\tlog_assert(cell->hasPort(ID::Y));\\n\\t\\tsig_y = values_map(assign_map(cell->getPort(ID::Y)));\\n\\t\\tif (sig_y.is_fully_const())\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (cell->hasPort(ID::S)) {\\n\\t\\t\\tsig_s = cell->getPort(ID::S);\\n\\t\\t}\\n\\n\\t\\tif (cell->hasPort(ID::A))\\n\\t\\t\\tsig_a = cell->getPort(ID::A);\\n\\n\\t\\tif (cell->hasPort(ID::B))\\n\\t\\t\\tsig_b = cell->getPort(ID::B);\\n\\n\\t\\tif (cell->type.in(ID($mux), ID($pmux), ID($_MUX_), ID($_NMUX_)))\\n\\t\\t{\\n\\t\\t\\tstd::vector<RTLIL::SigSpec> y_candidates;\\n\\t\\t\\tint count_set_s_bits = 0;\\n\\n\\t\\t\\tif (!eval(sig_s, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tfor (int i = 0; i < sig_s.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tRTLIL::State s_bit = sig_s.extract(i, 1).as_const().bits.at(0);\\n\\t\\t\\t\\tRTLIL::SigSpec b_slice = sig_b.extract(sig_y.size()*i, sig_y.size());\\n\\n\\t\\t\\t\\tif (s_bit == RTLIL::State::Sx || s_bit == RTLIL::State::S1)\\n\\t\\t\\t\\t\\ty_candidates.push_back(b_slice);\\n\\n\\t\\t\\t\\tif (s_bit == RTLIL::State::S1)\\n\\t\\t\\t\\t\\tcount_set_s_bits++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (count_set_s_bits == 0)\\n\\t\\t\\t\\ty_candidates.push_back(sig_a);\\n\\n\\t\\t\\tstd::vector<RTLIL::Const> y_values;\\n\\n\\t\\t\\tlog_assert(y_candidates.size() > 0);\\n\\t\\t\\tfor (auto &yc : y_candidates) {\\n\\t\\t\\t\\tif (!eval(yc, undef, cell))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tif (cell->type == ID($_NMUX_))\\n\\t\\t\\t\\t\\ty_values.push_back(RTLIL::const_not(yc.as_const(), Const(), false, false, GetSize(yc)));\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ty_values.push_back(yc.as_const());\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (y_values.size() > 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstd::vector<RTLIL::State> master_bits = y_values.at(0).bits;\\n\\n\\t\\t\\t\\tfor (size_t i = 1; i < y_values.size(); i++) {\\n\\t\\t\\t\\t\\tstd::vector<RTLIL::State> &slave_bits = y_values.at(i).bits;\\n\\t\\t\\t\\t\\tlog_assert(master_bits.size() == slave_bits.size());\\n\\t\\t\\t\\t\\tfor (size_t j = 0; j < master_bits.size(); j++)\\n\\t\\t\\t\\t\\t\\tif (master_bits[j] != slave_bits[j])\\n\\t\\t\\t\\t\\t\\t\\tmaster_bits[j] = RTLIL::State::Sx;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tset(sig_y, RTLIL::Const(master_bits));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tset(sig_y, y_values.front());\\n\\t\\t}\\n\\t\\telse if (cell->type == ID($bmux))\\n\\t\\t{\\n\\t\\t\\tif (!eval(sig_s, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (sig_s.is_fully_def()) {\\n\\t\\t\\t\\tint sel = sig_s.as_int();\\n\\t\\t\\t\\tint width = GetSize(sig_y);\\n\\t\\t\\t\\tSigSpec res = sig_a.extract(sel * width, width);\\n\\t\\t\\t\\tif (!eval(res, undef, cell))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tset(sig_y, res.as_const());\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (!eval(sig_a, undef, cell))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tset(sig_y, const_bmux(sig_a.as_const(), sig_s.as_const()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (cell->type == ID($demux))\\n\\t\\t{\\n\\t\\t\\tif (!eval(sig_a, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (sig_a.is_fully_zero()) {\\n\\t\\t\\t\\tset(sig_y, Const(0, GetSize(sig_y)));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (!eval(sig_s, undef, cell))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tset(sig_y, const_demux(sig_a.as_const(), sig_s.as_const()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (cell->type == ID($fa))\\n\\t\\t{\\n\\t\\t\\tRTLIL::SigSpec sig_c = cell->getPort(ID::C);\\n\\t\\t\\tRTLIL::SigSpec sig_x = cell->getPort(ID::X);\\n\\t\\t\\tint width = GetSize(sig_c);\\n\\n\\t\\t\\tif (!eval(sig_a, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (!eval(sig_b, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (!eval(sig_c, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tRTLIL::Const t1 = const_xor(sig_a.as_const(), sig_b.as_const(), false, false, width);\\n\\t\\t\\tRTLIL::Const val_y = const_xor(t1, sig_c.as_const(), false, false, width);\\n\\n\\t\\t\\tRTLIL::Const t2 = const_and(sig_a.as_const(), sig_b.as_const(), false, false, width);\\n\\t\\t\\tRTLIL::Const t3 = const_and(sig_c.as_const(), t1, false, false, width);\\n\\t\\t\\tRTLIL::Const val_x = const_or(t2, t3, false, false, width);\\n\\n\\t\\t\\tfor (int i = 0; i < GetSize(val_y); i++)\\n\\t\\t\\t\\tif (val_y.bits[i] == RTLIL::Sx)\\n\\t\\t\\t\\t\\tval_x.bits[i] = RTLIL::Sx;\\n\\n\\t\\t\\tset(sig_y, val_y);\\n\\t\\t\\tset(sig_x, val_x);\\n\\t\\t}\\n\\t\\telse if (cell->type == ID($alu))\\n\\t\\t{\\n\\t\\t\\tbool signed_a = cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters[ID::A_SIGNED].as_bool();\\n\\t\\t\\tbool signed_b = cell->parameters.count(ID::B_SIGNED) > 0 && cell->parameters[ID::B_SIGNED].as_bool();\\n\\n\\t\\t\\tRTLIL::SigSpec sig_ci = cell->getPort(ID::CI);\\n\\t\\t\\tRTLIL::SigSpec sig_bi = cell->getPort(ID::BI);\\n\\n\\t\\t\\tif (!eval(sig_a, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (!eval(sig_b, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (!eval(sig_ci, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (!eval(sig_bi, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tRTLIL::SigSpec sig_x = cell->getPort(ID::X);\\n\\t\\t\\tRTLIL::SigSpec sig_co = cell->getPort(ID::CO);\\n\\n\\t\\t\\tbool any_input_undef = !(sig_a.is_fully_def() && sig_b.is_fully_def() && sig_ci.is_fully_def() && sig_bi.is_fully_def());\\n\\t\\t\\tsig_a.extend_u0(GetSize(sig_y), signed_a);\\n\\t\\t\\tsig_b.extend_u0(GetSize(sig_y), signed_b);\\n\\n\\t\\t\\tbool carry = sig_ci[0] == State::S1;\\n\\t\\t\\tbool b_inv = sig_bi[0] == State::S1;\\n\\n\\t\\t\\tfor (int i = 0; i < GetSize(sig_y); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tRTLIL::SigSpec x_inputs = { sig_a[i], sig_b[i], sig_bi[0] };\\n\\n\\t\\t\\t\\tif (!x_inputs.is_fully_def()) {\\n\\t\\t\\t\\t\\tset(sig_x[i], RTLIL::Sx);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbool bit_a = sig_a[i] == State::S1;\\n\\t\\t\\t\\t\\tbool bit_b = (sig_b[i] == State::S1) != b_inv;\\n\\t\\t\\t\\t\\tbool bit_x = bit_a != bit_b;\\n\\t\\t\\t\\t\\tset(sig_x[i], bit_x ? State::S1 : State::S0);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (any_input_undef) {\\n\\t\\t\\t\\t\\tset(sig_y[i], RTLIL::Sx);\\n\\t\\t\\t\\t\\tset(sig_co[i], RTLIL::Sx);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbool bit_a = sig_a[i] == State::S1;\\n\\t\\t\\t\\t\\tbool bit_b = (sig_b[i] == State::S1) != b_inv;\\n\\t\\t\\t\\t\\tbool bit_y = (bit_a != bit_b) != carry;\\n\\t\\t\\t\\t\\tcarry = (bit_a && bit_b) || (bit_a && carry) || (bit_b && carry);\\n\\t\\t\\t\\t\\tset(sig_y[i], bit_y ? State::S1 : State::S0);\\n\\t\\t\\t\\t\\tset(sig_co[i], carry ? State::S1 : State::S0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (cell->type == ID($macc))\\n\\t\\t{\\n\\t\\t\\tMacc macc;\\n\\t\\t\\tmacc.from_cell(cell);\\n\\n\\t\\t\\tif (!eval(macc.bit_ports, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tfor (auto &port : macc.ports) {\\n\\t\\t\\t\\tif (!eval(port.in_a, undef, cell))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tif (!eval(port.in_b, undef, cell))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tRTLIL::Const result(0, GetSize(cell->getPort(ID::Y)));\\n\\t\\t\\tif (!macc.eval(result))\\n\\t\\t\\t\\tlog_abort();\\n\\n\\t\\t\\tset(cell->getPort(ID::Y), result);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tRTLIL::SigSpec sig_c, sig_d;\\n\\n\\t\\t\\tif (cell->type.in(ID($_AOI3_), ID($_OAI3_), ID($_AOI4_), ID($_OAI4_))) {\\n\\t\\t\\t\\tif (cell->hasPort(ID::C))\\n\\t\\t\\t\\t\\tsig_c = cell->getPort(ID::C);\\n\\t\\t\\t\\tif (cell->hasPort(ID::D))\\n\\t\\t\\t\\t\\tsig_d = cell->getPort(ID::D);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (sig_a.size() > 0 && !eval(sig_a, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (sig_b.size() > 0 && !eval(sig_b, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (sig_c.size() > 0 && !eval(sig_c, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (sig_d.size() > 0 && !eval(sig_d, undef, cell))\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tbool eval_err = false;\\n\\t\\t\\tRTLIL::Const eval_ret = CellTypes::eval(cell, sig_a.as_const(), sig_b.as_const(), sig_c.as_const(), sig_d.as_const(), &eval_err);\\n\\n\\t\\t\\tif (eval_err)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tset(sig_y, eval_ret);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool eval(RTLIL::SigSpec &sig, RTLIL::SigSpec &undef, RTLIL::Cell *busy_cell = NULL)\\n\\t{\\n\\t\\tassign_map.apply(sig);\\n\\t\\tvalues_map.apply(sig);\\n\\n\\t\\tif (sig.is_fully_const())\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (stop_signals.check_any(sig)) {\\n\\t\\t\\tundef = stop_signals.extract(sig);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (busy_cell) {\\n\\t\\t\\tif (busy.count(busy_cell) > 0) {\\n\\t\\t\\t\\tundef = sig;\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tbusy.insert(busy_cell);\\n\\t\\t}\\n\\n\\t\\tstd::set<RTLIL::Cell*> driver_cells;\\n\\t\\tsig2driver.find(sig, driver_cells);\\n\\t\\tfor (auto cell : driver_cells) {\\n\\t\\t\\tif (!eval(cell, undef)) {\\n\\t\\t\\t\\tif (busy_cell)\\n\\t\\t\\t\\t\\tbusy.erase(busy_cell);\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (busy_cell)\\n\\t\\t\\tbusy.erase(busy_cell);\\n\\n\\t\\tvalues_map.apply(sig);\\n\\t\\tif (sig.is_fully_const())\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (defaultval != RTLIL::State::Sm) {\\n\\t\\t\\tfor (auto &bit : sig)\\n\\t\\t\\t\\tif (bit.wire) bit = defaultval;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (auto &c : sig.chunks())\\n\\t\\t\\tif (c.wire != NULL)\\n\\t\\t\\t\\tundef.append(c);\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool eval(RTLIL::SigSpec &sig)\\n\\t{\\n\\t\\tRTLIL::SigSpec undef;\\n\\t\\treturn eval(sig, undef);\\n\\t}\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"constids.inc\": \"X(A)\\nX(abc9_box)\\nX(abc9_box_id)\\nX(abc9_box_seq)\\nX(abc9_bypass)\\nX(abc9_carry)\\nX(abc9_flop)\\nX(abc9_keep)\\nX(abc9_lut)\\nX(abc9_mergeability)\\nX(abc9_scc_id)\\nX(abcgroup)\\nX(ABITS)\\nX(AD)\\nX(ADDR)\\nX(allconst)\\nX(allseq)\\nX(ALOAD)\\nX(ALOAD_POLARITY)\\nX(always_comb)\\nX(always_ff)\\nX(always_latch)\\nX(anyconst)\\nX(anyseq)\\nX(ARGS)\\nX(ARGS_WIDTH)\\nX(ARST)\\nX(ARST_POLARITY)\\nX(ARST_VALUE)\\nX(A_SIGNED)\\nX(A_WIDTH)\\nX(B)\\nX(BI)\\nX(BITS_USED)\\nX(blackbox)\\nX(B_SIGNED)\\nX(bugpoint_keep)\\nX(B_WIDTH)\\nX(BYTE)\\nX(C)\\nX(cells_not_processed)\\nX(CE_OVER_SRST)\\nX(CFG_ABITS)\\nX(CFG_DBITS)\\nX(CFG_INIT)\\nX(CI)\\nX(CLK)\\nX(clkbuf_driver)\\nX(clkbuf_inhibit)\\nX(clkbuf_inv)\\nX(clkbuf_sink)\\nX(CLK_ENABLE)\\nX(CLK_POLARITY)\\nX(CLR)\\nX(CLR_POLARITY)\\nX(CO)\\nX(COLLISION_X_MASK)\\nX(CONFIG)\\nX(CONFIG_WIDTH)\\nX(CTRL_IN)\\nX(CTRL_IN_WIDTH)\\nX(CTRL_OUT)\\nX(CTRL_OUT_WIDTH)\\nX(D)\\nX(DAT)\\nX(DATA)\\nX(DAT_DST_PEN)\\nX(DAT_DST_POL)\\nX(defaultvalue)\\nX(DELAY)\\nX(DEPTH)\\nX(DST)\\nX(DST_EN)\\nX(DST_PEN)\\nX(DST_POL)\\nX(DST_WIDTH)\\nX(dynports)\\nX(E)\\nX(EDGE_EN)\\nX(EDGE_POL)\\nX(EN)\\nX(EN_DST)\\nX(EN_POLARITY)\\nX(EN_SRC)\\nX(enum_base_type)\\nX(enum_type)\\nX(equiv_merged)\\nX(equiv_region)\\nX(extract_order)\\nX(F)\\nX(FLAVOR)\\nX(FORMAT)\\nX(force_downto)\\nX(force_upto)\\nX(fsm_encoding)\\nX(fsm_export)\\nX(FULL)\\nX(full_case)\\nX(G)\\nX(gclk)\\nX(gentb_clock)\\nX(gentb_constant)\\nX(gentb_skip)\\nX(H)\\nX(hdlname)\\nX(hierconn)\\nX(I)\\nX(INIT)\\nX(INIT_VALUE)\\nX(init)\\nX(initial_top)\\nX(interface_modport)\\nX(interfaces_replaced_in_module)\\nX(interface_type)\\nX(invertible_pin)\\nX(iopad_external_pin)\\nX(is_interface)\\nX(J)\\nX(K)\\nX(keep)\\nX(keep_hierarchy)\\nX(L)\\nX(lib_whitebox)\\nX(localparam)\\nX(logic_block)\\nX(lram)\\nX(LUT)\\nX(lut_keep)\\nX(M)\\nX(maximize)\\nX(mem2reg)\\nX(MEMID)\\nX(minimize)\\nX(module_not_derived)\\nX(N)\\nX(NAME)\\nX(noblackbox)\\nX(nolatches)\\nX(nomem2init)\\nX(nomem2reg)\\nX(nomeminit)\\nX(nosync)\\nX(nowrshmsk)\\nX(no_ram)\\nX(no_rw_check)\\nX(O)\\nX(OFFSET)\\nX(onehot)\\nX(P)\\nX(parallel_case)\\nX(parameter)\\nX(PORTID)\\nX(PRIORITY)\\nX(PRIORITY_MASK)\\nX(Q)\\nX(qwp_position)\\nX(R)\\nX(ram_block)\\nX(ram_style)\\nX(ramstyle)\\nX(RD_ADDR)\\nX(RD_ARST)\\nX(RD_ARST_VALUE)\\nX(RD_CE_OVER_SRST)\\nX(RD_CLK)\\nX(RD_CLK_ENABLE)\\nX(RD_CLK_POLARITY)\\nX(RD_COLLISION_X_MASK)\\nX(RD_DATA)\\nX(RD_EN)\\nX(RD_INIT_VALUE)\\nX(RD_PORTS)\\nX(RD_SRST)\\nX(RD_SRST_VALUE)\\nX(RD_TRANSPARENCY_MASK)\\nX(RD_TRANSPARENT)\\nX(RD_WIDE_CONTINUATION)\\nX(reg)\\nX(replaced_by_gclk)\\nX(reprocess_after)\\nX(rom_block)\\nX(rom_style)\\nX(romstyle)\\nX(S)\\nX(SET)\\nX(SET_POLARITY)\\nX(SIZE)\\nX(SRC)\\nX(src)\\nX(SRC_DST_PEN)\\nX(SRC_DST_POL)\\nX(SRC_EN)\\nX(SRC_PEN)\\nX(SRC_POL)\\nX(SRC_WIDTH)\\nX(SRST)\\nX(SRST_POLARITY)\\nX(SRST_VALUE)\\nX(sta_arrival)\\nX(STATE_BITS)\\nX(STATE_NUM)\\nX(STATE_NUM_LOG2)\\nX(STATE_RST)\\nX(STATE_TABLE)\\nX(smtlib2_module)\\nX(smtlib2_comb_expr)\\nX(submod)\\nX(syn_ramstyle)\\nX(syn_romstyle)\\nX(S_WIDTH)\\nX(T)\\nX(TABLE)\\nX(TAG)\\nX(techmap_autopurge)\\nX(_TECHMAP_BITS_CONNMAP_)\\nX(_TECHMAP_CELLNAME_)\\nX(_TECHMAP_CELLTYPE_)\\nX(techmap_celltype)\\nX(_TECHMAP_FAIL_)\\nX(techmap_maccmap)\\nX(_TECHMAP_REPLACE_)\\nX(techmap_simplemap)\\nX(_techmap_special_)\\nX(techmap_wrap)\\nX(T_FALL_MAX)\\nX(T_FALL_MIN)\\nX(T_FALL_TYP)\\nX(T_LIMIT)\\nX(T_LIMIT2)\\nX(T_LIMIT2_MAX)\\nX(T_LIMIT2_MIN)\\nX(T_LIMIT2_TYP)\\nX(T_LIMIT_MAX)\\nX(T_LIMIT_MIN)\\nX(T_LIMIT_TYP)\\nX(to_delete)\\nX(top)\\nX(TRANS_NUM)\\nX(TRANSPARENCY_MASK)\\nX(TRANSPARENT)\\nX(TRANS_TABLE)\\nX(TRG)\\nX(TRG_ENABLE)\\nX(TRG_POLARITY)\\nX(TRG_WIDTH)\\nX(T_RISE_MAX)\\nX(T_RISE_MIN)\\nX(T_RISE_TYP)\\nX(TYPE)\\nX(U)\\nX(unique)\\nX(unused_bits)\\nX(V)\\nX(via_celltype)\\nX(wand)\\nX(whitebox)\\nX(WIDTH)\\nX(wildcard_port_conns)\\nX(wiretype)\\nX(wor)\\nX(WORDS)\\nX(WR_ADDR)\\nX(WR_CLK)\\nX(WR_CLK_ENABLE)\\nX(WR_CLK_POLARITY)\\nX(WR_DATA)\\nX(WR_EN)\\nX(WR_PORTS)\\nX(WR_PRIORITY_MASK)\\nX(WR_WIDE_CONTINUATION)\\nX(X)\\nX(xprop_decoder)\\nX(Y)\\nX(Y_WIDTH)\\n\",\n                \"cost.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef COST_H\\n#define COST_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct CellCosts\\n{\\n\\tstatic const dict<RTLIL::IdString, int>& default_gate_cost() {\\n\\t\\tstatic const dict<RTLIL::IdString, int> db = {\\n\\t\\t\\t{ ID($_BUF_),    1 },\\n\\t\\t\\t{ ID($_NOT_),    2 },\\n\\t\\t\\t{ ID($_AND_),    4 },\\n\\t\\t\\t{ ID($_NAND_),   4 },\\n\\t\\t\\t{ ID($_OR_),     4 },\\n\\t\\t\\t{ ID($_NOR_),    4 },\\n\\t\\t\\t{ ID($_ANDNOT_), 4 },\\n\\t\\t\\t{ ID($_ORNOT_),  4 },\\n\\t\\t\\t{ ID($_XOR_),    5 },\\n\\t\\t\\t{ ID($_XNOR_),   5 },\\n\\t\\t\\t{ ID($_AOI3_),   6 },\\n\\t\\t\\t{ ID($_OAI3_),   6 },\\n\\t\\t\\t{ ID($_AOI4_),   7 },\\n\\t\\t\\t{ ID($_OAI4_),   7 },\\n\\t\\t\\t{ ID($_MUX_),    4 },\\n\\t\\t\\t{ ID($_NMUX_),   4 }\\n\\t\\t};\\n\\t\\treturn db;\\n\\t}\\n\\n\\tstatic const dict<RTLIL::IdString, int>& cmos_gate_cost() {\\n\\t\\tstatic const dict<RTLIL::IdString, int> db = {\\n\\t\\t\\t{ ID($_BUF_),     1 },\\n\\t\\t\\t{ ID($_NOT_),     2 },\\n\\t\\t\\t{ ID($_AND_),     6 },\\n\\t\\t\\t{ ID($_NAND_),    4 },\\n\\t\\t\\t{ ID($_OR_),      6 },\\n\\t\\t\\t{ ID($_NOR_),     4 },\\n\\t\\t\\t{ ID($_ANDNOT_),  6 },\\n\\t\\t\\t{ ID($_ORNOT_),   6 },\\n\\t\\t\\t{ ID($_XOR_),    12 },\\n\\t\\t\\t{ ID($_XNOR_),   12 },\\n\\t\\t\\t{ ID($_AOI3_),    6 },\\n\\t\\t\\t{ ID($_OAI3_),    6 },\\n\\t\\t\\t{ ID($_AOI4_),    8 },\\n\\t\\t\\t{ ID($_OAI4_),    8 },\\n\\t\\t\\t{ ID($_MUX_),    12 },\\n\\t\\t\\t{ ID($_NMUX_),   10 }\\n\\t\\t};\\n\\t\\treturn db;\\n\\t}\\n\\n\\tdict<RTLIL::IdString, int> mod_cost_cache;\\n\\tconst dict<RTLIL::IdString, int> *gate_cost = nullptr;\\n\\tDesign *design = nullptr;\\n\\n\\tint get(RTLIL::IdString type) const\\n\\t{\\n\\t\\tif (gate_cost && gate_cost->count(type))\\n\\t\\t\\treturn gate_cost->at(type);\\n\\n\\t\\tlog_warning(\\\"Can't determine cost of %s cell.\\\\n\\\", log_id(type));\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tint get(RTLIL::Cell *cell)\\n\\t{\\n\\t\\tif (gate_cost && gate_cost->count(cell->type))\\n\\t\\t\\treturn gate_cost->at(cell->type);\\n\\n\\t\\tif (design && design->module(cell->type) && cell->parameters.empty())\\n\\t\\t{\\n\\t\\t\\tRTLIL::Module *mod = design->module(cell->type);\\n\\n\\t\\t\\tif (mod->attributes.count(ID(cost)))\\n\\t\\t\\t\\treturn mod->attributes.at(ID(cost)).as_int();\\n\\n\\t\\t\\tif (mod_cost_cache.count(mod->name))\\n\\t\\t\\t\\treturn mod_cost_cache.at(mod->name);\\n\\n\\t\\t\\tint module_cost = 1;\\n\\t\\t\\tfor (auto c : mod->cells())\\n\\t\\t\\t\\tmodule_cost += get(c);\\n\\n\\t\\t\\tmod_cost_cache[mod->name] = module_cost;\\n\\t\\t\\treturn module_cost;\\n\\t\\t}\\n\\n\\t\\tlog_warning(\\\"Can't determine cost of %s cell (%d parameters).\\\\n\\\", log_id(cell->type), GetSize(cell->parameters));\\n\\t\\treturn 1;\\n\\t}\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"ff.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2020  Marcelina Kościelnicka <mwk@0x04.net>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef FF_H\\n#define FF_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n#include \\\"kernel/ffinit.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\n// Describes a flip-flop or a latch.\\n//\\n// If has_gclk, this is a formal verification FF with implicit global clock:\\n// Q is simply previous cycle's D. Additionally if is_anyinit is true, this is\\n// an $anyinit cell which always has an undefined initialization value. Note\\n// that $anyinit is not considered to be among the FF celltypes, so a pass has\\n// to explicitly opt-in to process $anyinit cells with FfData.\\n//\\n// Otherwise, the FF/latch can have any number of features selected by has_*\\n// attributes that determine Q's value (in order of decreasing priority):\\n//\\n// - on start, register is initialized to val_init\\n// - if has_sr is present:\\n//   - sig_clr is per-bit async clear, and sets the corresponding bit to 0\\n//     if active\\n//   - sig_set is per-bit async set, and sets the corresponding bit to 1\\n//     if active\\n// - if has_arst is present:\\n//   - sig_arst is whole-reg async reset, and sets the whole register to val_arst\\n// - if has_aload is present:\\n//   - sig_aload is whole-reg async load (aka latch gate enable), and sets the whole\\n//     register to sig_ad\\n// - if has_clk is present, and we're currently on a clock edge:\\n//   - if has_ce is present and ce_over_srst is true:\\n//     - ignore clock edge (don't change value) unless sig_ce is active\\n//   - if has_srst is present:\\n//     - sig_srst is whole-reg sync reset and sets the register to val_srst\\n//   - if has_ce is present and ce_over_srst is false:\\n//     - ignore clock edge (don't change value) unless sig_ce is active\\n//   - set whole reg to sig_d\\n// - if nothing of the above applies, the reg value remains unchanged\\n//\\n// Since the yosys FF cell library isn't fully generic, not all combinations\\n// of the features above can be supported:\\n//\\n// - only one of has_srst, has_arst, has_sr can be used\\n// - if has_clk is used together with has_aload, then has_srst, has_arst,\\n//   has_sr cannot be used\\n//\\n// The valid feature combinations are thus:\\n//\\n// - has_clk + optional has_ce [dff/dffe]\\n// - has_clk + optional has_ce + has_arst [adff/adffe]\\n// - has_clk + optional has_ce + has_aload [aldff/aldffe]\\n// - has_clk + optional has_ce + has_sr [dffsr/dffsre]\\n// - has_clk + optional has_ce + has_srst [sdff/sdffe/sdffce]\\n// - has_aload [dlatch]\\n// - has_aload + has_arst [adlatch]\\n// - has_aload + has_sr [dlatchsr]\\n// - has_sr [sr]\\n// - has_arst [does not correspond to a native cell, represented as dlatch with const D input]\\n// - empty set [not a cell — will be emitted as a simple direct connection]\\n\\nstruct FfData {\\n\\tModule *module;\\n\\tFfInitVals *initvals;\\n\\tCell *cell;\\n\\tIdString name;\\n\\t// The FF output.\\n\\tSigSpec sig_q;\\n\\t// The sync data input, present if has_clk or has_gclk.\\n\\tSigSpec sig_d;\\n\\t// The async data input, present if has_aload.\\n\\tSigSpec sig_ad;\\n\\t// The sync clock, present if has_clk.\\n\\tSigSpec sig_clk;\\n\\t// The clock enable, present if has_ce.\\n\\tSigSpec sig_ce;\\n\\t// The async load enable, present if has_aload.\\n\\tSigSpec sig_aload;\\n\\t// The async reset, preset if has_arst.\\n\\tSigSpec sig_arst;\\n\\t// The sync reset, preset if has_srst.\\n\\tSigSpec sig_srst;\\n\\t// The async clear (per-lane), present if has_sr.\\n\\tSigSpec sig_clr;\\n\\t// The async set (per-lane), present if has_sr.\\n\\tSigSpec sig_set;\\n\\t// True if this is a clocked (edge-sensitive) flip-flop.\\n\\tbool has_clk;\\n\\t// True if this is a $ff, exclusive with every other has_*.\\n\\tbool has_gclk;\\n\\t// True if this FF has a clock enable.  Depends on has_clk.\\n\\tbool has_ce;\\n\\t// True if this FF has async load function — this includes D latches.\\n\\t// If this and has_clk are both set, has_arst and has_sr cannot be set.\\n\\tbool has_aload;\\n\\t// True if this FF has sync set/reset.  Depends on has_clk, exclusive\\n\\t// with has_arst, has_sr, has_aload.\\n\\tbool has_srst;\\n\\t// True if this FF has async set/reset.  Exclusive with has_srst,\\n\\t// has_sr.  If this and has_clk are both set, has_aload cannot be set.\\n\\tbool has_arst;\\n\\t// True if this FF has per-bit async set + clear.  Exclusive with\\n\\t// has_srst, has_arst.  If this and has_clk are both set, has_aload\\n\\t// cannot be set.\\n\\tbool has_sr;\\n\\t// If has_ce and has_srst are both set, determines their relative\\n\\t// priorities: if true, inactive ce disables srst; if false, srst\\n\\t// operates independent of ce.\\n\\tbool ce_over_srst;\\n\\t// True if this FF is a fine cell, false if it is a coarse cell.\\n\\t// If true, width must be 1.\\n\\tbool is_fine;\\n\\t// True if this FF is an $anyinit cell.  Depends on has_gclk.\\n\\tbool is_anyinit;\\n\\t// Polarities, corresponding to sig_*.  True means active-high, false\\n\\t// means active-low.\\n\\tbool pol_clk;\\n\\tbool pol_ce;\\n\\tbool pol_aload;\\n\\tbool pol_arst;\\n\\tbool pol_srst;\\n\\tbool pol_clr;\\n\\tbool pol_set;\\n\\t// The value loaded by sig_arst.\\n\\tConst val_arst;\\n\\t// The value loaded by sig_srst.\\n\\tConst val_srst;\\n\\t// The initial value at power-up.\\n\\tConst val_init;\\n\\t// The FF data width in bits.\\n\\tint width;\\n\\tdict<IdString, Const> attributes;\\n\\n\\tFfData(Module *module = nullptr, FfInitVals *initvals = nullptr, IdString name = IdString()) : module(module), initvals(initvals), cell(nullptr), name(name) {\\n\\t\\twidth = 0;\\n\\t\\thas_clk = false;\\n\\t\\thas_gclk = false;\\n\\t\\thas_ce = false;\\n\\t\\thas_aload = false;\\n\\t\\thas_srst = false;\\n\\t\\thas_arst = false;\\n\\t\\thas_sr = false;\\n\\t\\tce_over_srst = false;\\n\\t\\tis_fine = false;\\n\\t\\tis_anyinit = false;\\n\\t\\tpol_clk = false;\\n\\t\\tpol_aload = false;\\n\\t\\tpol_ce = false;\\n\\t\\tpol_arst = false;\\n\\t\\tpol_srst = false;\\n\\t\\tpol_clr = false;\\n\\t\\tpol_set = false;\\n\\t}\\n\\n\\tFfData(FfInitVals *initvals, Cell *cell_);\\n\\n\\t// Returns a FF identical to this one, but only keeping bit indices from the argument.\\n\\tFfData slice(const std::vector<int> &bits);\\n\\n\\tvoid add_dummy_ce();\\n\\tvoid add_dummy_srst();\\n\\tvoid add_dummy_arst();\\n\\tvoid add_dummy_aload();\\n\\tvoid add_dummy_sr();\\n\\tvoid add_dummy_clk();\\n\\n\\tvoid arst_to_aload();\\n\\tvoid arst_to_sr();\\n\\n\\tvoid aload_to_sr();\\n\\n\\t// Given a FF with both has_ce and has_srst, sets ce_over_srst to the given value and\\n\\t// fixes up control signals appropriately to preserve semantics.\\n\\tvoid convert_ce_over_srst(bool val);\\n\\n\\tvoid unmap_ce();\\n\\tvoid unmap_srst();\\n\\n\\tvoid unmap_ce_srst() {\\n\\t\\tunmap_ce();\\n\\t\\tunmap_srst();\\n\\t}\\n\\n\\tCell *emit();\\n\\n\\t// Removes init attribute from the Q output, but keeps val_init unchanged.\\n\\t// It will be automatically reattached on emit.  Use this before changing sig_q.\\n\\tvoid remove_init() {\\n\\t\\tif (initvals)\\n\\t\\t\\tinitvals->remove_init(sig_q);\\n\\t}\\n\\n\\tvoid remove();\\n\\n\\t// Flip the sense of the given bit slices of the FF: insert inverters on data\\n\\t// inputs and output, flip the corresponding init/reset bits, swap clr/set\\n\\t// inputs with proper priority fix.\\n\\tvoid flip_bits(const pool<int> &bits);\\n\\n\\tvoid flip_rst_bits(const pool<int> &bits);\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"ffinit.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2020  Marcelina Kościelnicka <mwk@0x04.net>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef FFINIT_H\\n#define FFINIT_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n#include \\\"kernel/sigtools.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct FfInitVals\\n{\\n\\tconst SigMap *sigmap;\\n\\tdict<SigBit, std::pair<State,SigBit>> initbits;\\n\\n\\tvoid set(const SigMap *sigmap_, RTLIL::Module *module)\\n\\t{\\n\\t\\tsigmap = sigmap_;\\n\\t\\tinitbits.clear();\\n\\t\\tfor (auto wire : module->wires())\\n\\t\\t{\\n\\t\\t\\tif (wire->attributes.count(ID::init) == 0)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tSigSpec wirebits = (*sigmap)(wire);\\n\\t\\t\\tConst initval = wire->attributes.at(ID::init);\\n\\n\\t\\t\\tfor (int i = 0; i < GetSize(wirebits) && i < GetSize(initval); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSigBit bit = wirebits[i];\\n\\t\\t\\t\\tState val = initval[i];\\n\\n\\t\\t\\t\\tif (val != State::S0 && val != State::S1 && bit.wire != nullptr)\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (initbits.count(bit)) {\\n\\t\\t\\t\\t\\tif (initbits.at(bit).first != val)\\n\\t\\t\\t\\t\\t\\tlog_error(\\\"Conflicting init values for signal %s (%s = %s != %s).\\\\n\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\tlog_signal(bit), log_signal(SigBit(wire, i)),\\n\\t\\t\\t\\t\\t\\t\\t\\tlog_signal(val), log_signal(initbits.at(bit).first));\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinitbits[bit] = std::make_pair(val,SigBit(wire,i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tRTLIL::State operator()(RTLIL::SigBit bit) const\\n\\t{\\n\\t\\tauto it = initbits.find((*sigmap)(bit));\\n\\t\\tif (it != initbits.end())\\n\\t\\t\\treturn it->second.first;\\n\\t\\telse\\n\\t\\t\\treturn State::Sx;\\n\\t}\\n\\n\\tRTLIL::Const operator()(const RTLIL::SigSpec &sig) const\\n\\t{\\n\\t\\tRTLIL::Const res;\\n\\t\\tfor (auto bit : sig)\\n\\t\\t\\tres.bits.push_back((*this)(bit));\\n\\t\\treturn res;\\n\\t}\\n\\n\\tvoid set_init(RTLIL::SigBit bit, RTLIL::State val)\\n\\t{\\n\\t\\tSigBit mbit = (*sigmap)(bit);\\n\\t\\tSigBit abit = bit;\\n\\t\\tauto it = initbits.find(mbit);\\n\\t\\tif (it != initbits.end())\\n\\t\\t\\tabit = it->second.second;\\n\\t\\telse if (val == State::Sx)\\n\\t\\t\\treturn;\\n\\t\\tlog_assert(abit.wire);\\n\\t\\tinitbits[mbit] = std::make_pair(val,abit);\\n\\t\\tauto it2 = abit.wire->attributes.find(ID::init);\\n\\t\\tif (it2 != abit.wire->attributes.end()) {\\n\\t\\t\\tit2->second[abit.offset] = val;\\n\\t\\t\\tif (it2->second.is_fully_undef())\\n\\t\\t\\t\\tabit.wire->attributes.erase(it2);\\n\\t\\t} else if (val != State::Sx) {\\n\\t\\t\\tConst cval(State::Sx, GetSize(abit.wire));\\n\\t\\t\\tcval[abit.offset] = val;\\n\\t\\t\\tabit.wire->attributes[ID::init] = cval;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid set_init(const RTLIL::SigSpec &sig, RTLIL::Const val)\\n\\t{\\n\\t\\tlog_assert(GetSize(sig) == GetSize(val));\\n\\t\\tfor (int i = 0; i < GetSize(sig); i++)\\n\\t\\t\\tset_init(sig[i], val[i]);\\n\\t}\\n\\n\\tvoid remove_init(RTLIL::SigBit bit)\\n\\t{\\n\\t\\tset_init(bit, State::Sx);\\n\\t}\\n\\n\\tvoid remove_init(const RTLIL::SigSpec &sig)\\n\\t{\\n\\t\\tfor (auto bit : sig)\\n\\t\\t\\tremove_init(bit);\\n\\t}\\n\\n\\tvoid clear()\\n\\t{\\n\\t\\tinitbits.clear();\\n\\t}\\n\\n\\tFfInitVals (const SigMap *sigmap, RTLIL::Module *module)\\n\\t{\\n\\t\\tset(sigmap, module);\\n\\t}\\n\\n\\tFfInitVals () {}\\n};\\n\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"ffmerge.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2021  Marcelina Kościelnicka <mwk@0x04.net>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef FFMERGE_H\\n#define FFMERGE_H\\n\\n#include \\\"kernel/ffinit.h\\\"\\n#include \\\"kernel/ff.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\n// A helper class for passes that want to merge FFs on the input or output\\n// of a cell into the cell itself.\\n//\\n// The procedure is:\\n//\\n// 1. Construct this class (at beginning of processing for a given module).\\n// 2. For every considered cell:\\n//\\n//    a. Call find_output_ff for every considered output.\\n//    b. Call find_input_ff for every considered input.\\n//    c. Look at the FF description returned (if any) from each call, reject\\n//       results that cannot be merged into given cell for any reason.\\n//       If both inputs and outputs are being merged, take care of FF bits that\\n//       are returned in both input and output results (a FF bit cannot be\\n//       merged to both).  Decide on the final set of FF bits to merge.\\n//    d. Call remove_output_ff for every find_output_ff result that will be used\\n//       for merging.  This removes the actual FF bits from design and from index.\\n//    e. Call mark_input_ff for every find_input_ff result that will be used\\n//       for merging.  This updates the index disallowing further usage of these\\n//       FF bits for output FF merging, if they were eligible before.  The actual\\n//       FF bits are still left in the design and can be merged into other inputs.\\n//       If the FF bits are not otherwise used, they will be removed by later\\n//       opt passes.\\n//    f. Merge the FFs into the cell.\\n//\\n// Note that, if both inputs and outputs are being considered for merging in\\n// a single pass, the result may be nondeterministic (depending on cell iteration\\n// order) because a given FF bit could be eligible for both input and output merge,\\n// perhaps in different cells.  For this reason, it may be a good idea to separate\\n// input and output merging.\\n\\nstruct FfMergeHelper\\n{\\n\\tconst SigMap *sigmap;\\n\\tRTLIL::Module *module;\\n\\tFfInitVals *initvals;\\n\\n\\tdict<SigBit, std::pair<Cell*, int>> dff_driver;\\n\\tdict<SigBit, pool<std::pair<Cell*, int>>> dff_sink;\\n\\tdict<SigBit, int> sigbit_users_count;\\n\\n\\t// Returns true if all bits in sig are completely unused.\\n\\tbool is_output_unused(RTLIL::SigSpec sig);\\n\\n\\t// Finds the FF to merge into a given cell output.  Takes sig, which\\n\\t// is the current cell output — it will be the sig_d of the found FF.\\n\\t// If found, returns true, and fills the two output arguments.\\n\\t//\\n\\t// For every bit of sig, this function finds a FF bit that has\\n\\t// the same sig_d, and fills the output FfData according to the FF\\n\\t// bits found.  This function will only consider FF bits that are\\n\\t// the only user of the given sig bits — if any bit in sig is used\\n\\t// by anything other than a single FF, this function will return false.\\n\\t//\\n\\t// The returned FfData structure does not correspond to any actual FF\\n\\t// cell in the design — it is the amalgamation of extracted FF bits,\\n\\t// possibly coming from several FF cells.\\n\\t//\\n\\t// If some of the bits in sig have no users at all, this function\\n\\t// will accept them as well (and fill returned FfData with dummy values\\n\\t// for the given bit, effectively synthesizing an unused FF bit of the\\n\\t// appropriate type).  However, if all bits in sig are completely\\n\\t// unused, this function will fail and return false (having no idea\\n\\t// what kind of FF to produce) — use the above helper if that case\\n\\t// is important to handle.\\n\\t//\\n\\t// Note that this function does not remove the FF bits returned from\\n\\t// the design — this is so that the caller can decide whether to accept\\n\\t// this FF for merging or not.  If the result is accepted,\\n\\t// remove_output_ff should be called on the second output argument.\\n\\tbool find_output_ff(RTLIL::SigSpec sig, FfData &ff, pool<std::pair<Cell *, int>> &bits);\\n\\n\\t// Like above, but returns a FF to merge into a given cell input.  Takes\\n\\t// sig_q, which is the current cell input — it will search for FFs with\\n\\t// matching sig_q.\\n\\t//\\n\\t// As opposed to find_output_ff, this function doesn't care about usage\\n\\t// counts, and may return FF bits that also have other fanout.  This\\n\\t// should not be a problem for input FF merging.\\n\\t//\\n\\t// As a special case, if some of the bits in sig_q are constant, this\\n\\t// function will accept them as well, by synthesizing in-place\\n\\t// a constant-input FF bit (with matching initial value and reset value).\\n\\t// However, this will not work if the input is all-constant — if the caller\\n\\t// cares about this case, it needs to check for it explicitely.\\n\\tbool find_input_ff(RTLIL::SigSpec sig, FfData &ff, pool<std::pair<Cell *, int>> &bits);\\n\\n\\t// To be called on find_output_ff result that will be merged.  This\\n\\t// marks the given FF bits as used up (and not to be considered for\\n\\t// further merging as inputs), and reconnects their Q ports to a dummy\\n\\t// wire (since the wire previously connected there will now be driven\\n\\t// by the merged-to cell instead).\\n\\tvoid remove_output_ff(const pool<std::pair<Cell *, int>> &bits);\\n\\n\\t// To be called on find_input_ff result that will be merged.  This\\n\\t// marks the given FF bits as used, and disallows merging them as\\n\\t// outputs.  They can, however, still be merged as inputs again\\n\\t// (perhaps for another cell).\\n\\tvoid mark_input_ff(const pool<std::pair<Cell *, int>> &bits);\\n\\n\\tvoid set(FfInitVals *initvals_, RTLIL::Module *module_);\\n\\n\\tvoid clear();\\n\\n\\tFfMergeHelper(FfInitVals *initvals, RTLIL::Module *module) {\\n\\t\\tset(initvals, module);\\n\\t}\\n\\n\\tFfMergeHelper() {}\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"fmt.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2020  whitequark <whitequark@whitequark.org>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef FMT_H\\n#define FMT_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\n// Verilog format argument, such as the arguments in:\\n//   $display(\\\"foo %d bar %01x\\\", 4'b0, $signed(2'b11))\\nstruct VerilogFmtArg {\\n\\tenum {\\n\\t\\tSTRING  = 0,\\n\\t\\tINTEGER = 1,\\n\\t\\tTIME    = 2,\\n\\t} type;\\n\\n\\t// All types\\n\\tstd::string filename;\\n\\tunsigned first_line;\\n\\n\\t// STRING type\\n\\tstd::string str;\\n\\n\\t// INTEGER type\\n\\tRTLIL::SigSpec sig;\\n\\tbool signed_ = false;\\n\\n\\t// TIME type\\n\\tbool realtime = false;\\n};\\n\\n// RTLIL format part, such as the substitutions in:\\n//   \\\"foo {4:> 4du} bar {2:<01hs}\\\"\\n// Must be kept in sync with `struct fmt_part` in backends/cxxrtl/runtime/cxxrtl/cxxrtl.h!\\nstruct FmtPart {\\n\\tenum {\\n\\t\\tLITERAL  \\t= 0,\\n\\t\\tINTEGER \\t= 1,\\n\\t\\tSTRING    = 2,\\n\\t\\tUNICHAR   = 3,\\n\\t\\tVLOG_TIME = 4,\\n\\t} type;\\n\\n\\t// LITERAL type\\n\\tstd::string str;\\n\\n\\t// INTEGER/STRING/UNICHAR types\\n\\tRTLIL::SigSpec sig;\\n\\n\\t// INTEGER/STRING/VLOG_TIME types\\n\\tenum {\\n\\t\\tRIGHT\\t= 0,\\n\\t\\tLEFT\\t= 1,\\n\\t\\tNUMERIC\\t= 2,\\n\\t} justify = RIGHT;\\n\\tchar padding = '\\\\0';\\n\\tsize_t width = 0;\\n\\n\\t// INTEGER type\\n\\tunsigned base = 10;\\n\\tbool signed_ = false;\\n\\tenum {\\n\\t\\tMINUS\\t\\t= 0,\\n\\t\\tPLUS_MINUS\\t= 1,\\n\\t\\tSPACE_MINUS\\t= 2,\\n\\t} sign = MINUS;\\n\\tbool hex_upper = false;\\n\\tbool show_base = false;\\n\\tbool group = false;\\n\\n\\t// VLOG_TIME type\\n\\tbool realtime = false;\\n};\\n\\nstruct Fmt {\\npublic:\\n\\tstd::vector<FmtPart> parts;\\n\\n\\tvoid append_literal(const std::string &str);\\n\\n\\tvoid parse_rtlil(const RTLIL::Cell *cell);\\n\\tvoid emit_rtlil(RTLIL::Cell *cell) const;\\n\\n\\tvoid parse_verilog(const std::vector<VerilogFmtArg> &args, bool sformat_like, int default_base, RTLIL::IdString task_name, RTLIL::IdString module_name);\\n\\tstd::vector<VerilogFmtArg> emit_verilog() const;\\n\\n\\tvoid emit_cxxrtl(std::ostream &os, std::string indent, std::function<void(const RTLIL::SigSpec &)> emit_sig, const std::string &context) const;\\n\\n\\tstd::string render() const;\\n\\nprivate:\\n\\tvoid apply_verilog_automatic_sizing_and_add(FmtPart &part);\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"hashlib.h\": \"// This is free and unencumbered software released into the public domain.\\n//\\n// Anyone is free to copy, modify, publish, use, compile, sell, or\\n// distribute this software, either in source code form or as a compiled\\n// binary, for any purpose, commercial or non-commercial, and by any\\n// means.\\n\\n// -------------------------------------------------------\\n// Written by Claire Xenia Wolf <claire@yosyshq.com> in 2014\\n// -------------------------------------------------------\\n\\n#ifndef HASHLIB_H\\n#define HASHLIB_H\\n\\n#include <stdexcept>\\n#include <algorithm>\\n#include <string>\\n#include <vector>\\n\\n#include <stdint.h>\\n\\nnamespace hashlib {\\n\\nconst int hashtable_size_trigger = 2;\\nconst int hashtable_size_factor = 3;\\n\\n// The XOR version of DJB2\\ninline unsigned int mkhash(unsigned int a, unsigned int b) {\\n\\treturn ((a << 5) + a) ^ b;\\n}\\n\\n// traditionally 5381 is used as starting value for the djb2 hash\\nconst unsigned int mkhash_init = 5381;\\n\\n// The ADD version of DJB2\\n// (use this version for cache locality in b)\\ninline unsigned int mkhash_add(unsigned int a, unsigned int b) {\\n\\treturn ((a << 5) + a) + b;\\n}\\n\\ninline unsigned int mkhash_xorshift(unsigned int a) {\\n\\tif (sizeof(a) == 4) {\\n\\t\\ta ^= a << 13;\\n\\t\\ta ^= a >> 17;\\n\\t\\ta ^= a << 5;\\n\\t} else if (sizeof(a) == 8) {\\n\\t\\ta ^= a << 13;\\n\\t\\ta ^= a >> 7;\\n\\t\\ta ^= a << 17;\\n\\t} else\\n\\t\\tthrow std::runtime_error(\\\"mkhash_xorshift() only implemented for 32 bit and 64 bit ints\\\");\\n\\treturn a;\\n}\\n\\ntemplate<typename T> struct hash_ops {\\n\\tstatic inline bool cmp(const T &a, const T &b) {\\n\\t\\treturn a == b;\\n\\t}\\n\\tstatic inline unsigned int hash(const T &a) {\\n\\t\\treturn a.hash();\\n\\t}\\n};\\n\\nstruct hash_int_ops {\\n\\ttemplate<typename T>\\n\\tstatic inline bool cmp(T a, T b) {\\n\\t\\treturn a == b;\\n\\t}\\n};\\n\\ntemplate<> struct hash_ops<bool> : hash_int_ops\\n{\\n\\tstatic inline unsigned int hash(bool a) {\\n\\t\\treturn a ? 1 : 0;\\n\\t}\\n};\\ntemplate<> struct hash_ops<int32_t> : hash_int_ops\\n{\\n\\tstatic inline unsigned int hash(int32_t a) {\\n\\t\\treturn a;\\n\\t}\\n};\\ntemplate<> struct hash_ops<int64_t> : hash_int_ops\\n{\\n\\tstatic inline unsigned int hash(int64_t a) {\\n\\t\\treturn mkhash((unsigned int)(a), (unsigned int)(a >> 32));\\n\\t}\\n};\\ntemplate<> struct hash_ops<uint32_t> : hash_int_ops\\n{\\n\\tstatic inline unsigned int hash(uint32_t a) {\\n\\t\\treturn a;\\n\\t}\\n};\\ntemplate<> struct hash_ops<uint64_t> : hash_int_ops\\n{\\n\\tstatic inline unsigned int hash(uint64_t a) {\\n\\t\\treturn mkhash((unsigned int)(a), (unsigned int)(a >> 32));\\n\\t}\\n};\\n\\ntemplate<> struct hash_ops<std::string> {\\n\\tstatic inline bool cmp(const std::string &a, const std::string &b) {\\n\\t\\treturn a == b;\\n\\t}\\n\\tstatic inline unsigned int hash(const std::string &a) {\\n\\t\\tunsigned int v = 0;\\n\\t\\tfor (auto c : a)\\n\\t\\t\\tv = mkhash(v, c);\\n\\t\\treturn v;\\n\\t}\\n};\\n\\ntemplate<typename P, typename Q> struct hash_ops<std::pair<P, Q>> {\\n\\tstatic inline bool cmp(std::pair<P, Q> a, std::pair<P, Q> b) {\\n\\t\\treturn a == b;\\n\\t}\\n\\tstatic inline unsigned int hash(std::pair<P, Q> a) {\\n\\t\\treturn mkhash(hash_ops<P>::hash(a.first), hash_ops<Q>::hash(a.second));\\n\\t}\\n};\\n\\ntemplate<typename... T> struct hash_ops<std::tuple<T...>> {\\n\\tstatic inline bool cmp(std::tuple<T...> a, std::tuple<T...> b) {\\n\\t\\treturn a == b;\\n\\t}\\n\\ttemplate<size_t I = 0>\\n\\tstatic inline typename std::enable_if<I == sizeof...(T), unsigned int>::type hash(std::tuple<T...>) {\\n\\t\\treturn mkhash_init;\\n\\t}\\n\\ttemplate<size_t I = 0>\\n\\tstatic inline typename std::enable_if<I != sizeof...(T), unsigned int>::type hash(std::tuple<T...> a) {\\n\\t\\ttypedef hash_ops<typename std::tuple_element<I, std::tuple<T...>>::type> element_ops_t;\\n\\t\\treturn mkhash(hash<I+1>(a), element_ops_t::hash(std::get<I>(a)));\\n\\t}\\n};\\n\\ntemplate<typename T> struct hash_ops<std::vector<T>> {\\n\\tstatic inline bool cmp(std::vector<T> a, std::vector<T> b) {\\n\\t\\treturn a == b;\\n\\t}\\n\\tstatic inline unsigned int hash(std::vector<T> a) {\\n\\t\\tunsigned int h = mkhash_init;\\n\\t\\tfor (auto k : a)\\n\\t\\t\\th = mkhash(h, hash_ops<T>::hash(k));\\n\\t\\treturn h;\\n\\t}\\n};\\n\\nstruct hash_cstr_ops {\\n\\tstatic inline bool cmp(const char *a, const char *b) {\\n\\t\\tfor (int i = 0; a[i] || b[i]; i++)\\n\\t\\t\\tif (a[i] != b[i])\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n\\tstatic inline unsigned int hash(const char *a) {\\n\\t\\tunsigned int hash = mkhash_init;\\n\\t\\twhile (*a)\\n\\t\\t\\thash = mkhash(hash, *(a++));\\n\\t\\treturn hash;\\n\\t}\\n};\\n\\nstruct hash_ptr_ops {\\n\\tstatic inline bool cmp(const void *a, const void *b) {\\n\\t\\treturn a == b;\\n\\t}\\n\\tstatic inline unsigned int hash(const void *a) {\\n\\t\\treturn (uintptr_t)a;\\n\\t}\\n};\\n\\nstruct hash_obj_ops {\\n\\tstatic inline bool cmp(const void *a, const void *b) {\\n\\t\\treturn a == b;\\n\\t}\\n\\ttemplate<typename T>\\n\\tstatic inline unsigned int hash(const T *a) {\\n\\t\\treturn a ? a->hash() : 0;\\n\\t}\\n};\\n\\ntemplate<typename T>\\ninline unsigned int mkhash(const T &v) {\\n\\treturn hash_ops<T>().hash(v);\\n}\\n\\ninline int hashtable_size(int min_size)\\n{\\n\\tstatic std::vector<int> zero_and_some_primes = {\\n\\t\\t0, 23, 29, 37, 47, 59, 79, 101, 127, 163, 211, 269, 337, 431, 541, 677,\\n\\t\\t853, 1069, 1361, 1709, 2137, 2677, 3347, 4201, 5261, 6577, 8231, 10289,\\n\\t\\t12889, 16127, 20161, 25219, 31531, 39419, 49277, 61603, 77017, 96281,\\n\\t\\t120371, 150473, 188107, 235159, 293957, 367453, 459317, 574157, 717697,\\n\\t\\t897133, 1121423, 1401791, 1752239, 2190299, 2737937, 3422429, 4278037,\\n\\t\\t5347553, 6684443, 8355563, 10444457, 13055587, 16319519, 20399411,\\n\\t\\t25499291, 31874149, 39842687, 49803361, 62254207, 77817767, 97272239,\\n\\t\\t121590311, 151987889, 189984863, 237481091, 296851369, 371064217\\n\\t};\\n\\n\\tfor (auto p : zero_and_some_primes)\\n\\t\\tif (p >= min_size) return p;\\n\\n\\tif (sizeof(int) == 4)\\n\\t\\tthrow std::length_error(\\\"hash table exceeded maximum size.\\\\nDesign is likely too large for yosys to handle, if possible try not to flatten the design.\\\");\\n\\n\\tfor (auto p : zero_and_some_primes)\\n\\t\\tif (100129 * p > min_size) return 100129 * p;\\n\\n\\tthrow std::length_error(\\\"hash table exceeded maximum size.\\\");\\n}\\n\\ntemplate<typename K, typename T, typename OPS = hash_ops<K>> class dict;\\ntemplate<typename K, int offset = 0, typename OPS = hash_ops<K>> class idict;\\ntemplate<typename K, typename OPS = hash_ops<K>> class pool;\\ntemplate<typename K, typename OPS = hash_ops<K>> class mfp;\\n\\ntemplate<typename K, typename T, typename OPS>\\nclass dict\\n{\\n\\tstruct entry_t\\n\\t{\\n\\t\\tstd::pair<K, T> udata;\\n\\t\\tint next;\\n\\n\\t\\tentry_t() { }\\n\\t\\tentry_t(const std::pair<K, T> &udata, int next) : udata(udata), next(next) { }\\n\\t\\tentry_t(std::pair<K, T> &&udata, int next) : udata(std::move(udata)), next(next) { }\\n\\t\\tbool operator<(const entry_t &other) const { return udata.first < other.udata.first; }\\n\\t};\\n\\n\\tstd::vector<int> hashtable;\\n\\tstd::vector<entry_t> entries;\\n\\tOPS ops;\\n\\n#ifdef NDEBUG\\n\\tstatic inline void do_assert(bool) { }\\n#else\\n\\tstatic inline void do_assert(bool cond) {\\n\\t\\tif (!cond) throw std::runtime_error(\\\"dict<> assert failed.\\\");\\n\\t}\\n#endif\\n\\n\\tint do_hash(const K &key) const\\n\\t{\\n\\t\\tunsigned int hash = 0;\\n\\t\\tif (!hashtable.empty())\\n\\t\\t\\thash = ops.hash(key) % (unsigned int)(hashtable.size());\\n\\t\\treturn hash;\\n\\t}\\n\\n\\tvoid do_rehash()\\n\\t{\\n\\t\\thashtable.clear();\\n\\t\\thashtable.resize(hashtable_size(entries.capacity() * hashtable_size_factor), -1);\\n\\n\\t\\tfor (int i = 0; i < int(entries.size()); i++) {\\n\\t\\t\\tdo_assert(-1 <= entries[i].next && entries[i].next < int(entries.size()));\\n\\t\\t\\tint hash = do_hash(entries[i].udata.first);\\n\\t\\t\\tentries[i].next = hashtable[hash];\\n\\t\\t\\thashtable[hash] = i;\\n\\t\\t}\\n\\t}\\n\\n\\tint do_erase(int index, int hash)\\n\\t{\\n\\t\\tdo_assert(index < int(entries.size()));\\n\\t\\tif (hashtable.empty() || index < 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint k = hashtable[hash];\\n\\t\\tdo_assert(0 <= k && k < int(entries.size()));\\n\\n\\t\\tif (k == index) {\\n\\t\\t\\thashtable[hash] = entries[index].next;\\n\\t\\t} else {\\n\\t\\t\\twhile (entries[k].next != index) {\\n\\t\\t\\t\\tk = entries[k].next;\\n\\t\\t\\t\\tdo_assert(0 <= k && k < int(entries.size()));\\n\\t\\t\\t}\\n\\t\\t\\tentries[k].next = entries[index].next;\\n\\t\\t}\\n\\n\\t\\tint back_idx = entries.size()-1;\\n\\n\\t\\tif (index != back_idx)\\n\\t\\t{\\n\\t\\t\\tint back_hash = do_hash(entries[back_idx].udata.first);\\n\\n\\t\\t\\tk = hashtable[back_hash];\\n\\t\\t\\tdo_assert(0 <= k && k < int(entries.size()));\\n\\n\\t\\t\\tif (k == back_idx) {\\n\\t\\t\\t\\thashtable[back_hash] = index;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile (entries[k].next != back_idx) {\\n\\t\\t\\t\\t\\tk = entries[k].next;\\n\\t\\t\\t\\t\\tdo_assert(0 <= k && k < int(entries.size()));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tentries[k].next = index;\\n\\t\\t\\t}\\n\\n\\t\\t\\tentries[index] = std::move(entries[back_idx]);\\n\\t\\t}\\n\\n\\t\\tentries.pop_back();\\n\\n\\t\\tif (entries.empty())\\n\\t\\t\\thashtable.clear();\\n\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tint do_lookup(const K &key, int &hash) const\\n\\t{\\n\\t\\tif (hashtable.empty())\\n\\t\\t\\treturn -1;\\n\\n\\t\\tif (entries.size() * hashtable_size_trigger > hashtable.size()) {\\n\\t\\t\\t((dict*)this)->do_rehash();\\n\\t\\t\\thash = do_hash(key);\\n\\t\\t}\\n\\n\\t\\tint index = hashtable[hash];\\n\\n\\t\\twhile (index >= 0 && !ops.cmp(entries[index].udata.first, key)) {\\n\\t\\t\\tindex = entries[index].next;\\n\\t\\t\\tdo_assert(-1 <= index && index < int(entries.size()));\\n\\t\\t}\\n\\n\\t\\treturn index;\\n\\t}\\n\\n\\tint do_insert(const K &key, int &hash)\\n\\t{\\n\\t\\tif (hashtable.empty()) {\\n\\t\\t\\tentries.emplace_back(std::pair<K, T>(key, T()), -1);\\n\\t\\t\\tdo_rehash();\\n\\t\\t\\thash = do_hash(key);\\n\\t\\t} else {\\n\\t\\t\\tentries.emplace_back(std::pair<K, T>(key, T()), hashtable[hash]);\\n\\t\\t\\thashtable[hash] = entries.size() - 1;\\n\\t\\t}\\n\\t\\treturn entries.size() - 1;\\n\\t}\\n\\n\\tint do_insert(const std::pair<K, T> &value, int &hash)\\n\\t{\\n\\t\\tif (hashtable.empty()) {\\n\\t\\t\\tentries.emplace_back(value, -1);\\n\\t\\t\\tdo_rehash();\\n\\t\\t\\thash = do_hash(value.first);\\n\\t\\t} else {\\n\\t\\t\\tentries.emplace_back(value, hashtable[hash]);\\n\\t\\t\\thashtable[hash] = entries.size() - 1;\\n\\t\\t}\\n\\t\\treturn entries.size() - 1;\\n\\t}\\n\\n\\tint do_insert(std::pair<K, T> &&rvalue, int &hash)\\n\\t{\\n\\t\\tif (hashtable.empty()) {\\n\\t\\t\\tauto key = rvalue.first;\\n\\t\\t\\tentries.emplace_back(std::forward<std::pair<K, T>>(rvalue), -1);\\n\\t\\t\\tdo_rehash();\\n\\t\\t\\thash = do_hash(key);\\n\\t\\t} else {\\n\\t\\t\\tentries.emplace_back(std::forward<std::pair<K, T>>(rvalue), hashtable[hash]);\\n\\t\\t\\thashtable[hash] = entries.size() - 1;\\n\\t\\t}\\n\\t\\treturn entries.size() - 1;\\n\\t}\\n\\npublic:\\n\\tclass const_iterator\\n\\t{\\n\\t\\tfriend class dict;\\n\\tprotected:\\n\\t\\tconst dict *ptr;\\n\\t\\tint index;\\n\\t\\tconst_iterator(const dict *ptr, int index) : ptr(ptr), index(index) { }\\n\\tpublic:\\n\\t\\ttypedef std::forward_iterator_tag iterator_category;\\n\\t\\ttypedef std::pair<K, T> value_type;\\n\\t\\ttypedef ptrdiff_t difference_type;\\n\\t\\ttypedef std::pair<K, T>* pointer;\\n\\t\\ttypedef std::pair<K, T>& reference;\\n\\t\\tconst_iterator() { }\\n\\t\\tconst_iterator operator++() { index--; return *this; }\\n\\t\\tconst_iterator operator+=(int amt) { index -= amt; return *this; }\\n\\t\\tbool operator<(const const_iterator &other) const { return index > other.index; }\\n\\t\\tbool operator==(const const_iterator &other) const { return index == other.index; }\\n\\t\\tbool operator!=(const const_iterator &other) const { return index != other.index; }\\n\\t\\tconst std::pair<K, T> &operator*() const { return ptr->entries[index].udata; }\\n\\t\\tconst std::pair<K, T> *operator->() const { return &ptr->entries[index].udata; }\\n\\t};\\n\\n\\tclass iterator\\n\\t{\\n\\t\\tfriend class dict;\\n\\tprotected:\\n\\t\\tdict *ptr;\\n\\t\\tint index;\\n\\t\\titerator(dict *ptr, int index) : ptr(ptr), index(index) { }\\n\\tpublic:\\n\\t\\ttypedef std::forward_iterator_tag iterator_category;\\n\\t\\ttypedef std::pair<K, T> value_type;\\n\\t\\ttypedef ptrdiff_t difference_type;\\n\\t\\ttypedef std::pair<K, T>* pointer;\\n\\t\\ttypedef std::pair<K, T>& reference;\\n\\t\\titerator() { }\\n\\t\\titerator operator++() { index--; return *this; }\\n\\t\\titerator operator+=(int amt) { index -= amt; return *this; }\\n\\t\\tbool operator<(const iterator &other) const { return index > other.index; }\\n\\t\\tbool operator==(const iterator &other) const { return index == other.index; }\\n\\t\\tbool operator!=(const iterator &other) const { return index != other.index; }\\n\\t\\tstd::pair<K, T> &operator*() { return ptr->entries[index].udata; }\\n\\t\\tstd::pair<K, T> *operator->() { return &ptr->entries[index].udata; }\\n\\t\\tconst std::pair<K, T> &operator*() const { return ptr->entries[index].udata; }\\n\\t\\tconst std::pair<K, T> *operator->() const { return &ptr->entries[index].udata; }\\n\\t\\toperator const_iterator() const { return const_iterator(ptr, index); }\\n\\t};\\n\\n\\tconstexpr dict()\\n\\t{\\n\\t}\\n\\n\\tdict(const dict &other)\\n\\t{\\n\\t\\tentries = other.entries;\\n\\t\\tdo_rehash();\\n\\t}\\n\\n\\tdict(dict &&other)\\n\\t{\\n\\t\\tswap(other);\\n\\t}\\n\\n\\tdict &operator=(const dict &other) {\\n\\t\\tentries = other.entries;\\n\\t\\tdo_rehash();\\n\\t\\treturn *this;\\n\\t}\\n\\n\\tdict &operator=(dict &&other) {\\n\\t\\tclear();\\n\\t\\tswap(other);\\n\\t\\treturn *this;\\n\\t}\\n\\n\\tdict(const std::initializer_list<std::pair<K, T>> &list)\\n\\t{\\n\\t\\tfor (auto &it : list)\\n\\t\\t\\tinsert(it);\\n\\t}\\n\\n\\ttemplate<class InputIterator>\\n\\tdict(InputIterator first, InputIterator last)\\n\\t{\\n\\t\\tinsert(first, last);\\n\\t}\\n\\n\\ttemplate<class InputIterator>\\n\\tvoid insert(InputIterator first, InputIterator last)\\n\\t{\\n\\t\\tfor (; first != last; ++first)\\n\\t\\t\\tinsert(*first);\\n\\t}\\n\\n\\tstd::pair<iterator, bool> insert(const K &key)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i >= 0)\\n\\t\\t\\treturn std::pair<iterator, bool>(iterator(this, i), false);\\n\\t\\ti = do_insert(key, hash);\\n\\t\\treturn std::pair<iterator, bool>(iterator(this, i), true);\\n\\t}\\n\\n\\tstd::pair<iterator, bool> insert(const std::pair<K, T> &value)\\n\\t{\\n\\t\\tint hash = do_hash(value.first);\\n\\t\\tint i = do_lookup(value.first, hash);\\n\\t\\tif (i >= 0)\\n\\t\\t\\treturn std::pair<iterator, bool>(iterator(this, i), false);\\n\\t\\ti = do_insert(value, hash);\\n\\t\\treturn std::pair<iterator, bool>(iterator(this, i), true);\\n\\t}\\n\\n\\tstd::pair<iterator, bool> insert(std::pair<K, T> &&rvalue)\\n\\t{\\n\\t\\tint hash = do_hash(rvalue.first);\\n\\t\\tint i = do_lookup(rvalue.first, hash);\\n\\t\\tif (i >= 0)\\n\\t\\t\\treturn std::pair<iterator, bool>(iterator(this, i), false);\\n\\t\\ti = do_insert(std::forward<std::pair<K, T>>(rvalue), hash);\\n\\t\\treturn std::pair<iterator, bool>(iterator(this, i), true);\\n\\t}\\n\\n\\tstd::pair<iterator, bool> emplace(K const &key, T const &value)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i >= 0)\\n\\t\\t\\treturn std::pair<iterator, bool>(iterator(this, i), false);\\n\\t\\ti = do_insert(std::make_pair(key, value), hash);\\n\\t\\treturn std::pair<iterator, bool>(iterator(this, i), true);\\n\\t}\\n\\n\\tstd::pair<iterator, bool> emplace(K const &key, T &&rvalue)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i >= 0)\\n\\t\\t\\treturn std::pair<iterator, bool>(iterator(this, i), false);\\n\\t\\ti = do_insert(std::make_pair(key, std::forward<T>(rvalue)), hash);\\n\\t\\treturn std::pair<iterator, bool>(iterator(this, i), true);\\n\\t}\\n\\n\\tstd::pair<iterator, bool> emplace(K &&rkey, T const &value)\\n\\t{\\n\\t\\tint hash = do_hash(rkey);\\n\\t\\tint i = do_lookup(rkey, hash);\\n\\t\\tif (i >= 0)\\n\\t\\t\\treturn std::pair<iterator, bool>(iterator(this, i), false);\\n\\t\\ti = do_insert(std::make_pair(std::forward<K>(rkey), value), hash);\\n\\t\\treturn std::pair<iterator, bool>(iterator(this, i), true);\\n\\t}\\n\\n\\tstd::pair<iterator, bool> emplace(K &&rkey, T &&rvalue)\\n\\t{\\n\\t\\tint hash = do_hash(rkey);\\n\\t\\tint i = do_lookup(rkey, hash);\\n\\t\\tif (i >= 0)\\n\\t\\t\\treturn std::pair<iterator, bool>(iterator(this, i), false);\\n\\t\\ti = do_insert(std::make_pair(std::forward<K>(rkey), std::forward<T>(rvalue)), hash);\\n\\t\\treturn std::pair<iterator, bool>(iterator(this, i), true);\\n\\t}\\n\\n\\tint erase(const K &key)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint index = do_lookup(key, hash);\\n\\t\\treturn do_erase(index, hash);\\n\\t}\\n\\n\\titerator erase(iterator it)\\n\\t{\\n\\t\\tint hash = do_hash(it->first);\\n\\t\\tdo_erase(it.index, hash);\\n\\t\\treturn ++it;\\n\\t}\\n\\n\\tint count(const K &key) const\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\treturn i < 0 ? 0 : 1;\\n\\t}\\n\\n\\tint count(const K &key, const_iterator it) const\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\treturn i < 0 || i > it.index ? 0 : 1;\\n\\t}\\n\\n\\titerator find(const K &key)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\treturn end();\\n\\t\\treturn iterator(this, i);\\n\\t}\\n\\n\\tconst_iterator find(const K &key) const\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\treturn end();\\n\\t\\treturn const_iterator(this, i);\\n\\t}\\n\\n\\tT& at(const K &key)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\tthrow std::out_of_range(\\\"dict::at()\\\");\\n\\t\\treturn entries[i].udata.second;\\n\\t}\\n\\n\\tconst T& at(const K &key) const\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\tthrow std::out_of_range(\\\"dict::at()\\\");\\n\\t\\treturn entries[i].udata.second;\\n\\t}\\n\\n\\tconst T& at(const K &key, const T &defval) const\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\treturn defval;\\n\\t\\treturn entries[i].udata.second;\\n\\t}\\n\\n\\tT& operator[](const K &key)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\ti = do_insert(std::pair<K, T>(key, T()), hash);\\n\\t\\treturn entries[i].udata.second;\\n\\t}\\n\\n\\ttemplate<typename Compare = std::less<K>>\\n\\tvoid sort(Compare comp = Compare())\\n\\t{\\n\\t\\tstd::sort(entries.begin(), entries.end(), [comp](const entry_t &a, const entry_t &b){ return comp(b.udata.first, a.udata.first); });\\n\\t\\tdo_rehash();\\n\\t}\\n\\n\\tvoid swap(dict &other)\\n\\t{\\n\\t\\thashtable.swap(other.hashtable);\\n\\t\\tentries.swap(other.entries);\\n\\t}\\n\\n\\tbool operator==(const dict &other) const {\\n\\t\\tif (size() != other.size())\\n\\t\\t\\treturn false;\\n\\t\\tfor (auto &it : entries) {\\n\\t\\t\\tauto oit = other.find(it.udata.first);\\n\\t\\t\\tif (oit == other.end() || !(oit->second == it.udata.second))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool operator!=(const dict &other) const {\\n\\t\\treturn !operator==(other);\\n\\t}\\n\\n\\tunsigned int hash() const {\\n\\t\\tunsigned int h = mkhash_init;\\n\\t\\tfor (auto &entry : entries) {\\n\\t\\t\\th ^= hash_ops<K>::hash(entry.udata.first);\\n\\t\\t\\th ^= hash_ops<T>::hash(entry.udata.second);\\n\\t\\t}\\n\\t\\treturn h;\\n\\t}\\n\\n\\tvoid reserve(size_t n) { entries.reserve(n); }\\n\\tsize_t size() const { return entries.size(); }\\n\\tbool empty() const { return entries.empty(); }\\n\\tvoid clear() { hashtable.clear(); entries.clear(); }\\n\\n\\titerator begin() { return iterator(this, int(entries.size())-1); }\\n\\titerator element(int n) { return iterator(this, int(entries.size())-1-n); }\\n\\titerator end() { return iterator(nullptr, -1); }\\n\\n\\tconst_iterator begin() const { return const_iterator(this, int(entries.size())-1); }\\n\\tconst_iterator element(int n) const { return const_iterator(this, int(entries.size())-1-n); }\\n\\tconst_iterator end() const { return const_iterator(nullptr, -1); }\\n};\\n\\ntemplate<typename K, typename OPS>\\nclass pool\\n{\\n\\ttemplate<typename, int, typename> friend class idict;\\n\\nprotected:\\n\\tstruct entry_t\\n\\t{\\n\\t\\tK udata;\\n\\t\\tint next;\\n\\n\\t\\tentry_t() { }\\n\\t\\tentry_t(const K &udata, int next) : udata(udata), next(next) { }\\n\\t\\tentry_t(K &&udata, int next) : udata(std::move(udata)), next(next) { }\\n\\t};\\n\\n\\tstd::vector<int> hashtable;\\n\\tstd::vector<entry_t> entries;\\n\\tOPS ops;\\n\\n#ifdef NDEBUG\\n\\tstatic inline void do_assert(bool) { }\\n#else\\n\\tstatic inline void do_assert(bool cond) {\\n\\t\\tif (!cond) throw std::runtime_error(\\\"pool<> assert failed.\\\");\\n\\t}\\n#endif\\n\\n\\tint do_hash(const K &key) const\\n\\t{\\n\\t\\tunsigned int hash = 0;\\n\\t\\tif (!hashtable.empty())\\n\\t\\t\\thash = ops.hash(key) % (unsigned int)(hashtable.size());\\n\\t\\treturn hash;\\n\\t}\\n\\n\\tvoid do_rehash()\\n\\t{\\n\\t\\thashtable.clear();\\n\\t\\thashtable.resize(hashtable_size(entries.capacity() * hashtable_size_factor), -1);\\n\\n\\t\\tfor (int i = 0; i < int(entries.size()); i++) {\\n\\t\\t\\tdo_assert(-1 <= entries[i].next && entries[i].next < int(entries.size()));\\n\\t\\t\\tint hash = do_hash(entries[i].udata);\\n\\t\\t\\tentries[i].next = hashtable[hash];\\n\\t\\t\\thashtable[hash] = i;\\n\\t\\t}\\n\\t}\\n\\n\\tint do_erase(int index, int hash)\\n\\t{\\n\\t\\tdo_assert(index < int(entries.size()));\\n\\t\\tif (hashtable.empty() || index < 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint k = hashtable[hash];\\n\\t\\tif (k == index) {\\n\\t\\t\\thashtable[hash] = entries[index].next;\\n\\t\\t} else {\\n\\t\\t\\twhile (entries[k].next != index) {\\n\\t\\t\\t\\tk = entries[k].next;\\n\\t\\t\\t\\tdo_assert(0 <= k && k < int(entries.size()));\\n\\t\\t\\t}\\n\\t\\t\\tentries[k].next = entries[index].next;\\n\\t\\t}\\n\\n\\t\\tint back_idx = entries.size()-1;\\n\\n\\t\\tif (index != back_idx)\\n\\t\\t{\\n\\t\\t\\tint back_hash = do_hash(entries[back_idx].udata);\\n\\n\\t\\t\\tk = hashtable[back_hash];\\n\\t\\t\\tif (k == back_idx) {\\n\\t\\t\\t\\thashtable[back_hash] = index;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile (entries[k].next != back_idx) {\\n\\t\\t\\t\\t\\tk = entries[k].next;\\n\\t\\t\\t\\t\\tdo_assert(0 <= k && k < int(entries.size()));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tentries[k].next = index;\\n\\t\\t\\t}\\n\\n\\t\\t\\tentries[index] = std::move(entries[back_idx]);\\n\\t\\t}\\n\\n\\t\\tentries.pop_back();\\n\\n\\t\\tif (entries.empty())\\n\\t\\t\\thashtable.clear();\\n\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tint do_lookup(const K &key, int &hash) const\\n\\t{\\n\\t\\tif (hashtable.empty())\\n\\t\\t\\treturn -1;\\n\\n\\t\\tif (entries.size() * hashtable_size_trigger > hashtable.size()) {\\n\\t\\t\\t((pool*)this)->do_rehash();\\n\\t\\t\\thash = do_hash(key);\\n\\t\\t}\\n\\n\\t\\tint index = hashtable[hash];\\n\\n\\t\\twhile (index >= 0 && !ops.cmp(entries[index].udata, key)) {\\n\\t\\t\\tindex = entries[index].next;\\n\\t\\t\\tdo_assert(-1 <= index && index < int(entries.size()));\\n\\t\\t}\\n\\n\\t\\treturn index;\\n\\t}\\n\\n\\tint do_insert(const K &value, int &hash)\\n\\t{\\n\\t\\tif (hashtable.empty()) {\\n\\t\\t\\tentries.emplace_back(value, -1);\\n\\t\\t\\tdo_rehash();\\n\\t\\t\\thash = do_hash(value);\\n\\t\\t} else {\\n\\t\\t\\tentries.emplace_back(value, hashtable[hash]);\\n\\t\\t\\thashtable[hash] = entries.size() - 1;\\n\\t\\t}\\n\\t\\treturn entries.size() - 1;\\n\\t}\\n\\n\\tint do_insert(K &&rvalue, int &hash)\\n\\t{\\n\\t\\tif (hashtable.empty()) {\\n\\t\\t\\tentries.emplace_back(std::forward<K>(rvalue), -1);\\n\\t\\t\\tdo_rehash();\\n\\t\\t\\thash = do_hash(rvalue);\\n\\t\\t} else {\\n\\t\\t\\tentries.emplace_back(std::forward<K>(rvalue), hashtable[hash]);\\n\\t\\t\\thashtable[hash] = entries.size() - 1;\\n\\t\\t}\\n\\t\\treturn entries.size() - 1;\\n\\t}\\n\\npublic:\\n\\tclass const_iterator\\n\\t{\\n\\t\\tfriend class pool;\\n\\tprotected:\\n\\t\\tconst pool *ptr;\\n\\t\\tint index;\\n\\t\\tconst_iterator(const pool *ptr, int index) : ptr(ptr), index(index) { }\\n\\tpublic:\\n\\t\\ttypedef std::forward_iterator_tag iterator_category;\\n\\t\\ttypedef K value_type;\\n\\t\\ttypedef ptrdiff_t difference_type;\\n\\t\\ttypedef K* pointer;\\n\\t\\ttypedef K& reference;\\n\\t\\tconst_iterator() { }\\n\\t\\tconst_iterator operator++() { index--; return *this; }\\n\\t\\tbool operator==(const const_iterator &other) const { return index == other.index; }\\n\\t\\tbool operator!=(const const_iterator &other) const { return index != other.index; }\\n\\t\\tconst K &operator*() const { return ptr->entries[index].udata; }\\n\\t\\tconst K *operator->() const { return &ptr->entries[index].udata; }\\n\\t};\\n\\n\\tclass iterator\\n\\t{\\n\\t\\tfriend class pool;\\n\\tprotected:\\n\\t\\tpool *ptr;\\n\\t\\tint index;\\n\\t\\titerator(pool *ptr, int index) : ptr(ptr), index(index) { }\\n\\tpublic:\\n\\t\\ttypedef std::forward_iterator_tag iterator_category;\\n\\t\\ttypedef K value_type;\\n\\t\\ttypedef ptrdiff_t difference_type;\\n\\t\\ttypedef K* pointer;\\n\\t\\ttypedef K& reference;\\n\\t\\titerator() { }\\n\\t\\titerator operator++() { index--; return *this; }\\n\\t\\tbool operator==(const iterator &other) const { return index == other.index; }\\n\\t\\tbool operator!=(const iterator &other) const { return index != other.index; }\\n\\t\\tK &operator*() { return ptr->entries[index].udata; }\\n\\t\\tK *operator->() { return &ptr->entries[index].udata; }\\n\\t\\tconst K &operator*() const { return ptr->entries[index].udata; }\\n\\t\\tconst K *operator->() const { return &ptr->entries[index].udata; }\\n\\t\\toperator const_iterator() const { return const_iterator(ptr, index); }\\n\\t};\\n\\n\\tconstexpr pool()\\n\\t{\\n\\t}\\n\\n\\tpool(const pool &other)\\n\\t{\\n\\t\\tentries = other.entries;\\n\\t\\tdo_rehash();\\n\\t}\\n\\n\\tpool(pool &&other)\\n\\t{\\n\\t\\tswap(other);\\n\\t}\\n\\n\\tpool &operator=(const pool &other) {\\n\\t\\tentries = other.entries;\\n\\t\\tdo_rehash();\\n\\t\\treturn *this;\\n\\t}\\n\\n\\tpool &operator=(pool &&other) {\\n\\t\\tclear();\\n\\t\\tswap(other);\\n\\t\\treturn *this;\\n\\t}\\n\\n\\tpool(const std::initializer_list<K> &list)\\n\\t{\\n\\t\\tfor (auto &it : list)\\n\\t\\t\\tinsert(it);\\n\\t}\\n\\n\\ttemplate<class InputIterator>\\n\\tpool(InputIterator first, InputIterator last)\\n\\t{\\n\\t\\tinsert(first, last);\\n\\t}\\n\\n\\ttemplate<class InputIterator>\\n\\tvoid insert(InputIterator first, InputIterator last)\\n\\t{\\n\\t\\tfor (; first != last; ++first)\\n\\t\\t\\tinsert(*first);\\n\\t}\\n\\n\\tstd::pair<iterator, bool> insert(const K &value)\\n\\t{\\n\\t\\tint hash = do_hash(value);\\n\\t\\tint i = do_lookup(value, hash);\\n\\t\\tif (i >= 0)\\n\\t\\t\\treturn std::pair<iterator, bool>(iterator(this, i), false);\\n\\t\\ti = do_insert(value, hash);\\n\\t\\treturn std::pair<iterator, bool>(iterator(this, i), true);\\n\\t}\\n\\n\\tstd::pair<iterator, bool> insert(K &&rvalue)\\n\\t{\\n\\t\\tint hash = do_hash(rvalue);\\n\\t\\tint i = do_lookup(rvalue, hash);\\n\\t\\tif (i >= 0)\\n\\t\\t\\treturn std::pair<iterator, bool>(iterator(this, i), false);\\n\\t\\ti = do_insert(std::forward<K>(rvalue), hash);\\n\\t\\treturn std::pair<iterator, bool>(iterator(this, i), true);\\n\\t}\\n\\n\\ttemplate<typename... Args>\\n\\tstd::pair<iterator, bool> emplace(Args&&... args)\\n\\t{\\n\\t\\treturn insert(K(std::forward<Args>(args)...));\\n\\t}\\n\\n\\tint erase(const K &key)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint index = do_lookup(key, hash);\\n\\t\\treturn do_erase(index, hash);\\n\\t}\\n\\n\\titerator erase(iterator it)\\n\\t{\\n\\t\\tint hash = do_hash(*it);\\n\\t\\tdo_erase(it.index, hash);\\n\\t\\treturn ++it;\\n\\t}\\n\\n\\tint count(const K &key) const\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\treturn i < 0 ? 0 : 1;\\n\\t}\\n\\n\\tint count(const K &key, const_iterator it) const\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\treturn i < 0 || i > it.index ? 0 : 1;\\n\\t}\\n\\n\\titerator find(const K &key)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\treturn end();\\n\\t\\treturn iterator(this, i);\\n\\t}\\n\\n\\tconst_iterator find(const K &key) const\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\treturn end();\\n\\t\\treturn const_iterator(this, i);\\n\\t}\\n\\n\\tbool operator[](const K &key)\\n\\t{\\n\\t\\tint hash = do_hash(key);\\n\\t\\tint i = do_lookup(key, hash);\\n\\t\\treturn i >= 0;\\n\\t}\\n\\n\\ttemplate<typename Compare = std::less<K>>\\n\\tvoid sort(Compare comp = Compare())\\n\\t{\\n\\t\\tstd::sort(entries.begin(), entries.end(), [comp](const entry_t &a, const entry_t &b){ return comp(b.udata, a.udata); });\\n\\t\\tdo_rehash();\\n\\t}\\n\\n\\tK pop()\\n\\t{\\n\\t\\titerator it = begin();\\n\\t\\tK ret = *it;\\n\\t\\terase(it);\\n\\t\\treturn ret;\\n\\t}\\n\\n\\tvoid swap(pool &other)\\n\\t{\\n\\t\\thashtable.swap(other.hashtable);\\n\\t\\tentries.swap(other.entries);\\n\\t}\\n\\n\\tbool operator==(const pool &other) const {\\n\\t\\tif (size() != other.size())\\n\\t\\t\\treturn false;\\n\\t\\tfor (auto &it : entries)\\n\\t\\t\\tif (!other.count(it.udata))\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool operator!=(const pool &other) const {\\n\\t\\treturn !operator==(other);\\n\\t}\\n\\n\\tunsigned int hash() const {\\n\\t\\tunsigned int hashval = mkhash_init;\\n\\t\\tfor (auto &it : entries)\\n\\t\\t\\thashval ^= ops.hash(it.udata);\\n\\t\\treturn hashval;\\n\\t}\\n\\n\\tvoid reserve(size_t n) { entries.reserve(n); }\\n\\tsize_t size() const { return entries.size(); }\\n\\tbool empty() const { return entries.empty(); }\\n\\tvoid clear() { hashtable.clear(); entries.clear(); }\\n\\n\\titerator begin() { return iterator(this, int(entries.size())-1); }\\n\\titerator element(int n) { return iterator(this, int(entries.size())-1-n); }\\n\\titerator end() { return iterator(nullptr, -1); }\\n\\n\\tconst_iterator begin() const { return const_iterator(this, int(entries.size())-1); }\\n\\tconst_iterator element(int n) const { return const_iterator(this, int(entries.size())-1-n); }\\n\\tconst_iterator end() const { return const_iterator(nullptr, -1); }\\n};\\n\\ntemplate<typename K, int offset, typename OPS>\\nclass idict\\n{\\n\\tpool<K, OPS> database;\\n\\npublic:\\n\\tclass const_iterator\\n\\t{\\n\\t\\tfriend class idict;\\n\\tprotected:\\n\\t\\tconst idict &container;\\n\\t\\tint index;\\n\\t\\tconst_iterator(const idict &container, int index) : container(container), index(index) { }\\n\\tpublic:\\n\\t\\ttypedef std::forward_iterator_tag iterator_category;\\n\\t\\ttypedef K value_type;\\n\\t\\ttypedef ptrdiff_t difference_type;\\n\\t\\ttypedef K* pointer;\\n\\t\\ttypedef K& reference;\\n\\t\\tconst_iterator() { }\\n\\t\\tconst_iterator operator++() { index++; return *this; }\\n\\t\\tbool operator==(const const_iterator &other) const { return index == other.index; }\\n\\t\\tbool operator!=(const const_iterator &other) const { return index != other.index; }\\n\\t\\tconst K &operator*() const { return container[index]; }\\n\\t\\tconst K *operator->() const { return &container[index]; }\\n\\t};\\n\\n\\tconstexpr idict()\\n\\t{\\n\\t}\\n\\n\\tint operator()(const K &key)\\n\\t{\\n\\t\\tint hash = database.do_hash(key);\\n\\t\\tint i = database.do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\ti = database.do_insert(key, hash);\\n\\t\\treturn i + offset;\\n\\t}\\n\\n\\tint at(const K &key) const\\n\\t{\\n\\t\\tint hash = database.do_hash(key);\\n\\t\\tint i = database.do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\tthrow std::out_of_range(\\\"idict::at()\\\");\\n\\t\\treturn i + offset;\\n\\t}\\n\\n\\tint at(const K &key, int defval) const\\n\\t{\\n\\t\\tint hash = database.do_hash(key);\\n\\t\\tint i = database.do_lookup(key, hash);\\n\\t\\tif (i < 0)\\n\\t\\t\\treturn defval;\\n\\t\\treturn i + offset;\\n\\t}\\n\\n\\tint count(const K &key) const\\n\\t{\\n\\t\\tint hash = database.do_hash(key);\\n\\t\\tint i = database.do_lookup(key, hash);\\n\\t\\treturn i < 0 ? 0 : 1;\\n\\t}\\n\\n\\tvoid expect(const K &key, int i)\\n\\t{\\n\\t\\tint j = (*this)(key);\\n\\t\\tif (i != j)\\n\\t\\t\\tthrow std::out_of_range(\\\"idict::expect()\\\");\\n\\t}\\n\\n\\tconst K &operator[](int index) const\\n\\t{\\n\\t\\treturn database.entries.at(index - offset).udata;\\n\\t}\\n\\n\\tvoid swap(idict &other)\\n\\t{\\n\\t\\tdatabase.swap(other.database);\\n\\t}\\n\\n\\tvoid reserve(size_t n) { database.reserve(n); }\\n\\tsize_t size() const { return database.size(); }\\n\\tbool empty() const { return database.empty(); }\\n\\tvoid clear() { database.clear(); }\\n\\n\\tconst_iterator begin() const { return const_iterator(*this, offset); }\\n\\tconst_iterator element(int n) const { return const_iterator(*this, n); }\\n\\tconst_iterator end() const { return const_iterator(*this, offset + size()); }\\n};\\n\\ntemplate<typename K, typename OPS>\\nclass mfp\\n{\\n\\tmutable idict<K, 0, OPS> database;\\n\\tmutable std::vector<int> parents;\\n\\npublic:\\n\\ttypedef typename idict<K, 0, OPS>::const_iterator const_iterator;\\n\\n\\tconstexpr mfp()\\n\\t{\\n\\t}\\n\\n\\tint operator()(const K &key) const\\n\\t{\\n\\t\\tint i = database(key);\\n\\t\\tparents.resize(database.size(), -1);\\n\\t\\treturn i;\\n\\t}\\n\\n\\tconst K &operator[](int index) const\\n\\t{\\n\\t\\treturn database[index];\\n\\t}\\n\\n\\tint ifind(int i) const\\n\\t{\\n\\t\\tint p = i, k = i;\\n\\n\\t\\twhile (parents[p] != -1)\\n\\t\\t\\tp = parents[p];\\n\\n\\t\\twhile (k != p) {\\n\\t\\t\\tint next_k = parents[k];\\n\\t\\t\\tparents[k] = p;\\n\\t\\t\\tk = next_k;\\n\\t\\t}\\n\\n\\t\\treturn p;\\n\\t}\\n\\n\\tvoid imerge(int i, int j)\\n\\t{\\n\\t\\ti = ifind(i);\\n\\t\\tj = ifind(j);\\n\\n\\t\\tif (i != j)\\n\\t\\t\\tparents[i] = j;\\n\\t}\\n\\n\\tvoid ipromote(int i)\\n\\t{\\n\\t\\tint k = i;\\n\\n\\t\\twhile (k != -1) {\\n\\t\\t\\tint next_k = parents[k];\\n\\t\\t\\tparents[k] = i;\\n\\t\\t\\tk = next_k;\\n\\t\\t}\\n\\n\\t\\tparents[i] = -1;\\n\\t}\\n\\n\\tint lookup(const K &a) const\\n\\t{\\n\\t\\treturn ifind((*this)(a));\\n\\t}\\n\\n\\tconst K &find(const K &a) const\\n\\t{\\n\\t\\tint i = database.at(a, -1);\\n\\t\\tif (i < 0)\\n\\t\\t\\treturn a;\\n\\t\\treturn (*this)[ifind(i)];\\n\\t}\\n\\n\\tvoid merge(const K &a, const K &b)\\n\\t{\\n\\t\\timerge((*this)(a), (*this)(b));\\n\\t}\\n\\n\\tvoid promote(const K &a)\\n\\t{\\n\\t\\tint i = database.at(a, -1);\\n\\t\\tif (i >= 0)\\n\\t\\t\\tipromote(i);\\n\\t}\\n\\n\\tvoid swap(mfp &other)\\n\\t{\\n\\t\\tdatabase.swap(other.database);\\n\\t\\tparents.swap(other.parents);\\n\\t}\\n\\n\\tvoid reserve(size_t n) { database.reserve(n); }\\n\\tsize_t size() const { return database.size(); }\\n\\tbool empty() const { return database.empty(); }\\n\\tvoid clear() { database.clear(); parents.clear(); }\\n\\n\\tconst_iterator begin() const { return database.begin(); }\\n\\tconst_iterator element(int n) const { return database.element(n); }\\n\\tconst_iterator end() const { return database.end(); }\\n};\\n\\n} /* namespace hashlib */\\n\\n#endif\\n\",\n                \"json.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2022  Jannis Harder <jix@yosyshq.com> <me@jix.one>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef JSON_H\\n#define JSON_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n#include \\\"libs/json11/json11.hpp\\\"\\n#include <functional>\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nusing json11::Json;\\n\\nclass PrettyJson\\n{\\n    enum Scope {\\n        VALUE,\\n        OBJECT_FIRST,\\n        OBJECT,\\n        ARRAY_FIRST,\\n        ARRAY,\\n    };\\n\\n    struct Target {\\n        virtual void emit(const char *data) = 0;\\n        virtual void flush() {};\\n        virtual ~Target() {};\\n    };\\n\\n    std::string newline_indent = \\\"\\\\n\\\";\\n    std::vector<std::unique_ptr<Target>> targets;\\n    std::vector<Scope> state = {VALUE};\\n    int compact_depth = INT_MAX;\\npublic:\\n\\n    void emit_to_log();\\n    void append_to_string(std::string &target);\\n    bool write_to_file(const std::string &path);\\n\\n    bool active() { return !targets.empty(); }\\n\\n    void compact() { compact_depth = GetSize(state); }\\n\\n    void line(bool space_if_inline = true);\\n    void raw(const char *raw_json);\\n    void flush();\\n    void begin_object();\\n    void begin_array();\\n    void end_object();\\n    void end_array();\\n    void name(const char *name);\\n    void begin_value();\\n    void end_value();\\n    void value_json(const Json &value);\\n    void value(unsigned int value) { value_json(Json((int)value)); }\\n    template<typename T>\\n    void value(T &&value) { value_json(Json(std::forward<T>(value))); };\\n\\n    void entry_json(const char *name, const Json &value);\\n    void entry(const char *name, unsigned int value) { entry_json(name, Json((int)value)); }\\n    template<typename T>\\n    void entry(const char *name, T &&value) { entry_json(name, Json(std::forward<T>(value))); };\\n\\n    template<typename T>\\n    void object(const T &&values)\\n    {\\n        begin_object();\\n        for (auto &item : values)\\n            entry(item.first, item.second);\\n        end_object();\\n    }\\n\\n    template<typename T>\\n    void array(const T &&values)\\n    {\\n        begin_object();\\n        for (auto &item : values)\\n            value(item);\\n        end_object();\\n    }\\n};\\n\\n\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"log.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef LOG_H\\n#define LOG_H\\n\\n#include \\\"kernel/yosys_common.h\\\"\\n\\n#include <time.h>\\n\\n#include <regex>\\n#define YS_REGEX_COMPILE(param) std::regex(param, \\\\\\n\\t\\t\\t\\tstd::regex_constants::nosubs | \\\\\\n\\t\\t\\t\\tstd::regex_constants::optimize | \\\\\\n\\t\\t\\t\\tstd::regex_constants::egrep)\\n#define YS_REGEX_COMPILE_WITH_SUBS(param) std::regex(param, \\\\\\n\\t\\t\\t\\tstd::regex_constants::optimize | \\\\\\n\\t\\t\\t\\tstd::regex_constants::egrep)\\n\\n#if defined(_WIN32)\\n#  include <intrin.h>\\n#else\\n#  include <sys/time.h>\\n#  include <sys/resource.h>\\n#  if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))\\n#    include <signal.h>\\n#  endif\\n#endif\\n\\n#if defined(_MSC_VER)\\n// At least this is not in MSVC++ 2013.\\n#  define __PRETTY_FUNCTION__ __FUNCTION__\\n#endif\\n\\n// from libs/sha1/sha1.h\\nclass SHA1;\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\n#define S__LINE__sub2(x) #x\\n#define S__LINE__sub1(x) S__LINE__sub2(x)\\n#define S__LINE__ S__LINE__sub1(__LINE__)\\n\\n// YS_DEBUGTRAP is a macro that is functionally equivalent to a breakpoint\\n// if the platform provides such functionality, and does nothing otherwise.\\n// If no debugger is attached, it starts a just-in-time debugger if available,\\n// and crashes the process otherwise.\\n#if defined(_WIN32)\\n# define YS_DEBUGTRAP __debugbreak()\\n#else\\n# ifndef __has_builtin\\n// __has_builtin is a GCC/Clang extension; on a different compiler (or old enough GCC/Clang)\\n// that does not have it, using __has_builtin(...) is a syntax error.\\n#  define __has_builtin(x) 0\\n# endif\\n# if __has_builtin(__builtin_debugtrap)\\n#  define YS_DEBUGTRAP __builtin_debugtrap()\\n# elif defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))\\n#  define YS_DEBUGTRAP raise(SIGTRAP)\\n# else\\n#  define YS_DEBUGTRAP do {} while(0)\\n# endif\\n#endif\\n\\n// YS_DEBUGTRAP_IF_DEBUGGING is a macro that is functionally equivalent to a breakpoint\\n// if a debugger is attached, and does nothing otherwise.\\n#if defined(_WIN32)\\n# define YS_DEBUGTRAP_IF_DEBUGGING do { if (IsDebuggerPresent()) DebugBreak(); } while(0)\\n# elif defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))\\n// There is no reliable (or portable) *nix equivalent of IsDebuggerPresent(). However,\\n// debuggers will stop when SIGTRAP is raised, even if the action is set to ignore.\\n# define YS_DEBUGTRAP_IF_DEBUGGING do { \\\\\\n\\t\\tauto old = signal(SIGTRAP, SIG_IGN); raise(SIGTRAP); signal(SIGTRAP, old); \\\\\\n\\t} while(0)\\n#else\\n# define YS_DEBUGTRAP_IF_DEBUGGING do {} while(0)\\n#endif\\n\\nstruct log_cmd_error_exception { };\\n\\nextern std::vector<FILE*> log_files;\\nextern std::vector<std::ostream*> log_streams;\\nextern std::vector<std::string> log_scratchpads;\\nextern std::map<std::string, std::set<std::string>> log_hdump;\\nextern std::vector<std::regex> log_warn_regexes, log_nowarn_regexes, log_werror_regexes;\\nextern std::set<std::string> log_warnings, log_experimentals, log_experimentals_ignored;\\nextern int log_warnings_count;\\nextern int log_warnings_count_noexpect;\\nextern bool log_expect_no_warnings;\\nextern bool log_hdump_all;\\nextern FILE *log_errfile;\\nextern SHA1 *log_hasher;\\n\\nextern bool log_time;\\nextern bool log_error_stderr;\\nextern bool log_cmd_error_throw;\\nextern bool log_quiet_warnings;\\nextern int log_verbose_level;\\nextern string log_last_error;\\nextern void (*log_error_atexit)();\\n\\nextern int log_make_debug;\\nextern int log_force_debug;\\nextern int log_debug_suppressed;\\n\\nvoid logv(const char *format, va_list ap);\\nvoid logv_header(RTLIL::Design *design, const char *format, va_list ap);\\nvoid logv_warning(const char *format, va_list ap);\\nvoid logv_warning_noprefix(const char *format, va_list ap);\\n[[noreturn]] void logv_error(const char *format, va_list ap);\\n[[noreturn]] void logv_file_error(const string &filename, int lineno, const char *format, va_list ap);\\n\\nvoid log(const char *format, ...)  YS_ATTRIBUTE(format(printf, 1, 2));\\nvoid log_header(RTLIL::Design *design, const char *format, ...) YS_ATTRIBUTE(format(printf, 2, 3));\\nvoid log_warning(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));\\nvoid log_experimental(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));\\n\\nvoid set_verific_logging(void (*cb)(int msg_type, const char *message_id, const char* file_path, unsigned int left_line, unsigned int left_col, unsigned int right_line, unsigned int right_col, const char *msg));\\nextern void (*log_verific_callback)(int msg_type, const char *message_id, const char* file_path, unsigned int left_line, unsigned int left_col, unsigned int right_line, unsigned int right_col, const char *msg);\\n\\n// Log with filename to report a problem in a source file.\\nvoid log_file_warning(const std::string &filename, int lineno, const char *format, ...) YS_ATTRIBUTE(format(printf, 3, 4));\\nvoid log_file_info(const std::string &filename, int lineno, const char *format, ...) YS_ATTRIBUTE(format(printf, 3, 4));\\n\\nvoid log_warning_noprefix(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));\\n[[noreturn]] void log_error(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));\\n[[noreturn]] void log_file_error(const string &filename, int lineno, const char *format, ...) YS_ATTRIBUTE(format(printf, 3, 4));\\n[[noreturn]] void log_cmd_error(const char *format, ...) YS_ATTRIBUTE(format(printf, 1, 2));\\n\\n#ifndef NDEBUG\\nstatic inline bool ys_debug(int n = 0) { if (log_force_debug) return true; log_debug_suppressed += n; return false; }\\n#else\\nstatic inline bool ys_debug(int = 0) { return false; }\\n#endif\\n#  define log_debug(...) do { if (ys_debug(1)) log(__VA_ARGS__); } while (0)\\n\\nstatic inline void log_suppressed() {\\n\\tif (log_debug_suppressed && !log_make_debug) {\\n\\t\\tlog(\\\"<suppressed ~%d debug messages>\\\\n\\\", log_debug_suppressed);\\n\\t\\tlog_debug_suppressed = 0;\\n\\t}\\n}\\n\\nstruct LogMakeDebugHdl {\\n\\tbool status = false;\\n\\tLogMakeDebugHdl(bool start_on = false) {\\n\\t\\tif (start_on)\\n\\t\\t\\ton();\\n\\t}\\n\\t~LogMakeDebugHdl() {\\n\\t\\toff();\\n\\t}\\n\\tvoid on() {\\n\\t\\tif (status) return;\\n\\t\\tstatus=true;\\n\\t\\tlog_make_debug++;\\n\\t}\\n\\tvoid off_silent() {\\n\\t\\tif (!status) return;\\n\\t\\tstatus=false;\\n\\t\\tlog_make_debug--;\\n\\t}\\n\\tvoid off() {\\n\\t\\toff_silent();\\n\\t}\\n};\\n\\nvoid log_spacer();\\nvoid log_push();\\nvoid log_pop();\\n\\nvoid log_backtrace(const char *prefix, int levels);\\nvoid log_reset_stack();\\nvoid log_flush();\\n\\nstruct LogExpectedItem\\n{\\n\\tLogExpectedItem(const std::regex &pat, int expected) :\\n\\t\\t\\tpattern(pat), expected_count(expected), current_count(0) {}\\n\\tLogExpectedItem() : expected_count(0), current_count(0) {}\\n\\n\\tstd::regex pattern;\\n\\tint expected_count;\\n\\tint current_count;\\n};\\n\\nextern dict<std::string, LogExpectedItem> log_expect_log, log_expect_warning, log_expect_error;\\nvoid log_check_expected();\\n\\nconst char *log_signal(const RTLIL::SigSpec &sig, bool autoint = true);\\nconst char *log_const(const RTLIL::Const &value, bool autoint = true);\\nconst char *log_id(const RTLIL::IdString &id);\\n\\ntemplate<typename T> static inline const char *log_id(T *obj, const char *nullstr = nullptr) {\\n\\tif (nullstr && obj == nullptr)\\n\\t\\treturn nullstr;\\n\\treturn log_id(obj->name);\\n}\\n\\nvoid log_module(RTLIL::Module *module, std::string indent = \\\"\\\");\\nvoid log_cell(RTLIL::Cell *cell, std::string indent = \\\"\\\");\\nvoid log_wire(RTLIL::Wire *wire, std::string indent = \\\"\\\");\\n\\n#ifndef NDEBUG\\nstatic inline void log_assert_worker(bool cond, const char *expr, const char *file, int line) {\\n\\tif (!cond) log_error(\\\"Assert `%s' failed in %s:%d.\\\\n\\\", expr, file, line);\\n}\\n#  define log_assert(_assert_expr_) YOSYS_NAMESPACE_PREFIX log_assert_worker(_assert_expr_, #_assert_expr_, __FILE__, __LINE__)\\n#else\\n#  define log_assert(_assert_expr_) do { if (0) { (void)(_assert_expr_); } } while(0)\\n#endif\\n\\n#define log_abort() YOSYS_NAMESPACE_PREFIX log_error(\\\"Abort in %s:%d.\\\\n\\\", __FILE__, __LINE__)\\n#define log_ping() YOSYS_NAMESPACE_PREFIX log(\\\"-- %s:%d %s --\\\\n\\\", __FILE__, __LINE__, __PRETTY_FUNCTION__)\\n\\n\\n// ---------------------------------------------------\\n// This is the magic behind the code coverage counters\\n// ---------------------------------------------------\\n\\n#if defined(YOSYS_ENABLE_COVER) && (defined(__linux__) || defined(__FreeBSD__))\\n\\n#define cover(_id) do { \\\\\\n    static CoverData __d __attribute__((section(\\\"yosys_cover_list\\\"), aligned(1), used)) = { __FILE__, __FUNCTION__, _id, __LINE__, 0 }; \\\\\\n    __d.counter++; \\\\\\n} while (0)\\n\\nstruct CoverData {\\n\\tconst char *file, *func, *id;\\n\\tint line, counter;\\n} YS_ATTRIBUTE(packed);\\n\\n// this two symbols are created by the linker for the \\\"yosys_cover_list\\\" ELF section\\nextern \\\"C\\\" struct CoverData __start_yosys_cover_list[];\\nextern \\\"C\\\" struct CoverData __stop_yosys_cover_list[];\\n\\nextern dict<std::string, std::pair<std::string, int>> extra_coverage_data;\\n\\nvoid cover_extra(std::string parent, std::string id, bool increment = true);\\ndict<std::string, std::pair<std::string, int>> get_coverage_data();\\n\\n#define cover_list(_id, ...) do { cover(_id); \\\\\\n\\tstd::string r = cover_list_worker(_id, __VA_ARGS__); \\\\\\n\\tlog_assert(r.empty()); \\\\\\n} while (0)\\n\\nstatic inline std::string cover_list_worker(std::string, std::string last) {\\n\\treturn last;\\n}\\n\\ntemplate<typename... T>\\nstd::string cover_list_worker(std::string prefix, std::string first, T... rest) {\\n\\tstd::string selected = cover_list_worker(prefix, rest...);\\n\\tcover_extra(prefix, prefix + \\\".\\\" + first, first == selected);\\n\\treturn first == selected ? \\\"\\\" : selected;\\n}\\n\\n#else\\n#  define cover(...) do { } while (0)\\n#  define cover_list(...) do { } while (0)\\n#endif\\n\\n\\n// ------------------------------------------------------------\\n// everything below this line are utilities for troubleshooting\\n// ------------------------------------------------------------\\n\\n// simple timer for performance measurements\\n// toggle the '#if 1' to get a baseline for the performance penalty added by the measurement\\nstruct PerformanceTimer\\n{\\n#if 1\\n\\tint64_t total_ns;\\n\\n\\tPerformanceTimer() {\\n\\t\\ttotal_ns = 0;\\n\\t}\\n\\n\\tstatic int64_t query() {\\n#  ifdef _WIN32\\n\\t\\treturn 0;\\n#  elif defined(RUSAGE_SELF)\\n\\t\\tstruct rusage rusage;\\n\\t\\tint64_t t = 0;\\n\\t\\tfor (int who : {RUSAGE_SELF, RUSAGE_CHILDREN}) {\\n\\t\\t\\tif (getrusage(who, &rusage) == -1) {\\n\\t\\t\\t\\tlog_cmd_error(\\\"getrusage failed!\\\\n\\\");\\n\\t\\t\\t\\tlog_abort();\\n\\t\\t\\t}\\n\\t\\t\\tt += 1000000000ULL * (int64_t) rusage.ru_utime.tv_sec + (int64_t) rusage.ru_utime.tv_usec * 1000ULL;\\n\\t\\t\\tt += 1000000000ULL * (int64_t) rusage.ru_stime.tv_sec + (int64_t) rusage.ru_stime.tv_usec * 1000ULL;\\n\\t\\t}\\n\\t\\treturn t;\\n#  else\\n#    error \\\"Don't know how to measure per-process CPU time. Need alternative method (times()/clocks()/gettimeofday()?).\\\"\\n#  endif\\n\\t}\\n\\n\\tvoid reset() {\\n\\t\\ttotal_ns = 0;\\n\\t}\\n\\n\\tvoid begin() {\\n\\t\\ttotal_ns -= query();\\n\\t}\\n\\n\\tvoid end() {\\n\\t\\ttotal_ns += query();\\n\\t}\\n\\n\\tfloat sec() const {\\n\\t\\treturn total_ns * 1e-9f;\\n\\t}\\n#else\\n\\tstatic int64_t query() { return 0; }\\n\\tvoid reset() { }\\n\\tvoid begin() { }\\n\\tvoid end() { }\\n\\tfloat sec() const { return 0; }\\n#endif\\n};\\n\\n// simple API for quickly dumping values when debugging\\n\\nstatic inline void log_dump_val_worker(short v) { log(\\\"%d\\\", v); }\\nstatic inline void log_dump_val_worker(unsigned short v) { log(\\\"%u\\\", v); }\\nstatic inline void log_dump_val_worker(int v) { log(\\\"%d\\\", v); }\\nstatic inline void log_dump_val_worker(unsigned int v) { log(\\\"%u\\\", v); }\\nstatic inline void log_dump_val_worker(long int v) { log(\\\"%ld\\\", v); }\\nstatic inline void log_dump_val_worker(unsigned long int v) { log(\\\"%lu\\\", v); }\\n#ifndef _WIN32\\nstatic inline void log_dump_val_worker(long long int v) { log(\\\"%lld\\\", v); }\\nstatic inline void log_dump_val_worker(unsigned long long int v) { log(\\\"%lld\\\", v); }\\n#endif\\nstatic inline void log_dump_val_worker(char c) { log(c >= 32 && c < 127 ? \\\"'%c'\\\" : \\\"'\\\\\\\\x%02x'\\\", c); }\\nstatic inline void log_dump_val_worker(unsigned char c) { log(c >= 32 && c < 127 ? \\\"'%c'\\\" : \\\"'\\\\\\\\x%02x'\\\", c); }\\nstatic inline void log_dump_val_worker(bool v) { log(\\\"%s\\\", v ? \\\"true\\\" : \\\"false\\\"); }\\nstatic inline void log_dump_val_worker(double v) { log(\\\"%f\\\", v); }\\nstatic inline void log_dump_val_worker(char *v) { log(\\\"%s\\\", v); }\\nstatic inline void log_dump_val_worker(const char *v) { log(\\\"%s\\\", v); }\\nstatic inline void log_dump_val_worker(std::string v) { log(\\\"%s\\\", v.c_str()); }\\nstatic inline void log_dump_val_worker(PerformanceTimer p) { log(\\\"%f seconds\\\", p.sec()); }\\nstatic inline void log_dump_args_worker(const char *p) { log_assert(*p == 0); }\\nvoid log_dump_val_worker(RTLIL::IdString v);\\nvoid log_dump_val_worker(RTLIL::SigSpec v);\\nvoid log_dump_val_worker(RTLIL::State v);\\n\\ntemplate<typename K, typename T, typename OPS> static inline void log_dump_val_worker(dict<K, T, OPS> &v);\\ntemplate<typename K, typename OPS> static inline void log_dump_val_worker(pool<K, OPS> &v);\\ntemplate<typename K> static inline void log_dump_val_worker(std::vector<K> &v);\\ntemplate<typename T> static inline void log_dump_val_worker(T *ptr);\\n\\ntemplate<typename K, typename T, typename OPS>\\nstatic inline void log_dump_val_worker(dict<K, T, OPS> &v) {\\n\\tlog(\\\"{\\\");\\n\\tbool first = true;\\n\\tfor (auto &it : v) {\\n\\t\\tlog(first ? \\\" \\\" : \\\", \\\");\\n\\t\\tlog_dump_val_worker(it.first);\\n\\t\\tlog(\\\": \\\");\\n\\t\\tlog_dump_val_worker(it.second);\\n\\t\\tfirst = false;\\n\\t}\\n\\tlog(\\\" }\\\");\\n}\\n\\ntemplate<typename K, typename OPS>\\nstatic inline void log_dump_val_worker(pool<K, OPS> &v) {\\n\\tlog(\\\"{\\\");\\n\\tbool first = true;\\n\\tfor (auto &it : v) {\\n\\t\\tlog(first ? \\\" \\\" : \\\", \\\");\\n\\t\\tlog_dump_val_worker(it);\\n\\t\\tfirst = false;\\n\\t}\\n\\tlog(\\\" }\\\");\\n}\\n\\ntemplate<typename K>\\nstatic inline void log_dump_val_worker(std::vector<K> &v) {\\n\\tlog(\\\"{\\\");\\n\\tbool first = true;\\n\\tfor (auto &it : v) {\\n\\t\\tlog(first ? \\\" \\\" : \\\", \\\");\\n\\t\\tlog_dump_val_worker(it);\\n\\t\\tfirst = false;\\n\\t}\\n\\tlog(\\\" }\\\");\\n}\\n\\ntemplate<typename T>\\nstatic inline void log_dump_val_worker(T *ptr) { log(\\\"%p\\\", ptr); }\\n\\ntemplate<typename T, typename ... Args>\\nvoid log_dump_args_worker(const char *p, T first, Args ... args)\\n{\\n\\tint next_p_state = 0;\\n\\tconst char *next_p = p;\\n\\twhile (*next_p && (next_p_state != 0 || *next_p != ',')) {\\n\\t\\tif (*next_p == '\\\"')\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tnext_p++;\\n\\t\\t\\t\\twhile (*next_p == '\\\\\\\\' && *(next_p + 1))\\n\\t\\t\\t\\t\\tnext_p += 2;\\n\\t\\t\\t} while (*next_p && *next_p != '\\\"');\\n\\t\\tif (*next_p == '\\\\'') {\\n\\t\\t\\tnext_p++;\\n\\t\\t\\tif (*next_p == '\\\\\\\\')\\n\\t\\t\\t\\tnext_p++;\\n\\t\\t\\tif (*next_p)\\n\\t\\t\\t\\tnext_p++;\\n\\t\\t}\\n\\t\\tif (*next_p == '(' || *next_p == '[' || *next_p == '{')\\n\\t\\t\\tnext_p_state++;\\n\\t\\tif ((*next_p == ')' || *next_p == ']' || *next_p == '}') && next_p_state > 0)\\n\\t\\t\\tnext_p_state--;\\n\\t\\tnext_p++;\\n\\t}\\n\\tlog(\\\"\\\\n\\\\t%.*s => \\\", int(next_p - p), p);\\n\\tif (*next_p == ',')\\n\\t\\tnext_p++;\\n\\twhile (*next_p == ' ' || *next_p == '\\\\t' || *next_p == '\\\\r' || *next_p == '\\\\n')\\n\\t\\tnext_p++;\\n\\tlog_dump_val_worker(first);\\n\\tlog_dump_args_worker(next_p, args ...);\\n}\\n\\n#define log_dump(...) do { \\\\\\n\\tlog(\\\"DEBUG DUMP IN %s AT %s:%d:\\\", __PRETTY_FUNCTION__, __FILE__, __LINE__); \\\\\\n\\tlog_dump_args_worker(#__VA_ARGS__, __VA_ARGS__); \\\\\\n\\tlog(\\\"\\\\n\\\"); \\\\\\n} while (0)\\n\\nYOSYS_NAMESPACE_END\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\n#endif\\n\",\n                \"macc.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef MACC_H\\n#define MACC_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct Macc\\n{\\n\\tstruct port_t {\\n\\t\\tRTLIL::SigSpec in_a, in_b;\\n\\t\\tbool is_signed, do_subtract;\\n\\t};\\n\\n\\tstd::vector<port_t> ports;\\n\\tRTLIL::SigSpec bit_ports;\\n\\n\\tvoid optimize(int width)\\n\\t{\\n\\t\\tstd::vector<port_t> new_ports;\\n\\t\\tRTLIL::SigSpec new_bit_ports;\\n\\t\\tRTLIL::Const off(0, width);\\n\\n\\t\\tfor (auto &port : ports)\\n\\t\\t{\\n\\t\\t\\tif (GetSize(port.in_a) == 0 && GetSize(port.in_b) == 0)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tif (GetSize(port.in_a) < GetSize(port.in_b))\\n\\t\\t\\t\\tstd::swap(port.in_a, port.in_b);\\n\\n\\t\\t\\tif (GetSize(port.in_a) == 1 && GetSize(port.in_b) == 0 && !port.is_signed && !port.do_subtract) {\\n\\t\\t\\t\\tbit_ports.append(port.in_a);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (port.in_a.is_fully_const() && port.in_b.is_fully_const()) {\\n\\t\\t\\t\\tRTLIL::Const v = port.in_a.as_const();\\n\\t\\t\\t\\tif (GetSize(port.in_b))\\n\\t\\t\\t\\t\\tv = const_mul(v, port.in_b.as_const(), port.is_signed, port.is_signed, width);\\n\\t\\t\\t\\tif (port.do_subtract)\\n\\t\\t\\t\\t\\toff = const_sub(off, v, port.is_signed, port.is_signed, width);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\toff = const_add(off, v, port.is_signed, port.is_signed, width);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (port.is_signed) {\\n\\t\\t\\t\\twhile (GetSize(port.in_a) > 1 && port.in_a[GetSize(port.in_a)-1] == port.in_a[GetSize(port.in_a)-2])\\n\\t\\t\\t\\t\\tport.in_a.remove(GetSize(port.in_a)-1);\\n\\t\\t\\t\\twhile (GetSize(port.in_b) > 1 && port.in_b[GetSize(port.in_b)-1] == port.in_b[GetSize(port.in_b)-2])\\n\\t\\t\\t\\t\\tport.in_b.remove(GetSize(port.in_b)-1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile (GetSize(port.in_a) > 1 && port.in_a[GetSize(port.in_a)-1] == State::S0)\\n\\t\\t\\t\\t\\tport.in_a.remove(GetSize(port.in_a)-1);\\n\\t\\t\\t\\twhile (GetSize(port.in_b) > 1 && port.in_b[GetSize(port.in_b)-1] == State::S0)\\n\\t\\t\\t\\t\\tport.in_b.remove(GetSize(port.in_b)-1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tnew_ports.push_back(port);\\n\\t\\t}\\n\\n\\t\\tfor (auto &bit : bit_ports)\\n\\t\\t\\tif (bit == State::S1)\\n\\t\\t\\t\\toff = const_add(off, RTLIL::Const(1, width), false, false, width);\\n\\t\\t\\telse if (bit != State::S0)\\n\\t\\t\\t\\tnew_bit_ports.append(bit);\\n\\n\\t\\tif (off.as_bool()) {\\n\\t\\t\\tport_t port;\\n\\t\\t\\tport.in_a = off;\\n\\t\\t\\tport.is_signed = false;\\n\\t\\t\\tport.do_subtract = false;\\n\\t\\t\\tnew_ports.push_back(port);\\n\\t\\t}\\n\\n\\t\\tnew_ports.swap(ports);\\n\\t\\tbit_ports = new_bit_ports;\\n\\t}\\n\\n\\tvoid from_cell(RTLIL::Cell *cell)\\n\\t{\\n\\t\\tRTLIL::SigSpec port_a = cell->getPort(ID::A);\\n\\n\\t\\tports.clear();\\n\\t\\tbit_ports = cell->getPort(ID::B);\\n\\n\\t\\tstd::vector<RTLIL::State> config_bits = cell->getParam(ID::CONFIG).bits;\\n\\t\\tint config_cursor = 0;\\n\\n\\t\\tint config_width = cell->getParam(ID::CONFIG_WIDTH).as_int();\\n\\t\\tlog_assert(GetSize(config_bits) >= config_width);\\n\\n\\t\\tint num_bits = 0;\\n\\t\\tif (config_bits[config_cursor++] == State::S1) num_bits |= 1;\\n\\t\\tif (config_bits[config_cursor++] == State::S1) num_bits |= 2;\\n\\t\\tif (config_bits[config_cursor++] == State::S1) num_bits |= 4;\\n\\t\\tif (config_bits[config_cursor++] == State::S1) num_bits |= 8;\\n\\n\\t\\tint port_a_cursor = 0;\\n\\t\\twhile (port_a_cursor < GetSize(port_a))\\n\\t\\t{\\n\\t\\t\\tlog_assert(config_cursor + 2 + 2*num_bits <= config_width);\\n\\n\\t\\t\\tport_t this_port;\\n\\t\\t\\tthis_port.is_signed = config_bits[config_cursor++] == State::S1;\\n\\t\\t\\tthis_port.do_subtract = config_bits[config_cursor++] == State::S1;\\n\\n\\t\\t\\tint size_a = 0;\\n\\t\\t\\tfor (int i = 0; i < num_bits; i++)\\n\\t\\t\\t\\tif (config_bits[config_cursor++] == State::S1)\\n\\t\\t\\t\\t\\tsize_a |= 1 << i;\\n\\n\\t\\t\\tthis_port.in_a = port_a.extract(port_a_cursor, size_a);\\n\\t\\t\\tport_a_cursor += size_a;\\n\\n\\t\\t\\tint size_b = 0;\\n\\t\\t\\tfor (int i = 0; i < num_bits; i++)\\n\\t\\t\\t\\tif (config_bits[config_cursor++] == State::S1)\\n\\t\\t\\t\\t\\tsize_b |= 1 << i;\\n\\n\\t\\t\\tthis_port.in_b = port_a.extract(port_a_cursor, size_b);\\n\\t\\t\\tport_a_cursor += size_b;\\n\\n\\t\\t\\tif (size_a || size_b)\\n\\t\\t\\t\\tports.push_back(this_port);\\n\\t\\t}\\n\\n\\t\\tlog_assert(config_cursor == config_width);\\n\\t\\tlog_assert(port_a_cursor == GetSize(port_a));\\n\\t}\\n\\n\\tvoid to_cell(RTLIL::Cell *cell) const\\n\\t{\\n\\t\\tRTLIL::SigSpec port_a;\\n\\t\\tstd::vector<RTLIL::State> config_bits;\\n\\t\\tint max_size = 0, num_bits = 0;\\n\\n\\t\\tfor (auto &port : ports) {\\n\\t\\t\\tmax_size = max(max_size, GetSize(port.in_a));\\n\\t\\t\\tmax_size = max(max_size, GetSize(port.in_b));\\n\\t\\t}\\n\\n\\t\\twhile (max_size)\\n\\t\\t\\tnum_bits++, max_size /= 2;\\n\\n\\t\\tlog_assert(num_bits < 16);\\n\\t\\tconfig_bits.push_back(num_bits & 1 ? State::S1 : State::S0);\\n\\t\\tconfig_bits.push_back(num_bits & 2 ? State::S1 : State::S0);\\n\\t\\tconfig_bits.push_back(num_bits & 4 ? State::S1 : State::S0);\\n\\t\\tconfig_bits.push_back(num_bits & 8 ? State::S1 : State::S0);\\n\\n\\t\\tfor (auto &port : ports)\\n\\t\\t{\\n\\t\\t\\tif (GetSize(port.in_a) == 0)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tconfig_bits.push_back(port.is_signed ? State::S1 : State::S0);\\n\\t\\t\\tconfig_bits.push_back(port.do_subtract ? State::S1 : State::S0);\\n\\n\\t\\t\\tint size_a = GetSize(port.in_a);\\n\\t\\t\\tfor (int i = 0; i < num_bits; i++)\\n\\t\\t\\t\\tconfig_bits.push_back(size_a & (1 << i) ? State::S1 : State::S0);\\n\\n\\t\\t\\tint size_b = GetSize(port.in_b);\\n\\t\\t\\tfor (int i = 0; i < num_bits; i++)\\n\\t\\t\\t\\tconfig_bits.push_back(size_b & (1 << i) ? State::S1 : State::S0);\\n\\n\\t\\t\\tport_a.append(port.in_a);\\n\\t\\t\\tport_a.append(port.in_b);\\n\\t\\t}\\n\\n\\t\\tcell->setPort(ID::A, port_a);\\n\\t\\tcell->setPort(ID::B, bit_ports);\\n\\t\\tcell->setParam(ID::CONFIG, config_bits);\\n\\t\\tcell->setParam(ID::CONFIG_WIDTH, GetSize(config_bits));\\n\\t\\tcell->setParam(ID::A_WIDTH, GetSize(port_a));\\n\\t\\tcell->setParam(ID::B_WIDTH, GetSize(bit_ports));\\n\\t}\\n\\n\\tbool eval(RTLIL::Const &result) const\\n\\t{\\n\\t\\tfor (auto &bit : result.bits)\\n\\t\\t\\tbit = State::S0;\\n\\n\\t\\tfor (auto &port : ports)\\n\\t\\t{\\n\\t\\t\\tif (!port.in_a.is_fully_const() || !port.in_b.is_fully_const())\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tRTLIL::Const summand;\\n\\t\\t\\tif (GetSize(port.in_b) == 0)\\n\\t\\t\\t\\tsummand = const_pos(port.in_a.as_const(), port.in_b.as_const(), port.is_signed, port.is_signed, GetSize(result));\\n\\t\\t\\telse\\n\\t\\t\\t\\tsummand = const_mul(port.in_a.as_const(), port.in_b.as_const(), port.is_signed, port.is_signed, GetSize(result));\\n\\n\\t\\t\\tif (port.do_subtract)\\n\\t\\t\\t\\tresult = const_sub(result, summand, port.is_signed, port.is_signed, GetSize(result));\\n\\t\\t\\telse\\n\\t\\t\\t\\tresult = const_add(result, summand, port.is_signed, port.is_signed, GetSize(result));\\n\\t\\t}\\n\\n\\t\\tfor (auto bit : bit_ports) {\\n\\t\\t\\tif (bit.wire)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tresult = const_add(result, bit.data, false, false, GetSize(result));\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tMacc(RTLIL::Cell *cell = nullptr)\\n\\t{\\n\\t\\tif (cell != nullptr)\\n\\t\\t\\tfrom_cell(cell);\\n\\t}\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"mem.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2020  Marcelina Kościelnicka <mwk@0x04.net>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef MEM_H\\n#define MEM_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n#include \\\"kernel/ffinit.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct MemRd : RTLIL::AttrObject {\\n\\tbool removed;\\n\\tCell *cell;\\n\\tint wide_log2;\\n\\tbool clk_enable, clk_polarity, ce_over_srst;\\n\\tConst arst_value, srst_value, init_value;\\n\\t// One bit for every write port, true iff simultanous read on this\\n\\t// port and write on the other port will bypass the written data\\n\\t// to this port's output (default behavior is to read old value).\\n\\t// Can only be set for write ports that have the same clock domain.\\n\\tstd::vector<bool> transparency_mask;\\n\\t// One bit for every write port, true iff simultanous read on this\\n\\t// port and write on the other port will return an all-X (don't care)\\n\\t// value.  Mutually exclusive with transparency_mask.\\n\\t// Can only be set for write ports that have the same clock domain.\\n\\t// For optimization purposes, this will also be set if we can\\n\\t// determine that the two ports can never be active simultanously\\n\\t// (making the above vacuously true).\\n\\tstd::vector<bool> collision_x_mask;\\n\\tSigSpec clk, en, arst, srst, addr, data;\\n\\n\\tMemRd() : removed(false), cell(nullptr), wide_log2(0), clk_enable(false), clk_polarity(true), ce_over_srst(false), clk(State::Sx), en(State::S1), arst(State::S0), srst(State::S0) {}\\n\\n\\t// Returns the address of given subword index accessed by this port.\\n\\tSigSpec sub_addr(int sub) {\\n\\t\\tSigSpec res = addr;\\n\\t\\tfor (int i = 0; i < wide_log2; i++)\\n\\t\\t\\tres[i] = State(sub >> i & 1);\\n\\t\\treturn res;\\n\\t}\\n};\\n\\nstruct MemWr : RTLIL::AttrObject {\\n\\tbool removed;\\n\\tCell *cell;\\n\\tint wide_log2;\\n\\tbool clk_enable, clk_polarity;\\n\\tstd::vector<bool> priority_mask;\\n\\tSigSpec clk, en, addr, data;\\n\\n\\tMemWr() : removed(false), cell(nullptr) {}\\n\\n\\t// Returns the address of given subword index accessed by this port.\\n\\tSigSpec sub_addr(int sub) {\\n\\t\\tSigSpec res = addr;\\n\\t\\tfor (int i = 0; i < wide_log2; i++)\\n\\t\\t\\tres[i] = State(sub >> i & 1);\\n\\t\\treturn res;\\n\\t}\\n\\n\\tstd::pair<SigSpec, std::vector<int>> compress_en();\\n\\tSigSpec decompress_en(const std::vector<int> &swizzle, SigSpec sig);\\n};\\n\\nstruct MemInit : RTLIL::AttrObject {\\n\\tbool removed;\\n\\tCell *cell;\\n\\tConst addr;\\n\\tConst data;\\n\\tConst en;\\n\\tMemInit() : removed(false), cell(nullptr) {}\\n};\\n\\nstruct Mem : RTLIL::AttrObject {\\n\\tModule *module;\\n\\tIdString memid;\\n\\tbool packed;\\n\\tRTLIL::Memory *mem;\\n\\tCell *cell;\\n\\tint width, start_offset, size;\\n\\tstd::vector<MemInit> inits;\\n\\tstd::vector<MemRd> rd_ports;\\n\\tstd::vector<MemWr> wr_ports;\\n\\n\\t// Removes this memory from the module.  The data in helper structures\\n\\t// is unaffected except for the cell/mem fields.\\n\\tvoid remove();\\n\\n\\t// Commits all changes in helper structures into the module — ports and\\n\\t// inits marked as removed are actually removed, new ports/inits create\\n\\t// new cells, modified port/inits are commited into their existing\\n\\t// cells.  Note that this reindexes the ports and inits array (actually\\n\\t// removing the ports/inits marked as removed).\\n\\tvoid emit();\\n\\n\\t// Marks all inits as removed.\\n\\tvoid clear_inits();\\n\\n\\t// Coalesces inits: whenever two inits have overlapping or touching\\n\\t// address ranges, they are combined into one, with the higher-priority\\n\\t// one's data overwriting the other.  Running this results in\\n\\t// an inits list equivalent to the original, in which all entries\\n\\t// cover disjoint (and non-touching) address ranges, and all enable\\n\\t// masks are all-1.\\n\\tvoid coalesce_inits();\\n\\n\\t// Checks consistency of this memory and all its ports/inits, using\\n\\t// log_assert.\\n\\tvoid check();\\n\\n\\t// Gathers all initialization data into a single big const covering\\n\\t// the whole memory.  For all non-initialized bits, Sx will be returned.\\n\\tConst get_init_data() const;\\n\\n\\t// Constructs and returns the helper structures for all memories\\n\\t// in a module.\\n\\tstatic std::vector<Mem> get_all_memories(Module *module);\\n\\n\\t// Constructs and returns the helper structures for all selected\\n\\t// memories in a module.\\n\\tstatic std::vector<Mem> get_selected_memories(Module *module);\\n\\n\\t// Converts a synchronous read port into an asynchronous one by\\n\\t// extracting the data (or, in some rare cases, address) register\\n\\t// into a separate cell, together with any soft-transparency\\n\\t// logic necessary to preserve its semantics.  Returns the created\\n\\t// register cell, if any.  Note that in some rare cases this function\\n\\t// may succeed and perform a conversion without creating a new\\n\\t// register — a nullptr result doesn't imply nothing was done.\\n\\tCell *extract_rdff(int idx, FfInitVals *initvals);\\n\\n\\t// Splits all wide ports in this memory into equivalent narrow ones.\\n\\t// This function performs no modifications at all to the actual\\n\\t// netlist unless and until emit() is called.\\n\\tvoid narrow();\\n\\n\\t// If write port idx2 currently has priority over write port idx1,\\n\\t// inserts extra logic on idx1's enable signal to disable writes\\n\\t// when idx2 is writing to the same address, then removes the priority\\n\\t// from the priority mask.  If there is a memory port that is\\n\\t// transparent with idx1, but not with idx2, that port is converted\\n\\t// to use soft transparency logic.\\n\\tvoid emulate_priority(int idx1, int idx2, FfInitVals *initvals);\\n\\n\\t// Creates soft-transparency logic on read port ridx, bypassing the\\n\\t// data from write port widx.  Should only be called when ridx is\\n\\t// transparent wrt widx in the first place.  Once we're done, the\\n\\t// transparency_mask bit will be cleared, and the collision_x_mask\\n\\t// bit will be set instead (since whatever value is read will be\\n\\t// replaced by the soft transparency logic).\\n\\tvoid emulate_transparency(int widx, int ridx, FfInitVals *initvals);\\n\\n\\t// Prepares for merging write port idx2 into idx1 (where idx1 < idx2).\\n\\t// Specifically, takes care of priority masks: any priority relations\\n\\t// that idx2 had are replicated onto idx1, unless they conflict with\\n\\t// priorities already present on idx1, in which case emulate_priority\\n\\t// is called.  Likewise, ensures transparency and undefined collision\\n\\t// masks of all read ports have the same values for both ports,\\n\\t// calling emulate_transparency if necessary.\\n\\tvoid prepare_wr_merge(int idx1, int idx2, FfInitVals *initvals);\\n\\n\\t// Prepares for merging read port idx2 into idx1.\\n\\t// Specifically, makes sure the transparency and undefined collision\\n\\t// masks of both ports are equal, by changing undefined behavior\\n\\t// of one port to the other's defined behavior, or by calling\\n\\t// emulate_transparency if necessary.\\n\\tvoid prepare_rd_merge(int idx1, int idx2, FfInitVals *initvals);\\n\\n\\t// Prepares the memory for widening a port to a given width.  This\\n\\t// involves ensuring that start_offset and size are aligned to the\\n\\t// target width.\\n\\tvoid widen_prep(int wide_log2);\\n\\n\\t// Widens a write port up to a given width.  The newly port is\\n\\t// equivalent to the original, made by replicating enable/data bits\\n\\t// and masking enable bits with decoders on the low part of the\\n\\t// original address.\\n\\tvoid widen_wr_port(int idx, int wide_log2);\\n\\n\\t// Emulates a sync read port's enable functionality in soft logic,\\n\\t// changing the actual read port's enable to be always-on.\\n\\tvoid emulate_rden(int idx, FfInitVals *initvals);\\n\\n\\t// Emulates a sync read port's initial/reset value functionality in\\n\\t// soft logic, removing it from the actual read port.\\n\\tvoid emulate_reset(int idx, bool emu_init, bool emu_arst, bool emu_srst, FfInitVals *initvals);\\n\\n\\t// Given a read port with ce_over_srst set, converts it to a port\\n\\t// with ce_over_srst unset without changing its behavior by adding\\n\\t// emulation logic.\\n\\tvoid emulate_rd_ce_over_srst(int idx);\\n\\n\\t// Given a read port with ce_over_srst unset, converts it to a port\\n\\t// with ce_over_srst set without changing its behavior by adding\\n\\t// emulation logic.\\n\\tvoid emulate_rd_srst_over_ce(int idx);\\n\\n\\t// Returns true iff emulate_read_first makes sense to call.\\n\\tbool emulate_read_first_ok();\\n\\n\\t// Emulates all read-first read-write port relationships in terms of\\n\\t// all-transparent ports, by delaying all write ports by one cycle.\\n\\t// This can only be used when all read ports and all write ports are\\n\\t// in the same clock domain.\\n\\tvoid emulate_read_first(FfInitVals *initvals);\\n\\n\\tMem(Module *module, IdString memid, int width, int start_offset, int size) : module(module), memid(memid), packed(false), mem(nullptr), cell(nullptr), width(width), start_offset(start_offset), size(size) {}\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"modtools.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef MODTOOLS_H\\n#define MODTOOLS_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n#include \\\"kernel/sigtools.h\\\"\\n#include \\\"kernel/celltypes.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct ModIndex : public RTLIL::Monitor\\n{\\n\\tstruct PortInfo {\\n\\t\\tRTLIL::Cell* cell;\\n\\t\\tRTLIL::IdString port;\\n\\t\\tint offset;\\n\\n\\t\\tPortInfo() : cell(), port(), offset() { }\\n\\t\\tPortInfo(RTLIL::Cell* _c, RTLIL::IdString _p, int _o) : cell(_c), port(_p), offset(_o) { }\\n\\n\\t\\tbool operator<(const PortInfo &other) const {\\n\\t\\t\\tif (cell != other.cell)\\n\\t\\t\\t\\treturn cell < other.cell;\\n\\t\\t\\tif (offset != other.offset)\\n\\t\\t\\t\\treturn offset < other.offset;\\n\\t\\t\\treturn port < other.port;\\n\\t\\t}\\n\\n\\t\\tbool operator==(const PortInfo &other) const {\\n\\t\\t\\treturn cell == other.cell && port == other.port && offset == other.offset;\\n\\t\\t}\\n\\n\\t\\tunsigned int hash() const {\\n\\t\\t\\treturn mkhash_add(mkhash(cell->name.hash(), port.hash()), offset);\\n\\t\\t}\\n\\t};\\n\\n\\tstruct SigBitInfo\\n\\t{\\n\\t\\tbool is_input, is_output;\\n\\t\\tpool<PortInfo> ports;\\n\\n\\t\\tSigBitInfo() : is_input(false), is_output(false) { }\\n\\n\\t\\tbool operator==(const SigBitInfo &other) const {\\n\\t\\t\\treturn is_input == other.is_input && is_output == other.is_output && ports == other.ports;\\n\\t\\t}\\n\\n\\t\\tvoid merge(const SigBitInfo &other)\\n\\t\\t{\\n\\t\\t\\tis_input = is_input || other.is_input;\\n\\t\\t\\tis_output = is_output || other.is_output;\\n\\t\\t\\tports.insert(other.ports.begin(), other.ports.end());\\n\\t\\t}\\n\\t};\\n\\n\\tSigMap sigmap;\\n\\tRTLIL::Module *module;\\n\\tstd::map<RTLIL::SigBit, SigBitInfo> database;\\n\\tint auto_reload_counter;\\n\\tbool auto_reload_module;\\n\\n\\tvoid port_add(RTLIL::Cell *cell, RTLIL::IdString port, const RTLIL::SigSpec &sig)\\n\\t{\\n\\t\\tfor (int i = 0; i < GetSize(sig); i++) {\\n\\t\\t\\tRTLIL::SigBit bit = sigmap(sig[i]);\\n\\t\\t\\tif (bit.wire)\\n\\t\\t\\t\\tdatabase[bit].ports.insert(PortInfo(cell, port, i));\\n\\t\\t}\\n\\t}\\n\\n\\tvoid port_del(RTLIL::Cell *cell, RTLIL::IdString port, const RTLIL::SigSpec &sig)\\n\\t{\\n\\t\\tfor (int i = 0; i < GetSize(sig); i++) {\\n\\t\\t\\tRTLIL::SigBit bit = sigmap(sig[i]);\\n\\t\\t\\tif (bit.wire)\\n\\t\\t\\t\\tdatabase[bit].ports.erase(PortInfo(cell, port, i));\\n\\t\\t}\\n\\t}\\n\\n\\tconst SigBitInfo &info(RTLIL::SigBit bit)\\n\\t{\\n\\t\\treturn database[sigmap(bit)];\\n\\t}\\n\\n\\tvoid reload_module(bool reset_sigmap = true)\\n\\t{\\n\\t\\tif (reset_sigmap) {\\n\\t\\t\\tsigmap.clear();\\n\\t\\t\\tsigmap.set(module);\\n\\t\\t}\\n\\n\\t\\tdatabase.clear();\\n\\t\\tfor (auto wire : module->wires())\\n\\t\\t\\tif (wire->port_input || wire->port_output)\\n\\t\\t\\t\\tfor (int i = 0; i < GetSize(wire); i++) {\\n\\t\\t\\t\\t\\tRTLIL::SigBit bit = sigmap(RTLIL::SigBit(wire, i));\\n\\t\\t\\t\\t\\tif (bit.wire && wire->port_input)\\n\\t\\t\\t\\t\\t\\tdatabase[bit].is_input = true;\\n\\t\\t\\t\\t\\tif (bit.wire && wire->port_output)\\n\\t\\t\\t\\t\\t\\tdatabase[bit].is_output = true;\\n\\t\\t\\t\\t}\\n\\t\\tfor (auto cell : module->cells())\\n\\t\\t\\tfor (auto &conn : cell->connections())\\n\\t\\t\\t\\tport_add(cell, conn.first, conn.second);\\n\\n\\t\\tif (auto_reload_module) {\\n\\t\\t\\tif (++auto_reload_counter > 2)\\n\\t\\t\\t\\tlog_warning(\\\"Auto-reload in ModIndex -- possible performance bug!\\\\n\\\");\\n\\t\\t\\tauto_reload_module = false;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid check()\\n\\t{\\n#ifndef NDEBUG\\n\\t\\tif (auto_reload_module)\\n\\t\\t\\treturn;\\n\\n\\t\\tfor (auto it : database)\\n\\t\\t\\tlog_assert(it.first == sigmap(it.first));\\n\\n\\t\\tauto database_bak = std::move(database);\\n\\t\\treload_module(false);\\n\\n\\t\\tif (!(database == database_bak))\\n\\t\\t{\\n\\t\\t\\tfor (auto &it : database_bak)\\n\\t\\t\\t\\tif (!database.count(it.first))\\n\\t\\t\\t\\t\\tlog(\\\"ModuleIndex::check(): Only in database_bak, not database: %s\\\\n\\\", log_signal(it.first));\\n\\n\\t\\t\\tfor (auto &it : database)\\n\\t\\t\\t\\tif (!database_bak.count(it.first))\\n\\t\\t\\t\\t\\tlog(\\\"ModuleIndex::check(): Only in database, not database_bak: %s\\\\n\\\", log_signal(it.first));\\n\\t\\t\\t\\telse if (!(it.second == database_bak.at(it.first)))\\n\\t\\t\\t\\t\\tlog(\\\"ModuleIndex::check(): Different content for database[%s].\\\\n\\\", log_signal(it.first));\\n\\n\\t\\t\\tlog_assert(database == database_bak);\\n\\t\\t}\\n#endif\\n\\t}\\n\\n\\tvoid notify_connect(RTLIL::Cell *cell, const RTLIL::IdString &port, const RTLIL::SigSpec &old_sig, const RTLIL::SigSpec &sig) override\\n\\t{\\n\\t\\tlog_assert(module == cell->module);\\n\\n\\t\\tif (auto_reload_module)\\n\\t\\t\\treturn;\\n\\n\\t\\tport_del(cell, port, old_sig);\\n\\t\\tport_add(cell, port, sig);\\n\\t}\\n\\n\\tvoid notify_connect(RTLIL::Module *mod, const RTLIL::SigSig &sigsig) override\\n\\t{\\n\\t\\tlog_assert(module == mod);\\n\\n\\t\\tif (auto_reload_module)\\n\\t\\t\\treturn;\\n\\n\\t\\tfor (int i = 0; i < GetSize(sigsig.first); i++)\\n\\t\\t{\\n\\t\\t\\tRTLIL::SigBit lhs = sigmap(sigsig.first[i]);\\n\\t\\t\\tRTLIL::SigBit rhs = sigmap(sigsig.second[i]);\\n\\t\\t\\tbool has_lhs = database.count(lhs) != 0;\\n\\t\\t\\tbool has_rhs = database.count(rhs) != 0;\\n\\n\\t\\t\\tif (!has_lhs && !has_rhs) {\\n\\t\\t\\t\\tsigmap.add(lhs, rhs);\\n\\t\\t\\t} else\\n\\t\\t\\tif (!has_rhs) {\\n\\t\\t\\t\\tSigBitInfo new_info = database.at(lhs);\\n\\t\\t\\t\\tdatabase.erase(lhs);\\n\\t\\t\\t\\tsigmap.add(lhs, rhs);\\n\\t\\t\\t\\tlhs = sigmap(lhs);\\n\\t\\t\\t\\tif (lhs.wire)\\n\\t\\t\\t\\t\\tdatabase[lhs] = new_info;\\n\\t\\t\\t} else\\n\\t\\t\\tif (!has_lhs) {\\n\\t\\t\\t\\tSigBitInfo new_info = database.at(rhs);\\n\\t\\t\\t\\tdatabase.erase(rhs);\\n\\t\\t\\t\\tsigmap.add(lhs, rhs);\\n\\t\\t\\t\\trhs = sigmap(rhs);\\n\\t\\t\\t\\tif (rhs.wire)\\n\\t\\t\\t\\t\\tdatabase[rhs] = new_info;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tSigBitInfo new_info = database.at(lhs);\\n\\t\\t\\t\\tnew_info.merge(database.at(rhs));\\n\\t\\t\\t\\tdatabase.erase(lhs);\\n\\t\\t\\t\\tdatabase.erase(rhs);\\n\\t\\t\\t\\tsigmap.add(lhs, rhs);\\n\\t\\t\\t\\trhs = sigmap(rhs);\\n\\t\\t\\t\\tif (rhs.wire)\\n\\t\\t\\t\\t\\tdatabase[rhs] = new_info;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvoid notify_connect(RTLIL::Module *mod, const std::vector<RTLIL::SigSig>&) override\\n\\t{\\n\\t\\tlog_assert(module == mod);\\n\\t\\tauto_reload_module = true;\\n\\t}\\n\\n\\tvoid notify_blackout(RTLIL::Module *mod) override\\n\\t{\\n\\t\\tlog_assert(module == mod);\\n\\t\\tauto_reload_module = true;\\n\\t}\\n\\n\\tModIndex(RTLIL::Module *_m) : sigmap(_m), module(_m)\\n\\t{\\n\\t\\tauto_reload_counter = 0;\\n\\t\\tauto_reload_module = true;\\n\\t\\tmodule->monitors.insert(this);\\n\\t}\\n\\n\\t~ModIndex()\\n\\t{\\n\\t\\tmodule->monitors.erase(this);\\n\\t}\\n\\n\\tSigBitInfo *query(RTLIL::SigBit bit)\\n\\t{\\n\\t\\tif (auto_reload_module)\\n\\t\\t\\treload_module();\\n\\n\\t\\tauto it = database.find(sigmap(bit));\\n\\t\\tif (it == database.end())\\n\\t\\t\\treturn nullptr;\\n\\t\\telse\\n\\t\\t\\treturn &it->second;\\n\\t}\\n\\n\\tbool query_is_input(RTLIL::SigBit bit)\\n\\t{\\n\\t\\tconst SigBitInfo *info = query(bit);\\n\\t\\tif (info == nullptr)\\n\\t\\t\\treturn false;\\n\\t\\treturn info->is_input;\\n\\t}\\n\\n\\tbool query_is_output(RTLIL::SigBit bit)\\n\\t{\\n\\t\\tconst SigBitInfo *info = query(bit);\\n\\t\\tif (info == nullptr)\\n\\t\\t\\treturn false;\\n\\t\\treturn info->is_output;\\n\\t}\\n\\n\\tpool<PortInfo> &query_ports(RTLIL::SigBit bit)\\n\\t{\\n\\t\\tstatic pool<PortInfo> empty_result_set;\\n\\t\\tSigBitInfo *info = query(bit);\\n\\t\\tif (info == nullptr)\\n\\t\\t\\treturn empty_result_set;\\n\\t\\treturn info->ports;\\n\\t}\\n\\n\\tvoid dump_db()\\n\\t{\\n\\t\\tlog(\\\"--- ModIndex Dump ---\\\\n\\\");\\n\\n\\t\\tif (auto_reload_module) {\\n\\t\\t\\tlog(\\\"AUTO-RELOAD\\\\n\\\");\\n\\t\\t\\treload_module();\\n\\t\\t}\\n\\n\\t\\tfor (auto &it : database) {\\n\\t\\t\\tlog(\\\"BIT %s:\\\\n\\\", log_signal(it.first));\\n\\t\\t\\tif (it.second.is_input)\\n\\t\\t\\t\\tlog(\\\"  PRIMARY INPUT\\\\n\\\");\\n\\t\\t\\tif (it.second.is_output)\\n\\t\\t\\t\\tlog(\\\"  PRIMARY OUTPUT\\\\n\\\");\\n\\t\\t\\tfor (auto &port : it.second.ports)\\n\\t\\t\\t\\tlog(\\\"  PORT: %s.%s[%d] (%s)\\\\n\\\", log_id(port.cell),\\n\\t\\t\\t\\t\\t\\tlog_id(port.port), port.offset, log_id(port.cell->type));\\n\\t\\t}\\n\\t}\\n};\\n\\nstruct ModWalker\\n{\\n\\tstruct PortBit\\n\\t{\\n\\t\\tRTLIL::Cell *cell;\\n\\t\\tRTLIL::IdString port;\\n\\t\\tint offset;\\n\\n\\t\\tbool operator<(const PortBit &other) const {\\n\\t\\t\\tif (cell != other.cell)\\n\\t\\t\\t\\treturn cell < other.cell;\\n\\t\\t\\tif (port != other.port)\\n\\t\\t\\t\\treturn port < other.port;\\n\\t\\t\\treturn offset < other.offset;\\n\\t\\t}\\n\\n\\t\\tbool operator==(const PortBit &other) const {\\n\\t\\t\\treturn cell == other.cell && port == other.port && offset == other.offset;\\n\\t\\t}\\n\\n\\t\\tunsigned int hash() const {\\n\\t\\t\\treturn mkhash_add(mkhash(cell->name.hash(), port.hash()), offset);\\n\\t\\t}\\n\\t};\\n\\n\\tRTLIL::Design *design;\\n\\tRTLIL::Module *module;\\n\\n\\tCellTypes ct;\\n\\tSigMap sigmap;\\n\\n\\tdict<RTLIL::SigBit, pool<PortBit>> signal_drivers;\\n\\tdict<RTLIL::SigBit, pool<PortBit>> signal_consumers;\\n\\tpool<RTLIL::SigBit> signal_inputs, signal_outputs;\\n\\n\\tdict<RTLIL::Cell*, pool<RTLIL::SigBit>> cell_outputs, cell_inputs;\\n\\n\\tvoid add_wire(RTLIL::Wire *wire)\\n\\t{\\n\\t\\tif (wire->port_input) {\\n\\t\\t\\tstd::vector<RTLIL::SigBit> bits = sigmap(wire);\\n\\t\\t\\tfor (auto bit : bits)\\n\\t\\t\\t\\tif (bit.wire != NULL)\\n\\t\\t\\t\\t\\tsignal_inputs.insert(bit);\\n\\t\\t}\\n\\n\\t\\tif (wire->port_output) {\\n\\t\\t\\tstd::vector<RTLIL::SigBit> bits = sigmap(wire);\\n\\t\\t\\tfor (auto bit : bits)\\n\\t\\t\\t\\tif (bit.wire != NULL)\\n\\t\\t\\t\\t\\tsignal_outputs.insert(bit);\\n\\t\\t}\\n\\t}\\n\\n\\tvoid add_cell_port(RTLIL::Cell *cell, RTLIL::IdString port, std::vector<RTLIL::SigBit> bits, bool is_output, bool is_input)\\n\\t{\\n\\t\\tfor (int i = 0; i < int(bits.size()); i++)\\n\\t\\t\\tif (bits[i].wire != NULL) {\\n\\t\\t\\t\\tPortBit pbit = { cell, port, i };\\n\\t\\t\\t\\tif (is_output) {\\n\\t\\t\\t\\t\\tsignal_drivers[bits[i]].insert(pbit);\\n\\t\\t\\t\\t\\tcell_outputs[cell].insert(bits[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (is_input) {\\n\\t\\t\\t\\t\\tsignal_consumers[bits[i]].insert(pbit);\\n\\t\\t\\t\\t\\tcell_inputs[cell].insert(bits[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n\\n\\tvoid add_cell(RTLIL::Cell *cell)\\n\\t{\\n\\t\\tif (ct.cell_known(cell->type)) {\\n\\t\\t\\tfor (auto &conn : cell->connections())\\n\\t\\t\\t\\tadd_cell_port(cell, conn.first, sigmap(conn.second),\\n\\t\\t\\t\\t\\t\\tct.cell_output(cell->type, conn.first),\\n\\t\\t\\t\\t\\t\\tct.cell_input(cell->type, conn.first));\\n\\t\\t} else {\\n\\t\\t\\tfor (auto &conn : cell->connections())\\n\\t\\t\\t\\tadd_cell_port(cell, conn.first, sigmap(conn.second), true, true);\\n\\t\\t}\\n\\t}\\n\\n\\tModWalker(RTLIL::Design *design, RTLIL::Module *module = nullptr) : design(design), module(NULL)\\n\\t{\\n\\t\\tct.setup(design);\\n\\t\\tif (module)\\n\\t\\t\\tsetup(module);\\n\\t}\\n\\n\\tvoid setup(RTLIL::Module *module, CellTypes *filter_ct = NULL)\\n\\t{\\n\\t\\tthis->module = module;\\n\\n\\t\\tsigmap.set(module);\\n\\n\\t\\tsignal_drivers.clear();\\n\\t\\tsignal_consumers.clear();\\n\\t\\tsignal_inputs.clear();\\n\\t\\tsignal_outputs.clear();\\n\\t\\tcell_inputs.clear();\\n\\t\\tcell_outputs.clear();\\n\\n\\t\\tfor (auto &it : module->wires_)\\n\\t\\t\\tadd_wire(it.second);\\n\\t\\tfor (auto &it : module->cells_)\\n\\t\\t\\tif (filter_ct == NULL || filter_ct->cell_known(it.second->type))\\n\\t\\t\\t\\tadd_cell(it.second);\\n\\t}\\n\\n\\t// get_* methods -- single RTLIL::SigBit\\n\\n\\tinline bool get_drivers(pool<PortBit> &result, RTLIL::SigBit bit) const\\n\\t{\\n\\t\\tbool found = false;\\n\\t\\tif (signal_drivers.count(bit)) {\\n\\t\\t\\tconst pool<PortBit> &r = signal_drivers.at(bit);\\n\\t\\t\\tresult.insert(r.begin(), r.end());\\n\\t\\t\\tfound = true;\\n\\t\\t}\\n\\t\\treturn found;\\n\\t}\\n\\n\\tinline bool get_consumers(pool<PortBit> &result, RTLIL::SigBit bit) const\\n\\t{\\n\\t\\tbool found = false;\\n\\t\\tif (signal_consumers.count(bit)) {\\n\\t\\t\\tconst pool<PortBit> &r = signal_consumers.at(bit);\\n\\t\\t\\tresult.insert(r.begin(), r.end());\\n\\t\\t\\tfound = true;\\n\\t\\t}\\n\\t\\treturn found;\\n\\t}\\n\\n\\tinline bool get_inputs(pool<RTLIL::SigBit> &result, RTLIL::SigBit bit) const\\n\\t{\\n\\t\\tbool found = false;\\n\\t\\tif (signal_inputs.count(bit))\\n\\t\\t\\tresult.insert(bit), found = true;\\n\\t\\treturn found;\\n\\t}\\n\\n\\tinline bool get_outputs(pool<RTLIL::SigBit> &result, RTLIL::SigBit bit) const\\n\\t{\\n\\t\\tbool found = false;\\n\\t\\tif (signal_outputs.count(bit))\\n\\t\\t\\tresult.insert(bit), found = true;\\n\\t\\treturn found;\\n\\t}\\n\\n\\t// get_* methods -- container of RTLIL::SigBit's (always by reference)\\n\\n\\ttemplate<typename T>\\n\\tinline bool get_drivers(pool<PortBit> &result, const T &bits) const\\n\\t{\\n\\t\\tbool found = false;\\n\\t\\tfor (RTLIL::SigBit bit : bits)\\n\\t\\t\\tif (signal_drivers.count(bit)) {\\n\\t\\t\\t\\tconst pool<PortBit> &r = signal_drivers.at(bit);\\n\\t\\t\\t\\tresult.insert(r.begin(), r.end());\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t}\\n\\t\\treturn found;\\n\\t}\\n\\n\\ttemplate<typename T>\\n\\tinline bool get_consumers(pool<PortBit> &result, const T &bits) const\\n\\t{\\n\\t\\tbool found = false;\\n\\t\\tfor (RTLIL::SigBit bit : bits)\\n\\t\\t\\tif (signal_consumers.count(bit)) {\\n\\t\\t\\t\\tconst pool<PortBit> &r = signal_consumers.at(bit);\\n\\t\\t\\t\\tresult.insert(r.begin(), r.end());\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t}\\n\\t\\treturn found;\\n\\t}\\n\\n\\ttemplate<typename T>\\n\\tinline bool get_inputs(pool<RTLIL::SigBit> &result, const T &bits) const\\n\\t{\\n\\t\\tbool found = false;\\n\\t\\tfor (RTLIL::SigBit bit : bits)\\n\\t\\t\\tif (signal_inputs.count(bit))\\n\\t\\t\\t\\tresult.insert(bit), found = true;\\n\\t\\treturn found;\\n\\t}\\n\\n\\ttemplate<typename T>\\n\\tinline bool get_outputs(pool<RTLIL::SigBit> &result, const T &bits) const\\n\\t{\\n\\t\\tbool found = false;\\n\\t\\tfor (RTLIL::SigBit bit : bits)\\n\\t\\t\\tif (signal_outputs.count(bit))\\n\\t\\t\\t\\tresult.insert(bit), found = true;\\n\\t\\treturn found;\\n\\t}\\n\\n\\t// get_* methods -- call by RTLIL::SigSpec (always by value)\\n\\n\\tbool get_drivers(pool<PortBit> &result, RTLIL::SigSpec signal) const\\n\\t{\\n\\t\\tstd::vector<RTLIL::SigBit> bits = sigmap(signal);\\n\\t\\treturn get_drivers(result, bits);\\n\\t}\\n\\n\\tbool get_consumers(pool<PortBit> &result, RTLIL::SigSpec signal) const\\n\\t{\\n\\t\\tstd::vector<RTLIL::SigBit> bits = sigmap(signal);\\n\\t\\treturn get_consumers(result, bits);\\n\\t}\\n\\n\\tbool get_inputs(pool<RTLIL::SigBit> &result, RTLIL::SigSpec signal) const\\n\\t{\\n\\t\\tstd::vector<RTLIL::SigBit> bits = sigmap(signal);\\n\\t\\treturn get_inputs(result, bits);\\n\\t}\\n\\n\\tbool get_outputs(pool<RTLIL::SigBit> &result, RTLIL::SigSpec signal) const\\n\\t{\\n\\t\\tstd::vector<RTLIL::SigBit> bits = sigmap(signal);\\n\\t\\treturn get_outputs(result, bits);\\n\\t}\\n\\n\\t// has_* methods -- call by reference\\n\\n\\ttemplate<typename T>\\n\\tinline bool has_drivers(const T &sig) const {\\n\\t\\tpool<PortBit> result;\\n\\t\\treturn get_drivers(result, sig);\\n\\t}\\n\\n\\ttemplate<typename T>\\n\\tinline bool has_consumers(const T &sig) const {\\n\\t\\tpool<PortBit> result;\\n\\t\\treturn get_consumers(result, sig);\\n\\t}\\n\\n\\ttemplate<typename T>\\n\\tinline bool has_inputs(const T &sig) const {\\n\\t\\tpool<RTLIL::SigBit> result;\\n\\t\\treturn get_inputs(result, sig);\\n\\t}\\n\\n\\ttemplate<typename T>\\n\\tinline bool has_outputs(const T &sig) const {\\n\\t\\tpool<RTLIL::SigBit> result;\\n\\t\\treturn get_outputs(result, sig);\\n\\t}\\n\\n\\t// has_* methods -- call by value\\n\\n\\tinline bool has_drivers(RTLIL::SigSpec sig) const {\\n\\t\\tpool<PortBit> result;\\n\\t\\treturn get_drivers(result, sig);\\n\\t}\\n\\n\\tinline bool has_consumers(RTLIL::SigSpec sig) const {\\n\\t\\tpool<PortBit> result;\\n\\t\\treturn get_consumers(result, sig);\\n\\t}\\n\\n\\tinline bool has_inputs(RTLIL::SigSpec sig) const {\\n\\t\\tpool<RTLIL::SigBit> result;\\n\\t\\treturn get_inputs(result, sig);\\n\\t}\\n\\n\\tinline bool has_outputs(RTLIL::SigSpec sig) const {\\n\\t\\tpool<RTLIL::SigBit> result;\\n\\t\\treturn get_outputs(result, sig);\\n\\t}\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"qcsat.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2021  Marcelina Kościelnicka <mwk@0x04.net>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef QCSAT_H\\n#define QCSAT_H\\n\\n#include \\\"kernel/satgen.h\\\"\\n#include \\\"kernel/modtools.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\n// This is a helper class meant for easy construction of quick SAT queries\\n// to a combinatorial input cone of some set of signals, meant for SAT-based\\n// optimizations.  Various knobs are provided to set just how much of the\\n// cone should be included in the model — since this class is meant for\\n// optimization, it should not be a correctness problem when some cells are\\n// skipped and the solver spuriously returns SAT with a solution that\\n// cannot exist in reality due to skipped constraints (ie. only UNSAT results\\n// from this class should be considered binding).\\nstruct QuickConeSat {\\n\\tModWalker &modwalker;\\n\\tezSatPtr ez;\\n\\tSatGen satgen;\\n\\n\\t// The effort level knobs.\\n\\n\\t// The maximum \\\"complexity level\\\" of cells that will be imported.\\n\\t// - 1: bitwise operations, muxes, equality comparisons, lut, sop, fa\\n\\t// - 2: addition, subtraction, greater/less than comparisons, lcu\\n\\t// - 3: shifts\\n\\t// - 4: multiplication, division, power\\n\\tint max_cell_complexity = 2;\\n\\t// The maximum number of cells to import, or 0 for no limit.\\n\\tint max_cell_count = 0;\\n\\t// If non-0, skip importing cells with more than this number of output bits.\\n\\tint max_cell_outs = 0;\\n\\n\\t// Internal state.\\n\\tpool<RTLIL::Cell*> imported_cells;\\n\\tpool<RTLIL::Wire*> imported_onehot;\\n\\tpool<RTLIL::SigBit> bits_queue;\\n\\n\\tQuickConeSat(ModWalker &modwalker) : modwalker(modwalker), ez(), satgen(ez.get(), &modwalker.sigmap) {}\\n\\n\\t// Imports a signal into the SAT solver, queues its input cone to be\\n\\t// imported in the next prepare() call.\\n\\tstd::vector<int> importSig(SigSpec sig);\\n\\tint importSigBit(SigBit bit);\\n\\n\\t// Imports the input cones of all previously importSig'd signals into\\n\\t// the SAT solver.\\n\\tvoid prepare();\\n\\n\\t// Returns the \\\"complexity level\\\" of a given cell.\\n\\tstatic int cell_complexity(RTLIL::Cell *cell);\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"register.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef REGISTER_H\\n#define REGISTER_H\\n\\n#include \\\"kernel/yosys_common.h\\\"\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct Pass\\n{\\n\\tstd::string pass_name, short_help;\\n\\tPass(std::string name, std::string short_help = \\\"** document me **\\\");\\n\\tvirtual ~Pass();\\n\\n\\tvirtual void help();\\n\\tvirtual void clear_flags();\\n\\tvirtual void execute(std::vector<std::string> args, RTLIL::Design *design) = 0;\\n\\n\\tint call_counter;\\n\\tint64_t runtime_ns;\\n\\tbool experimental_flag = false;\\n\\n\\tvoid experimental() {\\n\\t\\texperimental_flag = true;\\n\\t}\\n\\n\\tstruct pre_post_exec_state_t {\\n\\t\\tPass *parent_pass;\\n\\t\\tint64_t begin_ns;\\n\\t};\\n\\n\\tpre_post_exec_state_t pre_execute();\\n\\tvoid post_execute(pre_post_exec_state_t state);\\n\\n\\tvoid cmd_log_args(const std::vector<std::string> &args);\\n\\tvoid cmd_error(const std::vector<std::string> &args, size_t argidx, std::string msg);\\n\\tvoid extra_args(std::vector<std::string> args, size_t argidx, RTLIL::Design *design, bool select = true);\\n\\n\\tstatic void call(RTLIL::Design *design, std::string command);\\n\\tstatic void call(RTLIL::Design *design, std::vector<std::string> args);\\n\\n\\tstatic void call_on_selection(RTLIL::Design *design, const RTLIL::Selection &selection, std::string command);\\n\\tstatic void call_on_selection(RTLIL::Design *design, const RTLIL::Selection &selection, std::vector<std::string> args);\\n\\n\\tstatic void call_on_module(RTLIL::Design *design, RTLIL::Module *module, std::string command);\\n\\tstatic void call_on_module(RTLIL::Design *design, RTLIL::Module *module, std::vector<std::string> args);\\n\\n\\tPass *next_queued_pass;\\n\\tvirtual void run_register();\\n\\tstatic void init_register();\\n\\tstatic void done_register();\\n\\n\\tvirtual void on_register();\\n\\tvirtual void on_shutdown();\\n\\tvirtual bool replace_existing_pass() const { return false; }\\n};\\n\\nstruct ScriptPass : Pass\\n{\\n\\tbool block_active, help_mode;\\n\\tRTLIL::Design *active_design;\\n\\tstd::string active_run_from, active_run_to;\\n\\n\\tScriptPass(std::string name, std::string short_help = \\\"** document me **\\\") : Pass(name, short_help) { }\\n\\n\\tvirtual void script() = 0;\\n\\n\\tbool check_label(std::string label, std::string info = std::string());\\n\\tvoid run(std::string command, std::string info = std::string());\\n\\tvoid run_nocheck(std::string command, std::string info = std::string());\\n\\tvoid run_script(RTLIL::Design *design, std::string run_from = std::string(), std::string run_to = std::string());\\n\\tvoid help_script();\\n};\\n\\nstruct Frontend : Pass\\n{\\n\\t// for reading of here documents\\n\\tstatic FILE *current_script_file;\\n\\tstatic std::string last_here_document;\\n\\n\\tstd::string frontend_name;\\n\\tFrontend(std::string name, std::string short_help = \\\"** document me **\\\");\\n\\tvoid run_register() override;\\n\\t~Frontend() override;\\n\\tvoid execute(std::vector<std::string> args, RTLIL::Design *design) override final;\\n\\tvirtual void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Design *design) = 0;\\n\\n\\tstatic std::vector<std::string> next_args;\\n\\tvoid extra_args(std::istream *&f, std::string &filename, std::vector<std::string> args, size_t argidx, bool bin_input = false);\\n\\n\\tstatic void frontend_call(RTLIL::Design *design, std::istream *f, std::string filename, std::string command);\\n\\tstatic void frontend_call(RTLIL::Design *design, std::istream *f, std::string filename, std::vector<std::string> args);\\n};\\n\\nstruct Backend : Pass\\n{\\n\\tstd::string backend_name;\\n\\tBackend(std::string name, std::string short_help = \\\"** document me **\\\");\\n\\tvoid run_register() override;\\n\\t~Backend() override;\\n\\tvoid execute(std::vector<std::string> args, RTLIL::Design *design) override final;\\n\\tvirtual void execute(std::ostream *&f, std::string filename,  std::vector<std::string> args, RTLIL::Design *design) = 0;\\n\\n\\tvoid extra_args(std::ostream *&f, std::string &filename, std::vector<std::string> args, size_t argidx, bool bin_output = false);\\n\\n\\tstatic void backend_call(RTLIL::Design *design, std::ostream *f, std::string filename, std::string command);\\n\\tstatic void backend_call(RTLIL::Design *design, std::ostream *f, std::string filename, std::vector<std::string> args);\\n};\\n\\n// implemented in passes/cmds/select.cc\\nextern void handle_extra_select_args(Pass *pass, const std::vector<std::string> &args, size_t argidx, size_t args_size, RTLIL::Design *design);\\nextern RTLIL::Selection eval_select_args(const vector<string> &args, RTLIL::Design *design);\\nextern void eval_select_op(vector<RTLIL::Selection> &work, const string &op, RTLIL::Design *design);\\n\\nextern std::map<std::string, Pass*> pass_register;\\nextern std::map<std::string, Frontend*> frontend_register;\\nextern std::map<std::string, Backend*> backend_register;\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"rtlil.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef RTLIL_H\\n#define RTLIL_H\\n\\n#include \\\"kernel/yosys_common.h\\\"\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nnamespace RTLIL\\n{\\n\\tenum State : unsigned char {\\n\\t\\tS0 = 0,\\n\\t\\tS1 = 1,\\n\\t\\tSx = 2, // undefined value or conflict\\n\\t\\tSz = 3, // high-impedance / not-connected\\n\\t\\tSa = 4, // don't care (used only in cases)\\n\\t\\tSm = 5  // marker (used internally by some passes)\\n\\t};\\n\\n\\tenum SyncType : unsigned char {\\n\\t\\tST0 = 0, // level sensitive: 0\\n\\t\\tST1 = 1, // level sensitive: 1\\n\\t\\tSTp = 2, // edge sensitive: posedge\\n\\t\\tSTn = 3, // edge sensitive: negedge\\n\\t\\tSTe = 4, // edge sensitive: both edges\\n\\t\\tSTa = 5, // always active\\n\\t\\tSTg = 6, // global clock\\n\\t\\tSTi = 7  // init\\n\\t};\\n\\n\\tenum ConstFlags : unsigned char {\\n\\t\\tCONST_FLAG_NONE   = 0,\\n\\t\\tCONST_FLAG_STRING = 1,\\n\\t\\tCONST_FLAG_SIGNED = 2,  // only used for parameters\\n\\t\\tCONST_FLAG_REAL   = 4   // only used for parameters\\n\\t};\\n\\n\\tstruct Const;\\n\\tstruct AttrObject;\\n\\tstruct Selection;\\n\\tstruct Monitor;\\n\\tstruct Design;\\n\\tstruct Module;\\n\\tstruct Wire;\\n\\tstruct Memory;\\n\\tstruct Cell;\\n\\tstruct SigChunk;\\n\\tstruct SigBit;\\n\\tstruct SigSpecIterator;\\n\\tstruct SigSpecConstIterator;\\n\\tstruct SigSpec;\\n\\tstruct CaseRule;\\n\\tstruct SwitchRule;\\n\\tstruct MemWriteAction;\\n\\tstruct SyncRule;\\n\\tstruct Process;\\n\\tstruct Binding;\\n\\n\\ttypedef std::pair<SigSpec, SigSpec> SigSig;\\n\\n\\tstruct IdString\\n\\t{\\n\\t\\t#undef YOSYS_XTRACE_GET_PUT\\n\\t\\t#undef YOSYS_SORT_ID_FREE_LIST\\n\\t\\t#undef YOSYS_USE_STICKY_IDS\\n\\t\\t#undef YOSYS_NO_IDS_REFCNT\\n\\n\\t\\t// the global id string cache\\n\\n\\t\\tstatic bool destruct_guard_ok; // POD, will be initialized to zero\\n\\t\\tstatic struct destruct_guard_t {\\n\\t\\t\\tdestruct_guard_t() { destruct_guard_ok = true; }\\n\\t\\t\\t~destruct_guard_t() { destruct_guard_ok = false; }\\n\\t\\t} destruct_guard;\\n\\n\\t\\tstatic std::vector<char*> global_id_storage_;\\n\\t\\tstatic dict<char*, int, hash_cstr_ops> global_id_index_;\\n\\t#ifndef YOSYS_NO_IDS_REFCNT\\n\\t\\tstatic std::vector<int> global_refcount_storage_;\\n\\t\\tstatic std::vector<int> global_free_idx_list_;\\n\\t#endif\\n\\n\\t#ifdef YOSYS_USE_STICKY_IDS\\n\\t\\tstatic int last_created_idx_ptr_;\\n\\t\\tstatic int last_created_idx_[8];\\n\\t#endif\\n\\n\\t\\tstatic inline void xtrace_db_dump()\\n\\t\\t{\\n\\t\\t#ifdef YOSYS_XTRACE_GET_PUT\\n\\t\\t\\tfor (int idx = 0; idx < GetSize(global_id_storage_); idx++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (global_id_storage_.at(idx) == nullptr)\\n\\t\\t\\t\\t\\tlog(\\\"#X# DB-DUMP index %d: FREE\\\\n\\\", idx);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlog(\\\"#X# DB-DUMP index %d: '%s' (ref %d)\\\\n\\\", idx, global_id_storage_.at(idx), global_refcount_storage_.at(idx));\\n\\t\\t\\t}\\n\\t\\t#endif\\n\\t\\t}\\n\\n\\t\\tstatic inline void checkpoint()\\n\\t\\t{\\n\\t\\t#ifdef YOSYS_USE_STICKY_IDS\\n\\t\\t\\tlast_created_idx_ptr_ = 0;\\n\\t\\t\\tfor (int i = 0; i < 8; i++) {\\n\\t\\t\\t\\tif (last_created_idx_[i])\\n\\t\\t\\t\\t\\tput_reference(last_created_idx_[i]);\\n\\t\\t\\t\\tlast_created_idx_[i] = 0;\\n\\t\\t\\t}\\n\\t\\t#endif\\n\\t\\t#ifdef YOSYS_SORT_ID_FREE_LIST\\n\\t\\t\\tstd::sort(global_free_idx_list_.begin(), global_free_idx_list_.end(), std::greater<int>());\\n\\t\\t#endif\\n\\t\\t}\\n\\n\\t\\tstatic inline int get_reference(int idx)\\n\\t\\t{\\n\\t\\t\\tif (idx) {\\n\\t\\t#ifndef YOSYS_NO_IDS_REFCNT\\n\\t\\t\\t\\tglobal_refcount_storage_[idx]++;\\n\\t\\t#endif\\n\\t\\t#ifdef YOSYS_XTRACE_GET_PUT\\n\\t\\t\\t\\tif (yosys_xtrace)\\n\\t\\t\\t\\t\\tlog(\\\"#X# GET-BY-INDEX '%s' (index %d, refcount %d)\\\\n\\\", global_id_storage_.at(idx), idx, global_refcount_storage_.at(idx));\\n\\t\\t#endif\\n\\t\\t\\t}\\n\\t\\t\\treturn idx;\\n\\t\\t}\\n\\n\\t\\tstatic int get_reference(const char *p)\\n\\t\\t{\\n\\t\\t\\tlog_assert(destruct_guard_ok);\\n\\n\\t\\t\\tif (!p[0])\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tauto it = global_id_index_.find((char*)p);\\n\\t\\t\\tif (it != global_id_index_.end()) {\\n\\t\\t#ifndef YOSYS_NO_IDS_REFCNT\\n\\t\\t\\t\\tglobal_refcount_storage_.at(it->second)++;\\n\\t\\t#endif\\n\\t\\t#ifdef YOSYS_XTRACE_GET_PUT\\n\\t\\t\\t\\tif (yosys_xtrace)\\n\\t\\t\\t\\t\\tlog(\\\"#X# GET-BY-NAME '%s' (index %d, refcount %d)\\\\n\\\", global_id_storage_.at(it->second), it->second, global_refcount_storage_.at(it->second));\\n\\t\\t#endif\\n\\t\\t\\t\\treturn it->second;\\n\\t\\t\\t}\\n\\n\\t\\t\\tlog_assert(p[0] == '$' || p[0] == '\\\\\\\\');\\n\\t\\t\\tlog_assert(p[1] != 0);\\n\\t\\t\\tfor (const char *c = p; *c; c++)\\n\\t\\t\\t\\tif ((unsigned)*c <= (unsigned)' ')\\n\\t\\t\\t\\t\\tlog_error(\\\"Found control character or space (0x%02x) in string '%s' which is not allowed in RTLIL identifiers\\\\n\\\", *c, p);\\n\\n\\t\\t#ifndef YOSYS_NO_IDS_REFCNT\\n\\t\\t\\tif (global_free_idx_list_.empty()) {\\n\\t\\t\\t\\tif (global_id_storage_.empty()) {\\n\\t\\t\\t\\t\\tglobal_refcount_storage_.push_back(0);\\n\\t\\t\\t\\t\\tglobal_id_storage_.push_back((char*)\\\"\\\");\\n\\t\\t\\t\\t\\tglobal_id_index_[global_id_storage_.back()] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlog_assert(global_id_storage_.size() < 0x40000000);\\n\\t\\t\\t\\tglobal_free_idx_list_.push_back(global_id_storage_.size());\\n\\t\\t\\t\\tglobal_id_storage_.push_back(nullptr);\\n\\t\\t\\t\\tglobal_refcount_storage_.push_back(0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint idx = global_free_idx_list_.back();\\n\\t\\t\\tglobal_free_idx_list_.pop_back();\\n\\t\\t\\tglobal_id_storage_.at(idx) = strdup(p);\\n\\t\\t\\tglobal_id_index_[global_id_storage_.at(idx)] = idx;\\n\\t\\t\\tglobal_refcount_storage_.at(idx)++;\\n\\t\\t#else\\n\\t\\t\\tif (global_id_storage_.empty()) {\\n\\t\\t\\t\\tglobal_id_storage_.push_back((char*)\\\"\\\");\\n\\t\\t\\t\\tglobal_id_index_[global_id_storage_.back()] = 0;\\n\\t\\t\\t}\\n\\t\\t\\tint idx = global_id_storage_.size();\\n\\t\\t\\tglobal_id_storage_.push_back(strdup(p));\\n\\t\\t\\tglobal_id_index_[global_id_storage_.back()] = idx;\\n\\t\\t#endif\\n\\n\\t\\t\\tif (yosys_xtrace) {\\n\\t\\t\\t\\tlog(\\\"#X# New IdString '%s' with index %d.\\\\n\\\", p, idx);\\n\\t\\t\\t\\tlog_backtrace(\\\"-X- \\\", yosys_xtrace-1);\\n\\t\\t\\t}\\n\\n\\t\\t#ifdef YOSYS_XTRACE_GET_PUT\\n\\t\\t\\tif (yosys_xtrace)\\n\\t\\t\\t\\tlog(\\\"#X# GET-BY-NAME '%s' (index %d, refcount %d)\\\\n\\\", global_id_storage_.at(idx), idx, global_refcount_storage_.at(idx));\\n\\t\\t#endif\\n\\n\\t\\t#ifdef YOSYS_USE_STICKY_IDS\\n\\t\\t\\t// Avoid Create->Delete->Create pattern\\n\\t\\t\\tif (last_created_idx_[last_created_idx_ptr_])\\n\\t\\t\\t\\tput_reference(last_created_idx_[last_created_idx_ptr_]);\\n\\t\\t\\tlast_created_idx_[last_created_idx_ptr_] = idx;\\n\\t\\t\\tget_reference(last_created_idx_[last_created_idx_ptr_]);\\n\\t\\t\\tlast_created_idx_ptr_ = (last_created_idx_ptr_ + 1) & 7;\\n\\t\\t#endif\\n\\n\\t\\t\\treturn idx;\\n\\t\\t}\\n\\n\\t#ifndef YOSYS_NO_IDS_REFCNT\\n\\t\\tstatic inline void put_reference(int idx)\\n\\t\\t{\\n\\t\\t\\t// put_reference() may be called from destructors after the destructor of\\n\\t\\t\\t// global_refcount_storage_ has been run. in this case we simply do nothing.\\n\\t\\t\\tif (!destruct_guard_ok || !idx)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t#ifdef YOSYS_XTRACE_GET_PUT\\n\\t\\t\\tif (yosys_xtrace) {\\n\\t\\t\\t\\tlog(\\\"#X# PUT '%s' (index %d, refcount %d)\\\\n\\\", global_id_storage_.at(idx), idx, global_refcount_storage_.at(idx));\\n\\t\\t\\t}\\n\\t\\t#endif\\n\\n\\t\\t\\tint &refcount = global_refcount_storage_[idx];\\n\\n\\t\\t\\tif (--refcount > 0)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tlog_assert(refcount == 0);\\n\\t\\t\\tfree_reference(idx);\\n\\t\\t}\\n\\t\\tstatic inline void free_reference(int idx)\\n\\t\\t{\\n\\t\\t\\tif (yosys_xtrace) {\\n\\t\\t\\t\\tlog(\\\"#X# Removed IdString '%s' with index %d.\\\\n\\\", global_id_storage_.at(idx), idx);\\n\\t\\t\\t\\tlog_backtrace(\\\"-X- \\\", yosys_xtrace-1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tglobal_id_index_.erase(global_id_storage_.at(idx));\\n\\t\\t\\tfree(global_id_storage_.at(idx));\\n\\t\\t\\tglobal_id_storage_.at(idx) = nullptr;\\n\\t\\t\\tglobal_free_idx_list_.push_back(idx);\\n\\t\\t}\\n\\t#else\\n\\t\\tstatic inline void put_reference(int) { }\\n\\t#endif\\n\\n\\t\\t// the actual IdString object is just is a single int\\n\\n\\t\\tint index_;\\n\\n\\t\\tinline IdString() : index_(0) { }\\n\\t\\tinline IdString(const char *str) : index_(get_reference(str)) { }\\n\\t\\tinline IdString(const IdString &str) : index_(get_reference(str.index_)) { }\\n\\t\\tinline IdString(IdString &&str) : index_(str.index_) { str.index_ = 0; }\\n\\t\\tinline IdString(const std::string &str) : index_(get_reference(str.c_str())) { }\\n\\t\\tinline ~IdString() { put_reference(index_); }\\n\\n\\t\\tinline void operator=(const IdString &rhs) {\\n\\t\\t\\tput_reference(index_);\\n\\t\\t\\tindex_ = get_reference(rhs.index_);\\n\\t\\t}\\n\\n\\t\\tinline void operator=(const char *rhs) {\\n\\t\\t\\tIdString id(rhs);\\n\\t\\t\\t*this = id;\\n\\t\\t}\\n\\n\\t\\tinline void operator=(const std::string &rhs) {\\n\\t\\t\\tIdString id(rhs);\\n\\t\\t\\t*this = id;\\n\\t\\t}\\n\\n\\t\\tinline const char *c_str() const {\\n\\t\\t\\treturn global_id_storage_.at(index_);\\n\\t\\t}\\n\\n\\t\\tinline std::string str() const {\\n\\t\\t\\treturn std::string(global_id_storage_.at(index_));\\n\\t\\t}\\n\\n\\t\\tinline bool operator<(const IdString &rhs) const {\\n\\t\\t\\treturn index_ < rhs.index_;\\n\\t\\t}\\n\\n\\t\\tinline bool operator==(const IdString &rhs) const { return index_ == rhs.index_; }\\n\\t\\tinline bool operator!=(const IdString &rhs) const { return index_ != rhs.index_; }\\n\\n\\t\\t// The methods below are just convenience functions for better compatibility with std::string.\\n\\n\\t\\tbool operator==(const std::string &rhs) const { return c_str() == rhs; }\\n\\t\\tbool operator!=(const std::string &rhs) const { return c_str() != rhs; }\\n\\n\\t\\tbool operator==(const char *rhs) const { return strcmp(c_str(), rhs) == 0; }\\n\\t\\tbool operator!=(const char *rhs) const { return strcmp(c_str(), rhs) != 0; }\\n\\n\\t\\tchar operator[](size_t i) const {\\n                        const char *p = c_str();\\n#ifndef NDEBUG\\n\\t\\t\\tfor (; i != 0; i--, p++)\\n\\t\\t\\t\\tlog_assert(*p != 0);\\n\\t\\t\\treturn *p;\\n#else\\n\\t\\t\\treturn *(p + i);\\n#endif\\n\\t\\t}\\n\\n\\t\\tstd::string substr(size_t pos = 0, size_t len = std::string::npos) const {\\n\\t\\t\\tif (len == std::string::npos || len >= strlen(c_str() + pos))\\n\\t\\t\\t\\treturn std::string(c_str() + pos);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn std::string(c_str() + pos, len);\\n\\t\\t}\\n\\n\\t\\tint compare(size_t pos, size_t len, const char* s) const {\\n\\t\\t\\treturn strncmp(c_str()+pos, s, len);\\n\\t\\t}\\n\\n\\t\\tbool begins_with(const char* prefix) const {\\n\\t\\t\\tsize_t len = strlen(prefix);\\n\\t\\t\\tif (size() < len) return false;\\n\\t\\t\\treturn compare(0, len, prefix) == 0;\\n\\t\\t}\\n\\n\\t\\tbool ends_with(const char* suffix) const {\\n\\t\\t\\tsize_t len = strlen(suffix);\\n\\t\\t\\tif (size() < len) return false;\\n\\t\\t\\treturn compare(size()-len, len, suffix) == 0;\\n\\t\\t}\\n\\n\\t\\tbool contains(const char* str) const {\\n\\t\\t\\treturn strstr(c_str(), str);\\n\\t\\t}\\n\\n\\t\\tsize_t size() const {\\n\\t\\t\\treturn strlen(c_str());\\n\\t\\t}\\n\\n\\t\\tbool empty() const {\\n\\t\\t\\treturn c_str()[0] == 0;\\n\\t\\t}\\n\\n\\t\\tvoid clear() {\\n\\t\\t\\t*this = IdString();\\n\\t\\t}\\n\\n\\t\\tunsigned int hash() const {\\n\\t\\t\\treturn index_;\\n\\t\\t}\\n\\n\\t\\t// The following is a helper key_compare class. Instead of for example std::set<Cell*>\\n\\t\\t// use std::set<Cell*, IdString::compare_ptr_by_name<Cell>> if the order of cells in the\\n\\t\\t// set has an influence on the algorithm.\\n\\n\\t\\ttemplate<typename T> struct compare_ptr_by_name {\\n\\t\\t\\tbool operator()(const T *a, const T *b) const {\\n\\t\\t\\t\\treturn (a == nullptr || b == nullptr) ? (a < b) : (a->name < b->name);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// often one needs to check if a given IdString is part of a list (for example a list\\n\\t\\t// of cell types). the following functions helps with that.\\n\\n\\t\\ttemplate<typename... Args>\\n\\t\\tbool in(Args... args) const {\\n\\t\\t\\t// Credit: https://articles.emptycrate.com/2016/05/14/folds_in_cpp11_ish.html\\n\\t\\t\\tbool result = false;\\n\\t\\t\\t(void) std::initializer_list<int>{ (result = result || in(args), 0)... };\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tbool in(const IdString &rhs) const { return *this == rhs; }\\n\\t\\tbool in(const char *rhs) const { return *this == rhs; }\\n\\t\\tbool in(const std::string &rhs) const { return *this == rhs; }\\n\\t\\tbool in(const pool<IdString> &rhs) const { return rhs.count(*this) != 0; }\\n\\n\\t\\tbool isPublic() const { return begins_with(\\\"\\\\\\\\\\\"); }\\n\\t};\\n\\n\\tnamespace ID {\\n#define X(_id) extern IdString _id;\\n#include \\\"kernel/constids.inc\\\"\\n#undef X\\n\\t};\\n\\n\\textern dict<std::string, std::string> constpad;\\n\\n\\tconst pool<IdString> &builtin_ff_cell_types();\\n\\n\\tstatic inline std::string escape_id(const std::string &str) {\\n\\t\\tif (str.size() > 0 && str[0] != '\\\\\\\\' && str[0] != '$')\\n\\t\\t\\treturn \\\"\\\\\\\\\\\" + str;\\n\\t\\treturn str;\\n\\t}\\n\\n\\tstatic inline std::string unescape_id(const std::string &str) {\\n\\t\\tif (str.size() < 2)\\n\\t\\t\\treturn str;\\n\\t\\tif (str[0] != '\\\\\\\\')\\n\\t\\t\\treturn str;\\n\\t\\tif (str[1] == '$' || str[1] == '\\\\\\\\')\\n\\t\\t\\treturn str;\\n\\t\\tif (str[1] >= '0' && str[1] <= '9')\\n\\t\\t\\treturn str;\\n\\t\\treturn str.substr(1);\\n\\t}\\n\\n\\tstatic inline std::string unescape_id(const RTLIL::IdString &str) {\\n\\t\\treturn unescape_id(str.str());\\n\\t}\\n\\n\\tstatic inline const char *id2cstr(const RTLIL::IdString &str) {\\n\\t\\treturn log_id(str);\\n\\t}\\n\\n\\ttemplate <typename T> struct sort_by_name_id {\\n\\t\\tbool operator()(T *a, T *b) const {\\n\\t\\t\\treturn a->name < b->name;\\n\\t\\t}\\n\\t};\\n\\n\\ttemplate <typename T> struct sort_by_name_str {\\n\\t\\tbool operator()(T *a, T *b) const {\\n\\t\\t\\treturn strcmp(a->name.c_str(), b->name.c_str()) < 0;\\n\\t\\t}\\n\\t};\\n\\n\\tstruct sort_by_id_str {\\n\\t\\tbool operator()(const RTLIL::IdString &a, const RTLIL::IdString &b) const {\\n\\t\\t\\treturn strcmp(a.c_str(), b.c_str()) < 0;\\n\\t\\t}\\n\\t};\\n\\n\\tstatic inline std::string encode_filename(const std::string &filename)\\n\\t{\\n\\t\\tstd::stringstream val;\\n\\t\\tif (!std::any_of(filename.begin(), filename.end(), [](char c) {\\n\\t\\t\\treturn static_cast<unsigned char>(c) < 33 || static_cast<unsigned char>(c) > 126;\\n\\t\\t})) return filename;\\n\\t\\tfor (unsigned char const c : filename) {\\n\\t\\t\\tif (c < 33 || c > 126)\\n\\t\\t\\t\\tval << stringf(\\\"$%02x\\\", c);\\n\\t\\t\\telse\\n\\t\\t\\t\\tval << c;\\n\\t\\t}\\n\\t\\treturn val.str();\\n\\t}\\n\\n\\t// see calc.cc for the implementation of this functions\\n\\tRTLIL::Const const_not         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_and         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_or          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_xor         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_xnor        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\n\\tRTLIL::Const const_reduce_and  (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_reduce_or   (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_reduce_xor  (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_reduce_xnor (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_reduce_bool (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\n\\tRTLIL::Const const_logic_not   (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_logic_and   (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_logic_or    (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\n\\tRTLIL::Const const_shl         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_shr         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_sshl        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_sshr        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_shift       (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_shiftx      (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\n\\tRTLIL::Const const_lt          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_le          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_eq          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_ne          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_eqx         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_nex         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_ge          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_gt          (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\n\\tRTLIL::Const const_add         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_sub         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_mul         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_div         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_divfloor    (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_modfloor    (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_mod         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_pow         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\n\\tRTLIL::Const const_pos         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\tRTLIL::Const const_neg         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, bool signed2, int result_len);\\n\\n\\tRTLIL::Const const_mux         (const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3);\\n\\tRTLIL::Const const_pmux        (const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3);\\n\\tRTLIL::Const const_bmux        (const RTLIL::Const &arg1, const RTLIL::Const &arg2);\\n\\tRTLIL::Const const_demux       (const RTLIL::Const &arg1, const RTLIL::Const &arg2);\\n\\n\\tRTLIL::Const const_bweqx       (const RTLIL::Const &arg1, const RTLIL::Const &arg2);\\n\\tRTLIL::Const const_bwmux       (const RTLIL::Const &arg1, const RTLIL::Const &arg2, const RTLIL::Const &arg3);\\n\\n\\n\\t// This iterator-range-pair is used for Design::modules(), Module::wires() and Module::cells().\\n\\t// It maintains a reference counter that is used to make sure that the container is not modified while being iterated over.\\n\\n\\ttemplate<typename T>\\n\\tstruct ObjIterator {\\n\\t\\tusing iterator_category = std::forward_iterator_tag;\\n\\t\\tusing value_type = T;\\n\\t\\tusing difference_type = ptrdiff_t;\\n\\t\\tusing pointer = T*;\\n\\t\\tusing reference = T&;\\n\\t\\ttypename dict<RTLIL::IdString, T>::iterator it;\\n\\t\\tdict<RTLIL::IdString, T> *list_p;\\n\\t\\tint *refcount_p;\\n\\n\\t\\tObjIterator() : list_p(nullptr), refcount_p(nullptr) {\\n\\t\\t}\\n\\n\\t\\tObjIterator(decltype(list_p) list_p, int *refcount_p) : list_p(list_p), refcount_p(refcount_p) {\\n\\t\\t\\tif (list_p->empty()) {\\n\\t\\t\\t\\tthis->list_p = nullptr;\\n\\t\\t\\t\\tthis->refcount_p = nullptr;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tit = list_p->begin();\\n\\t\\t\\t\\t(*refcount_p)++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tObjIterator(const RTLIL::ObjIterator<T> &other) {\\n\\t\\t\\tit = other.it;\\n\\t\\t\\tlist_p = other.list_p;\\n\\t\\t\\trefcount_p = other.refcount_p;\\n\\t\\t\\tif (refcount_p)\\n\\t\\t\\t\\t(*refcount_p)++;\\n\\t\\t}\\n\\n\\t\\tObjIterator &operator=(const RTLIL::ObjIterator<T> &other) {\\n\\t\\t\\tif (refcount_p)\\n\\t\\t\\t\\t(*refcount_p)--;\\n\\t\\t\\tit = other.it;\\n\\t\\t\\tlist_p = other.list_p;\\n\\t\\t\\trefcount_p = other.refcount_p;\\n\\t\\t\\tif (refcount_p)\\n\\t\\t\\t\\t(*refcount_p)++;\\n\\t\\t\\treturn *this;\\n\\t\\t}\\n\\n\\t\\t~ObjIterator() {\\n\\t\\t\\tif (refcount_p)\\n\\t\\t\\t\\t(*refcount_p)--;\\n\\t\\t}\\n\\n\\t\\tinline T operator*() const {\\n\\t\\t\\tlog_assert(list_p != nullptr);\\n\\t\\t\\treturn it->second;\\n\\t\\t}\\n\\n\\t\\tinline bool operator!=(const RTLIL::ObjIterator<T> &other) const {\\n\\t\\t\\tif (list_p == nullptr || other.list_p == nullptr)\\n\\t\\t\\t\\treturn list_p != other.list_p;\\n\\t\\t\\treturn it != other.it;\\n\\t\\t}\\n\\n\\n\\t\\tinline bool operator==(const RTLIL::ObjIterator<T> &other) const {\\n\\t\\t\\treturn !(*this != other);\\n\\t\\t}\\n\\n\\t\\tinline ObjIterator<T>& operator++() {\\n\\t\\t\\tlog_assert(list_p != nullptr);\\n\\t\\t\\tif (++it == list_p->end()) {\\n\\t\\t\\t\\t(*refcount_p)--;\\n\\t\\t\\t\\tlist_p = nullptr;\\n\\t\\t\\t\\trefcount_p = nullptr;\\n\\t\\t\\t}\\n\\t\\t\\treturn *this;\\n\\t\\t}\\n\\n\\t\\tinline ObjIterator<T>& operator+=(int amt) {\\n\\t\\t\\tlog_assert(list_p != nullptr);\\n\\t\\t\\tit += amt;\\n\\t\\t\\tif (it == list_p->end()) {\\n\\t\\t\\t\\t(*refcount_p)--;\\n\\t\\t\\t\\tlist_p = nullptr;\\n\\t\\t\\t\\trefcount_p = nullptr;\\n\\t\\t\\t}\\n\\t\\t\\treturn *this;\\n\\t\\t}\\n\\n\\t\\tinline ObjIterator<T> operator+(int amt) {\\n\\t\\t\\tlog_assert(list_p != nullptr);\\n\\t\\t\\tObjIterator<T> new_obj(*this);\\n\\t\\t\\tnew_obj.it += amt;\\n\\t\\t\\tif (new_obj.it == list_p->end()) {\\n\\t\\t\\t\\t(*(new_obj.refcount_p))--;\\n\\t\\t\\t\\tnew_obj.list_p = nullptr;\\n\\t\\t\\t\\tnew_obj.refcount_p = nullptr;\\n\\t\\t\\t}\\n\\t\\t\\treturn new_obj;\\n\\t\\t}\\n\\n\\t\\tinline const ObjIterator<T> operator++(int) {\\n\\t\\t\\tObjIterator<T> result(*this);\\n\\t\\t\\t++(*this);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n\\n\\ttemplate<typename T>\\n\\tstruct ObjRange\\n\\t{\\n\\t\\tdict<RTLIL::IdString, T> *list_p;\\n\\t\\tint *refcount_p;\\n\\n\\t\\tObjRange(decltype(list_p) list_p, int *refcount_p) : list_p(list_p), refcount_p(refcount_p) { }\\n\\t\\tRTLIL::ObjIterator<T> begin() { return RTLIL::ObjIterator<T>(list_p, refcount_p); }\\n\\t\\tRTLIL::ObjIterator<T> end() { return RTLIL::ObjIterator<T>(); }\\n\\n\\t\\tsize_t size() const {\\n\\t\\t\\treturn list_p->size();\\n\\t\\t}\\n\\n\\t\\toperator pool<T>() const {\\n\\t\\t\\tpool<T> result;\\n\\t\\t\\tfor (auto &it : *list_p)\\n\\t\\t\\t\\tresult.insert(it.second);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\toperator std::vector<T>() const {\\n\\t\\t\\tstd::vector<T> result;\\n\\t\\t\\tresult.reserve(list_p->size());\\n\\t\\t\\tfor (auto &it : *list_p)\\n\\t\\t\\t\\tresult.push_back(it.second);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tpool<T> to_pool() const { return *this; }\\n\\t\\tstd::vector<T> to_vector() const { return *this; }\\n\\t};\\n};\\n\\nstruct RTLIL::Const\\n{\\n\\tint flags;\\n\\tstd::vector<RTLIL::State> bits;\\n\\n\\tConst() : flags(RTLIL::CONST_FLAG_NONE) {}\\n\\tConst(const std::string &str);\\n\\tConst(int val, int width = 32);\\n\\tConst(RTLIL::State bit, int width = 1);\\n\\tConst(const std::vector<RTLIL::State> &bits) : bits(bits) { flags = CONST_FLAG_NONE; }\\n\\tConst(const std::vector<bool> &bits);\\n\\tConst(const RTLIL::Const &c) = default;\\n\\tRTLIL::Const &operator =(const RTLIL::Const &other) = default;\\n\\n\\tbool operator <(const RTLIL::Const &other) const;\\n\\tbool operator ==(const RTLIL::Const &other) const;\\n\\tbool operator !=(const RTLIL::Const &other) const;\\n\\n\\tbool as_bool() const;\\n\\tint as_int(bool is_signed = false) const;\\n\\tstd::string as_string() const;\\n\\tstatic Const from_string(const std::string &str);\\n\\n\\tstd::string decode_string() const;\\n\\n\\tinline int size() const { return bits.size(); }\\n\\tinline bool empty() const { return bits.empty(); }\\n\\tinline RTLIL::State &operator[](int index) { return bits.at(index); }\\n\\tinline const RTLIL::State &operator[](int index) const { return bits.at(index); }\\n\\tinline decltype(bits)::iterator begin() { return bits.begin(); }\\n\\tinline decltype(bits)::iterator end() { return bits.end(); }\\n\\n\\tbool is_fully_zero() const;\\n\\tbool is_fully_ones() const;\\n\\tbool is_fully_def() const;\\n\\tbool is_fully_undef() const;\\n\\tbool is_fully_undef_x_only() const;\\n\\tbool is_onehot(int *pos = nullptr) const;\\n\\n\\tinline RTLIL::Const extract(int offset, int len = 1, RTLIL::State padding = RTLIL::State::S0) const {\\n\\t\\tRTLIL::Const ret;\\n\\t\\tret.bits.reserve(len);\\n\\t\\tfor (int i = offset; i < offset + len; i++)\\n\\t\\t\\tret.bits.push_back(i < GetSize(bits) ? bits[i] : padding);\\n\\t\\treturn ret;\\n\\t}\\n\\n\\tvoid extu(int width) {\\n\\t\\tbits.resize(width, RTLIL::State::S0);\\n\\t}\\n\\n\\tvoid exts(int width) {\\n\\t\\tbits.resize(width, bits.empty() ? RTLIL::State::Sx : bits.back());\\n\\t}\\n\\n\\tinline unsigned int hash() const {\\n\\t\\tunsigned int h = mkhash_init;\\n\\t\\tfor (auto b : bits)\\n\\t\\t\\th = mkhash(h, b);\\n\\t\\treturn h;\\n\\t}\\n};\\n\\nstruct RTLIL::AttrObject\\n{\\n\\tdict<RTLIL::IdString, RTLIL::Const> attributes;\\n\\n\\tbool has_attribute(const RTLIL::IdString &id) const;\\n\\n\\tvoid set_bool_attribute(const RTLIL::IdString &id, bool value=true);\\n\\tbool get_bool_attribute(const RTLIL::IdString &id) const;\\n\\n\\tbool get_blackbox_attribute(bool ignore_wb=false) const {\\n\\t\\treturn get_bool_attribute(ID::blackbox) || (!ignore_wb && get_bool_attribute(ID::whitebox));\\n\\t}\\n\\n\\tvoid set_string_attribute(const RTLIL::IdString& id, string value);\\n\\tstring get_string_attribute(const RTLIL::IdString &id) const;\\n\\n\\tvoid set_strpool_attribute(const RTLIL::IdString& id, const pool<string> &data);\\n\\tvoid add_strpool_attribute(const RTLIL::IdString& id, const pool<string> &data);\\n\\tpool<string> get_strpool_attribute(const RTLIL::IdString &id) const;\\n\\n\\tvoid set_src_attribute(const std::string &src) {\\n\\t\\tset_string_attribute(ID::src, src);\\n\\t}\\n\\tstd::string get_src_attribute() const {\\n\\t\\treturn get_string_attribute(ID::src);\\n\\t}\\n\\n\\tvoid set_hdlname_attribute(const vector<string> &hierarchy);\\n\\tvector<string> get_hdlname_attribute() const;\\n\\n\\tvoid set_intvec_attribute(const RTLIL::IdString& id, const vector<int> &data);\\n\\tvector<int> get_intvec_attribute(const RTLIL::IdString &id) const;\\n};\\n\\nstruct RTLIL::SigChunk\\n{\\n\\tRTLIL::Wire *wire;\\n\\tstd::vector<RTLIL::State> data; // only used if wire == NULL, LSB at index 0\\n\\tint width, offset;\\n\\n\\tSigChunk() : wire(nullptr), width(0), offset(0) {}\\n\\tSigChunk(const RTLIL::Const &value) : wire(nullptr), data(value.bits), width(GetSize(data)), offset(0) {}\\n\\tSigChunk(RTLIL::Const &&value) : wire(nullptr), data(std::move(value.bits)), width(GetSize(data)), offset(0) {}\\n\\tSigChunk(RTLIL::Wire *wire) : wire(wire), width(GetSize(wire)), offset(0) {}\\n\\tSigChunk(RTLIL::Wire *wire, int offset, int width = 1) : wire(wire), width(width), offset(offset) {}\\n\\tSigChunk(const std::string &str) : SigChunk(RTLIL::Const(str)) {}\\n\\tSigChunk(int val, int width = 32) : SigChunk(RTLIL::Const(val, width)) {}\\n\\tSigChunk(RTLIL::State bit, int width = 1) : SigChunk(RTLIL::Const(bit, width)) {}\\n\\tSigChunk(const RTLIL::SigBit &bit);\\n\\n\\tRTLIL::SigChunk extract(int offset, int length) const;\\n\\tinline int size() const { return width; }\\n\\tinline bool is_wire() const { return wire != NULL; }\\n\\n\\tbool operator <(const RTLIL::SigChunk &other) const;\\n\\tbool operator ==(const RTLIL::SigChunk &other) const;\\n\\tbool operator !=(const RTLIL::SigChunk &other) const;\\n};\\n\\nstruct RTLIL::SigBit\\n{\\n\\tRTLIL::Wire *wire;\\n\\tunion {\\n\\t\\tRTLIL::State data; // used if wire == NULL\\n\\t\\tint offset;        // used if wire != NULL\\n\\t};\\n\\n\\tSigBit();\\n\\tSigBit(RTLIL::State bit);\\n\\texplicit SigBit(bool bit);\\n\\tSigBit(RTLIL::Wire *wire);\\n\\tSigBit(RTLIL::Wire *wire, int offset);\\n\\tSigBit(const RTLIL::SigChunk &chunk);\\n\\tSigBit(const RTLIL::SigChunk &chunk, int index);\\n\\tSigBit(const RTLIL::SigSpec &sig);\\n\\tSigBit(const RTLIL::SigBit &sigbit) = default;\\n\\tRTLIL::SigBit &operator =(const RTLIL::SigBit &other) = default;\\n\\n\\tinline bool is_wire() const { return wire != NULL; }\\n\\n\\tbool operator <(const RTLIL::SigBit &other) const;\\n\\tbool operator ==(const RTLIL::SigBit &other) const;\\n\\tbool operator !=(const RTLIL::SigBit &other) const;\\n\\tunsigned int hash() const;\\n};\\n\\nstruct RTLIL::SigSpecIterator\\n{\\n\\ttypedef std::input_iterator_tag iterator_category;\\n\\ttypedef RTLIL::SigBit value_type;\\n\\ttypedef ptrdiff_t difference_type;\\n\\ttypedef RTLIL::SigBit* pointer;\\n\\ttypedef RTLIL::SigBit& reference;\\n\\n\\tRTLIL::SigSpec *sig_p;\\n\\tint index;\\n\\n\\tinline RTLIL::SigBit &operator*() const;\\n\\tinline bool operator!=(const RTLIL::SigSpecIterator &other) const { return index != other.index; }\\n\\tinline bool operator==(const RTLIL::SigSpecIterator &other) const { return index == other.index; }\\n\\tinline void operator++() { index++; }\\n};\\n\\nstruct RTLIL::SigSpecConstIterator\\n{\\n\\ttypedef std::input_iterator_tag iterator_category;\\n\\ttypedef RTLIL::SigBit value_type;\\n\\ttypedef ptrdiff_t difference_type;\\n\\ttypedef RTLIL::SigBit* pointer;\\n\\ttypedef RTLIL::SigBit& reference;\\n\\n\\tconst RTLIL::SigSpec *sig_p;\\n\\tint index;\\n\\n\\tinline const RTLIL::SigBit &operator*() const;\\n\\tinline bool operator!=(const RTLIL::SigSpecConstIterator &other) const { return index != other.index; }\\n\\tinline bool operator==(const RTLIL::SigSpecIterator &other) const { return index == other.index; }\\n\\tinline void operator++() { index++; }\\n};\\n\\nstruct RTLIL::SigSpec\\n{\\nprivate:\\n\\tint width_;\\n\\tunsigned long hash_;\\n\\tstd::vector<RTLIL::SigChunk> chunks_; // LSB at index 0\\n\\tstd::vector<RTLIL::SigBit> bits_; // LSB at index 0\\n\\n\\tvoid pack() const;\\n\\tvoid unpack() const;\\n\\tvoid updhash() const;\\n\\n\\tinline bool packed() const {\\n\\t\\treturn bits_.empty();\\n\\t}\\n\\n\\tinline void inline_unpack() const {\\n\\t\\tif (!chunks_.empty())\\n\\t\\t\\tunpack();\\n\\t}\\n\\n\\t// Only used by Module::remove(const pool<Wire*> &wires)\\n\\t// but cannot be more specific as it isn't yet declared\\n\\tfriend struct RTLIL::Module;\\n\\npublic:\\n\\tSigSpec() : width_(0), hash_(0) {}\\n\\tSigSpec(std::initializer_list<RTLIL::SigSpec> parts);\\n\\n\\tSigSpec(const RTLIL::Const &value);\\n\\tSigSpec(RTLIL::Const &&value);\\n\\tSigSpec(const RTLIL::SigChunk &chunk);\\n\\tSigSpec(RTLIL::SigChunk &&chunk);\\n\\tSigSpec(RTLIL::Wire *wire);\\n\\tSigSpec(RTLIL::Wire *wire, int offset, int width = 1);\\n\\tSigSpec(const std::string &str);\\n\\tSigSpec(int val, int width = 32);\\n\\tSigSpec(RTLIL::State bit, int width = 1);\\n\\tSigSpec(const RTLIL::SigBit &bit, int width = 1);\\n\\tSigSpec(const std::vector<RTLIL::SigChunk> &chunks);\\n\\tSigSpec(const std::vector<RTLIL::SigBit> &bits);\\n\\tSigSpec(const pool<RTLIL::SigBit> &bits);\\n\\tSigSpec(const std::set<RTLIL::SigBit> &bits);\\n\\texplicit SigSpec(bool bit);\\n\\n\\tsize_t get_hash() const {\\n\\t\\tif (!hash_) hash();\\n\\t\\treturn hash_;\\n\\t}\\n\\n\\tinline const std::vector<RTLIL::SigChunk> &chunks() const { pack(); return chunks_; }\\n\\tinline const std::vector<RTLIL::SigBit> &bits() const { inline_unpack(); return bits_; }\\n\\n\\tinline int size() const { return width_; }\\n\\tinline bool empty() const { return width_ == 0; }\\n\\n\\tinline RTLIL::SigBit &operator[](int index) { inline_unpack(); return bits_.at(index); }\\n\\tinline const RTLIL::SigBit &operator[](int index) const { inline_unpack(); return bits_.at(index); }\\n\\n\\tinline RTLIL::SigSpecIterator begin() { RTLIL::SigSpecIterator it; it.sig_p = this; it.index = 0; return it; }\\n\\tinline RTLIL::SigSpecIterator end() { RTLIL::SigSpecIterator it; it.sig_p = this; it.index = width_; return it; }\\n\\n\\tinline RTLIL::SigSpecConstIterator begin() const { RTLIL::SigSpecConstIterator it; it.sig_p = this; it.index = 0; return it; }\\n\\tinline RTLIL::SigSpecConstIterator end() const { RTLIL::SigSpecConstIterator it; it.sig_p = this; it.index = width_; return it; }\\n\\n\\tvoid sort();\\n\\tvoid sort_and_unify();\\n\\n\\tvoid replace(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec &with);\\n\\tvoid replace(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec &with, RTLIL::SigSpec *other) const;\\n\\n\\tvoid replace(const dict<RTLIL::SigBit, RTLIL::SigBit> &rules);\\n\\tvoid replace(const dict<RTLIL::SigBit, RTLIL::SigBit> &rules, RTLIL::SigSpec *other) const;\\n\\n\\tvoid replace(const std::map<RTLIL::SigBit, RTLIL::SigBit> &rules);\\n\\tvoid replace(const std::map<RTLIL::SigBit, RTLIL::SigBit> &rules, RTLIL::SigSpec *other) const;\\n\\n\\tvoid replace(int offset, const RTLIL::SigSpec &with);\\n\\n\\tvoid remove(const RTLIL::SigSpec &pattern);\\n\\tvoid remove(const RTLIL::SigSpec &pattern, RTLIL::SigSpec *other) const;\\n\\tvoid remove2(const RTLIL::SigSpec &pattern, RTLIL::SigSpec *other);\\n\\n\\tvoid remove(const pool<RTLIL::SigBit> &pattern);\\n\\tvoid remove(const pool<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other) const;\\n\\tvoid remove2(const pool<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other);\\n\\tvoid remove2(const std::set<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other);\\n\\tvoid remove2(const pool<RTLIL::Wire*> &pattern, RTLIL::SigSpec *other);\\n\\n\\tvoid remove(int offset, int length = 1);\\n\\tvoid remove_const();\\n\\n\\tRTLIL::SigSpec extract(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec *other = NULL) const;\\n\\tRTLIL::SigSpec extract(const pool<RTLIL::SigBit> &pattern, const RTLIL::SigSpec *other = NULL) const;\\n\\tRTLIL::SigSpec extract(int offset, int length = 1) const;\\n\\tRTLIL::SigSpec extract_end(int offset) const { return extract(offset, width_ - offset); }\\n\\n\\tRTLIL::SigBit lsb() const { log_assert(width_); return (*this)[0]; };\\n\\tRTLIL::SigBit msb() const { log_assert(width_); return (*this)[width_ - 1]; };\\n\\n\\tvoid append(const RTLIL::SigSpec &signal);\\n\\tinline void append(Wire *wire) { append(RTLIL::SigSpec(wire)); }\\n\\tinline void append(const RTLIL::SigChunk &chunk) { append(RTLIL::SigSpec(chunk)); }\\n\\tinline void append(const RTLIL::Const &const_) { append(RTLIL::SigSpec(const_)); }\\n\\n\\tvoid append(const RTLIL::SigBit &bit);\\n\\tinline void append(RTLIL::State state) { append(RTLIL::SigBit(state)); }\\n\\tinline void append(bool bool_) { append(RTLIL::SigBit(bool_)); }\\n\\n\\tvoid extend_u0(int width, bool is_signed = false);\\n\\n\\tRTLIL::SigSpec repeat(int num) const;\\n\\n\\tvoid reverse() { inline_unpack(); std::reverse(bits_.begin(), bits_.end()); }\\n\\n\\tbool operator <(const RTLIL::SigSpec &other) const;\\n\\tbool operator ==(const RTLIL::SigSpec &other) const;\\n\\tinline bool operator !=(const RTLIL::SigSpec &other) const { return !(*this == other); }\\n\\n\\tbool is_wire() const;\\n\\tbool is_chunk() const;\\n\\tinline bool is_bit() const { return width_ == 1; }\\n\\n\\tbool is_fully_const() const;\\n\\tbool is_fully_zero() const;\\n\\tbool is_fully_ones() const;\\n\\tbool is_fully_def() const;\\n\\tbool is_fully_undef() const;\\n\\tbool has_const() const;\\n\\tbool has_marked_bits() const;\\n\\tbool is_onehot(int *pos = nullptr) const;\\n\\n\\tbool as_bool() const;\\n\\tint as_int(bool is_signed = false) const;\\n\\tstd::string as_string() const;\\n\\tRTLIL::Const as_const() const;\\n\\tRTLIL::Wire *as_wire() const;\\n\\tRTLIL::SigChunk as_chunk() const;\\n\\tRTLIL::SigBit as_bit() const;\\n\\n\\tbool match(const char* pattern) const;\\n\\n\\tstd::set<RTLIL::SigBit> to_sigbit_set() const;\\n\\tpool<RTLIL::SigBit> to_sigbit_pool() const;\\n\\tstd::vector<RTLIL::SigBit> to_sigbit_vector() const;\\n\\tstd::map<RTLIL::SigBit, RTLIL::SigBit> to_sigbit_map(const RTLIL::SigSpec &other) const;\\n\\tdict<RTLIL::SigBit, RTLIL::SigBit> to_sigbit_dict(const RTLIL::SigSpec &other) const;\\n\\n\\tstatic bool parse(RTLIL::SigSpec &sig, RTLIL::Module *module, std::string str);\\n\\tstatic bool parse_sel(RTLIL::SigSpec &sig, RTLIL::Design *design, RTLIL::Module *module, std::string str);\\n\\tstatic bool parse_rhs(const RTLIL::SigSpec &lhs, RTLIL::SigSpec &sig, RTLIL::Module *module, std::string str);\\n\\n\\toperator std::vector<RTLIL::SigChunk>() const { return chunks(); }\\n\\toperator std::vector<RTLIL::SigBit>() const { return bits(); }\\n\\tconst RTLIL::SigBit &at(int offset, const RTLIL::SigBit &defval) { return offset < width_ ? (*this)[offset] : defval; }\\n\\n\\tunsigned int hash() const { if (!hash_) updhash(); return hash_; };\\n\\n#ifndef NDEBUG\\n\\tvoid check(Module *mod = nullptr) const;\\n#else\\n\\tvoid check(Module *mod = nullptr) const { (void)mod; }\\n#endif\\n};\\n\\nstruct RTLIL::Selection\\n{\\n\\tbool full_selection;\\n\\tpool<RTLIL::IdString> selected_modules;\\n\\tdict<RTLIL::IdString, pool<RTLIL::IdString>> selected_members;\\n\\n\\tSelection(bool full = true) : full_selection(full) { }\\n\\n\\tbool selected_module(const RTLIL::IdString &mod_name) const;\\n\\tbool selected_whole_module(const RTLIL::IdString &mod_name) const;\\n\\tbool selected_member(const RTLIL::IdString &mod_name, const RTLIL::IdString &memb_name) const;\\n\\tvoid optimize(RTLIL::Design *design);\\n\\n\\ttemplate<typename T1> void select(T1 *module) {\\n\\t\\tif (!full_selection && selected_modules.count(module->name) == 0) {\\n\\t\\t\\tselected_modules.insert(module->name);\\n\\t\\t\\tselected_members.erase(module->name);\\n\\t\\t}\\n\\t}\\n\\n\\ttemplate<typename T1, typename T2> void select(T1 *module, T2 *member) {\\n\\t\\tif (!full_selection && selected_modules.count(module->name) == 0)\\n\\t\\t\\tselected_members[module->name].insert(member->name);\\n\\t}\\n\\n\\tbool empty() const {\\n\\t\\treturn !full_selection && selected_modules.empty() && selected_members.empty();\\n\\t}\\n};\\n\\nstruct RTLIL::Monitor\\n{\\n\\tunsigned int hashidx_;\\n\\tunsigned int hash() const { return hashidx_; }\\n\\n\\tMonitor() {\\n\\t\\tstatic unsigned int hashidx_count = 123456789;\\n\\t\\thashidx_count = mkhash_xorshift(hashidx_count);\\n\\t\\thashidx_ = hashidx_count;\\n\\t}\\n\\n\\tvirtual ~Monitor() { }\\n\\tvirtual void notify_module_add(RTLIL::Module*) { }\\n\\tvirtual void notify_module_del(RTLIL::Module*) { }\\n\\tvirtual void notify_connect(RTLIL::Cell*, const RTLIL::IdString&, const RTLIL::SigSpec&, const RTLIL::SigSpec&) { }\\n\\tvirtual void notify_connect(RTLIL::Module*, const RTLIL::SigSig&) { }\\n\\tvirtual void notify_connect(RTLIL::Module*, const std::vector<RTLIL::SigSig>&) { }\\n\\tvirtual void notify_blackout(RTLIL::Module*) { }\\n};\\n\\n// Forward declaration; defined in preproc.h.\\nstruct define_map_t;\\n\\nstruct RTLIL::Design\\n{\\n\\tunsigned int hashidx_;\\n\\tunsigned int hash() const { return hashidx_; }\\n\\n\\tpool<RTLIL::Monitor*> monitors;\\n\\tdict<std::string, std::string> scratchpad;\\n\\n\\tint refcount_modules_;\\n\\tdict<RTLIL::IdString, RTLIL::Module*> modules_;\\n\\tstd::vector<RTLIL::Binding*> bindings_;\\n\\n\\tstd::vector<AST::AstNode*> verilog_packages, verilog_globals;\\n\\tstd::unique_ptr<define_map_t> verilog_defines;\\n\\n\\tstd::vector<RTLIL::Selection> selection_stack;\\n\\tdict<RTLIL::IdString, RTLIL::Selection> selection_vars;\\n\\tstd::string selected_active_module;\\n\\n\\tDesign();\\n\\t~Design();\\n\\n\\tRTLIL::ObjRange<RTLIL::Module*> modules();\\n\\tRTLIL::Module *module(const RTLIL::IdString &name);\\n\\tconst RTLIL::Module *module(const RTLIL::IdString &name) const;\\n\\tRTLIL::Module *top_module();\\n\\n\\tbool has(const RTLIL::IdString &id) const {\\n\\t\\treturn modules_.count(id) != 0;\\n\\t}\\n\\n\\tvoid add(RTLIL::Module *module);\\n\\tvoid add(RTLIL::Binding *binding);\\n\\n\\tRTLIL::Module *addModule(RTLIL::IdString name);\\n\\tvoid remove(RTLIL::Module *module);\\n\\tvoid rename(RTLIL::Module *module, RTLIL::IdString new_name);\\n\\n\\tvoid scratchpad_unset(const std::string &varname);\\n\\n\\tvoid scratchpad_set_int(const std::string &varname, int value);\\n\\tvoid scratchpad_set_bool(const std::string &varname, bool value);\\n\\tvoid scratchpad_set_string(const std::string &varname, std::string value);\\n\\n\\tint scratchpad_get_int(const std::string &varname, int default_value = 0) const;\\n\\tbool scratchpad_get_bool(const std::string &varname, bool default_value = false) const;\\n\\tstd::string scratchpad_get_string(const std::string &varname, const std::string &default_value = std::string()) const;\\n\\n\\tvoid sort();\\n\\tvoid check();\\n\\tvoid optimize();\\n\\n\\tbool selected_module(const RTLIL::IdString &mod_name) const;\\n\\tbool selected_whole_module(const RTLIL::IdString &mod_name) const;\\n\\tbool selected_member(const RTLIL::IdString &mod_name, const RTLIL::IdString &memb_name) const;\\n\\n\\tbool selected_module(RTLIL::Module *mod) const;\\n\\tbool selected_whole_module(RTLIL::Module *mod) const;\\n\\n\\tRTLIL::Selection &selection() {\\n\\t\\treturn selection_stack.back();\\n\\t}\\n\\n\\tconst RTLIL::Selection &selection() const {\\n\\t\\treturn selection_stack.back();\\n\\t}\\n\\n\\tbool full_selection() const {\\n\\t\\treturn selection_stack.back().full_selection;\\n\\t}\\n\\n\\ttemplate<typename T1> bool selected(T1 *module) const {\\n\\t\\treturn selected_module(module->name);\\n\\t}\\n\\n\\ttemplate<typename T1, typename T2> bool selected(T1 *module, T2 *member) const {\\n\\t\\treturn selected_member(module->name, member->name);\\n\\t}\\n\\n\\ttemplate<typename T1> void select(T1 *module) {\\n\\t\\tif (selection_stack.size() > 0) {\\n\\t\\t\\tRTLIL::Selection &sel = selection_stack.back();\\n\\t\\t\\tsel.select(module);\\n\\t\\t}\\n\\t}\\n\\n\\ttemplate<typename T1, typename T2> void select(T1 *module, T2 *member) {\\n\\t\\tif (selection_stack.size() > 0) {\\n\\t\\t\\tRTLIL::Selection &sel = selection_stack.back();\\n\\t\\t\\tsel.select(module, member);\\n\\t\\t}\\n\\t}\\n\\n\\n\\tstd::vector<RTLIL::Module*> selected_modules() const;\\n\\tstd::vector<RTLIL::Module*> selected_whole_modules() const;\\n\\tstd::vector<RTLIL::Module*> selected_whole_modules_warn(bool include_wb = false) const;\\n#ifdef WITH_PYTHON\\n\\tstatic std::map<unsigned int, RTLIL::Design*> *get_all_designs(void);\\n#endif\\n};\\n\\nstruct RTLIL::Module : public RTLIL::AttrObject\\n{\\n\\tunsigned int hashidx_;\\n\\tunsigned int hash() const { return hashidx_; }\\n\\nprotected:\\n\\tvoid add(RTLIL::Wire *wire);\\n\\tvoid add(RTLIL::Cell *cell);\\n\\tvoid add(RTLIL::Process *process);\\n\\npublic:\\n\\tRTLIL::Design *design;\\n\\tpool<RTLIL::Monitor*> monitors;\\n\\n\\tint refcount_wires_;\\n\\tint refcount_cells_;\\n\\n\\tdict<RTLIL::IdString, RTLIL::Wire*> wires_;\\n\\tdict<RTLIL::IdString, RTLIL::Cell*> cells_;\\n\\n\\tstd::vector<RTLIL::SigSig>   connections_;\\n\\tstd::vector<RTLIL::Binding*> bindings_;\\n\\n\\tRTLIL::IdString name;\\n\\tidict<RTLIL::IdString> avail_parameters;\\n\\tdict<RTLIL::IdString, RTLIL::Const> parameter_default_values;\\n\\tdict<RTLIL::IdString, RTLIL::Memory*> memories;\\n\\tdict<RTLIL::IdString, RTLIL::Process*> processes;\\n\\n\\tModule();\\n\\tvirtual ~Module();\\n\\tvirtual RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, bool mayfail = false);\\n\\tvirtual RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parameters, const dict<RTLIL::IdString, RTLIL::Module*> &interfaces, const dict<RTLIL::IdString, RTLIL::IdString> &modports, bool mayfail = false);\\n\\tvirtual size_t count_id(const RTLIL::IdString& id);\\n\\tvirtual void expand_interfaces(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Module *> &local_interfaces);\\n\\tvirtual bool reprocess_if_necessary(RTLIL::Design *design);\\n\\n\\tvirtual void sort();\\n\\tvirtual void check();\\n\\tvirtual void optimize();\\n\\tvirtual void makeblackbox();\\n\\n\\tvoid connect(const RTLIL::SigSig &conn);\\n\\tvoid connect(const RTLIL::SigSpec &lhs, const RTLIL::SigSpec &rhs);\\n\\tvoid new_connections(const std::vector<RTLIL::SigSig> &new_conn);\\n\\tconst std::vector<RTLIL::SigSig> &connections() const;\\n\\n\\tstd::vector<RTLIL::IdString> ports;\\n\\tvoid fixup_ports();\\n\\n\\ttemplate<typename T> void rewrite_sigspecs(T &functor);\\n\\ttemplate<typename T> void rewrite_sigspecs2(T &functor);\\n\\tvoid cloneInto(RTLIL::Module *new_mod) const;\\n\\tvirtual RTLIL::Module *clone() const;\\n\\n\\tbool has_memories() const;\\n\\tbool has_processes() const;\\n\\n\\tbool has_memories_warn() const;\\n\\tbool has_processes_warn() const;\\n\\n\\tstd::vector<RTLIL::Wire*> selected_wires() const;\\n\\tstd::vector<RTLIL::Cell*> selected_cells() const;\\n\\n\\ttemplate<typename T> bool selected(T *member) const {\\n\\t\\treturn design->selected_member(name, member->name);\\n\\t}\\n\\n\\tRTLIL::Wire* wire(const RTLIL::IdString &id) {\\n\\t\\tauto it = wires_.find(id);\\n\\t\\treturn it == wires_.end() ? nullptr : it->second;\\n\\t}\\n\\tRTLIL::Cell* cell(const RTLIL::IdString &id) {\\n\\t\\tauto it = cells_.find(id);\\n\\t\\treturn it == cells_.end() ? nullptr : it->second;\\n\\t}\\n\\n\\tconst RTLIL::Wire* wire(const RTLIL::IdString &id) const{\\n\\t\\tauto it = wires_.find(id);\\n\\t\\treturn it == wires_.end() ? nullptr : it->second;\\n\\t}\\n\\tconst RTLIL::Cell* cell(const RTLIL::IdString &id) const {\\n\\t\\tauto it = cells_.find(id);\\n\\t\\treturn it == cells_.end() ? nullptr : it->second;\\n\\t}\\n\\n\\tRTLIL::ObjRange<RTLIL::Wire*> wires() { return RTLIL::ObjRange<RTLIL::Wire*>(&wires_, &refcount_wires_); }\\n\\tRTLIL::ObjRange<RTLIL::Cell*> cells() { return RTLIL::ObjRange<RTLIL::Cell*>(&cells_, &refcount_cells_); }\\n\\n\\tvoid add(RTLIL::Binding *binding);\\n\\n\\t// Removing wires is expensive. If you have to remove wires, remove them all at once.\\n\\tvoid remove(const pool<RTLIL::Wire*> &wires);\\n\\tvoid remove(RTLIL::Cell *cell);\\n\\tvoid remove(RTLIL::Process *process);\\n\\n\\tvoid rename(RTLIL::Wire *wire, RTLIL::IdString new_name);\\n\\tvoid rename(RTLIL::Cell *cell, RTLIL::IdString new_name);\\n\\tvoid rename(RTLIL::IdString old_name, RTLIL::IdString new_name);\\n\\n\\tvoid swap_names(RTLIL::Wire *w1, RTLIL::Wire *w2);\\n\\tvoid swap_names(RTLIL::Cell *c1, RTLIL::Cell *c2);\\n\\n\\tRTLIL::IdString uniquify(RTLIL::IdString name);\\n\\tRTLIL::IdString uniquify(RTLIL::IdString name, int &index);\\n\\n\\tRTLIL::Wire *addWire(RTLIL::IdString name, int width = 1);\\n\\tRTLIL::Wire *addWire(RTLIL::IdString name, const RTLIL::Wire *other);\\n\\n\\tRTLIL::Cell *addCell(RTLIL::IdString name, RTLIL::IdString type);\\n\\tRTLIL::Cell *addCell(RTLIL::IdString name, const RTLIL::Cell *other);\\n\\n\\tRTLIL::Memory *addMemory(RTLIL::IdString name, const RTLIL::Memory *other);\\n\\n\\tRTLIL::Process *addProcess(RTLIL::IdString name);\\n\\tRTLIL::Process *addProcess(RTLIL::IdString name, const RTLIL::Process *other);\\n\\n\\t// The add* methods create a cell and return the created cell. All signals must exist in advance.\\n\\n\\tRTLIL::Cell* addNot (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addPos (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addNeg (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addAnd  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addOr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addXor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addXnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addReduceAnd  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addReduceOr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addReduceXor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addReduceXnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addReduceBool (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addShl    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addShr    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addSshl   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addSshr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addShift  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addShiftx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addLt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addLe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addEq  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addNe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addEqx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addNex (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addGe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addGt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addAdd (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addSub (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addMul (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\t// truncating division\\n\\tRTLIL::Cell* addDiv (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\t// truncating modulo\\n\\tRTLIL::Cell* addMod (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDivFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addModFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addPow (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool a_signed = false, bool b_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addFa (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_c, const RTLIL::SigSpec &sig_x, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addLogicNot (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addLogicAnd (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addLogicOr  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addMux  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addPmux (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addBmux (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDemux (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addBweqx  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addBwmux  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addSlice  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, RTLIL::Const offset, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addConcat (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addLut    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_y, RTLIL::Const lut, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addTribuf (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAssert (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAssume (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addLive   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addFair   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addCover  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_en, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addEquiv  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addSr    (RTLIL::IdString name, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, const RTLIL::SigSpec &sig_q, bool set_polarity = true, bool clr_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addFf    (RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDff   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_d,   const RTLIL::SigSpec &sig_q, bool clk_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDffe  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDffsr (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDffsre (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAdff (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const arst_value, bool clk_polarity = true, bool arst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAdffe (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const arst_value, bool clk_polarity = true, bool en_polarity = true, bool arst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAldff (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_aload, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool aload_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAldffe (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_aload,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool en_polarity = true, bool aload_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addSdff (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const srst_value, bool clk_polarity = true, bool srst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addSdffe (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst,  const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const srst_value, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addSdffce (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const srst_value, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDlatch (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAdlatch (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, RTLIL::Const arst_value, bool en_polarity = true, bool arst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDlatchsr (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr, RTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addBufGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addNotGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAndGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addNandGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addOrGate     (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addNorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addXorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addXnorGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAndnotGate (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addOrnotGate  (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addMuxGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addNmuxGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAoi3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addOai3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAoi4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addOai4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const RTLIL::SigBit &sig_y, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addSrGate     (RTLIL::IdString name, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,\\n\\t\\t\\tconst RTLIL::SigSpec &sig_q, bool set_polarity = true, bool clr_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addFfGate     (RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDffGate    (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDffeGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDffsrGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,\\n\\t\\t\\tRTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDffsreGate (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,\\n\\t\\t\\tRTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool clk_polarity = true, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAdffGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,\\n\\t\\t\\tbool arst_value = false, bool clk_polarity = true, bool arst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAdffeGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,\\n\\t\\t\\tbool arst_value = false, bool clk_polarity = true, bool en_polarity = true, bool arst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAldffGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_aload, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,\\n\\t\\t\\tconst RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool aload_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAldffeGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_aload, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,\\n\\t\\t\\tconst RTLIL::SigSpec &sig_ad, bool clk_polarity = true, bool en_polarity = true, bool aload_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addSdffGate   (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,\\n\\t\\t\\tbool srst_value = false, bool clk_polarity = true, bool srst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addSdffeGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,\\n\\t\\t\\tbool srst_value = false, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addSdffceGate (RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_srst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,\\n\\t\\t\\tbool srst_value = false, bool clk_polarity = true, bool en_polarity = true, bool srst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDlatchGate (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addAdlatchGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_arst, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q,\\n\\t\\t\\tbool arst_value = false, bool en_polarity = true, bool arst_polarity = true, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell* addDlatchsrGate  (RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const RTLIL::SigSpec &sig_set, const RTLIL::SigSpec &sig_clr,\\n\\t\\t\\tRTLIL::SigSpec sig_d, const RTLIL::SigSpec &sig_q, bool en_polarity = true, bool set_polarity = true, bool clr_polarity = true, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::Cell* addAnyinit(RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL::SigSpec &sig_q, const std::string &src = \\\"\\\");\\n\\n\\t// The methods without the add* prefix create a cell and an output signal. They return the newly created output signal.\\n\\n\\tRTLIL::SigSpec Not (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Pos (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Neg (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec And  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Or   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Xor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Xnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec ReduceAnd  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec ReduceOr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec ReduceXor  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec ReduceXnor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec ReduceBool (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec Shl    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Shr    (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Sshl   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Sshr   (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Shift  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Shiftx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec Lt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Le  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Eq  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Ne  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Eqx (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Nex (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Ge  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Gt  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec Add (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Sub (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Mul (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\t// truncating division\\n\\tRTLIL::SigSpec Div (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\t// truncating modulo\\n\\tRTLIL::SigSpec Mod (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec DivFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec ModFloor (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Pow (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool a_signed = false, bool b_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec LogicNot (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec LogicAnd (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec LogicOr  (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, bool is_signed = false, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec Mux      (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Pmux     (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Bmux     (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Demux     (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec Bweqx      (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Bwmux      (RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_b, const RTLIL::SigSpec &sig_s, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigBit BufGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit NotGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit AndGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit NandGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit OrGate     (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit NorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit XorGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit XnorGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit AndnotGate (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit OrnotGate  (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit MuxGate    (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit NmuxGate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_s, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit Aoi3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit Oai3Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit Aoi4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigBit Oai4Gate   (RTLIL::IdString name, const RTLIL::SigBit &sig_a, const RTLIL::SigBit &sig_b, const RTLIL::SigBit &sig_c, const RTLIL::SigBit &sig_d, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec Anyconst  (RTLIL::IdString name, int width = 1, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Anyseq    (RTLIL::IdString name, int width = 1, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Allconst  (RTLIL::IdString name, int width = 1, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Allseq    (RTLIL::IdString name, int width = 1, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec Initstate (RTLIL::IdString name, const std::string &src = \\\"\\\");\\n\\n\\tRTLIL::SigSpec SetTag          (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_c, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell*   addSetTag       (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_c, const RTLIL::SigSpec &sig_y, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec GetTag          (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const std::string &src = \\\"\\\");\\n\\tRTLIL::Cell*   addOverwriteTag (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const RTLIL::SigSpec &sig_s, const RTLIL::SigSpec &sig_c, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec OriginalTag     (RTLIL::IdString name, const std::string &tag, const RTLIL::SigSpec &sig_a, const std::string &src = \\\"\\\");\\n\\tRTLIL::SigSpec FutureFF        (RTLIL::IdString name, const RTLIL::SigSpec &sig_e, const std::string &src = \\\"\\\");\\n\\n#ifdef WITH_PYTHON\\n\\tstatic std::map<unsigned int, RTLIL::Module*> *get_all_modules(void);\\n#endif\\n};\\n\\nstruct RTLIL::Wire : public RTLIL::AttrObject\\n{\\n\\tunsigned int hashidx_;\\n\\tunsigned int hash() const { return hashidx_; }\\n\\nprotected:\\n\\t// use module->addWire() and module->remove() to create or destroy wires\\n\\tfriend struct RTLIL::Module;\\n\\tWire();\\n\\t~Wire();\\n\\npublic:\\n\\t// do not simply copy wires\\n\\tWire(RTLIL::Wire &other) = delete;\\n\\tvoid operator=(RTLIL::Wire &other) = delete;\\n\\n\\tRTLIL::Module *module;\\n\\tRTLIL::IdString name;\\n\\tint width, start_offset, port_id;\\n\\tbool port_input, port_output, upto, is_signed;\\n\\n#ifdef WITH_PYTHON\\n\\tstatic std::map<unsigned int, RTLIL::Wire*> *get_all_wires(void);\\n#endif\\n};\\n\\ninline int GetSize(RTLIL::Wire *wire) {\\n\\treturn wire->width;\\n}\\n\\nstruct RTLIL::Memory : public RTLIL::AttrObject\\n{\\n\\tunsigned int hashidx_;\\n\\tunsigned int hash() const { return hashidx_; }\\n\\n\\tMemory();\\n\\n\\tRTLIL::IdString name;\\n\\tint width, start_offset, size;\\n#ifdef WITH_PYTHON\\n\\t~Memory();\\n\\tstatic std::map<unsigned int, RTLIL::Memory*> *get_all_memorys(void);\\n#endif\\n};\\n\\nstruct RTLIL::Cell : public RTLIL::AttrObject\\n{\\n\\tunsigned int hashidx_;\\n\\tunsigned int hash() const { return hashidx_; }\\n\\nprotected:\\n\\t// use module->addCell() and module->remove() to create or destroy cells\\n\\tfriend struct RTLIL::Module;\\n\\tCell();\\n\\t~Cell();\\n\\npublic:\\n\\t// do not simply copy cells\\n\\tCell(RTLIL::Cell &other) = delete;\\n\\tvoid operator=(RTLIL::Cell &other) = delete;\\n\\n\\tRTLIL::Module *module;\\n\\tRTLIL::IdString name;\\n\\tRTLIL::IdString type;\\n\\tdict<RTLIL::IdString, RTLIL::SigSpec> connections_;\\n\\tdict<RTLIL::IdString, RTLIL::Const> parameters;\\n\\n\\t// access cell ports\\n\\tbool hasPort(const RTLIL::IdString &portname) const;\\n\\tvoid unsetPort(const RTLIL::IdString &portname);\\n\\tvoid setPort(const RTLIL::IdString &portname, RTLIL::SigSpec signal);\\n\\tconst RTLIL::SigSpec &getPort(const RTLIL::IdString &portname) const;\\n\\tconst dict<RTLIL::IdString, RTLIL::SigSpec> &connections() const;\\n\\n\\t// information about cell ports\\n\\tbool known() const;\\n\\tbool input(const RTLIL::IdString &portname) const;\\n\\tbool output(const RTLIL::IdString &portname) const;\\n\\n\\t// access cell parameters\\n\\tbool hasParam(const RTLIL::IdString &paramname) const;\\n\\tvoid unsetParam(const RTLIL::IdString &paramname);\\n\\tvoid setParam(const RTLIL::IdString &paramname, RTLIL::Const value);\\n\\tconst RTLIL::Const &getParam(const RTLIL::IdString &paramname) const;\\n\\n\\tvoid sort();\\n\\tvoid check();\\n\\tvoid fixup_parameters(bool set_a_signed = false, bool set_b_signed = false);\\n\\n\\tbool has_keep_attr() const {\\n\\t\\treturn get_bool_attribute(ID::keep) || (module && module->design && module->design->module(type) &&\\n\\t\\t\\t\\tmodule->design->module(type)->get_bool_attribute(ID::keep));\\n\\t}\\n\\n\\ttemplate<typename T> void rewrite_sigspecs(T &functor);\\n\\ttemplate<typename T> void rewrite_sigspecs2(T &functor);\\n\\n#ifdef WITH_PYTHON\\n\\tstatic std::map<unsigned int, RTLIL::Cell*> *get_all_cells(void);\\n#endif\\n\\n\\tbool has_memid() const;\\n\\tbool is_mem_cell() const;\\n};\\n\\nstruct RTLIL::CaseRule : public RTLIL::AttrObject\\n{\\n\\tstd::vector<RTLIL::SigSpec> compare;\\n\\tstd::vector<RTLIL::SigSig> actions;\\n\\tstd::vector<RTLIL::SwitchRule*> switches;\\n\\n\\t~CaseRule();\\n\\n\\tbool empty() const;\\n\\n\\ttemplate<typename T> void rewrite_sigspecs(T &functor);\\n\\ttemplate<typename T> void rewrite_sigspecs2(T &functor);\\n\\tRTLIL::CaseRule *clone() const;\\n};\\n\\nstruct RTLIL::SwitchRule : public RTLIL::AttrObject\\n{\\n\\tRTLIL::SigSpec signal;\\n\\tstd::vector<RTLIL::CaseRule*> cases;\\n\\n\\t~SwitchRule();\\n\\n\\tbool empty() const;\\n\\n\\ttemplate<typename T> void rewrite_sigspecs(T &functor);\\n\\ttemplate<typename T> void rewrite_sigspecs2(T &functor);\\n\\tRTLIL::SwitchRule *clone() const;\\n};\\n\\nstruct RTLIL::MemWriteAction : RTLIL::AttrObject\\n{\\n\\tRTLIL::IdString memid;\\n\\tRTLIL::SigSpec address;\\n\\tRTLIL::SigSpec data;\\n\\tRTLIL::SigSpec enable;\\n\\tRTLIL::Const priority_mask;\\n};\\n\\nstruct RTLIL::SyncRule\\n{\\n\\tRTLIL::SyncType type;\\n\\tRTLIL::SigSpec signal;\\n\\tstd::vector<RTLIL::SigSig> actions;\\n\\tstd::vector<RTLIL::MemWriteAction> mem_write_actions;\\n\\n\\ttemplate<typename T> void rewrite_sigspecs(T &functor);\\n\\ttemplate<typename T> void rewrite_sigspecs2(T &functor);\\n\\tRTLIL::SyncRule *clone() const;\\n};\\n\\nstruct RTLIL::Process : public RTLIL::AttrObject\\n{\\n\\tunsigned int hashidx_;\\n\\tunsigned int hash() const { return hashidx_; }\\n\\nprotected:\\n\\t// use module->addProcess() and module->remove() to create or destroy processes\\n\\tfriend struct RTLIL::Module;\\n\\tProcess();\\n\\t~Process();\\n\\npublic:\\n\\tRTLIL::IdString name;\\n\\tRTLIL::Module *module;\\n\\tRTLIL::CaseRule root_case;\\n\\tstd::vector<RTLIL::SyncRule*> syncs;\\n\\n\\ttemplate<typename T> void rewrite_sigspecs(T &functor);\\n\\ttemplate<typename T> void rewrite_sigspecs2(T &functor);\\n\\tRTLIL::Process *clone() const;\\n};\\n\\n\\ninline RTLIL::SigBit::SigBit() : wire(NULL), data(RTLIL::State::S0) { }\\ninline RTLIL::SigBit::SigBit(RTLIL::State bit) : wire(NULL), data(bit) { }\\ninline RTLIL::SigBit::SigBit(bool bit) : wire(NULL), data(bit ? State::S1 : State::S0) { }\\ninline RTLIL::SigBit::SigBit(RTLIL::Wire *wire) : wire(wire), offset(0) { log_assert(wire && wire->width == 1); }\\ninline RTLIL::SigBit::SigBit(RTLIL::Wire *wire, int offset) : wire(wire), offset(offset) { log_assert(wire != nullptr); }\\ninline RTLIL::SigBit::SigBit(const RTLIL::SigChunk &chunk) : wire(chunk.wire) { log_assert(chunk.width == 1); if (wire) offset = chunk.offset; else data = chunk.data[0]; }\\ninline RTLIL::SigBit::SigBit(const RTLIL::SigChunk &chunk, int index) : wire(chunk.wire) { if (wire) offset = chunk.offset + index; else data = chunk.data[index]; }\\n\\ninline bool RTLIL::SigBit::operator<(const RTLIL::SigBit &other) const {\\n\\tif (wire == other.wire)\\n\\t\\treturn wire ? (offset < other.offset) : (data < other.data);\\n\\tif (wire != nullptr && other.wire != nullptr)\\n\\t\\treturn wire->name < other.wire->name;\\n\\treturn (wire != nullptr) < (other.wire != nullptr);\\n}\\n\\ninline bool RTLIL::SigBit::operator==(const RTLIL::SigBit &other) const {\\n\\treturn (wire == other.wire) && (wire ? (offset == other.offset) : (data == other.data));\\n}\\n\\ninline bool RTLIL::SigBit::operator!=(const RTLIL::SigBit &other) const {\\n\\treturn (wire != other.wire) || (wire ? (offset != other.offset) : (data != other.data));\\n}\\n\\ninline unsigned int RTLIL::SigBit::hash() const {\\n\\tif (wire)\\n\\t\\treturn mkhash_add(wire->name.hash(), offset);\\n\\treturn data;\\n}\\n\\ninline RTLIL::SigBit &RTLIL::SigSpecIterator::operator*() const {\\n\\treturn (*sig_p)[index];\\n}\\n\\ninline const RTLIL::SigBit &RTLIL::SigSpecConstIterator::operator*() const {\\n\\treturn (*sig_p)[index];\\n}\\n\\ninline RTLIL::SigBit::SigBit(const RTLIL::SigSpec &sig) {\\n\\tlog_assert(sig.size() == 1 && sig.chunks().size() == 1);\\n\\t*this = SigBit(sig.chunks().front());\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::Module::rewrite_sigspecs(T &functor)\\n{\\n\\tfor (auto &it : cells_)\\n\\t\\tit.second->rewrite_sigspecs(functor);\\n\\tfor (auto &it : processes)\\n\\t\\tit.second->rewrite_sigspecs(functor);\\n\\tfor (auto &it : connections_) {\\n\\t\\tfunctor(it.first);\\n\\t\\tfunctor(it.second);\\n\\t}\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::Module::rewrite_sigspecs2(T &functor)\\n{\\n\\tfor (auto &it : cells_)\\n\\t\\tit.second->rewrite_sigspecs2(functor);\\n\\tfor (auto &it : processes)\\n\\t\\tit.second->rewrite_sigspecs2(functor);\\n\\tfor (auto &it : connections_) {\\n\\t\\tfunctor(it.first, it.second);\\n\\t}\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::Cell::rewrite_sigspecs(T &functor) {\\n\\tfor (auto &it : connections_)\\n\\t\\tfunctor(it.second);\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::Cell::rewrite_sigspecs2(T &functor) {\\n\\tfor (auto &it : connections_)\\n\\t\\tfunctor(it.second);\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::CaseRule::rewrite_sigspecs(T &functor) {\\n\\tfor (auto &it : compare)\\n\\t\\tfunctor(it);\\n\\tfor (auto &it : actions) {\\n\\t\\tfunctor(it.first);\\n\\t\\tfunctor(it.second);\\n\\t}\\n\\tfor (auto it : switches)\\n\\t\\tit->rewrite_sigspecs(functor);\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::CaseRule::rewrite_sigspecs2(T &functor) {\\n\\tfor (auto &it : compare)\\n\\t\\tfunctor(it);\\n\\tfor (auto &it : actions) {\\n\\t\\tfunctor(it.first, it.second);\\n\\t}\\n\\tfor (auto it : switches)\\n\\t\\tit->rewrite_sigspecs2(functor);\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::SwitchRule::rewrite_sigspecs(T &functor)\\n{\\n\\tfunctor(signal);\\n\\tfor (auto it : cases)\\n\\t\\tit->rewrite_sigspecs(functor);\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::SwitchRule::rewrite_sigspecs2(T &functor)\\n{\\n\\tfunctor(signal);\\n\\tfor (auto it : cases)\\n\\t\\tit->rewrite_sigspecs2(functor);\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::SyncRule::rewrite_sigspecs(T &functor)\\n{\\n\\tfunctor(signal);\\n\\tfor (auto &it : actions) {\\n\\t\\tfunctor(it.first);\\n\\t\\tfunctor(it.second);\\n\\t}\\n\\tfor (auto &it : mem_write_actions) {\\n\\t\\tfunctor(it.address);\\n\\t\\tfunctor(it.data);\\n\\t\\tfunctor(it.enable);\\n\\t}\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::SyncRule::rewrite_sigspecs2(T &functor)\\n{\\n\\tfunctor(signal);\\n\\tfor (auto &it : actions) {\\n\\t\\tfunctor(it.first, it.second);\\n\\t}\\n\\tfor (auto &it : mem_write_actions) {\\n\\t\\tfunctor(it.address);\\n\\t\\tfunctor(it.data);\\n\\t\\tfunctor(it.enable);\\n\\t}\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::Process::rewrite_sigspecs(T &functor)\\n{\\n\\troot_case.rewrite_sigspecs(functor);\\n\\tfor (auto it : syncs)\\n\\t\\tit->rewrite_sigspecs(functor);\\n}\\n\\ntemplate<typename T>\\nvoid RTLIL::Process::rewrite_sigspecs2(T &functor)\\n{\\n\\troot_case.rewrite_sigspecs2(functor);\\n\\tfor (auto it : syncs)\\n\\t\\tit->rewrite_sigspecs2(functor);\\n}\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"satgen.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef SATGEN_H\\n#define SATGEN_H\\n\\n#include \\\"kernel/rtlil.h\\\"\\n#include \\\"kernel/sigtools.h\\\"\\n#include \\\"kernel/celltypes.h\\\"\\n#include \\\"kernel/macc.h\\\"\\n\\n#include \\\"libs/ezsat/ezminisat.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\n// defined in kernel/register.cc\\nextern struct SatSolver *yosys_satsolver_list;\\nextern struct SatSolver *yosys_satsolver;\\n\\nstruct SatSolver\\n{\\n\\tstring name;\\n\\tSatSolver *next;\\n\\tvirtual ezSAT *create() = 0;\\n\\n\\tSatSolver(string name) : name(name) {\\n\\t\\tnext = yosys_satsolver_list;\\n\\t\\tyosys_satsolver_list = this;\\n\\t}\\n\\n\\tvirtual ~SatSolver() {\\n\\t\\tauto p = &yosys_satsolver_list;\\n\\t\\twhile (*p) {\\n\\t\\t\\tif (*p == this)\\n\\t\\t\\t\\t*p = next;\\n\\t\\t\\telse\\n\\t\\t\\t\\tp = &(*p)->next;\\n\\t\\t}\\n\\t\\tif (yosys_satsolver == this)\\n\\t\\t\\tyosys_satsolver = yosys_satsolver_list;\\n\\t}\\n};\\n\\nstruct ezSatPtr : public std::unique_ptr<ezSAT> {\\n\\tezSatPtr() : unique_ptr<ezSAT>(yosys_satsolver->create()) { }\\n};\\n\\nstruct SatGen\\n{\\n\\tezSAT *ez;\\n\\tSigMap *sigmap;\\n\\tstd::string prefix;\\n\\tSigPool initial_state;\\n\\tstd::map<std::string, RTLIL::SigSpec> asserts_a, asserts_en;\\n\\tstd::map<std::string, RTLIL::SigSpec> assumes_a, assumes_en;\\n\\tstd::map<std::string, std::map<RTLIL::SigBit, int>> imported_signals;\\n\\tstd::map<std::pair<std::string, int>, bool> initstates;\\n\\tbool ignore_div_by_zero;\\n\\tbool model_undef;\\n\\tbool def_formal = false;\\n\\n\\tSatGen(ezSAT *ez, SigMap *sigmap, std::string prefix = std::string()) :\\n\\t\\t\\tez(ez), sigmap(sigmap), prefix(prefix), ignore_div_by_zero(false), model_undef(false)\\n\\t{\\n\\t}\\n\\n\\tvoid setContext(SigMap *sigmap, std::string prefix = std::string())\\n\\t{\\n\\t\\tthis->sigmap = sigmap;\\n\\t\\tthis->prefix = prefix;\\n\\t}\\n\\n\\tstd::vector<int> importSigSpecWorker(RTLIL::SigSpec sig, std::string &pf, bool undef_mode, bool dup_undef)\\n\\t{\\n\\t\\tlog_assert(!undef_mode || model_undef);\\n\\t\\tsigmap->apply(sig);\\n\\n\\t\\tstd::vector<int> vec;\\n\\t\\tvec.reserve(GetSize(sig));\\n\\n\\t\\tfor (auto &bit : sig)\\n\\t\\t\\tif (bit.wire == NULL) {\\n\\t\\t\\t\\tif (model_undef && dup_undef && bit == RTLIL::State::Sx)\\n\\t\\t\\t\\t\\tvec.push_back(ez->frozen_literal());\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tvec.push_back(bit == (undef_mode ? RTLIL::State::Sx : RTLIL::State::S1) ? ez->CONST_TRUE : ez->CONST_FALSE);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstd::string name = pf + (bit.wire->width == 1 ? stringf(\\\"%s\\\", log_id(bit.wire)) : stringf(\\\"%s [%d]\\\", log_id(bit.wire->name), bit.offset));\\n\\t\\t\\t\\tvec.push_back(ez->frozen_literal(name));\\n\\t\\t\\t\\timported_signals[pf][bit] = vec.back();\\n\\t\\t\\t}\\n\\t\\treturn vec;\\n\\t}\\n\\n\\tstd::vector<int> importSigSpec(RTLIL::SigSpec sig, int timestep = -1)\\n\\t{\\n\\t\\tlog_assert(timestep != 0);\\n\\t\\tstd::string pf = prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\treturn importSigSpecWorker(sig, pf, false, false);\\n\\t}\\n\\n\\tstd::vector<int> importDefSigSpec(RTLIL::SigSpec sig, int timestep = -1)\\n\\t{\\n\\t\\tlog_assert(timestep != 0);\\n\\t\\tstd::string pf = prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\treturn importSigSpecWorker(sig, pf, false, true);\\n\\t}\\n\\n\\tstd::vector<int> importUndefSigSpec(RTLIL::SigSpec sig, int timestep = -1)\\n\\t{\\n\\t\\tlog_assert(timestep != 0);\\n\\t\\tstd::string pf = \\\"undef:\\\" + prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\treturn importSigSpecWorker(sig, pf, true, false);\\n\\t}\\n\\n\\tint importSigBit(RTLIL::SigBit bit, int timestep = -1)\\n\\t{\\n\\t\\tlog_assert(timestep != 0);\\n\\t\\tstd::string pf = prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\treturn importSigSpecWorker(bit, pf, false, false).front();\\n\\t}\\n\\n\\tint importDefSigBit(RTLIL::SigBit bit, int timestep = -1)\\n\\t{\\n\\t\\tlog_assert(timestep != 0);\\n\\t\\tstd::string pf = prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\treturn importSigSpecWorker(bit, pf, false, true).front();\\n\\t}\\n\\n\\tint importUndefSigBit(RTLIL::SigBit bit, int timestep = -1)\\n\\t{\\n\\t\\tlog_assert(timestep != 0);\\n\\t\\tstd::string pf = \\\"undef:\\\" + prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\treturn importSigSpecWorker(bit, pf, true, false).front();\\n\\t}\\n\\n\\tbool importedSigBit(RTLIL::SigBit bit, int timestep = -1)\\n\\t{\\n\\t\\tlog_assert(timestep != 0);\\n\\t\\tstd::string pf = prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\treturn imported_signals[pf].count(bit) != 0;\\n\\t}\\n\\n\\tvoid getAsserts(RTLIL::SigSpec &sig_a, RTLIL::SigSpec &sig_en, int timestep = -1)\\n\\t{\\n\\t\\tstd::string pf = prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\tsig_a = asserts_a[pf];\\n\\t\\tsig_en = asserts_en[pf];\\n\\t}\\n\\n\\tvoid getAssumes(RTLIL::SigSpec &sig_a, RTLIL::SigSpec &sig_en, int timestep = -1)\\n\\t{\\n\\t\\tstd::string pf = prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\tsig_a = assumes_a[pf];\\n\\t\\tsig_en = assumes_en[pf];\\n\\t}\\n\\n\\tint importAsserts(int timestep = -1)\\n\\t{\\n\\t\\tstd::vector<int> check_bits, enable_bits;\\n\\t\\tstd::string pf = prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\tif (model_undef) {\\n\\t\\t\\tcheck_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(asserts_a[pf], timestep)), importDefSigSpec(asserts_a[pf], timestep));\\n\\t\\t\\tenable_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(asserts_en[pf], timestep)), importDefSigSpec(asserts_en[pf], timestep));\\n\\t\\t} else {\\n\\t\\t\\tcheck_bits = importDefSigSpec(asserts_a[pf], timestep);\\n\\t\\t\\tenable_bits = importDefSigSpec(asserts_en[pf], timestep);\\n\\t\\t}\\n\\t\\treturn ez->vec_reduce_and(ez->vec_or(check_bits, ez->vec_not(enable_bits)));\\n\\t}\\n\\n\\tint importAssumes(int timestep = -1)\\n\\t{\\n\\t\\tstd::vector<int> check_bits, enable_bits;\\n\\t\\tstd::string pf = prefix + (timestep == -1 ? \\\"\\\" : stringf(\\\"@%d:\\\", timestep));\\n\\t\\tif (model_undef) {\\n\\t\\t\\tcheck_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(assumes_a[pf], timestep)), importDefSigSpec(assumes_a[pf], timestep));\\n\\t\\t\\tenable_bits = ez->vec_and(ez->vec_not(importUndefSigSpec(assumes_en[pf], timestep)), importDefSigSpec(assumes_en[pf], timestep));\\n\\t\\t} else {\\n\\t\\t\\tcheck_bits = importDefSigSpec(assumes_a[pf], timestep);\\n\\t\\t\\tenable_bits = importDefSigSpec(assumes_en[pf], timestep);\\n\\t\\t}\\n\\t\\treturn ez->vec_reduce_and(ez->vec_or(check_bits, ez->vec_not(enable_bits)));\\n\\t}\\n\\n\\tint signals_eq(RTLIL::SigSpec lhs, RTLIL::SigSpec rhs, int timestep_lhs = -1, int timestep_rhs = -1)\\n\\t{\\n\\t\\tif (timestep_rhs < 0)\\n\\t\\t\\ttimestep_rhs = timestep_lhs;\\n\\n\\t\\tlog_assert(lhs.size() == rhs.size());\\n\\n\\t\\tstd::vector<int> vec_lhs = importSigSpec(lhs, timestep_lhs);\\n\\t\\tstd::vector<int> vec_rhs = importSigSpec(rhs, timestep_rhs);\\n\\n\\t\\tif (!model_undef)\\n\\t\\t\\treturn ez->vec_eq(vec_lhs, vec_rhs);\\n\\n\\t\\tstd::vector<int> undef_lhs = importUndefSigSpec(lhs, timestep_lhs);\\n\\t\\tstd::vector<int> undef_rhs = importUndefSigSpec(rhs, timestep_rhs);\\n\\n\\t\\tstd::vector<int> eq_bits;\\n\\t\\tfor (int i = 0; i < lhs.size(); i++)\\n\\t\\t\\teq_bits.push_back(ez->AND(ez->IFF(undef_lhs.at(i), undef_rhs.at(i)),\\n\\t\\t\\t\\t\\tez->IFF(ez->OR(vec_lhs.at(i), undef_lhs.at(i)), ez->OR(vec_rhs.at(i), undef_rhs.at(i)))));\\n\\t\\treturn ez->expression(ezSAT::OpAnd, eq_bits);\\n\\t}\\n\\n\\tvoid extendSignalWidth(std::vector<int> &vec_a, std::vector<int> &vec_b, RTLIL::Cell *cell, size_t y_width = 0, bool forced_signed = false)\\n\\t{\\n\\t\\tbool is_signed = forced_signed;\\n\\t\\tif (!forced_signed && cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters.count(ID::B_SIGNED) > 0)\\n\\t\\t\\tis_signed = cell->parameters[ID::A_SIGNED].as_bool() && cell->parameters[ID::B_SIGNED].as_bool();\\n\\t\\twhile (vec_a.size() < vec_b.size() || vec_a.size() < y_width)\\n\\t\\t\\tvec_a.push_back(is_signed && vec_a.size() > 0 ? vec_a.back() : ez->CONST_FALSE);\\n\\t\\twhile (vec_b.size() < vec_a.size() || vec_b.size() < y_width)\\n\\t\\t\\tvec_b.push_back(is_signed && vec_b.size() > 0 ? vec_b.back() : ez->CONST_FALSE);\\n\\t}\\n\\n\\tvoid extendSignalWidth(std::vector<int> &vec_a, std::vector<int> &vec_b, std::vector<int> &vec_y, RTLIL::Cell *cell, bool forced_signed = false)\\n\\t{\\n\\t\\textendSignalWidth(vec_a, vec_b, cell, vec_y.size(), forced_signed);\\n\\t\\twhile (vec_y.size() < vec_a.size())\\n\\t\\t\\tvec_y.push_back(ez->literal());\\n\\t}\\n\\n\\tvoid extendSignalWidthUnary(std::vector<int> &vec_a, std::vector<int> &vec_y, RTLIL::Cell *cell, bool forced_signed = false)\\n\\t{\\n\\t\\tbool is_signed = forced_signed || (cell->parameters.count(ID::A_SIGNED) > 0 && cell->parameters[ID::A_SIGNED].as_bool());\\n\\t\\twhile (vec_a.size() < vec_y.size())\\n\\t\\t\\tvec_a.push_back(is_signed && vec_a.size() > 0 ? vec_a.back() : ez->CONST_FALSE);\\n\\t\\twhile (vec_y.size() < vec_a.size())\\n\\t\\t\\tvec_y.push_back(ez->literal());\\n\\t}\\n\\n\\tvoid undefGating(std::vector<int> &vec_y, std::vector<int> &vec_yy, std::vector<int> &vec_undef)\\n\\t{\\n\\t\\tlog_assert(model_undef);\\n\\t\\tlog_assert(vec_y.size() == vec_yy.size());\\n\\t\\tif (vec_y.size() > vec_undef.size()) {\\n\\t\\t\\tstd::vector<int> trunc_y(vec_y.begin(), vec_y.begin() + vec_undef.size());\\n\\t\\t\\tstd::vector<int> trunc_yy(vec_yy.begin(), vec_yy.begin() + vec_undef.size());\\n\\t\\t\\tez->assume(ez->expression(ezSAT::OpAnd, ez->vec_or(vec_undef, ez->vec_iff(trunc_y, trunc_yy))));\\n\\t\\t} else {\\n\\t\\t\\tlog_assert(vec_y.size() == vec_undef.size());\\n\\t\\t\\tez->assume(ez->expression(ezSAT::OpAnd, ez->vec_or(vec_undef, ez->vec_iff(vec_y, vec_yy))));\\n\\t\\t}\\n\\t}\\n\\n\\tstd::pair<std::vector<int>, std::vector<int>> mux(int s, int undef_s, const std::vector<int> &a, const std::vector<int> &undef_a, const std::vector<int> &b, const std::vector<int> &undef_b) {\\n\\t\\tstd::vector<int> res;\\n\\t\\tstd::vector<int> undef_res;\\n\\t\\tres = ez->vec_ite(s, b, a);\\n\\t\\tif (model_undef) {\\n\\t\\t\\tstd::vector<int> unequal_ab = ez->vec_not(ez->vec_iff(a, b));\\n\\t\\t\\tstd::vector<int> undef_ab = ez->vec_or(unequal_ab, ez->vec_or(undef_a, undef_b));\\n\\t\\t\\tundef_res = ez->vec_ite(undef_s, undef_ab, ez->vec_ite(s, undef_b, undef_a));\\n\\t\\t}\\n\\t\\treturn std::make_pair(res, undef_res);\\n\\t}\\n\\n\\tvoid undefGating(int y, int yy, int undef)\\n\\t{\\n\\t\\tez->assume(ez->OR(undef, ez->IFF(y, yy)));\\n\\t}\\n\\n\\tvoid setInitState(int timestep)\\n\\t{\\n\\t\\tauto key = make_pair(prefix, timestep);\\n\\t\\tlog_assert(initstates.count(key) == 0 || initstates.at(key) == true);\\n\\t\\tinitstates[key] = true;\\n\\t}\\n\\n\\tbool importCell(RTLIL::Cell *cell, int timestep = -1);\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"scopeinfo.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2024  Jannis Harder <jix@yosyshq.com> <me@jix.one>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef SCOPEINFO_H\\n#define SCOPEINFO_H\\n\\n#include <vector>\\n#include <algorithm>\\n\\n#include \\\"kernel/yosys.h\\\"\\n#include \\\"kernel/celltypes.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\ntemplate<typename T>\\nclass IdTree\\n{\\npublic:\\n\\tstruct Cursor;\\n\\nprotected:\\n\\tIdTree *parent = nullptr;\\n\\tIdString scope_name;\\n\\tint depth = 0;\\n\\n\\tpool<IdString> names;\\n\\tdict<IdString, T> entries;\\npublic: // XXX\\n\\tdict<IdString, std::unique_ptr<IdTree>> subtrees;\\n\\n\\ttemplate<typename P, typename T_ref>\\n\\tstatic Cursor do_insert(IdTree *tree, P begin, P end, T_ref &&value)\\n\\t{\\n\\t\\tlog_assert(begin != end && \\\"path must be non-empty\\\");\\n\\t\\twhile (true) {\\n\\t\\t\\tIdString name = *begin;\\n\\t\\t\\t++begin;\\n\\t\\t\\tlog_assert(!name.empty());\\n\\t\\t\\ttree->names.insert(name);\\n\\t\\t\\tif (begin == end) {\\n\\t\\t\\t\\ttree->entries.emplace(name, std::forward<T_ref>(value));\\n\\t\\t\\t\\treturn Cursor(tree, name);\\n\\t\\t\\t}\\n\\t\\t\\tauto &unique = tree->subtrees[name];\\n\\t\\t\\tif (!unique) {\\n\\t\\t\\t\\tunique.reset(new IdTree);\\n\\t\\t\\t\\tunique->scope_name = name;\\n\\t\\t\\t\\tunique->parent = tree;\\n\\t\\t\\t\\tunique->depth = tree->depth + 1;\\n\\t\\t\\t}\\n\\t\\t\\ttree = unique.get();\\n\\t\\t}\\n\\t}\\n\\npublic:\\n\\tIdTree() = default;\\n\\tIdTree(const IdTree &) = delete;\\n\\tIdTree(IdTree &&) = delete;\\n\\n\\t// A cursor remains valid as long as the (sub-)IdTree it points at is alive\\n\\tstruct Cursor\\n\\t{\\n\\t\\tfriend class IdTree;\\n\\tprotected:\\n\\tpublic:\\n\\t\\tIdTree *target;\\n\\t\\tIdString scope_name;\\n\\n\\t\\tCursor() : target(nullptr) {}\\n\\t\\tCursor(IdTree *target, IdString scope_name) : target(target), scope_name(scope_name) {\\n\\t\\t\\tif (scope_name.empty())\\n\\t\\t\\t\\tlog_assert(target->parent == nullptr);\\n\\t\\t}\\n\\n\\t\\tCursor do_first_child() {\\n\\t\\t\\tIdTree *tree = nullptr;\\n\\t\\t\\tif (scope_name.empty()) {\\n\\t\\t\\t\\ttree = target;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tauto found = target->subtrees.find(scope_name);\\n\\t\\t\\t\\tif (found != target->subtrees.end()) {\\n\\t\\t\\t\\t\\ttree = found->second.get();\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn Cursor();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (tree->names.empty()) {\\n\\t\\t\\t\\treturn Cursor();\\n\\t\\t\\t}\\n\\t\\t\\treturn Cursor(tree, *tree->names.begin());\\n\\t\\t}\\n\\n\\t\\tCursor do_next_sibling() {\\n\\t\\t\\tif (scope_name.empty())\\n\\t\\t\\t\\treturn Cursor();\\n\\t\\t\\tauto found = target->names.find(scope_name);\\n\\t\\t\\tif (found == target->names.end())\\n\\t\\t\\t\\treturn Cursor();\\n\\t\\t\\t++found;\\n\\t\\t\\tif (found == target->names.end())\\n\\t\\t\\t\\treturn Cursor();\\n\\t\\t\\treturn Cursor(target, *found);\\n\\t\\t}\\n\\n\\t\\tCursor do_parent() {\\n\\t\\t\\tif (scope_name.empty())\\n\\t\\t\\t\\treturn Cursor();\\n\\t\\t\\tif (target->parent != nullptr)\\n\\t\\t\\t\\treturn Cursor(target->parent, target->scope_name);\\n\\t\\t\\treturn Cursor(target, IdString());\\n\\t\\t}\\n\\n\\t\\tCursor do_next_preorder() {\\n\\t\\t\\tCursor current = *this;\\n\\t\\t\\tCursor next = current.do_first_child();\\n\\t\\t\\tif (next.valid())\\n\\t\\t\\t\\treturn next;\\n\\t\\t\\twhile (current.valid()) {\\n\\t\\t\\t\\tif (next.valid())\\n\\t\\t\\t\\t\\treturn next;\\n\\t\\t\\t\\tnext = current.do_next_sibling();\\n\\t\\t\\t\\tif (next.valid())\\n\\t\\t\\t\\t\\treturn next;\\n\\t\\t\\t\\tcurrent = current.do_parent();\\n\\t\\t\\t}\\n\\t\\t\\treturn current;\\n\\t\\t}\\n\\n\\t\\tCursor do_child(IdString name) {\\n\\t\\t\\tIdTree *tree = nullptr;\\n\\t\\t\\tif (scope_name.empty()) {\\n\\t\\t\\t\\ttree = target;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tauto found = target->subtrees.find(scope_name);\\n\\t\\t\\t\\tif (found != target->subtrees.end()) {\\n\\t\\t\\t\\t\\ttree = found->second.get();\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn Cursor();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tauto found = tree->names.find(name);\\n\\t\\t\\tif (found == tree->names.end()) {\\n\\t\\t\\t\\treturn Cursor();\\n\\t\\t\\t}\\n\\t\\t\\treturn Cursor(tree, *found);\\n\\t\\t}\\n\\n\\tpublic:\\n\\t\\tbool operator==(const Cursor &other) const {\\n\\t\\t\\treturn target == other.target && scope_name == other.scope_name;\\n\\t\\t}\\n\\t\\tbool operator!=(const Cursor &other) const {\\n\\t\\t\\treturn !(*this == other);\\n\\t\\t}\\n\\n\\t\\tbool valid() const {\\n\\t\\t\\treturn target != nullptr;\\n\\t\\t}\\n\\n\\t\\tint depth() const {\\n\\t\\t\\tlog_assert(valid());\\n\\t\\t\\treturn target->depth + !scope_name.empty();\\n\\t\\t}\\n\\n\\t\\tbool is_root() const {\\n\\t\\t\\treturn target != nullptr && scope_name.empty();\\n\\t\\t}\\n\\n\\t\\tbool has_entry() const {\\n\\t\\t\\tlog_assert(valid());\\n\\t\\t\\treturn !scope_name.empty() && target->entries.count(scope_name);\\n\\t\\t}\\n\\n\\t\\tT &entry() {\\n\\t\\t\\tlog_assert(!scope_name.empty());\\n\\t\\t\\treturn target->entries.at(scope_name);\\n\\t\\t}\\n\\n\\t\\tvoid assign_path_to(std::vector<IdString> &out_path) {\\n\\t\\t\\tlog_assert(valid());\\n\\t\\t\\tout_path.clear();\\n\\t\\t\\tif (scope_name.empty())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tout_path.push_back(scope_name);\\n\\t\\t\\tIdTree *current = target;\\n\\t\\t\\twhile (current->parent) {\\n\\t\\t\\t\\tout_path.push_back(current->scope_name);\\n\\t\\t\\t\\tcurrent = current->parent;\\n\\t\\t\\t}\\n\\t\\t\\tstd::reverse(out_path.begin(), out_path.end());\\n\\t\\t}\\n\\n\\t\\tstd::vector<IdString> path() {\\n\\t\\t\\tstd::vector<IdString> result;\\n\\t\\t\\tassign_path_to(result);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tstd::string path_str() {\\n\\t\\t\\tstd::string result;\\n\\t\\t\\tfor (const auto &item : path()) {\\n\\t\\t\\t\\tif (!result.empty())\\n\\t\\t\\t\\t\\tresult.push_back(' ');\\n\\t\\t\\t\\tresult += RTLIL::unescape_id(item);\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tCursor first_child() {\\n\\t\\t\\tlog_assert(valid());\\n\\t\\t\\treturn do_first_child();\\n\\t\\t}\\n\\n\\t\\tCursor next_preorder() {\\n\\t\\t\\tlog_assert(valid());\\n\\t\\t\\treturn do_next_preorder();\\n\\t\\t}\\n\\n\\t\\tCursor parent() {\\n\\t\\t\\tlog_assert(valid());\\n\\t\\t\\treturn do_parent();\\n\\t\\t}\\n\\n\\t\\tCursor child(IdString name) {\\n\\t\\t\\tlog_assert(valid());\\n\\t\\t\\treturn do_child(name);\\n\\t\\t}\\n\\n\\t\\tCursor common_ancestor(Cursor other) {\\n\\t\\t\\tCursor current = *this;\\n\\n\\t\\t\\twhile (current != other) {\\n\\t\\t\\t\\tif (!current.valid() || !other.valid())\\n\\t\\t\\t\\t\\treturn Cursor();\\n\\t\\t\\t\\tint delta = current.depth() - other.depth();\\n\\t\\t\\t\\tif (delta >= 0)\\n\\t\\t\\t\\t\\tcurrent = current.do_parent();\\n\\t\\t\\t\\tif (delta <= 0)\\n\\t\\t\\t\\t\\tother = other.do_parent();\\n\\t\\t\\t}\\n\\t\\t\\treturn current;\\n\\t\\t}\\n\\t};\\n\\n\\ttemplate<typename P>\\n\\tCursor insert(P begin, P end, const T &value) {\\n\\t\\treturn do_insert(this, begin, end, value);\\n\\t}\\n\\n\\ttemplate<typename P>\\n\\tCursor insert(P begin, P end, T &&value) {\\n\\t\\treturn do_insert(this, begin, end, std::move(value));\\n\\t}\\n\\n\\ttemplate<typename P>\\n\\tCursor insert(const P &path, const T &value) {\\n\\t\\treturn do_insert(this, path.begin(), path.end(), value);\\n\\t}\\n\\n\\ttemplate<typename P>\\n\\tCursor insert(const P &path, T &&value) {\\n\\t\\treturn do_insert(this, path.begin(), path.end(), std::move(value));\\n\\t}\\n\\n\\tCursor cursor() {\\n\\t\\treturn parent ? Cursor(this->parent, this->scope_name) : Cursor(this, IdString());\\n\\t}\\n\\n\\ttemplate<typename P>\\n\\tCursor cursor(P begin, P end) {\\n\\t\\tCursor current = cursor();\\n\\t\\tfor (; begin != end; ++begin) {\\n\\t\\t\\tcurrent = current.do_child(*begin);\\n\\t\\t\\tif (!current.valid())\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\treturn current;\\n\\t}\\n\\n\\ttemplate<typename P>\\n\\tCursor cursor(const P &path) {\\n\\t\\treturn cursor(path.begin(), path.end());\\n\\t}\\n};\\n\\n\\nstruct ModuleItem {\\n\\tenum class Type {\\n\\t\\tWire,\\n\\t\\tCell,\\n\\t};\\n\\tType type;\\n\\tvoid *ptr;\\n\\n\\tModuleItem(Wire *wire) : type(Type::Wire), ptr(wire) {}\\n\\tModuleItem(Cell *cell) : type(Type::Cell), ptr(cell) {}\\n\\n\\tbool is_wire() const { return type == Type::Wire; }\\n\\tbool is_cell() const { return type == Type::Cell; }\\n\\n\\tWire *wire() const { return type == Type::Wire ? static_cast<Wire *>(ptr) : nullptr; }\\n\\tCell *cell() const { return type == Type::Cell ? static_cast<Cell *>(ptr) : nullptr; }\\n\\n\\tbool operator==(const ModuleItem &other) const { return ptr == other.ptr && type == other.type; }\\n\\tunsigned int hash() const { return (uintptr_t)ptr; }\\n};\\n\\nstatic inline void log_dump_val_worker(typename IdTree<ModuleItem>::Cursor cursor ) { log(\\\"%p %s\\\", cursor.target, log_id(cursor.scope_name)); }\\n\\ntemplate<typename T>\\nstatic inline void log_dump_val_worker(const typename std::unique_ptr<T> &cursor ) { log(\\\"unique %p\\\", cursor.get()); }\\n\\ntemplate<typename O>\\nstd::vector<IdString> parse_hdlname(const O* object)\\n{\\n\\tstd::vector<IdString> path;\\n\\tif (!object->name.isPublic())\\n\\t\\treturn path;\\n\\tfor (auto const &item : object->get_hdlname_attribute())\\n\\t\\tpath.push_back(\\\"\\\\\\\\\\\" + item);\\n\\tif (path.empty())\\n\\t\\tpath.push_back(object->name);\\n\\treturn path;\\n}\\n\\ntemplate<typename O>\\nstd::pair<std::vector<IdString>, IdString> parse_scopename(const O* object)\\n{\\n\\tstd::vector<IdString> path;\\n\\tIdString trailing = object->name;\\n\\tif (object->name.isPublic()) {\\n\\t\\tfor (auto const &item : object->get_hdlname_attribute())\\n\\t\\t\\tpath.push_back(\\\"\\\\\\\\\\\" + item);\\n\\t\\tif (!path.empty()) {\\n\\t\\t\\ttrailing = path.back();\\n\\t\\t\\tpath.pop_back();\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor (auto const &item : split_tokens(object->get_string_attribute(ID(scopename)), \\\" \\\"))\\n\\t\\t\\tpath.push_back(\\\"\\\\\\\\\\\" + item);\\n\\n\\t}\\n\\treturn {path, trailing};\\n}\\n\\nstruct ModuleHdlnameIndex {\\n\\ttypedef IdTree<ModuleItem>::Cursor Cursor;\\n\\n\\tRTLIL::Module *module;\\n\\tIdTree<ModuleItem> tree;\\n\\tdict<ModuleItem, Cursor> lookup;\\n\\n\\tModuleHdlnameIndex(RTLIL::Module *module) : module(module) {}\\n\\nprivate:\\n\\ttemplate<typename I, typename Filter>\\n\\tvoid index_items(I begin, I end, Filter filter);\\n\\npublic:\\n\\t// Index all wires and cells of the module\\n\\tvoid index();\\n\\n\\t// Index all wires of the module\\n\\tvoid index_wires();\\n\\n\\t// Index all cells of the module\\n\\tvoid index_cells();\\n\\n\\t// Index only the $scopeinfo cells of the module.\\n\\t// This is sufficient when using `containing_scope`.\\n\\tvoid index_scopeinfo_cells();\\n\\n\\n\\t// Return the cursor for the containing scope of some RTLIL object (Wire/Cell/...)\\n\\ttemplate<typename O>\\n\\tstd::pair<Cursor, IdString> containing_scope(O *object) {\\n\\t\\tauto pair = parse_scopename(object);\\n\\t\\treturn {tree.cursor(pair.first), pair.second};\\n\\t}\\n\\n\\t// Return a vector of source locations starting from the indexed module to\\n\\t// the scope represented by the cursor. The vector alternates module and\\n\\t// module item source locations, using empty strings for missing src\\n\\t// attributes.\\n\\tstd::vector<std::string> scope_sources(Cursor cursor);\\n\\n\\t// Return a vector of source locations starting from the indexed module to\\n\\t// the passed RTLIL object (Wire/Cell/...). The vector alternates module\\n\\t// and module item source locations, using empty strings for missing src\\n\\t// attributes.\\n\\ttemplate<typename O>\\n\\tstd::vector<std::string> sources(O *object) {\\n\\t\\tauto pair = parse_scopename(object);\\n\\t\\tstd::vector<std::string> result = scope_sources(tree.cursor(pair.first));\\n\\t\\tresult.push_back(object->get_src_attribute());\\n\\t\\treturn result;\\n\\t}\\n};\\n\\nenum class ScopeinfoAttrs {\\n\\tModule,\\n\\tCell,\\n};\\n\\n// Check whether the flattened module or flattened cell corresponding to a $scopeinfo cell had a specific attribute.\\nbool scopeinfo_has_attribute(const RTLIL::Cell *scopeinfo, ScopeinfoAttrs attrs, const RTLIL::IdString &id);\\n\\n// Get a specific attribute from the flattened module or flattened cell corresponding to a $scopeinfo cell.\\nRTLIL::Const scopeinfo_get_attribute(const RTLIL::Cell *scopeinfo, ScopeinfoAttrs attrs, const RTLIL::IdString &id);\\n\\n// Get all attribute from the flattened module or flattened cell corresponding to a $scopeinfo cell.\\ndict<RTLIL::IdString, RTLIL::Const> scopeinfo_attributes(const RTLIL::Cell *scopeinfo, ScopeinfoAttrs attrs);\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"sigtools.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef SIGTOOLS_H\\n#define SIGTOOLS_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct SigPool\\n{\\n\\tstruct bitDef_t : public std::pair<RTLIL::Wire*, int> {\\n\\t\\tbitDef_t() : std::pair<RTLIL::Wire*, int>(NULL, 0) { }\\n\\t\\tbitDef_t(const RTLIL::SigBit &bit) : std::pair<RTLIL::Wire*, int>(bit.wire, bit.offset) { }\\n\\t\\tunsigned int hash() const { return first->name.hash() + second; }\\n\\t};\\n\\n\\tpool<bitDef_t> bits;\\n\\n\\tvoid clear()\\n\\t{\\n\\t\\tbits.clear();\\n\\t}\\n\\n\\tvoid add(const RTLIL::SigSpec &sig)\\n\\t{\\n\\t\\tfor (auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL)\\n\\t\\t\\t\\tbits.insert(bit);\\n\\t}\\n\\n\\tvoid add(const SigPool &other)\\n\\t{\\n\\t\\tfor (auto &bit : other.bits)\\n\\t\\t\\tbits.insert(bit);\\n\\t}\\n\\n\\tvoid del(const RTLIL::SigSpec &sig)\\n\\t{\\n\\t\\tfor (auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL)\\n\\t\\t\\t\\tbits.erase(bit);\\n\\t}\\n\\n\\tvoid del(const SigPool &other)\\n\\t{\\n\\t\\tfor (auto &bit : other.bits)\\n\\t\\t\\tbits.erase(bit);\\n\\t}\\n\\n\\tvoid expand(const RTLIL::SigSpec &from, const RTLIL::SigSpec &to)\\n\\t{\\n\\t\\tlog_assert(GetSize(from) == GetSize(to));\\n\\t\\tfor (int i = 0; i < GetSize(from); i++) {\\n\\t\\t\\tbitDef_t bit_from(from[i]), bit_to(to[i]);\\n\\t\\t\\tif (bit_from.first != NULL && bit_to.first != NULL && bits.count(bit_from) > 0)\\n\\t\\t\\t\\tbits.insert(bit_to);\\n\\t\\t}\\n\\t}\\n\\n\\tRTLIL::SigSpec extract(const RTLIL::SigSpec &sig) const\\n\\t{\\n\\t\\tRTLIL::SigSpec result;\\n\\t\\tfor (auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL && bits.count(bit))\\n\\t\\t\\t\\tresult.append(bit);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tRTLIL::SigSpec remove(const RTLIL::SigSpec &sig) const\\n\\t{\\n\\t\\tRTLIL::SigSpec result;\\n\\t\\tfor (auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL && bits.count(bit) == 0)\\n\\t\\t\\t\\tresult.append(bit);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tbool check(const RTLIL::SigBit &bit) const\\n\\t{\\n\\t\\treturn bit.wire != NULL && bits.count(bit);\\n\\t}\\n\\n\\tbool check_any(const RTLIL::SigSpec &sig) const\\n\\t{\\n\\t\\tfor (auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL && bits.count(bit))\\n\\t\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool check_all(const RTLIL::SigSpec &sig) const\\n\\t{\\n\\t\\tfor (auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL && bits.count(bit) == 0)\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tRTLIL::SigSpec export_one() const\\n\\t{\\n\\t\\tfor (auto &bit : bits)\\n\\t\\t\\treturn RTLIL::SigSpec(bit.first, bit.second);\\n\\t\\treturn RTLIL::SigSpec();\\n\\t}\\n\\n\\tRTLIL::SigSpec export_all() const\\n\\t{\\n\\t\\tpool<RTLIL::SigBit> sig;\\n\\t\\tfor (auto &bit : bits)\\n\\t\\t\\tsig.insert(RTLIL::SigBit(bit.first, bit.second));\\n\\t\\treturn sig;\\n\\t}\\n\\n\\tsize_t size() const\\n\\t{\\n\\t\\treturn bits.size();\\n\\t}\\n};\\n\\ntemplate <typename T, class Compare = void>\\nstruct SigSet\\n{\\n\\tstatic_assert(!std::is_same<Compare,void>::value, \\\"Default value for `Compare' class not found for SigSet<T>. Please specify.\\\");\\n\\n\\tstruct bitDef_t : public std::pair<RTLIL::Wire*, int> {\\n\\t\\tbitDef_t() : std::pair<RTLIL::Wire*, int>(NULL, 0) { }\\n\\t\\tbitDef_t(const RTLIL::SigBit &bit) : std::pair<RTLIL::Wire*, int>(bit.wire, bit.offset) { }\\n\\t\\tunsigned int hash() const { return first->name.hash() + second; }\\n\\t};\\n\\n\\tdict<bitDef_t, std::set<T, Compare>> bits;\\n\\n\\tvoid clear()\\n\\t{\\n\\t\\tbits.clear();\\n\\t}\\n\\n\\tvoid insert(const RTLIL::SigSpec &sig, T data)\\n\\t{\\n\\t\\tfor (const auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL)\\n\\t\\t\\t\\tbits[bit].insert(data);\\n\\t}\\n\\n\\tvoid insert(const RTLIL::SigSpec& sig, const std::set<T> &data)\\n\\t{\\n\\t\\tfor (const auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL)\\n\\t\\t\\t\\tbits[bit].insert(data.begin(), data.end());\\n\\t}\\n\\n\\tvoid erase(const RTLIL::SigSpec& sig)\\n\\t{\\n\\t\\tfor (const auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL)\\n\\t\\t\\t\\tbits[bit].clear();\\n\\t}\\n\\n\\tvoid erase(const RTLIL::SigSpec &sig, T data)\\n\\t{\\n\\t\\tfor (const auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL)\\n\\t\\t\\t\\tbits[bit].erase(data);\\n\\t}\\n\\n\\tvoid erase(const RTLIL::SigSpec &sig, const std::set<T> &data)\\n\\t{\\n\\t\\tfor (const auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL)\\n\\t\\t\\t\\tbits[bit].erase(data.begin(), data.end());\\n\\t}\\n\\n\\tvoid find(const RTLIL::SigSpec &sig, std::set<T> &result)\\n\\t{\\n\\t\\tfor (const auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL) {\\n\\t\\t\\t\\tauto &data = bits[bit];\\n\\t\\t\\t\\tresult.insert(data.begin(), data.end());\\n\\t\\t\\t}\\n\\t}\\n\\n\\tvoid find(const RTLIL::SigSpec &sig, pool<T> &result)\\n\\t{\\n\\t\\tfor (const auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL) {\\n\\t\\t\\t\\tauto &data = bits[bit];\\n\\t\\t\\t\\tresult.insert(data.begin(), data.end());\\n\\t\\t\\t}\\n\\t}\\n\\n\\tstd::set<T> find(const RTLIL::SigSpec &sig)\\n\\t{\\n\\t\\tstd::set<T> result;\\n\\t\\tfind(sig, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tbool has(const RTLIL::SigSpec &sig)\\n\\t{\\n\\t\\tfor (auto &bit : sig)\\n\\t\\t\\tif (bit.wire != NULL && bits.count(bit))\\n\\t\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n};\\n\\ntemplate<typename T>\\nclass SigSet<T, typename std::enable_if<!std::is_pointer<T>::value>::type> : public SigSet<T, std::less<T>> {};\\ntemplate<typename T>\\nusing sort_by_name_id_guard = typename std::enable_if<std::is_same<T,RTLIL::Cell*>::value>::type;\\ntemplate<typename T>\\nclass SigSet<T, sort_by_name_id_guard<T>> : public SigSet<T, RTLIL::sort_by_name_id<typename std::remove_pointer<T>::type>> {};\\n\\nstruct SigMap\\n{\\n\\tmfp<SigBit> database;\\n\\n\\tSigMap(RTLIL::Module *module = NULL)\\n\\t{\\n\\t\\tif (module != NULL)\\n\\t\\t\\tset(module);\\n\\t}\\n\\n\\tvoid swap(SigMap &other)\\n\\t{\\n\\t\\tdatabase.swap(other.database);\\n\\t}\\n\\n\\tvoid clear()\\n\\t{\\n\\t\\tdatabase.clear();\\n\\t}\\n\\n\\tvoid set(RTLIL::Module *module)\\n\\t{\\n\\t\\tint bitcount = 0;\\n\\t\\tfor (auto &it : module->connections())\\n\\t\\t\\tbitcount += it.first.size();\\n\\n\\t\\tdatabase.clear();\\n\\t\\tdatabase.reserve(bitcount);\\n\\n\\t\\tfor (auto &it : module->connections())\\n\\t\\t\\tadd(it.first, it.second);\\n\\t}\\n\\n\\tvoid add(const RTLIL::SigSpec& from, const RTLIL::SigSpec& to)\\n\\t{\\n\\t\\tlog_assert(GetSize(from) == GetSize(to));\\n\\n\\t\\tfor (int i = 0; i < GetSize(from); i++)\\n\\t\\t{\\n\\t\\t\\tint bfi = database.lookup(from[i]);\\n\\t\\t\\tint bti = database.lookup(to[i]);\\n\\n\\t\\t\\tconst RTLIL::SigBit &bf = database[bfi];\\n\\t\\t\\tconst RTLIL::SigBit &bt = database[bti];\\n\\n\\t\\t\\tif (bf.wire || bt.wire)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdatabase.imerge(bfi, bti);\\n\\n\\t\\t\\t\\tif (bf.wire == nullptr)\\n\\t\\t\\t\\t\\tdatabase.ipromote(bfi);\\n\\n\\t\\t\\t\\tif (bt.wire == nullptr)\\n\\t\\t\\t\\t\\tdatabase.ipromote(bti);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvoid add(const RTLIL::SigBit &bit)\\n\\t{\\n\\t\\tconst auto &b = database.find(bit);\\n\\t\\tif (b.wire != nullptr)\\n\\t\\t\\tdatabase.promote(bit);\\n\\t}\\n\\n\\tvoid add(const RTLIL::SigSpec &sig)\\n\\t{\\n\\t\\tfor (const auto &bit : sig)\\n\\t\\t\\tadd(bit);\\n\\t}\\n\\n\\tinline void add(Wire *wire) { return add(RTLIL::SigSpec(wire)); }\\n\\n\\tvoid apply(RTLIL::SigBit &bit) const\\n\\t{\\n\\t\\tbit = database.find(bit);\\n\\t}\\n\\n\\tvoid apply(RTLIL::SigSpec &sig) const\\n\\t{\\n\\t\\tfor (auto &bit : sig)\\n\\t\\t\\tapply(bit);\\n\\t}\\n\\n\\tRTLIL::SigBit operator()(RTLIL::SigBit bit) const\\n\\t{\\n\\t\\tapply(bit);\\n\\t\\treturn bit;\\n\\t}\\n\\n\\tRTLIL::SigSpec operator()(RTLIL::SigSpec sig) const\\n\\t{\\n\\t\\tapply(sig);\\n\\t\\treturn sig;\\n\\t}\\n\\n\\tRTLIL::SigSpec operator()(RTLIL::Wire *wire) const\\n\\t{\\n\\t\\tSigSpec sig(wire);\\n\\t\\tapply(sig);\\n\\t\\treturn sig;\\n\\t}\\n\\n\\tRTLIL::SigSpec allbits() const\\n\\t{\\n\\t\\tRTLIL::SigSpec sig;\\n\\t\\tfor (const auto &bit : database)\\n\\t\\t\\tif (bit.wire != nullptr)\\n\\t\\t\\t\\tsig.append(bit);\\n\\t\\treturn sig;\\n\\t}\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif /* SIGTOOLS_H */\\n\",\n                \"timinginfo.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *            (C) 2020  Eddie Hung    <eddie@fpgeh.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef TIMINGINFO_H\\n#define TIMINGINFO_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct TimingInfo\\n{\\n\\tstruct NameBit\\n\\t{\\n\\t\\tRTLIL::IdString name;\\n\\t\\tint offset;\\n\\t\\tNameBit() : offset(0) {}\\n\\t\\tNameBit(const RTLIL::IdString name, int offset) : name(name), offset(offset) {}\\n\\t\\texplicit NameBit(const RTLIL::SigBit &b) : name(b.wire->name), offset(b.offset) {}\\n\\t\\tbool operator==(const NameBit& nb) const { return nb.name == name && nb.offset == offset; }\\n\\t\\tbool operator!=(const NameBit& nb) const { return !operator==(nb); }\\n\\t\\tunsigned int hash() const { return mkhash_add(name.hash(), offset); }\\n\\t};\\n\\tstruct BitBit\\n\\t{\\n\\t\\tNameBit first, second;\\n\\t\\tBitBit(const NameBit &first, const NameBit &second) : first(first), second(second) {}\\n\\t\\tBitBit(const SigBit &first, const SigBit &second) : first(first), second(second) {}\\n\\t\\tbool operator==(const BitBit& bb) const { return bb.first == first && bb.second == second; }\\n\\t\\tunsigned int hash() const { return mkhash_add(first.hash(), second.hash()); }\\n\\t};\\n\\n\\tstruct ModuleTiming\\n\\t{\\n\\t\\tdict<BitBit, int> comb;\\n\\t\\tdict<NameBit, std::pair<int,NameBit>> arrival, required;\\n\\t\\tbool has_inputs;\\n\\t};\\n\\n\\tdict<RTLIL::IdString, ModuleTiming> data;\\n\\n\\tTimingInfo()\\n\\t{\\n\\t}\\n\\n\\tTimingInfo(RTLIL::Design *design)\\n\\t{\\n\\t\\tsetup(design);\\n\\t}\\n\\n\\tvoid setup(RTLIL::Design *design)\\n\\t{\\n\\t\\tfor (auto module : design->modules()) {\\n\\t\\t\\tif (!module->get_blackbox_attribute())\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tsetup_module(module);\\n\\t\\t}\\n\\t}\\n\\n\\tconst ModuleTiming& setup_module(RTLIL::Module *module)\\n\\t{\\n\\t\\tauto r = data.insert(module->name);\\n\\t\\tlog_assert(r.second);\\n\\t\\tauto &t = r.first->second;\\n\\n\\t\\tfor (auto cell : module->cells()) {\\n\\t\\t\\tif (cell->type == ID($specify2)) {\\n\\t\\t\\t\\tauto en = cell->getPort(ID::EN);\\n\\t\\t\\t\\tif (en.is_fully_const() && !en.as_bool())\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tauto src = cell->getPort(ID::SRC);\\n\\t\\t\\t\\tauto dst = cell->getPort(ID::DST);\\n\\t\\t\\t\\tfor (const auto &c : src.chunks())\\n\\t\\t\\t\\t\\tif (!c.wire || !c.wire->port_input)\\n\\t\\t\\t\\t\\t\\tlog_error(\\\"Module '%s' contains specify cell '%s' where SRC '%s' is not a module input.\\\\n\\\", log_id(module), log_id(cell), log_signal(src));\\n\\t\\t\\t\\tfor (const auto &c : dst.chunks())\\n\\t\\t\\t\\t\\tif (!c.wire || !c.wire->port_output)\\n\\t\\t\\t\\t\\t\\tlog_error(\\\"Module '%s' contains specify cell '%s' where DST '%s' is not a module output.\\\\n\\\", log_id(module), log_id(cell), log_signal(dst));\\n\\t\\t\\t\\tint rise_max = cell->getParam(ID::T_RISE_MAX).as_int();\\n\\t\\t\\t\\tint fall_max = cell->getParam(ID::T_FALL_MAX).as_int();\\n\\t\\t\\t\\tint max = std::max(rise_max,fall_max);\\n\\t\\t\\t\\tif (max < 0)\\n\\t\\t\\t\\t\\tlog_error(\\\"Module '%s' contains specify cell '%s' with T_{RISE,FALL}_MAX < 0.\\\\n\\\", log_id(module), log_id(cell));\\n\\t\\t\\t\\tif (cell->getParam(ID::FULL).as_bool()) {\\n\\t\\t\\t\\t\\tfor (const auto &s : src)\\n\\t\\t\\t\\t\\t\\tfor (const auto &d : dst) {\\n\\t\\t\\t\\t\\t\\t\\tauto r = t.comb.insert(BitBit(s,d));\\n\\t\\t\\t\\t\\t\\t\\tif (!r.second)\\n\\t\\t\\t\\t\\t\\t\\t\\tlog_error(\\\"Module '%s' contains multiple specify cells for SRC '%s' and DST '%s'.\\\\n\\\", log_id(module), log_signal(s), log_signal(d));\\n\\t\\t\\t\\t\\t\\t\\tr.first->second = max;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tlog_assert(GetSize(src) == GetSize(dst));\\n\\t\\t\\t\\t\\tfor (auto i = 0; i < GetSize(src); i++) {\\n\\t\\t\\t\\t\\t\\tconst auto &s = src[i];\\n\\t\\t\\t\\t\\t\\tconst auto &d = dst[i];\\n\\t\\t\\t\\t\\t\\tauto r = t.comb.insert(BitBit(s,d));\\n\\t\\t\\t\\t\\t\\tif (!r.second)\\n\\t\\t\\t\\t\\t\\t\\tlog_error(\\\"Module '%s' contains multiple specify cells for SRC '%s' and DST '%s'.\\\\n\\\", log_id(module), log_signal(s), log_signal(d));\\n\\t\\t\\t\\t\\t\\tr.first->second = max;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (cell->type == ID($specify3)) {\\n\\t\\t\\t\\tauto src = cell->getPort(ID::SRC).as_bit();\\n\\t\\t\\t\\tauto dst = cell->getPort(ID::DST);\\n\\t\\t\\t\\tif (!src.wire || !src.wire->port_input)\\n\\t\\t\\t\\t\\tlog_error(\\\"Module '%s' contains specify cell '%s' where SRC '%s' is not a module input.\\\\n\\\", log_id(module), log_id(cell), log_signal(src));\\n\\t\\t\\t\\tfor (const auto &c : dst.chunks())\\n\\t\\t\\t\\t\\tif (!c.wire->port_output)\\n\\t\\t\\t\\t\\t\\tlog_error(\\\"Module '%s' contains specify cell '%s' where DST '%s' is not a module output.\\\\n\\\", log_id(module), log_id(cell), log_signal(dst));\\n\\t\\t\\t\\tint rise_max = cell->getParam(ID::T_RISE_MAX).as_int();\\n\\t\\t\\t\\tint fall_max = cell->getParam(ID::T_FALL_MAX).as_int();\\n\\t\\t\\t\\tint max = std::max(rise_max,fall_max);\\n\\t\\t\\t\\tif (max < 0) {\\n\\t\\t\\t\\t\\tlog_warning(\\\"Module '%s' contains specify cell '%s' with T_{RISE,FALL}_MAX < 0 which is currently unsupported. Clamping to 0.\\\\n\\\", log_id(module), log_id(cell));\\n\\t\\t\\t\\t\\tmax = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (const auto &d : dst) {\\n\\t\\t\\t\\t\\tauto r = t.arrival.insert(NameBit(d));\\n\\t\\t\\t\\t\\tauto &v = r.first->second;\\n\\t\\t\\t\\t\\tif (r.second || v.first < max) {\\n\\t\\t\\t\\t\\t\\tv.first = max;\\n\\t\\t\\t\\t\\t\\tv.second = NameBit(src);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (cell->type == ID($specrule)) {\\n\\t\\t\\t\\tIdString type = cell->getParam(ID::TYPE).decode_string();\\n\\t\\t\\t\\tif (type != ID($setup) && type != ID($setuphold))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tauto src = cell->getPort(ID::SRC);\\n\\t\\t\\t\\tauto dst = cell->getPort(ID::DST).as_bit();\\n\\t\\t\\t\\tfor (const auto &c : src.chunks())\\n\\t\\t\\t\\t\\tif (!c.wire || !c.wire->port_input)\\n\\t\\t\\t\\t\\t\\tlog_error(\\\"Module '%s' contains specify cell '%s' where SRC '%s' is not a module input.\\\\n\\\", log_id(module), log_id(cell), log_signal(src));\\n\\t\\t\\t\\tif (!dst.wire || !dst.wire->port_input)\\n\\t\\t\\t\\t\\tlog_error(\\\"Module '%s' contains specify cell '%s' where DST '%s' is not a module input.\\\\n\\\", log_id(module), log_id(cell), log_signal(dst));\\n\\t\\t\\t\\tint max = cell->getParam(ID::T_LIMIT_MAX).as_int();\\n\\t\\t\\t\\tif (max < 0) {\\n\\t\\t\\t\\t\\tlog_warning(\\\"Module '%s' contains specify cell '%s' with T_LIMIT_MAX < 0 which is currently unsupported. Clamping to 0.\\\\n\\\", log_id(module), log_id(cell));\\n\\t\\t\\t\\t\\tmax = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (const auto &s : src) {\\n\\t\\t\\t\\t\\tauto r = t.required.insert(NameBit(s));\\n\\t\\t\\t\\t\\tauto &v = r.first->second;\\n\\t\\t\\t\\t\\tif (r.second || v.first < max) {\\n\\t\\t\\t\\t\\t\\tv.first = max;\\n\\t\\t\\t\\t\\t\\tv.second = NameBit(dst);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (auto port_name : module->ports) {\\n\\t\\t\\tauto wire = module->wire(port_name);\\n\\t\\t\\tif (wire->port_input) {\\n\\t\\t\\t\\tt.has_inputs = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn t;\\n\\t}\\n\\n\\tdecltype(data)::const_iterator find(RTLIL::IdString module_name) const { return data.find(module_name); }\\n\\tdecltype(data)::const_iterator end() const { return data.end(); }\\n\\tint count(RTLIL::IdString module_name) const { return data.count(module_name); }\\n\\tconst ModuleTiming& at(RTLIL::IdString module_name) const { return data.at(module_name); }\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"utils.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n// This file contains various c++ utility routines and helper classes that\\n// do not depend on any other components of yosys (except stuff like log_*).\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\n#ifndef UTILS_H\\n#define UTILS_H\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\n// ------------------------------------------------\\n// A map-like container, but you can save and restore the state\\n// ------------------------------------------------\\n\\ntemplate<typename Key, typename T, typename OPS = hash_ops<Key>>\\nstruct stackmap\\n{\\nprivate:\\n\\tstd::vector<dict<Key, T*, OPS>> backup_state;\\n\\tdict<Key, T, OPS> current_state;\\n\\tstatic T empty_tuple;\\n\\npublic:\\n\\tstackmap() { }\\n\\tstackmap(const dict<Key, T, OPS> &other) : current_state(other) { }\\n\\n\\ttemplate<typename Other>\\n\\tvoid operator=(const Other &other)\\n\\t{\\n\\t\\tfor (auto &it : current_state)\\n\\t\\t\\tif (!backup_state.empty() && backup_state.back().count(it.first) == 0)\\n\\t\\t\\t\\tbackup_state.back()[it.first] = new T(it.second);\\n\\t\\tcurrent_state.clear();\\n\\n\\t\\tfor (auto &it : other)\\n\\t\\t\\tset(it.first, it.second);\\n\\t}\\n\\n\\tbool has(const Key &k)\\n\\t{\\n\\t\\treturn current_state.count(k) != 0;\\n\\t}\\n\\n\\tvoid set(const Key &k, const T &v)\\n\\t{\\n\\t\\tif (!backup_state.empty() && backup_state.back().count(k) == 0)\\n\\t\\t\\tbackup_state.back()[k] = current_state.count(k) ? new T(current_state.at(k)) : nullptr;\\n\\t\\tcurrent_state[k] = v;\\n\\t}\\n\\n\\tvoid unset(const Key &k)\\n\\t{\\n\\t\\tif (!backup_state.empty() && backup_state.back().count(k) == 0)\\n\\t\\t\\tbackup_state.back()[k] = current_state.count(k) ? new T(current_state.at(k)) : nullptr;\\n\\t\\tcurrent_state.erase(k);\\n\\t}\\n\\n\\tconst T &get(const Key &k)\\n\\t{\\n\\t\\tif (current_state.count(k) == 0)\\n\\t\\t\\treturn empty_tuple;\\n\\t\\treturn current_state.at(k);\\n\\t}\\n\\n\\tvoid reset(const Key &k)\\n\\t{\\n\\t\\tfor (int i = GetSize(backup_state)-1; i >= 0; i--)\\n\\t\\t\\tif (backup_state[i].count(k) != 0) {\\n\\t\\t\\t\\tif (backup_state[i].at(k) == nullptr)\\n\\t\\t\\t\\t\\tcurrent_state.erase(k);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcurrent_state[k] = *backup_state[i].at(k);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\tcurrent_state.erase(k);\\n\\t}\\n\\n\\tconst dict<Key, T, OPS> &stdmap()\\n\\t{\\n\\t\\treturn current_state;\\n\\t}\\n\\n\\tvoid save()\\n\\t{\\n\\t\\tbackup_state.resize(backup_state.size()+1);\\n\\t}\\n\\n\\tvoid restore()\\n\\t{\\n\\t\\tlog_assert(!backup_state.empty());\\n\\t\\tfor (auto &it : backup_state.back())\\n\\t\\t\\tif (it.second != nullptr) {\\n\\t\\t\\t\\tcurrent_state[it.first] = *it.second;\\n\\t\\t\\t\\tdelete it.second;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tcurrent_state.erase(it.first);\\n\\t\\tbackup_state.pop_back();\\n\\t}\\n\\n\\t~stackmap()\\n\\t{\\n\\t\\twhile (!backup_state.empty())\\n\\t\\t\\trestore();\\n\\t}\\n};\\n\\n\\n// ------------------------------------------------\\n// A simple class for topological sorting\\n// ------------------------------------------------\\n\\ntemplate <typename T, typename C = std::less<T>, typename OPS = hash_ops<T>> class TopoSort\\n{\\n      public:\\n\\t// We use this ordering of the edges in the adjacency matrix for\\n\\t// exact compatibility with an older implementation.\\n\\tstruct IndirectCmp {\\n                IndirectCmp(const std::vector<T> &nodes) : node_cmp_(), nodes_(nodes) {}\\n\\t\\tbool operator()(int a, int b) const\\n\\t\\t{\\n                        log_assert(static_cast<size_t>(a) < nodes_.size());\\n\\t\\t\\tlog_assert(static_cast<size_t>(b) < nodes_.size());\\n\\t\\t\\treturn node_cmp_(nodes_[a], nodes_[b]);\\n\\t\\t}\\n\\t\\tconst C node_cmp_;\\n\\t\\tconst std::vector<T> &nodes_;\\n\\t};\\n\\n\\tbool analyze_loops;\\n\\tstd::map<T, int, C> node_to_index;\\n\\tstd::vector<std::set<int, IndirectCmp>> edges;\\n\\tstd::vector<T> sorted;\\n\\tstd::set<std::vector<T>> loops;\\n\\n\\tTopoSort() : indirect_cmp(nodes)\\n\\t{\\n\\t\\tanalyze_loops = true;\\n\\t\\tfound_loops = false;\\n\\t}\\n\\n\\tint node(T n)\\n\\t{\\n                auto rv = node_to_index.emplace(n, static_cast<int>(nodes.size()));\\n                if (rv.second) {\\n      \\t              nodes.push_back(n);\\n\\t\\t      edges.push_back(std::set<int, IndirectCmp>(indirect_cmp));\\n\\t\\t}\\n\\t\\treturn rv.first->second;\\n\\t}\\n\\n\\tvoid edge(int l_index, int r_index) { edges[r_index].insert(l_index); }\\n\\n\\tvoid edge(T left, T right) { edge(node(left), node(right)); }\\n\\n\\tbool has_node(const T &node) { return node_to_index.find(node) != node_to_index.end(); }\\n\\n\\tbool sort()\\n\\t{\\n\\t\\tlog_assert(GetSize(node_to_index) == GetSize(edges));\\n\\t\\tlog_assert(GetSize(nodes) == GetSize(edges));\\n\\n\\t\\tloops.clear();\\n\\t\\tsorted.clear();\\n\\t\\tfound_loops = false;\\n\\n\\t\\tstd::vector<bool> marked_cells(edges.size(), false);\\n\\t\\tstd::vector<bool> active_cells(edges.size(), false);\\n\\t\\tstd::vector<int> active_stack;\\n\\t\\tsorted.reserve(edges.size());\\n\\n\\t\\tfor (const auto &it : node_to_index)\\n\\t\\t\\tsort_worker(it.second, marked_cells, active_cells, active_stack);\\n\\n\\t\\tlog_assert(GetSize(sorted) == GetSize(nodes));\\n\\n\\t\\treturn !found_loops;\\n\\t}\\n\\n\\t// Build the more expensive representation of edges for\\n\\t// a few passes that use it directly.\\n\\tstd::map<T, std::set<T, C>, C> get_database()\\n\\t{\\n\\t\\tstd::map<T, std::set<T, C>, C> database;\\n\\t\\tfor (size_t i = 0; i < nodes.size(); ++i) {\\n\\t\\t\\tstd::set<T, C> converted_edge_set;\\n\\t\\t\\tfor (int other_node : edges[i]) {\\n\\t\\t\\t\\tconverted_edge_set.insert(nodes[other_node]);\\n\\t\\t\\t}\\n\\t\\t\\tdatabase.emplace(nodes[i], converted_edge_set);\\n\\t\\t}\\n\\t\\treturn database;\\n\\t}\\n\\n      private:\\n\\tbool found_loops;\\n\\tstd::vector<T> nodes;\\n\\tconst IndirectCmp indirect_cmp;\\n\\n\\tvoid sort_worker(const int root_index, std::vector<bool> &marked_cells, std::vector<bool> &active_cells, std::vector<int> &active_stack)\\n\\t{\\n\\t\\tif (active_cells[root_index]) {\\n\\t\\t\\tfound_loops = true;\\n\\t\\t\\tif (analyze_loops) {\\n\\t\\t\\t\\tstd::vector<T> loop;\\n\\t\\t\\t\\tfor (int i = GetSize(active_stack) - 1; i >= 0; i--) {\\n\\t\\t\\t\\t\\tconst int index = active_stack[i];\\n\\t\\t\\t\\t\\tloop.push_back(nodes[index]);\\n\\t\\t\\t\\t\\tif (index == root_index)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tloops.insert(loop);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (marked_cells[root_index])\\n\\t\\t\\treturn;\\n\\n\\t\\tif (!edges[root_index].empty()) {\\n\\t\\t\\tif (analyze_loops)\\n\\t\\t\\t\\tactive_stack.push_back(root_index);\\n\\t\\t\\tactive_cells[root_index] = true;\\n\\n\\t\\t\\tfor (int left_n : edges[root_index])\\n\\t\\t\\t\\tsort_worker(left_n, marked_cells, active_cells, active_stack);\\n\\n\\t\\t\\tif (analyze_loops)\\n\\t\\t\\t\\tactive_stack.pop_back();\\n\\t\\t\\tactive_cells[root_index] = false;\\n\\t\\t}\\n\\n\\t\\tmarked_cells[root_index] = true;\\n\\t\\tsorted.push_back(nodes[root_index]);\\n\\t}\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"yosys.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n\\n// *** NOTE TO THE READER ***\\n//\\n// Maybe you have just opened this file in the hope to learn more about the\\n// Yosys API. Let me congratulate you on this great decision!  ;)\\n//\\n// If you want to know how the design is represented by Yosys in the memory,\\n// you should read \\\"kernel/rtlil.h\\\".\\n//\\n// If you want to know how to register a command with Yosys, you could read\\n// \\\"kernel/register.h\\\", but it would be easier to just look at a simple\\n// example instead. A simple one would be \\\"passes/cmds/log.cc\\\".\\n//\\n// This header is very boring. It just defines some general things that\\n// belong nowhere else and includes the interesting headers.\\n//\\n// Find more information in the \\\"guidelines/GettingStarted\\\" file.\\n\\n\\n#ifndef YOSYS_H\\n#define YOSYS_H\\n\\n#include \\\"kernel/yosys_common.h\\\"\\n\\n#include \\\"kernel/log.h\\\"\\n#include \\\"kernel/rtlil.h\\\"\\n#include \\\"kernel/register.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nvoid yosys_setup();\\n\\n#ifdef WITH_PYTHON\\nbool yosys_already_setup();\\n#endif\\n\\nvoid yosys_shutdown();\\n\\n#ifdef YOSYS_ENABLE_TCL\\nTcl_Interp *yosys_get_tcl_interp();\\n#endif\\n\\nextern RTLIL::Design *yosys_design;\\n\\nRTLIL::Design *yosys_get_design();\\nstd::string proc_self_dirname();\\nstd::string proc_share_dirname();\\nstd::string proc_program_prefix();\\nconst char *create_prompt(RTLIL::Design *design, int recursion_counter);\\nstd::vector<std::string> glob_filename(const std::string &filename_pattern);\\nvoid rewrite_filename(std::string &filename);\\n\\nvoid run_pass(std::string command, RTLIL::Design *design = nullptr);\\nbool run_frontend(std::string filename, std::string command, RTLIL::Design *design = nullptr, std::string *from_to_label = nullptr);\\nvoid run_backend(std::string filename, std::string command, RTLIL::Design *design = nullptr);\\nvoid shell(RTLIL::Design *design);\\n\\n// journal of all input and output files read (for \\\"yosys -E\\\")\\nextern std::set<std::string> yosys_input_files, yosys_output_files;\\n\\n// from kernel/version_*.o (cc source generated from Makefile)\\nextern const char *yosys_version_str;\\n\\n// from passes/cmds/design.cc\\nextern std::map<std::string, RTLIL::Design*> saved_designs;\\nextern std::vector<RTLIL::Design*> pushed_designs;\\n\\n// from passes/cmds/pluginc.cc\\nextern std::map<std::string, void*> loaded_plugins;\\n#ifdef WITH_PYTHON\\nextern std::map<std::string, void*> loaded_python_plugins;\\n#endif\\nextern std::map<std::string, std::string> loaded_plugin_aliases;\\nvoid load_plugin(std::string filename, std::vector<std::string> aliases);\\n\\nextern std::string yosys_share_dirname;\\nextern std::string yosys_abc_executable;\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"yosys_common.h\": \"/* -*- c++ -*-\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef YOSYS_COMMON_H\\n#define YOSYS_COMMON_H\\n\\n#include <map>\\n#include <set>\\n#include <tuple>\\n#include <vector>\\n#include <string>\\n#include <algorithm>\\n#include <functional>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <initializer_list>\\n#include <stdexcept>\\n#include <memory>\\n#include <cmath>\\n#include <cstddef>\\n\\n#include <sstream>\\n#include <fstream>\\n#include <istream>\\n#include <ostream>\\n#include <iostream>\\n\\n#include <stdarg.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <stdint.h>\\n#include <stdio.h>\\n#include <limits.h>\\n#include <sys/stat.h>\\n#include <errno.h>\\n\\n#ifdef WITH_PYTHON\\n#include <Python.h>\\n#endif\\n\\n#ifndef _YOSYS_\\n#  error It looks like you are trying to build Yosys without the config defines set. \\\\\\n         When building Yosys with a custom make system, make sure you set all the \\\\\\n         defines the Yosys Makefile would set for your build configuration.\\n#endif\\n\\n#ifdef YOSYS_ENABLE_TCL\\n#  include <tcl.h>\\n#  ifdef YOSYS_MXE_HACKS\\nextern Tcl_Command Tcl_CreateCommand(Tcl_Interp *interp, const char *cmdName, Tcl_CmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *deleteProc);\\nextern Tcl_Interp *Tcl_CreateInterp(void);\\nextern void Tcl_Preserve(ClientData data);\\nextern void Tcl_Release(ClientData clientData);\\nextern int Tcl_InterpDeleted(Tcl_Interp *interp);\\nextern void Tcl_DeleteInterp(Tcl_Interp *interp);\\nextern int Tcl_Eval(Tcl_Interp *interp, const char *script);\\nextern int Tcl_EvalFile(Tcl_Interp *interp, const char *fileName);\\nextern void Tcl_Finalize(void);\\nextern int Tcl_GetCommandInfo(Tcl_Interp *interp, const char *cmdName, Tcl_CmdInfo *infoPtr);\\nextern const char *Tcl_GetStringResult(Tcl_Interp *interp);\\nextern Tcl_Obj *Tcl_NewStringObj(const char *bytes, int length);\\nextern Tcl_Obj *Tcl_NewIntObj(int intValue);\\nextern Tcl_Obj *Tcl_NewListObj(int objc, Tcl_Obj *const objv[]);\\nextern Tcl_Obj *Tcl_ObjSetVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr, int flags);\\n#  endif\\n#  undef CONST\\n#  undef INLINE\\n#endif\\n\\n#ifdef _WIN32\\n#  undef NOMINMAX\\n#  define NOMINMAX 1\\n#  undef YY_NO_UNISTD_H\\n#  define YY_NO_UNISTD_H 1\\n\\n#  include <windows.h>\\n#  include <io.h>\\n#  include <direct.h>\\n\\n#  define strtok_r strtok_s\\n#  define strdup _strdup\\n#  define snprintf _snprintf\\n#  define getcwd _getcwd\\n#  define mkdir _mkdir\\n#  define popen _popen\\n#  define pclose _pclose\\n\\n#  ifndef __MINGW32__\\n#    define PATH_MAX MAX_PATH\\n#    define isatty _isatty\\n#    define fileno _fileno\\n#  endif\\n\\n// The following defines conflict with our identifiers:\\n#  undef CONST\\n// `wingdi.h` defines a TRANSPARENT macro that conflicts with X(TRANSPARENT) entry in kernel/constids.inc\\n#  undef TRANSPARENT\\n#endif\\n\\n#ifndef PATH_MAX\\n#  define PATH_MAX 4096\\n#endif\\n\\n\\n#define YOSYS_NAMESPACE          Yosys\\n#define PRIVATE_NAMESPACE_BEGIN  namespace {\\n#define PRIVATE_NAMESPACE_END    }\\n#define YOSYS_NAMESPACE_BEGIN    namespace Yosys {\\n#define YOSYS_NAMESPACE_END      }\\n#define YOSYS_NAMESPACE_PREFIX   Yosys::\\n#define USING_YOSYS_NAMESPACE    using namespace Yosys;\\n\\n#if defined(__GNUC__) || defined(__clang__)\\n#  define YS_ATTRIBUTE(...) __attribute__((__VA_ARGS__))\\n#elif defined(_MSC_VER)\\n#  define YS_ATTRIBUTE(...)\\n#else\\n#  define YS_ATTRIBUTE(...)\\n#endif\\n\\n#if defined(__GNUC__) || defined(__clang__)\\n#  define YS_MAYBE_UNUSED __attribute__((__unused__))\\n#else\\n#  define YS_MAYBE_UNUSED\\n#endif\\n\\n#if __cplusplus >= 201703L\\n#  define YS_FALLTHROUGH [[fallthrough]];\\n#elif defined(__clang__)\\n#  define YS_FALLTHROUGH [[clang::fallthrough]];\\n#elif defined(__GNUC__)\\n#  define YS_FALLTHROUGH [[gnu::fallthrough]];\\n#else\\n#  define YS_FALLTHROUGH\\n#endif\\n\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\n// Note: All headers included in hashlib.h must be included\\n// outside of YOSYS_NAMESPACE before this or bad things will happen.\\n#ifdef HASHLIB_H\\n#  undef HASHLIB_H\\n#  include \\\"kernel/hashlib.h\\\"\\n#else\\n#  include \\\"kernel/hashlib.h\\\"\\n#  undef HASHLIB_H\\n#endif\\n\\n\\nusing std::vector;\\nusing std::string;\\nusing std::tuple;\\nusing std::pair;\\n\\nusing std::make_tuple;\\nusing std::make_pair;\\nusing std::get;\\nusing std::min;\\nusing std::max;\\n\\n// A primitive shared string implementation that does not\\n// move its .c_str() when the object is copied or moved.\\nstruct shared_str {\\n\\tstd::shared_ptr<string> content;\\n\\tshared_str() { }\\n\\tshared_str(string s) { content = std::shared_ptr<string>(new string(s)); }\\n\\tshared_str(const char *s) { content = std::shared_ptr<string>(new string(s)); }\\n\\tconst char *c_str() const { return content->c_str(); }\\n\\tconst string &str() const { return *content; }\\n\\tbool operator==(const shared_str &other) const { return *content == *other.content; }\\n\\tunsigned int hash() const { return hashlib::hash_ops<std::string>::hash(*content); }\\n};\\n\\nusing hashlib::mkhash;\\nusing hashlib::mkhash_init;\\nusing hashlib::mkhash_add;\\nusing hashlib::mkhash_xorshift;\\nusing hashlib::hash_ops;\\nusing hashlib::hash_cstr_ops;\\nusing hashlib::hash_ptr_ops;\\nusing hashlib::hash_obj_ops;\\nusing hashlib::dict;\\nusing hashlib::idict;\\nusing hashlib::pool;\\nusing hashlib::mfp;\\n\\nnamespace RTLIL {\\n\\tstruct IdString;\\n\\tstruct Const;\\n\\tstruct SigBit;\\n\\tstruct SigSpec;\\n\\tstruct Wire;\\n\\tstruct Cell;\\n\\tstruct Memory;\\n\\tstruct Process;\\n\\tstruct Module;\\n\\tstruct Design;\\n\\tstruct Monitor;\\n    struct Selection;\\n\\tstruct SigChunk;\\n\\tenum State : unsigned char;\\n\\n\\ttypedef std::pair<SigSpec, SigSpec> SigSig;\\n\\n    namespace ID {}\\n}\\n\\nnamespace AST {\\n\\tstruct AstNode;\\n}\\n\\nusing RTLIL::IdString;\\nusing RTLIL::Const;\\nusing RTLIL::SigBit;\\nusing RTLIL::SigSpec;\\nusing RTLIL::Wire;\\nusing RTLIL::Cell;\\nusing RTLIL::Module;\\nusing RTLIL::Design;\\n\\nusing RTLIL::State;\\nusing RTLIL::SigChunk;\\nusing RTLIL::SigSig;\\n\\nnamespace hashlib {\\n\\ttemplate<> struct hash_ops<RTLIL::Wire*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<RTLIL::Cell*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<RTLIL::Memory*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<RTLIL::Process*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<RTLIL::Module*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<RTLIL::Design*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<RTLIL::Monitor*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<AST::AstNode*> : hash_obj_ops {};\\n\\n\\ttemplate<> struct hash_ops<const RTLIL::Wire*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<const RTLIL::Cell*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<const RTLIL::Memory*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<const RTLIL::Process*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<const RTLIL::Module*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<const RTLIL::Design*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<const RTLIL::Monitor*> : hash_obj_ops {};\\n\\ttemplate<> struct hash_ops<const AST::AstNode*> : hash_obj_ops {};\\n}\\n\\nvoid memhasher_on();\\nvoid memhasher_off();\\nvoid memhasher_do();\\n\\nextern bool memhasher_active;\\ninline void memhasher() { if (memhasher_active) memhasher_do(); }\\n\\nvoid yosys_banner();\\nint ceil_log2(int x) YS_ATTRIBUTE(const);\\n\\ninline std::string vstringf(const char *fmt, va_list ap)\\n{\\n        // For the common case of strings shorter than 128, save a heap\\n        // allocation by using a stack allocated buffer.\\n        const int kBufSize = 128;\\n        char buf[kBufSize];\\n        buf[0] = '\\\\0';\\n        va_list apc;\\n        va_copy(apc, ap);\\n        int n = vsnprintf(buf, kBufSize, fmt, apc);\\n        va_end(apc);\\n        if (n < kBufSize)\\n          return std::string(buf);\\n\\n        std::string string;\\n        char *str = NULL;\\n#if defined(_WIN32 )|| defined(__CYGWIN__)\\n        int sz = 2 * kBufSize, rc;\\n        while (1) {\\n\\t\\tva_copy(apc, ap);\\n\\t\\tstr = (char*)realloc(str, sz);\\n\\t\\trc = vsnprintf(str, sz, fmt, apc);\\n\\t\\tva_end(apc);\\n\\t\\tif (rc >= 0 && rc < sz)\\n\\t\\t\\tbreak;\\n\\t\\tsz *= 2;\\n\\t}\\n\\tif (str != NULL) {\\n\\t\\tstring = str;\\n\\t\\tfree(str);\\n\\t}\\n\\treturn string;\\n#else\\n        if (vasprintf(&str, fmt, ap) < 0)\\n          str = NULL;\\n        if (str != NULL) {\\n          string = str;\\n          free(str);\\n        }\\n\\treturn string;\\n#endif\\n}\\n\\nstd::string stringf(const char *fmt, ...) YS_ATTRIBUTE(format(printf, 1, 2));\\n\\ninline std::string stringf(const char *fmt, ...)\\n{\\n\\tstd::string string;\\n\\tva_list ap;\\n\\n\\tva_start(ap, fmt);\\n\\tstring = vstringf(fmt, ap);\\n\\tva_end(ap);\\n\\n\\treturn string;\\n}\\n\\nint readsome(std::istream &f, char *s, int n);\\nstd::string next_token(std::string &text, const char *sep = \\\" \\\\t\\\\r\\\\n\\\", bool long_strings = false);\\nstd::vector<std::string> split_tokens(const std::string &text, const char *sep = \\\" \\\\t\\\\r\\\\n\\\");\\nbool patmatch(const char *pattern, const char *string);\\n#if !defined(YOSYS_DISABLE_SPAWN)\\nint run_command(const std::string &command, std::function<void(const std::string&)> process_line = std::function<void(const std::string&)>());\\n#endif\\nstd::string get_base_tmpdir();\\nstd::string make_temp_file(std::string template_str = get_base_tmpdir() + \\\"/yosys_XXXXXX\\\");\\nstd::string make_temp_dir(std::string template_str = get_base_tmpdir() + \\\"/yosys_XXXXXX\\\");\\nbool check_file_exists(std::string filename, bool is_exec = false);\\nbool check_directory_exists(const std::string& dirname);\\nbool is_absolute_path(std::string filename);\\nvoid remove_directory(std::string dirname);\\nbool create_directory(const std::string& dirname);\\nstd::string escape_filename_spaces(const std::string& filename);\\n\\ntemplate<typename T> int GetSize(const T &obj) { return obj.size(); }\\ninline int GetSize(RTLIL::Wire *wire);\\n\\nextern int autoidx;\\nextern int yosys_xtrace;\\n\\nRTLIL::IdString new_id(std::string file, int line, std::string func);\\nRTLIL::IdString new_id_suffix(std::string file, int line, std::string func, std::string suffix);\\n\\n#define NEW_ID \\\\\\n\\tYOSYS_NAMESPACE_PREFIX new_id(__FILE__, __LINE__, __FUNCTION__)\\n#define NEW_ID_SUFFIX(suffix) \\\\\\n\\tYOSYS_NAMESPACE_PREFIX new_id_suffix(__FILE__, __LINE__, __FUNCTION__, suffix)\\n\\n// Create a statically allocated IdString object, using for example ID::A or ID($add).\\n//\\n// Recipe for Converting old code that is using conversion of strings like ID::A and\\n// \\\"$add\\\" for creating IdStrings: Run below SED command on the .cc file and then use for\\n// example \\\"meld foo.cc foo.cc.orig\\\" to manually compile errors, if necessary.\\n//\\n//  sed -i.orig -r 's/\\\"\\\\\\\\\\\\\\\\([a-zA-Z0-9_]+)\\\"/ID(\\\\1)/g; s/\\\"(\\\\$[a-zA-Z0-9_]+)\\\"/ID(\\\\1)/g;' <filename>\\n//\\n#define ID(_id) ([]() { const char *p = \\\"\\\\\\\\\\\" #_id, *q = p[1] == '$' ? p+1 : p; \\\\\\n        static const YOSYS_NAMESPACE_PREFIX RTLIL::IdString id(q); return id; })()\\nnamespace ID = RTLIL::ID;\\n\\nnamespace hashlib {\\n\\ttemplate<> struct hash_ops<RTLIL::State> : hash_ops<int> {};\\n}\\n\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                \"yw.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2022  Jannis Harder <jix@yosyshq.com> <me@jix.one>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef YW_H\\n#define YW_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n#include \\\"kernel/mem.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct IdPath : public std::vector<RTLIL::IdString>\\n{\\n\\ttemplate<typename... T>\\n\\tIdPath(T&&... args) : std::vector<RTLIL::IdString>(std::forward<T>(args)...) { }\\n\\tIdPath prefix() const { return {begin(), end() - !empty()}; }\\n\\tstd::string str() const;\\n\\n\\tbool has_address() const { int tmp; return get_address(tmp); };\\n\\tbool get_address(int &addr) const;\\n\\n\\tint hash() const { return hashlib::hash_ops<std::vector<RTLIL::IdString>>::hash(*this); }\\n};\\n\\nstruct WitnessHierarchyItem {\\n\\tRTLIL::Module *module;\\n\\tRTLIL::Wire *wire = nullptr;\\n\\tRTLIL::Cell *cell = nullptr;\\n\\tMem *mem = nullptr;\\n\\n\\tWitnessHierarchyItem(RTLIL::Module *module, RTLIL::Wire *wire) : module(module), wire(wire) {}\\n\\tWitnessHierarchyItem(RTLIL::Module *module, RTLIL::Cell *cell) : module(module), cell(cell) {}\\n\\tWitnessHierarchyItem(RTLIL::Module *module, Mem *mem) : module(module), mem(mem) {}\\n};\\n\\ntemplate<typename D, typename T>\\nvoid witness_hierarchy(RTLIL::Module *module, D data, T callback);\\n\\ntemplate<class T> static std::vector<std::string> witness_path(T *obj) {\\n\\tstd::vector<std::string> path;\\n\\tif (obj->name.isPublic()) {\\n\\t\\tauto hdlname = obj->get_string_attribute(ID::hdlname);\\n\\t\\tfor (auto token : split_tokens(hdlname))\\n\\t\\t\\tpath.push_back(\\\"\\\\\\\\\\\" + token);\\n\\t}\\n\\tif (path.empty())\\n\\t\\tpath.push_back(obj->name.str());\\n\\treturn path;\\n}\\n\\nstruct ReadWitness\\n{\\n\\tstruct Clock {\\n\\t\\tIdPath path;\\n\\t\\tint offset;\\n\\t\\tbool is_posedge = false;\\n\\t\\tbool is_negedge = false;\\n\\t};\\n\\n\\tstruct Signal {\\n\\t\\tIdPath path;\\n\\t\\tint offset;\\n\\t\\tint width;\\n\\t\\tbool init_only;\\n\\n\\t\\tint bits_offset;\\n\\t};\\n\\n\\tstruct Step {\\n\\t\\tstd::string bits;\\n\\t};\\n\\n\\tstd::string filename;\\n\\tstd::vector<Clock> clocks;\\n\\tstd::vector<Signal> signals;\\n\\tstd::vector<Step> steps;\\n\\n\\tReadWitness(const std::string &filename);\\n\\n\\tRTLIL::Const get_bits(int t, int bits_offset, int width) const;\\n};\\n\\ntemplate<typename D, typename T>\\nvoid witness_hierarchy_recursion(IdPath &path, int hdlname_mode, RTLIL::Module *module, D data, T &callback)\\n{\\n\\tauto const &const_path = path;\\n\\tsize_t path_size = path.size();\\n\\tfor (auto wire : module->wires())\\n\\t{\\n\\t\\tauto hdlname = hdlname_mode < 0 ? std::vector<std::string>() : wire->get_hdlname_attribute();\\n\\t\\tfor (auto item : hdlname)\\n\\t\\t\\tpath.push_back(\\\"\\\\\\\\\\\" + item);\\n\\t\\tif (hdlname.size() == 1 && path.back() == wire->name)\\n\\t\\t\\thdlname.clear();\\n\\t\\tif (!hdlname.empty())\\n\\t\\t\\tcallback(const_path, WitnessHierarchyItem(module, wire), data);\\n\\t\\tpath.resize(path_size);\\n\\t\\tif (hdlname.empty() || hdlname_mode <= 0) {\\n\\t\\t\\tpath.push_back(wire->name);\\n\\t\\t\\tcallback(const_path, WitnessHierarchyItem(module, wire), data);\\n\\t\\t\\tpath.pop_back();\\n\\t\\t}\\n\\t}\\n\\n\\tfor (auto cell : module->cells())\\n\\t{\\n\\t\\tModule *child = module->design->module(cell->type);\\n\\t\\tif (child == nullptr)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tauto hdlname = hdlname_mode < 0 ? std::vector<std::string>() : cell->get_hdlname_attribute();\\n\\t\\tfor (auto item : hdlname)\\n\\t\\t\\tpath.push_back(\\\"\\\\\\\\\\\" + item);\\n\\t\\tif (hdlname.size() == 1 && path.back() == cell->name)\\n\\t\\t\\thdlname.clear();\\n\\t\\tif (!hdlname.empty()) {\\n\\t\\t\\tD child_data = callback(const_path, WitnessHierarchyItem(module, cell), data);\\n\\t\\t\\twitness_hierarchy_recursion<D, T>(path, 1, child, child_data, callback);\\n\\t\\t}\\n\\t\\tpath.resize(path_size);\\n\\t\\tif (hdlname.empty() || hdlname_mode <= 0) {\\n\\t\\t\\tpath.push_back(cell->name);\\n\\t\\t\\tD child_data = callback(const_path, WitnessHierarchyItem(module, cell), data);\\n\\t\\t\\twitness_hierarchy_recursion<D, T>(path, hdlname.empty() ? hdlname_mode : -1, child, child_data, callback);\\n\\t\\t\\tpath.pop_back();\\n\\t\\t}\\n\\t}\\n\\n\\tfor (auto mem : Mem::get_all_memories(module)) {\\n\\t\\tstd::vector<std::string> hdlname;\\n\\n\\t\\tif (hdlname_mode >= 0 && mem.cell != nullptr)\\n\\t\\t\\thdlname = mem.cell->get_hdlname_attribute();\\n\\t\\tfor (auto item : hdlname)\\n\\t\\t\\tpath.push_back(\\\"\\\\\\\\\\\" + item);\\n\\t\\tif (hdlname.size() == 1 && path.back() == mem.cell->name)\\n\\t\\t\\thdlname.clear();\\n\\t\\tif (!hdlname.empty()) {\\n\\t\\t\\tcallback(const_path, WitnessHierarchyItem(module, &mem), data);\\n\\t\\t}\\n\\t\\tpath.resize(path_size);\\n\\n\\t\\tif (hdlname.empty() || hdlname_mode <= 0) {\\n\\t\\t\\tpath.push_back(mem.memid);\\n\\t\\t\\tcallback(const_path, WitnessHierarchyItem(module, &mem), data);\\n\\t\\t\\tpath.pop_back();\\n\\n\\t\\t\\tif (mem.cell != nullptr && mem.cell->name != mem.memid) {\\n\\t\\t\\t\\tpath.push_back(mem.cell->name);\\n\\t\\t\\t\\tcallback(const_path, WitnessHierarchyItem(module, &mem), data);\\n\\t\\t\\t\\tpath.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\ntemplate<typename D, typename T>\\nvoid witness_hierarchy(RTLIL::Module *module, D data, T callback)\\n{\\n\\tIdPath path;\\n\\twitness_hierarchy_recursion<D, T>(path, 0, module, data, callback);\\n}\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n            },\n            \"libs\": {\n                \"ezsat\": {\n                    \"ezminisat.h\": \"/*\\n *  ezSAT -- A simple and easy to use CNF generator for SAT solvers\\n *\\n *  Copyright (C) 2013  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef EZMINISAT_H\\n#define EZMINISAT_H\\n\\n#define EZMINISAT_SIMPSOLVER 1\\n#define EZMINISAT_VERBOSITY 0\\n#define EZMINISAT_INCREMENTAL 1\\n\\n#include \\\"ezsat.h\\\"\\n#include <time.h>\\n\\n// minisat is using limit macros and format macros in their headers that\\n// can be the source of some troubles when used from c++11. therefore we\\n// don't force ezSAT users to use minisat headers..\\nnamespace Minisat {\\n\\tclass Solver;\\n\\tclass SimpSolver;\\n}\\n\\nclass ezMiniSAT : public ezSAT\\n{\\nprivate:\\n#if EZMINISAT_SIMPSOLVER\\n\\ttypedef Minisat::SimpSolver Solver;\\n#else\\n\\ttypedef Minisat::Solver Solver;\\n#endif\\n\\tSolver *minisatSolver;\\n\\tstd::vector<int> minisatVars;\\n\\tbool foundContradiction;\\n\\n#if EZMINISAT_SIMPSOLVER && EZMINISAT_INCREMENTAL\\n\\tstd::set<int> cnfFrozenVars;\\n#endif\\n\\n#ifndef _WIN32\\n\\tstatic ezMiniSAT *alarmHandlerThis;\\n\\tstatic clock_t alarmHandlerTimeout;\\n\\tstatic void alarmHandler(int);\\n#endif\\n\\npublic:\\n\\tezMiniSAT();\\n\\tvirtual ~ezMiniSAT();\\n\\tvirtual void clear();\\n#if EZMINISAT_SIMPSOLVER && EZMINISAT_INCREMENTAL\\n\\tvirtual void freeze(int id);\\n\\tvirtual bool eliminated(int idx);\\n#endif\\n\\tvirtual bool solver(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std::vector<int> &assumptions);\\n};\\n\\n#endif\\n\",\n                    \"ezsat.h\": \"/*\\n *  ezSAT -- A simple and easy to use CNF generator for SAT solvers\\n *\\n *  Copyright (C) 2013  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef EZSAT_H\\n#define EZSAT_H\\n\\n#include <set>\\n#include <map>\\n#include <vector>\\n#include <string>\\n#include <stdio.h>\\n#include <stdint.h>\\n\\nclass ezSAT\\n{\\n\\t// each token (terminal or non-terminal) is represented by an integer number\\n\\t//\\n\\t// the zero token:\\n\\t// the number zero is not used as valid token number and is used to encode\\n\\t// unused parameters for the functions.\\n\\t//\\n\\t// positive numbers are literals, with 1 = CONST_TRUE and 2 = CONST_FALSE;\\n\\t//\\n\\t// negative numbers are non-literal expressions. each expression is represented\\n\\t// by an operator id and a list of expressions (literals or non-literals).\\n\\npublic:\\n\\tenum OpId {\\n\\t\\tOpNot, OpAnd, OpOr, OpXor, OpIFF, OpITE\\n\\t};\\n\\n\\tstatic const int CONST_TRUE;\\n\\tstatic const int CONST_FALSE;\\n\\nprivate:\\n\\tbool flag_keep_cnf;\\n\\tbool flag_non_incremental;\\n\\n\\tbool non_incremental_solve_used_up;\\n\\n\\tstd::map<std::string, int> literalsCache;\\n\\tstd::vector<std::string> literals;\\n\\n\\tstd::map<std::pair<OpId, std::vector<int>>, int> expressionsCache;\\n\\tstd::vector<std::pair<OpId, std::vector<int>>> expressions;\\n\\n\\tbool cnfConsumed;\\n\\tint cnfVariableCount, cnfClausesCount;\\n\\tstd::vector<int> cnfLiteralVariables, cnfExpressionVariables;\\n\\tstd::vector<std::vector<int>> cnfClauses, cnfClausesBackup;\\n\\n\\tvoid add_clause(const std::vector<int> &args);\\n\\tvoid add_clause(const std::vector<int> &args, bool argsPolarity, int a = 0, int b = 0, int c = 0);\\n\\tvoid add_clause(int a, int b = 0, int c = 0);\\n\\n\\tint bind_cnf_not(const std::vector<int> &args);\\n\\tint bind_cnf_and(const std::vector<int> &args);\\n\\tint bind_cnf_or(const std::vector<int> &args);\\n\\nprotected:\\n\\tvoid preSolverCallback();\\n\\npublic:\\n\\tint solverTimeout;\\n\\tbool solverTimoutStatus;\\n\\n\\tezSAT();\\n\\tvirtual ~ezSAT();\\n\\n\\tunsigned int statehash;\\n\\tvoid addhash(unsigned int);\\n\\n\\tvoid keep_cnf() { flag_keep_cnf = true; }\\n\\tvoid non_incremental() { flag_non_incremental = true; }\\n\\n\\tbool mode_keep_cnf() const { return flag_keep_cnf; }\\n\\tbool mode_non_incremental() const { return flag_non_incremental; }\\n\\n\\t// manage expressions\\n\\n\\tint value(bool val);\\n\\tint literal();\\n\\tint literal(const std::string &name);\\n\\tint frozen_literal();\\n\\tint frozen_literal(const std::string &name);\\n\\tint expression(OpId op, int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0);\\n\\tint expression(OpId op, const std::vector<int> &args);\\n\\n\\tvoid lookup_literal(int id, std::string &name) const;\\n\\tconst std::string &lookup_literal(int id) const;\\n\\n\\tvoid lookup_expression(int id, OpId &op, std::vector<int> &args) const;\\n\\tconst std::vector<int> &lookup_expression(int id, OpId &op) const;\\n\\n\\tint parse_string(const std::string &text);\\n\\tstd::string to_string(int id) const;\\n\\n\\tint numLiterals() const { return literals.size(); }\\n\\tint numExpressions() const { return expressions.size(); }\\n\\n\\tint eval(int id, const std::vector<int> &values) const;\\n\\n\\t// SAT solver interface\\n\\t// If you are planning on using the solver API (and not simply create a CNF) you must use a child class\\n\\t// of ezSAT that actually implements a solver backend, such as ezMiniSAT (see ezminisat.h).\\n\\n\\tvirtual bool solver(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std::vector<int> &assumptions);\\n\\n\\tbool solve(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std::vector<int> &assumptions) {\\n\\t\\treturn solver(modelExpressions, modelValues, assumptions);\\n\\t}\\n\\n\\tbool solve(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0) {\\n\\t\\tstd::vector<int> assumptions;\\n\\t\\tif (a != 0) assumptions.push_back(a);\\n\\t\\tif (b != 0) assumptions.push_back(b);\\n\\t\\tif (c != 0) assumptions.push_back(c);\\n\\t\\tif (d != 0) assumptions.push_back(d);\\n\\t\\tif (e != 0) assumptions.push_back(e);\\n\\t\\tif (f != 0) assumptions.push_back(f);\\n\\t\\treturn solver(modelExpressions, modelValues, assumptions);\\n\\t}\\n\\n\\tbool solve(int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0) {\\n\\t\\tstd::vector<int> assumptions, modelExpressions;\\n\\t\\tstd::vector<bool> modelValues;\\n\\t\\tif (a != 0) assumptions.push_back(a);\\n\\t\\tif (b != 0) assumptions.push_back(b);\\n\\t\\tif (c != 0) assumptions.push_back(c);\\n\\t\\tif (d != 0) assumptions.push_back(d);\\n\\t\\tif (e != 0) assumptions.push_back(e);\\n\\t\\tif (f != 0) assumptions.push_back(f);\\n\\t\\treturn solver(modelExpressions, modelValues, assumptions);\\n\\t}\\n\\n\\tvoid setSolverTimeout(int newTimeoutSeconds) {\\n\\t\\tsolverTimeout = newTimeoutSeconds;\\n\\t}\\n\\n\\tbool getSolverTimoutStatus() {\\n\\t\\treturn solverTimoutStatus;\\n\\t}\\n\\n\\t// manage CNF (usually only accessed by SAT solvers)\\n\\n\\tvirtual void clear();\\n\\tvirtual void freeze(int id);\\n\\tvirtual bool eliminated(int idx);\\n\\tvoid assume(int id);\\n\\tvoid assume(int id, int context_id) { assume(OR(id, NOT(context_id))); }\\n\\tint bind(int id, bool auto_freeze = true);\\n\\tint bound(int id) const;\\n\\n\\tint numCnfVariables() const { return cnfVariableCount; }\\n\\tint numCnfClauses() const { return cnfClausesCount; }\\n\\tconst std::vector<std::vector<int>> &cnf() const { return cnfClauses; }\\n\\n\\tvoid consumeCnf();\\n\\tvoid consumeCnf(std::vector<std::vector<int>> &cnf);\\n\\n\\t// use this function to get the full CNF in keep_cnf mode\\n\\tvoid getFullCnf(std::vector<std::vector<int>> &full_cnf) const;\\n\\n\\tstd::string cnfLiteralInfo(int idx) const;\\n\\n\\t// simple helpers for build expressions easily\\n\\n\\tstruct _V {\\n\\t\\tint id;\\n\\t\\tstd::string name;\\n\\t\\t_V(int id) : id(id) { }\\n\\t\\t_V(const char *name) : id(0), name(name) { }\\n\\t\\t_V(const std::string &name) : id(0), name(name) { }\\n\\t\\tint get(ezSAT *that) {\\n\\t\\t\\tif (name.empty())\\n\\t\\t\\t\\treturn id;\\n\\t\\t\\treturn that->frozen_literal(name);\\n\\t\\t}\\n\\t};\\n\\n\\tint VAR(_V a) {\\n\\t\\treturn a.get(this);\\n\\t}\\n\\n\\tint NOT(_V a) {\\n\\t\\treturn expression(OpNot, a.get(this));\\n\\t}\\n\\n\\tint AND(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {\\n\\t\\treturn expression(OpAnd, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));\\n\\t}\\n\\n\\tint OR(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {\\n\\t\\treturn expression(OpOr, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));\\n\\t}\\n\\n\\tint XOR(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {\\n\\t\\treturn expression(OpXor, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));\\n\\t}\\n\\n\\tint IFF(_V a, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {\\n\\t\\treturn expression(OpIFF, a.get(this), b.get(this), c.get(this), d.get(this), e.get(this), f.get(this));\\n\\t}\\n\\n\\tint ITE(_V a, _V b, _V c) {\\n\\t\\treturn expression(OpITE, a.get(this), b.get(this), c.get(this));\\n\\t}\\n\\n\\tvoid SET(_V a, _V b) {\\n\\t\\tassume(IFF(a.get(this), b.get(this)));\\n\\t}\\n\\n\\t// simple helpers for building expressions with bit vectors\\n\\n\\tstd::vector<int> vec_const(const std::vector<bool> &bits);\\n\\tstd::vector<int> vec_const_signed(int64_t value, int numBits);\\n\\tstd::vector<int> vec_const_unsigned(uint64_t value, int numBits);\\n\\tstd::vector<int> vec_var(int numBits);\\n\\tstd::vector<int> vec_var(std::string name, int numBits);\\n\\tstd::vector<int> vec_cast(const std::vector<int> &vec1, int toBits, bool signExtend = false);\\n\\n\\tstd::vector<int> vec_not(const std::vector<int> &vec1);\\n\\tstd::vector<int> vec_and(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tstd::vector<int> vec_or(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tstd::vector<int> vec_xor(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\n\\tstd::vector<int> vec_iff(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tstd::vector<int> vec_ite(const std::vector<int> &vec1, const std::vector<int> &vec2, const std::vector<int> &vec3);\\n\\tstd::vector<int> vec_ite(int sel, const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\n\\tstd::vector<int> vec_count(const std::vector<int> &vec, int numBits, bool clip = true);\\n\\tstd::vector<int> vec_add(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tstd::vector<int> vec_sub(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tstd::vector<int> vec_neg(const std::vector<int> &vec);\\n\\n\\tvoid vec_cmp(const std::vector<int> &vec1, const std::vector<int> &vec2, int &carry, int &overflow, int &sign, int &zero);\\n\\n\\tint vec_lt_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tint vec_le_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tint vec_ge_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tint vec_gt_signed(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\n\\tint vec_lt_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tint vec_le_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tint vec_ge_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tint vec_gt_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\n\\tint vec_eq(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tint vec_ne(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\n\\tstd::vector<int> vec_shl(const std::vector<int> &vec1, int shift, bool signExtend = false);\\n\\tstd::vector<int> vec_srl(const std::vector<int> &vec1, int shift);\\n\\n\\tstd::vector<int> vec_shr(const std::vector<int> &vec1, int shift, bool signExtend = false) { return vec_shl(vec1, -shift, signExtend); }\\n\\tstd::vector<int> vec_srr(const std::vector<int> &vec1, int shift) { return vec_srl(vec1, -shift); }\\n\\n\\tstd::vector<int> vec_shift(const std::vector<int> &vec1, int shift, int extend_left, int extend_right);\\n\\tstd::vector<int> vec_shift_right(const std::vector<int> &vec1, const std::vector<int> &vec2, bool vec2_signed, int extend_left, int extend_right);\\n\\tstd::vector<int> vec_shift_left(const std::vector<int> &vec1, const std::vector<int> &vec2, bool vec2_signed, int extend_left, int extend_right);\\n\\n\\tvoid vec_append(std::vector<int> &vec, const std::vector<int> &vec1) const;\\n\\tvoid vec_append_signed(std::vector<int> &vec, const std::vector<int> &vec1, int64_t value);\\n\\tvoid vec_append_unsigned(std::vector<int> &vec, const std::vector<int> &vec1, uint64_t value);\\n\\n\\tint64_t vec_model_get_signed(const std::vector<int> &modelExpressions, const std::vector<bool> &modelValues, const std::vector<int> &vec1) const;\\n\\tuint64_t vec_model_get_unsigned(const std::vector<int> &modelExpressions, const std::vector<bool> &modelValues, const std::vector<int> &vec1) const;\\n\\n\\tint vec_reduce_and(const std::vector<int> &vec1);\\n\\tint vec_reduce_or(const std::vector<int> &vec1);\\n\\n\\tvoid vec_set(const std::vector<int> &vec1, const std::vector<int> &vec2);\\n\\tvoid vec_set_signed(const std::vector<int> &vec1, int64_t value);\\n\\tvoid vec_set_unsigned(const std::vector<int> &vec1, uint64_t value);\\n\\n\\t// helpers for generating ezSATbit and ezSATvec objects\\n\\n\\tstruct ezSATbit bit(_V a);\\n\\tstruct ezSATvec vec(const std::vector<int> &vec);\\n\\n\\t// printing CNF and internal state\\n\\n\\tvoid printDIMACS(FILE *f, bool verbose = false) const;\\n\\tvoid printInternalState(FILE *f) const;\\n\\n\\t// more sophisticated constraints (designed to be used directly with assume(..))\\n\\n\\tint onehot(const std::vector<int> &vec, bool max_only = false);\\n\\tint manyhot(const std::vector<int> &vec, int min_hot, int max_hot = -1);\\n\\tint ordered(const std::vector<int> &vec1, const std::vector<int> &vec2, bool allow_equal = true);\\n};\\n\\n// helper classes for using operator overloading when generating complex expressions\\n\\nstruct ezSATbit\\n{\\n\\tezSAT &sat;\\n\\tint id;\\n\\n\\tezSATbit(ezSAT &sat, ezSAT::_V a) : sat(sat), id(sat.VAR(a)) { }\\n\\n\\tezSATbit operator ~() { return ezSATbit(sat, sat.NOT(id)); }\\n\\tezSATbit operator &(const ezSATbit &other) { return ezSATbit(sat, sat.AND(id, other.id)); }\\n\\tezSATbit operator |(const ezSATbit &other) { return ezSATbit(sat, sat.OR(id, other.id)); }\\n\\tezSATbit operator ^(const ezSATbit &other) { return ezSATbit(sat, sat.XOR(id, other.id)); }\\n\\tezSATbit operator ==(const ezSATbit &other) { return ezSATbit(sat, sat.IFF(id, other.id)); }\\n\\tezSATbit operator !=(const ezSATbit &other) { return ezSATbit(sat, sat.NOT(sat.IFF(id, other.id))); }\\n\\n\\toperator int() const { return id; }\\n\\toperator ezSAT::_V() const { return ezSAT::_V(id); }\\n\\toperator std::vector<int>() const { return std::vector<int>(1, id); }\\n};\\n\\nstruct ezSATvec\\n{\\n\\tezSAT &sat;\\n\\tstd::vector<int> vec;\\n\\n\\tezSATvec(ezSAT &sat, const std::vector<int> &vec) : sat(sat), vec(vec) { }\\n\\n\\tezSATvec operator ~() { return ezSATvec(sat, sat.vec_not(vec)); }\\n\\tezSATvec operator -() { return ezSATvec(sat, sat.vec_neg(vec)); }\\n\\n\\tezSATvec operator &(const ezSATvec &other) { return ezSATvec(sat, sat.vec_and(vec, other.vec)); }\\n\\tezSATvec operator |(const ezSATvec &other) { return ezSATvec(sat, sat.vec_or(vec, other.vec)); }\\n\\tezSATvec operator ^(const ezSATvec &other) { return ezSATvec(sat, sat.vec_xor(vec, other.vec)); }\\n\\n\\tezSATvec operator +(const ezSATvec &other) { return ezSATvec(sat, sat.vec_add(vec, other.vec)); }\\n\\tezSATvec operator -(const ezSATvec &other) { return ezSATvec(sat, sat.vec_sub(vec, other.vec)); }\\n\\n\\tezSATbit operator < (const ezSATvec &other) { return ezSATbit(sat, sat.vec_lt_unsigned(vec, other.vec)); }\\n\\tezSATbit operator <=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_le_unsigned(vec, other.vec)); }\\n\\tezSATbit operator ==(const ezSATvec &other) { return ezSATbit(sat, sat.vec_eq(vec, other.vec)); }\\n\\tezSATbit operator !=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_ne(vec, other.vec)); }\\n\\tezSATbit operator >=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_ge_unsigned(vec, other.vec)); }\\n\\tezSATbit operator > (const ezSATvec &other) { return ezSATbit(sat, sat.vec_gt_unsigned(vec, other.vec)); }\\n\\n\\tezSATvec operator <<(int shift) { return ezSATvec(sat, sat.vec_shl(vec, shift)); }\\n\\tezSATvec operator >>(int shift) { return ezSATvec(sat, sat.vec_shr(vec, shift)); }\\n\\n\\toperator std::vector<int>() const { return vec; }\\n};\\n\\n#endif\\n\",\n                },\n                \"json11\": {\n                    \"json11.hpp\": \"/* json11\\n *\\n * json11 is a tiny JSON library for C++11, providing JSON parsing and serialization.\\n *\\n * The core object provided by the library is json11::Json. A Json object represents any JSON\\n * value: null, bool, number (int or double), string (std::string), array (std::vector), or\\n * object (std::map).\\n *\\n * Json objects act like values: they can be assigned, copied, moved, compared for equality or\\n * order, etc. There are also helper methods Json::dump, to serialize a Json to a string, and\\n * Json::parse (static) to parse a std::string as a Json object.\\n *\\n * Internally, the various types of Json object are represented by the JsonValue class\\n * hierarchy.\\n *\\n * A note on numbers - JSON specifies the syntax of number formatting but not its semantics,\\n * so some JSON implementations distinguish between integers and floating-point numbers, while\\n * some don't. In json11, we choose the latter. Because some JSON implementations (namely\\n * Javascript itself) treat all numbers as the same type, distinguishing the two leads\\n * to JSON that will be *silently* changed by a round-trip through those implementations.\\n * Dangerous! To avoid that risk, json11 stores all numbers as double internally, but also\\n * provides integer helpers.\\n *\\n * Fortunately, double-precision IEEE754 ('double') can precisely store any integer in the\\n * range +/-2^53, which includes every 'int' on most systems. (Timestamps often use int64\\n * or long long to avoid the Y2038K problem; a double storing microseconds since some epoch\\n * will be exact for +/- 275 years.)\\n */\\n\\n/* Copyright (c) 2013 Dropbox, Inc.\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n * THE SOFTWARE.\\n */\\n\\n#pragma once\\n\\n#include <string>\\n#include <vector>\\n#include <map>\\n#include <memory>\\n#include <initializer_list>\\n\\n#ifdef _MSC_VER\\n    #if _MSC_VER <= 1800 // VS 2013\\n        #ifndef noexcept\\n            #define noexcept throw()\\n        #endif\\n\\n        #ifndef snprintf\\n            #define snprintf _snprintf_s\\n        #endif\\n    #endif\\n#endif\\n\\nnamespace json11 {\\n\\nenum JsonParse {\\n    STANDARD, COMMENTS\\n};\\n\\nclass JsonValue;\\n\\nclass Json final {\\npublic:\\n    // Types\\n    enum Type {\\n        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT\\n    };\\n\\n    // Array and object typedefs\\n    typedef std::vector<Json> array;\\n    typedef std::map<std::string, Json> object;\\n\\n    // Constructors for the various types of JSON value.\\n    Json() noexcept;                // NUL\\n    Json(std::nullptr_t) noexcept;  // NUL\\n    Json(double value);             // NUMBER\\n    Json(int value);                // NUMBER\\n    Json(bool value);               // BOOL\\n    Json(const std::string &value); // STRING\\n    Json(std::string &&value);      // STRING\\n    Json(const char * value);       // STRING\\n    Json(const array &values);      // ARRAY\\n    Json(array &&values);           // ARRAY\\n    Json(const object &values);     // OBJECT\\n    Json(object &&values);          // OBJECT\\n\\n    // Implicit constructor: anything with a to_json() function.\\n    template <class T, class = decltype(&T::to_json)>\\n    Json(const T & t) : Json(t.to_json()) {}\\n\\n    // Implicit constructor: map-like objects (std::map, std::unordered_map, etc)\\n    template <class M, typename std::enable_if<\\n        std::is_constructible<std::string, decltype(std::declval<M>().begin()->first)>::value\\n        && std::is_constructible<Json, decltype(std::declval<M>().begin()->second)>::value,\\n            int>::type = 0>\\n    Json(const M & m) : Json(object(m.begin(), m.end())) {}\\n\\n    // Implicit constructor: vector-like objects (std::list, std::vector, std::set, etc)\\n    template <class V, typename std::enable_if<\\n        std::is_constructible<Json, decltype(*std::declval<V>().begin())>::value,\\n            int>::type = 0>\\n    Json(const V & v) : Json(array(v.begin(), v.end())) {}\\n\\n    // This prevents Json(some_pointer) from accidentally producing a bool. Use\\n    // Json(bool(some_pointer)) if that behavior is desired.\\n    Json(void *) = delete;\\n\\n    // Accessors\\n    Type type() const;\\n\\n    bool is_null()   const { return type() == NUL; }\\n    bool is_number() const { return type() == NUMBER; }\\n    bool is_bool()   const { return type() == BOOL; }\\n    bool is_string() const { return type() == STRING; }\\n    bool is_array()  const { return type() == ARRAY; }\\n    bool is_object() const { return type() == OBJECT; }\\n\\n    // Return the enclosed value if this is a number, 0 otherwise. Note that json11 does not\\n    // distinguish between integer and non-integer numbers - number_value() and int_value()\\n    // can both be applied to a NUMBER-typed object.\\n    double number_value() const;\\n    int int_value() const;\\n\\n    // Return the enclosed value if this is a boolean, false otherwise.\\n    bool bool_value() const;\\n    // Return the enclosed string if this is a string, \\\"\\\" otherwise.\\n    const std::string &string_value() const;\\n    // Return the enclosed std::vector if this is an array, or an empty vector otherwise.\\n    const array &array_items() const;\\n    // Return the enclosed std::map if this is an object, or an empty map otherwise.\\n    const object &object_items() const;\\n\\n    // Return a reference to arr[i] if this is an array, Json() otherwise.\\n    const Json & operator[](size_t i) const;\\n    // Return a reference to obj[key] if this is an object, Json() otherwise.\\n    const Json & operator[](const std::string &key) const;\\n\\n    // Serialize.\\n    void dump(std::string &out) const;\\n    std::string dump() const {\\n        std::string out;\\n        dump(out);\\n        return out;\\n    }\\n\\n    // Parse. If parse fails, return Json() and assign an error message to err.\\n    static Json parse(const std::string & in,\\n                      std::string & err,\\n                      JsonParse strategy = JsonParse::STANDARD);\\n    static Json parse(const char * in,\\n                      std::string & err,\\n                      JsonParse strategy = JsonParse::STANDARD) {\\n        if (in) {\\n            return parse(std::string(in), err, strategy);\\n        } else {\\n            err = \\\"null input\\\";\\n            return nullptr;\\n        }\\n    }\\n    // Parse multiple objects, concatenated or separated by whitespace\\n    static std::vector<Json> parse_multi(\\n        const std::string & in,\\n        std::string::size_type & parser_stop_pos,\\n        std::string & err,\\n        JsonParse strategy = JsonParse::STANDARD);\\n\\n    static inline std::vector<Json> parse_multi(\\n        const std::string & in,\\n        std::string & err,\\n        JsonParse strategy = JsonParse::STANDARD) {\\n        std::string::size_type parser_stop_pos;\\n        return parse_multi(in, parser_stop_pos, err, strategy);\\n    }\\n\\n    bool operator== (const Json &rhs) const;\\n    bool operator<  (const Json &rhs) const;\\n    bool operator!= (const Json &rhs) const { return !(*this == rhs); }\\n    bool operator<= (const Json &rhs) const { return !(rhs < *this); }\\n    bool operator>  (const Json &rhs) const { return  (rhs < *this); }\\n    bool operator>= (const Json &rhs) const { return !(*this < rhs); }\\n\\n    /* has_shape(types, err)\\n     *\\n     * Return true if this is a JSON object and, for each item in types, has a field of\\n     * the given type. If not, return false and set err to a descriptive message.\\n     */\\n    typedef std::initializer_list<std::pair<std::string, Type>> shape;\\n    bool has_shape(const shape & types, std::string & err) const;\\n\\nprivate:\\n    std::shared_ptr<JsonValue> m_ptr;\\n};\\n\\n// Internal class hierarchy - JsonValue objects are not exposed to users of this API.\\nclass JsonValue {\\nprotected:\\n    friend class Json;\\n    friend class JsonInt;\\n    friend class JsonDouble;\\n    virtual Json::Type type() const = 0;\\n    virtual bool equals(const JsonValue * other) const = 0;\\n    virtual bool less(const JsonValue * other) const = 0;\\n    virtual void dump(std::string &out) const = 0;\\n    virtual double number_value() const;\\n    virtual int int_value() const;\\n    virtual bool bool_value() const;\\n    virtual const std::string &string_value() const;\\n    virtual const Json::array &array_items() const;\\n    virtual const Json &operator[](size_t i) const;\\n    virtual const Json::object &object_items() const;\\n    virtual const Json &operator[](const std::string &key) const;\\n    virtual ~JsonValue() {}\\n};\\n\\n} // namespace json11\\n\",\n                },\n                \"sha1\": {\n                    \"sha1.h\": \"/*\\n    sha1.h - header of\\n\\n    ============\\n    SHA-1 in C++\\n    ============\\n\\n    100% Public Domain.\\n\\n    Original C Code\\n        -- Steve Reid <steve@edmweb.com>\\n    Small changes to fit into bglibs\\n        -- Bruce Guenter <bruce@untroubled.org>\\n    Translation to simpler C++ Code\\n        -- Volker Grabsch <vog@notjusthosting.com>\\n    Fixing bugs and improving style\\n        -- Eugene Hopkinson <slowriot at voxelstorm dot com>\\n*/\\n\\n#ifndef SHA1_HPP\\n#define SHA1_HPP\\n\\n\\n#include <iostream>\\n#include <string>\\n#include <stdint.h>\\n\\nclass SHA1\\n{\\npublic:\\n    SHA1();\\n    void update(const std::string &s);\\n    void update(std::istream &is);\\n    std::string final();\\n    static std::string from_file(const std::string &filename);\\n\\nprivate:\\n    static constexpr unsigned int DIGEST_INTS = 5;  /* number of 32bit integers per SHA1 digest */\\n    static constexpr unsigned int BLOCK_INTS = 16;  /* number of 32bit integers per SHA1 block */\\n    static constexpr unsigned int BLOCK_BYTES = BLOCK_INTS * 4;\\n\\n    uint32_t digest[DIGEST_INTS];\\n    std::string buffer;\\n    uint64_t transforms;\\n\\n    void reset();\\n    void transform(uint32_t block[BLOCK_BYTES]);\\n\\n    static void read(std::istream &is, std::string &s, size_t max);\\n    static void buffer_to_block(const std::string &buffer, uint32_t block[BLOCK_INTS]);\\n};\\n\\nstd::string sha1(const std::string &string);\\n\\n\\n\\n#endif /* SHA1_HPP */\\n\",\n                },\n            },\n            \"passes\": {\n                \"fsm\": {\n                    \"fsmdata.h\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n#ifndef FSMDATA_H\\n#define FSMDATA_H\\n\\n#include \\\"kernel/yosys.h\\\"\\n\\nYOSYS_NAMESPACE_BEGIN\\n\\nstruct FsmData\\n{\\n\\tint num_inputs, num_outputs, state_bits, reset_state;\\n\\tstruct transition_t { int state_in, state_out; RTLIL::Const ctrl_in, ctrl_out; };\\n\\tstd::vector<transition_t> transition_table;\\n\\tstd::vector<RTLIL::Const> state_table;\\n\\n\\tvoid copy_to_cell(RTLIL::Cell *cell)\\n\\t{\\n\\t\\tcell->parameters[ID::CTRL_IN_WIDTH] = RTLIL::Const(num_inputs);\\n\\t\\tcell->parameters[ID::CTRL_OUT_WIDTH] = RTLIL::Const(num_outputs);\\n\\n\\t\\tint state_num_log2 = 0;\\n\\t\\tfor (int i = state_table.size(); i > 0; i = i >> 1)\\n\\t\\t\\tstate_num_log2++;\\n\\t\\tstate_num_log2 = max(state_num_log2, 1);\\n\\n\\t\\tcell->parameters[ID::STATE_BITS] = RTLIL::Const(state_bits);\\n\\t\\tcell->parameters[ID::STATE_NUM] = RTLIL::Const(state_table.size());\\n\\t\\tcell->parameters[ID::STATE_NUM_LOG2] = RTLIL::Const(state_num_log2);\\n\\t\\tcell->parameters[ID::STATE_RST] = RTLIL::Const(reset_state);\\n\\t\\tcell->parameters[ID::STATE_TABLE] = RTLIL::Const();\\n\\n\\t\\tfor (int i = 0; i < int(state_table.size()); i++) {\\n\\t\\t\\tstd::vector<RTLIL::State> &bits_table = cell->parameters[ID::STATE_TABLE].bits;\\n\\t\\t\\tstd::vector<RTLIL::State> &bits_state = state_table[i].bits;\\n\\t\\t\\tbits_table.insert(bits_table.end(), bits_state.begin(), bits_state.end());\\n\\t\\t}\\n\\n\\t\\tcell->parameters[ID::TRANS_NUM] = RTLIL::Const(transition_table.size());\\n\\t\\tcell->parameters[ID::TRANS_TABLE] = RTLIL::Const();\\n\\t\\tfor (int i = 0; i < int(transition_table.size()); i++)\\n\\t\\t{\\n\\t\\t\\tstd::vector<RTLIL::State> &bits_table = cell->parameters[ID::TRANS_TABLE].bits;\\n\\t\\t\\ttransition_t &tr = transition_table[i];\\n\\n\\t\\t\\tRTLIL::Const const_state_in = RTLIL::Const(tr.state_in, state_num_log2);\\n\\t\\t\\tRTLIL::Const const_state_out = RTLIL::Const(tr.state_out, state_num_log2);\\n\\t\\t\\tstd::vector<RTLIL::State> &bits_state_in = const_state_in.bits;\\n\\t\\t\\tstd::vector<RTLIL::State> &bits_state_out = const_state_out.bits;\\n\\n\\t\\t\\tstd::vector<RTLIL::State> &bits_ctrl_in = tr.ctrl_in.bits;\\n\\t\\t\\tstd::vector<RTLIL::State> &bits_ctrl_out = tr.ctrl_out.bits;\\n\\n\\t\\t\\t// append lsb first\\n\\t\\t\\tbits_table.insert(bits_table.end(), bits_ctrl_out.begin(), bits_ctrl_out.end());\\n\\t\\t\\tbits_table.insert(bits_table.end(), bits_state_out.begin(), bits_state_out.end());\\n\\t\\t\\tbits_table.insert(bits_table.end(), bits_ctrl_in.begin(), bits_ctrl_in.end());\\n\\t\\t\\tbits_table.insert(bits_table.end(), bits_state_in.begin(), bits_state_in.end());\\n\\t\\t}\\n\\t}\\n\\n\\tvoid copy_from_cell(RTLIL::Cell *cell)\\n\\t{\\n\\t\\tnum_inputs = cell->parameters[ID::CTRL_IN_WIDTH].as_int();\\n\\t\\tnum_outputs = cell->parameters[ID::CTRL_OUT_WIDTH].as_int();\\n\\n\\t\\tstate_bits = cell->parameters[ID::STATE_BITS].as_int();\\n\\t\\treset_state = cell->parameters[ID::STATE_RST].as_int();\\n\\n\\t\\tint state_num = cell->parameters[ID::STATE_NUM].as_int();\\n\\t\\tint state_num_log2 = cell->parameters[ID::STATE_NUM_LOG2].as_int();\\n\\t\\tint trans_num = cell->parameters[ID::TRANS_NUM].as_int();\\n\\n\\t\\tif (reset_state < 0 || reset_state >= state_num)\\n\\t\\t\\treset_state = -1;\\n\\n\\t\\tconst RTLIL::Const &state_table = cell->parameters[ID::STATE_TABLE];\\n\\t\\tconst RTLIL::Const &trans_table = cell->parameters[ID::TRANS_TABLE];\\n\\n\\t\\tfor (int i = 0; i < state_num; i++) {\\n\\t\\t\\tRTLIL::Const state_code;\\n\\t\\t\\tint off_begin = i*state_bits, off_end = off_begin + state_bits;\\n\\t\\t\\tstate_code.bits.insert(state_code.bits.begin(), state_table.bits.begin()+off_begin, state_table.bits.begin()+off_end);\\n\\t\\t\\tthis->state_table.push_back(state_code);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < trans_num; i++)\\n\\t\\t{\\n\\t\\t\\tauto off_ctrl_out = trans_table.bits.begin() + i*(num_inputs+num_outputs+2*state_num_log2);\\n\\t\\t\\tauto off_state_out = off_ctrl_out + num_outputs;\\n\\t\\t\\tauto off_ctrl_in = off_state_out + state_num_log2;\\n\\t\\t\\tauto off_state_in = off_ctrl_in + num_inputs;\\n\\t\\t\\tauto off_end = off_state_in + state_num_log2;\\n\\n\\t\\t\\tRTLIL::Const state_in, state_out, ctrl_in, ctrl_out;\\n\\t\\t\\tctrl_out.bits.insert(state_in.bits.begin(), off_ctrl_out, off_state_out);\\n\\t\\t\\tstate_out.bits.insert(state_out.bits.begin(), off_state_out, off_ctrl_in);\\n\\t\\t\\tctrl_in.bits.insert(ctrl_in.bits.begin(), off_ctrl_in, off_state_in);\\n\\t\\t\\tstate_in.bits.insert(state_in.bits.begin(), off_state_in, off_end);\\n\\n\\t\\t\\ttransition_t tr;\\n\\t\\t\\ttr.state_in = state_in.as_int();\\n\\t\\t\\ttr.state_out = state_out.as_int();\\n\\t\\t\\ttr.ctrl_in = ctrl_in;\\n\\t\\t\\ttr.ctrl_out = ctrl_out;\\n\\n\\t\\t\\tif (tr.state_in < 0 || tr.state_in >= state_num)\\n\\t\\t\\t\\ttr.state_in = -1;\\n\\t\\t\\tif (tr.state_out < 0 || tr.state_out >= state_num)\\n\\t\\t\\t\\ttr.state_out = -1;\\n\\n\\t\\t\\ttransition_table.push_back(tr);\\n\\t\\t}\\n\\t}\\n\\n\\tvoid log_info(RTLIL::Cell *cell)\\n\\t{\\n\\t\\tlog(\\\"-------------------------------------\\\\n\\\");\\n\\t\\tlog(\\\"\\\\n\\\");\\n\\t\\tlog(\\\"  Information on FSM %s (%s):\\\\n\\\", cell->name.c_str(), cell->parameters[ID::NAME].decode_string().c_str());\\n\\t\\tlog(\\\"\\\\n\\\");\\n\\t\\tlog(\\\"  Number of input signals:  %3d\\\\n\\\", num_inputs);\\n\\t\\tlog(\\\"  Number of output signals: %3d\\\\n\\\", num_outputs);\\n\\t\\tlog(\\\"  Number of state bits:     %3d\\\\n\\\", state_bits);\\n\\n\\t\\tlog(\\\"\\\\n\\\");\\n\\t\\tlog(\\\"  Input signals:\\\\n\\\");\\n\\t\\tRTLIL::SigSpec sig_in = cell->getPort(ID::CTRL_IN);\\n\\t\\tfor (int i = 0; i < GetSize(sig_in); i++)\\n\\t\\t\\tlog(\\\"  %3d: %s\\\\n\\\", i, log_signal(sig_in[i]));\\n\\n\\t\\tlog(\\\"\\\\n\\\");\\n\\t\\tlog(\\\"  Output signals:\\\\n\\\");\\n\\t\\tRTLIL::SigSpec sig_out = cell->getPort(ID::CTRL_OUT);\\n\\t\\tfor (int i = 0; i < GetSize(sig_out); i++)\\n\\t\\t\\tlog(\\\"  %3d: %s\\\\n\\\", i, log_signal(sig_out[i]));\\n\\n\\t\\tlog(\\\"\\\\n\\\");\\n\\t\\tlog(\\\"  State encoding:\\\\n\\\");\\n\\t\\tfor (int i = 0; i < GetSize(state_table); i++)\\n\\t\\t\\tlog(\\\"  %3d: %10s%s\\\\n\\\", i, log_signal(state_table[i], false),\\n\\t\\t\\t\\t\\tint(i) == reset_state ? \\\"  <RESET STATE>\\\" : \\\"\\\");\\n\\n\\t\\tlog(\\\"\\\\n\\\");\\n\\t\\tlog(\\\"  Transition Table (state_in, ctrl_in, state_out, ctrl_out):\\\\n\\\");\\n\\t\\tfor (int i = 0; i < GetSize(transition_table); i++) {\\n\\t\\t\\ttransition_t &tr = transition_table[i];\\n\\t\\t\\tlog(\\\"  %5d: %5d %s   -> %5d %s\\\\n\\\", i, tr.state_in, log_signal(tr.ctrl_in), tr.state_out, log_signal(tr.ctrl_out));\\n\\t\\t}\\n\\n\\t\\tlog(\\\"\\\\n\\\");\\n\\t\\tlog(\\\"-------------------------------------\\\\n\\\");\\n\\t}\\n\\n\\t// implemented in fsm_opt.cc\\n\\tstatic void optimize_fsm(RTLIL::Cell *cell, RTLIL::Module *module);\\n};\\n\\nYOSYS_NAMESPACE_END\\n\\n#endif\\n\",\n                },\n            },\n        },\n        \"intel\": {\n            \"common\": {\n                \"altpll_bb.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n/* No clearbox model */\\n`ifdef NO_CLEARBOX\\n(* blackbox *)\\nmodule altpll\\n  ( inclk,\\n    fbin,\\n    pllena,\\n    clkswitch,\\n    areset,\\n    pfdena,\\n    clkena,\\n    extclkena,\\n    scanclk,\\n    scanaclr,\\n    scanclkena,\\n    scanread,\\n    scanwrite,\\n    scandata,\\n    phasecounterselect,\\n    phaseupdown,\\n    phasestep,\\n    configupdate,\\n    fbmimicbidir,\\n    clk,\\n    extclk,\\n    clkbad,\\n    enable0,\\n    enable1,\\n    activeclock,\\n    clkloss,\\n    locked,\\n    scandataout,\\n    scandone,\\n    sclkout0,\\n    sclkout1,\\n    phasedone,\\n    vcooverrange,\\n    vcounderrange,\\n    fbout,\\n    fref,\\n    icdrclk,\\n    c0,\\n    c1,\\n    c2,\\n    c3,\\n    c4);\\n\\n   parameter   intended_device_family    = \\\"MAX 10\\\";\\n   parameter   operation_mode            = \\\"NORMAL\\\";\\n   parameter   pll_type                  = \\\"AUTO\\\";\\n   parameter   qualify_conf_done         = \\\"OFF\\\";\\n   parameter   compensate_clock          = \\\"CLK0\\\";\\n   parameter   scan_chain                = \\\"LONG\\\";\\n   parameter   primary_clock             = \\\"inclk0\\\";\\n   parameter   inclk0_input_frequency    = 1000;\\n   parameter   inclk1_input_frequency    = 0;\\n   parameter   gate_lock_signal          = \\\"NO\\\";\\n   parameter   gate_lock_counter         = 0;\\n   parameter   lock_high                 = 1;\\n   parameter   lock_low                  = 0;\\n   parameter   valid_lock_multiplier     = 1;\\n   parameter   invalid_lock_multiplier   = 5;\\n   parameter   switch_over_type          = \\\"AUTO\\\";\\n   parameter   switch_over_on_lossclk    = \\\"OFF\\\" ;\\n   parameter   switch_over_on_gated_lock = \\\"OFF\\\" ;\\n   parameter   enable_switch_over_counter = \\\"OFF\\\";\\n   parameter   switch_over_counter       = 0;\\n   parameter   feedback_source           = \\\"EXTCLK0\\\" ;\\n   parameter   bandwidth                 = 0;\\n   parameter   bandwidth_type            = \\\"UNUSED\\\";\\n   parameter   lpm_hint                  = \\\"UNUSED\\\";\\n   parameter   spread_frequency          = 0;\\n   parameter   down_spread               = \\\"0.0\\\";\\n   parameter   self_reset_on_gated_loss_lock = \\\"OFF\\\";\\n   parameter   self_reset_on_loss_lock = \\\"OFF\\\";\\n   parameter   lock_window_ui           = \\\"0.05\\\";\\n   parameter   width_clock              = 6;\\n   parameter   width_phasecounterselect = 4;\\n   parameter   charge_pump_current_bits = 9999;\\n   parameter   loop_filter_c_bits = 9999;\\n   parameter   loop_filter_r_bits = 9999;\\n   parameter   scan_chain_mif_file = \\\"UNUSED\\\";\\n   parameter   clk9_multiply_by        = 1;\\n   parameter   clk8_multiply_by        = 1;\\n   parameter   clk7_multiply_by        = 1;\\n   parameter   clk6_multiply_by        = 1;\\n   parameter   clk5_multiply_by        = 1;\\n   parameter   clk4_multiply_by        = 1;\\n   parameter   clk3_multiply_by        = 1;\\n   parameter   clk2_multiply_by        = 1;\\n   parameter   clk1_multiply_by        = 1;\\n   parameter   clk0_multiply_by        = 1;\\n   parameter   clk9_divide_by          = 1;\\n   parameter   clk8_divide_by          = 1;\\n   parameter   clk7_divide_by          = 1;\\n   parameter   clk6_divide_by          = 1;\\n   parameter   clk5_divide_by          = 1;\\n   parameter   clk4_divide_by          = 1;\\n   parameter   clk3_divide_by          = 1;\\n   parameter   clk2_divide_by          = 1;\\n   parameter   clk1_divide_by          = 1;\\n   parameter   clk0_divide_by          = 1;\\n   parameter   clk9_phase_shift        = \\\"0\\\";\\n   parameter   clk8_phase_shift        = \\\"0\\\";\\n   parameter   clk7_phase_shift        = \\\"0\\\";\\n   parameter   clk6_phase_shift        = \\\"0\\\";\\n   parameter   clk5_phase_shift        = \\\"0\\\";\\n   parameter   clk4_phase_shift        = \\\"0\\\";\\n   parameter   clk3_phase_shift        = \\\"0\\\";\\n   parameter   clk2_phase_shift        = \\\"0\\\";\\n   parameter   clk1_phase_shift        = \\\"0\\\";\\n   parameter   clk0_phase_shift        = \\\"0\\\";\\n\\n   parameter   clk9_duty_cycle         = 50;\\n   parameter   clk8_duty_cycle         = 50;\\n   parameter   clk7_duty_cycle         = 50;\\n   parameter   clk6_duty_cycle         = 50;\\n   parameter   clk5_duty_cycle         = 50;\\n   parameter   clk4_duty_cycle         = 50;\\n   parameter   clk3_duty_cycle         = 50;\\n   parameter   clk2_duty_cycle         = 50;\\n   parameter   clk1_duty_cycle         = 50;\\n   parameter   clk0_duty_cycle         = 50;\\n\\n   parameter   clk9_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk8_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk7_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk6_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk5_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk4_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk3_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk2_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk1_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk0_use_even_counter_mode    = \\\"OFF\\\";\\n   parameter   clk9_use_even_counter_value   = \\\"OFF\\\";\\n   parameter   clk8_use_even_counter_value   = \\\"OFF\\\";\\n   parameter   clk7_use_even_counter_value   = \\\"OFF\\\";\\n   parameter   clk6_use_even_counter_value   = \\\"OFF\\\";\\n   parameter   clk5_use_even_counter_value   = \\\"OFF\\\";\\n   parameter   clk4_use_even_counter_value   = \\\"OFF\\\";\\n   parameter   clk3_use_even_counter_value   = \\\"OFF\\\";\\n   parameter   clk2_use_even_counter_value   = \\\"OFF\\\";\\n   parameter   clk1_use_even_counter_value   = \\\"OFF\\\";\\n   parameter   clk0_use_even_counter_value   = \\\"OFF\\\";\\n\\n   parameter   clk2_output_frequency   = 0;\\n   parameter   clk1_output_frequency   = 0;\\n   parameter   clk0_output_frequency   = 0;\\n\\n   parameter   vco_min             = 0;\\n   parameter   vco_max             = 0;\\n   parameter   vco_center          = 0;\\n   parameter   pfd_min             = 0;\\n   parameter   pfd_max             = 0;\\n   parameter   m_initial           = 1;\\n   parameter   m                   = 0;\\n   parameter   n                   = 1;\\n   parameter   m2                  = 1;\\n   parameter   n2                  = 1;\\n   parameter   ss                  = 0;\\n   parameter   l0_high             = 1;\\n   parameter   l1_high             = 1;\\n   parameter   g0_high             = 1;\\n   parameter   g1_high             = 1;\\n   parameter   g2_high             = 1;\\n   parameter   g3_high             = 1;\\n   parameter   e0_high             = 1;\\n   parameter   e1_high             = 1;\\n   parameter   e2_high             = 1;\\n   parameter   e3_high             = 1;\\n   parameter   l0_low              = 1;\\n   parameter   l1_low              = 1;\\n   parameter   g0_low              = 1;\\n   parameter   g1_low              = 1;\\n   parameter   g2_low              = 1;\\n   parameter   g3_low              = 1;\\n   parameter   e0_low              = 1;\\n   parameter   e1_low              = 1;\\n   parameter   e2_low              = 1;\\n   parameter   e3_low              = 1;\\n   parameter   l0_initial          = 1;\\n   parameter   l1_initial          = 1;\\n   parameter   g0_initial          = 1;\\n   parameter   g1_initial          = 1;\\n   parameter   g2_initial          = 1;\\n   parameter   g3_initial          = 1;\\n   parameter   e0_initial          = 1;\\n   parameter   e1_initial          = 1;\\n   parameter   e2_initial          = 1;\\n   parameter   e3_initial          = 1;\\n   parameter   l0_mode             = \\\"bypass\\\";\\n   parameter   l1_mode             = \\\"bypass\\\";\\n   parameter   g0_mode             = \\\"bypass\\\";\\n   parameter   g1_mode             = \\\"bypass\\\";\\n   parameter   g2_mode             = \\\"bypass\\\";\\n   parameter   g3_mode             = \\\"bypass\\\";\\n   parameter   e0_mode             = \\\"bypass\\\";\\n   parameter   e1_mode             = \\\"bypass\\\";\\n   parameter   e2_mode             = \\\"bypass\\\";\\n   parameter   e3_mode             = \\\"bypass\\\";\\n   parameter   l0_ph               = 0;\\n   parameter   l1_ph               = 0;\\n   parameter   g0_ph               = 0;\\n   parameter   g1_ph               = 0;\\n   parameter   g2_ph               = 0;\\n   parameter   g3_ph               = 0;\\n   parameter   e0_ph               = 0;\\n   parameter   e1_ph               = 0;\\n   parameter   e2_ph               = 0;\\n   parameter   e3_ph               = 0;\\n   parameter   m_ph                = 0;\\n   parameter   l0_time_delay       = 0;\\n   parameter   l1_time_delay       = 0;\\n   parameter   g0_time_delay       = 0;\\n   parameter   g1_time_delay       = 0;\\n   parameter   g2_time_delay       = 0;\\n   parameter   g3_time_delay       = 0;\\n   parameter   e0_time_delay       = 0;\\n   parameter   e1_time_delay       = 0;\\n   parameter   e2_time_delay       = 0;\\n   parameter   e3_time_delay       = 0;\\n   parameter   m_time_delay        = 0;\\n   parameter   n_time_delay        = 0;\\n   parameter   extclk3_counter     = \\\"e3\\\" ;\\n   parameter   extclk2_counter     = \\\"e2\\\" ;\\n   parameter   extclk1_counter     = \\\"e1\\\" ;\\n   parameter   extclk0_counter     = \\\"e0\\\" ;\\n   parameter   clk9_counter        = \\\"c9\\\" ;\\n   parameter   clk8_counter        = \\\"c8\\\" ;\\n   parameter   clk7_counter        = \\\"c7\\\" ;\\n   parameter   clk6_counter        = \\\"c6\\\" ;\\n   parameter   clk5_counter        = \\\"l1\\\" ;\\n   parameter   clk4_counter        = \\\"l0\\\" ;\\n   parameter   clk3_counter        = \\\"g3\\\" ;\\n   parameter   clk2_counter        = \\\"g2\\\" ;\\n   parameter   clk1_counter        = \\\"g1\\\" ;\\n   parameter   clk0_counter        = \\\"g0\\\" ;\\n   parameter   enable0_counter     = \\\"l0\\\";\\n   parameter   enable1_counter     = \\\"l0\\\";\\n   parameter   charge_pump_current = 2;\\n   parameter   loop_filter_r       = \\\"1.0\\\";\\n   parameter   loop_filter_c       = 5;\\n   parameter   vco_post_scale      = 0;\\n   parameter   vco_frequency_control = \\\"AUTO\\\";\\n   parameter   vco_phase_shift_step = 0;\\n   parameter   lpm_type            = \\\"altpll\\\";\\n\\n   parameter port_clkena0 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clkena1 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clkena2 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clkena3 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clkena4 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clkena5 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_extclkena0 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_extclkena1 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_extclkena2 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_extclkena3 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_extclk0 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_extclk1 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_extclk2 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_extclk3 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk0 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk1 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk2 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk3 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk4 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk5 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk6 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk7 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk8 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clk9 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_scandata = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_scandataout = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_scandone = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_sclkout1 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_sclkout0 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clkbad0 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clkbad1 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_activeclock = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clkloss = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_inclk1 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_inclk0 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_fbin = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_fbout = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_pllena = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_clkswitch = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_areset = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_pfdena = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_scanclk = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_scanaclr = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_scanread = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_scanwrite = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_enable0 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_enable1 = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_locked = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_configupdate = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_phasecounterselect = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_phasedone = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_phasestep = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_phaseupdown = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_vcooverrange = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_vcounderrange = \\\"PORT_CONNECTIVITY\\\";\\n   parameter port_scanclkena = \\\"PORT_CONNECTIVITY\\\";\\n   parameter using_fbmimicbidir_port = \\\"ON\\\";\\n\\n   input [1:0] inclk;\\n   input       fbin;\\n   input       pllena;\\n   input       clkswitch;\\n   input       areset;\\n   input       pfdena;\\n   input       clkena;\\n   input       extclkena;\\n   input       scanclk;\\n   input       scanaclr;\\n   input       scanclkena;\\n   input       scanread;\\n   input       scanwrite;\\n   input       scandata;\\n   input       phasecounterselect;\\n   input       phaseupdown;\\n   input       phasestep;\\n   input       configupdate;\\n   inout       fbmimicbidir;\\n\\n\\n   output [width_clock-1:0] clk;\\n   output [3:0]             extclk;\\n   output [1:0]             clkbad;\\n   output                   enable0;\\n   output                   enable1;\\n   output                   activeclock;\\n   output                   clkloss;\\n   output                   locked;\\n   output                   scandataout;\\n   output                   scandone;\\n   output                   sclkout0;\\n   output                   sclkout1;\\n   output                   phasedone;\\n   output                   vcooverrange;\\n   output                   vcounderrange;\\n   output                   fbout;\\n   output                   fref;\\n   output                   icdrclk;\\n   output                   c0, c1, c2, c3, c4;\\n\\nendmodule // altpll\\n`endif\\n\",\n                \"brams_m9k.txt\": \"bram $__M9K_ALTSYNCRAM_SINGLEPORT_FULL\\n  init   1\\n  abits  13 @M1\\n  dbits  1  @M1\\n  abits  12 @M2\\n  dbits  2  @M2\\n  abits  11 @M3\\n  dbits  4  @M3\\n  abits  10 @M4\\n  dbits  8  @M4\\n  abits  10 @M5\\n  dbits  9  @M5\\n  abits  9  @M6\\n  dbits  16 @M6\\n  abits  9  @M7\\n  dbits  18 @M7\\n  abits  8  @M8\\n  dbits  32 @M8\\n  abits  8  @M9\\n  dbits  36 @M9\\n  groups 2\\n  ports  1 1\\n  wrmode 0 1\\n  enable 1 1\\n  transp 0 0\\n  clocks 2 3\\n  clkpol 2 3\\nendbram\\n\\nmatch $__M9K_ALTSYNCRAM_SINGLEPORT_FULL\\n  min efficiency 2\\n  make_transp\\nendmatch\\n\",\n                \"brams_map_m9k.v\": \"module \\\\$__M9K_ALTSYNCRAM_SINGLEPORT_FULL (CLK2, CLK3, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);\\n\\n   parameter CFG_ABITS = 8;\\n   parameter CFG_DBITS = 36;\\n   parameter ABITS = 1;\\n   parameter DBITS = 1;\\n   parameter CLKPOL2 = 1;\\n   parameter CLKPOL3 = 1;\\n\\n   input CLK2;\\n   input CLK3;\\n   //Read data\\n   output [CFG_DBITS-1:0] A1DATA;\\n   input [CFG_ABITS-1:0]  A1ADDR;\\n   input                  A1EN;\\n   //Write data\\n   output [CFG_DBITS-1:0] B1DATA;\\n   input [CFG_ABITS-1:0]  B1ADDR;\\n   input                  B1EN;\\n\\n   wire [CFG_DBITS-1:0]   B1DATA_t;\\n\\n   localparam MODE = CFG_DBITS == 1  ? 1:\\n                     CFG_DBITS == 2  ? 2:\\n                     CFG_DBITS == 4  ? 3:\\n                     CFG_DBITS == 8  ? 4:\\n                     CFG_DBITS == 9  ? 5:\\n                     CFG_DBITS == 16 ? 6:\\n                     CFG_DBITS == 18 ? 7:\\n                     CFG_DBITS == 32 ? 8:\\n                     CFG_DBITS == 36 ? 9:\\n                     'bx;\\n\\n   localparam NUMWORDS = CFG_DBITS == 1  ? 8192:\\n                         CFG_DBITS == 2  ? 4096:\\n                         CFG_DBITS == 4  ? 2048:\\n                         CFG_DBITS == 8  ? 1024:\\n                         CFG_DBITS == 9  ? 1024:\\n                         CFG_DBITS == 16 ?  512:\\n                         CFG_DBITS == 18 ?  512:\\n                         CFG_DBITS == 32 ?  256:\\n                         CFG_DBITS == 36 ?  256:\\n                         'bx;\\n\\n   altsyncram  #(.clock_enable_input_b           (\\\"ALTERNATE\\\"   ),\\n                 .clock_enable_input_a           (\\\"ALTERNATE\\\"   ),\\n                 .clock_enable_output_b          (\\\"NORMAL\\\"      ),\\n                 .clock_enable_output_a          (\\\"NORMAL\\\"      ),\\n                 .wrcontrol_aclr_a               (\\\"NONE\\\"        ),\\n                 .indata_aclr_a                  (\\\"NONE\\\"        ),\\n                 .address_aclr_a                 (\\\"NONE\\\"        ),\\n                 .outdata_aclr_a                 (\\\"NONE\\\"        ),\\n                 .outdata_reg_a                  (\\\"UNREGISTERED\\\"),\\n                 .operation_mode                 (\\\"SINGLE_PORT\\\" ),\\n                 .intended_device_family         (\\\"CYCLONE IVE\\\" ),\\n                 .outdata_reg_a                  (\\\"UNREGISTERED\\\"),\\n                 .lpm_type                       (\\\"altsyncram\\\"  ),\\n                 .init_type                      (\\\"unused\\\"      ),\\n                 .ram_block_type                 (\\\"AUTO\\\"        ),\\n                 .lpm_hint                       (\\\"ENABLE_RUNTIME_MOD=NO\\\"), // Forced value\\n                 .power_up_uninitialized         (\\\"FALSE\\\"),\\n                 .read_during_write_mode_port_a  (\\\"NEW_DATA_NO_NBE_READ\\\"), // Forced value\\n                 .width_byteena_a                (1), // Forced value\\n                 .numwords_b                     ( NUMWORDS     ),\\n                 .numwords_a                     ( NUMWORDS     ),\\n                 .widthad_b                      ( CFG_DBITS    ),\\n                 .width_b                        ( CFG_ABITS    ),\\n                 .widthad_a                      ( CFG_DBITS    ),\\n                 .width_a                        ( CFG_ABITS    )\\n                 ) _TECHMAP_REPLACE_ (\\n                                      .data_a(B1DATA),\\n                                      .address_a(B1ADDR),\\n                                      .wren_a(B1EN),\\n                                      .rden_a(A1EN),\\n                                      .q_a(A1DATA),\\n                                      .data_b(B1DATA),\\n                                      .address_b(0),\\n                                      .wren_b(1'b0),\\n                                      .rden_b(1'b0),\\n                                      .q_b(),\\n                                      .clock0(CLK2),\\n                                      .clock1(1'b1), // Unused in single port mode\\n                                      .clocken0(1'b1),\\n                                      .clocken1(1'b1),\\n                                      .clocken2(1'b1),\\n                                      .clocken3(1'b1),\\n                                      .aclr0(1'b0),\\n                                      .aclr1(1'b0),\\n                                      .addressstall_a(1'b0),\\n                                      .addressstall_b(1'b0));\\n\\nendmodule\\n\\n\",\n                \"ff_map.v\": \"// Async Active Low Reset DFF\\nmodule  \\\\$_DFFE_PN0P_ (input D, C, R, E, output Q);\\n   parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n   generate if (_TECHMAP_WIREINIT_Q_ === 1'b1) begin\\n     dffeas #(.is_wysiwyg(\\\"TRUE\\\"), .power_up(\\\"high\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .clrn(R), .prn(1'b1), .ena(E), .asdata(1'b0), .aload(1'b0), .sclr(1'b0), .sload(1'b0));\\n   end else begin\\n     dffeas #(.is_wysiwyg(\\\"TRUE\\\"), .power_up(\\\"low\\\")) _TECHMAP_REPLACE_ (.d(D), .q(Q), .clk(C), .clrn(R), .prn(1'b1), .ena(E), .asdata(1'b0), .aload(1'b0), .sclr(1'b0), .sload(1'b0));\\n   end\\n   endgenerate\\n   wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\",\n                \"m9k_bb.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n(* blackbox *)\\nmodule altsyncram(data_a, address_a, wren_a, rden_a, q_a, data_b, address_b,  wren_b, rden_b,\\n                  q_b, clock0, clock1, clocken0, clocken1, clocken2, clocken3, aclr0, aclr1,\\n                  addressstall_a, addressstall_b);\\n\\n   parameter clock_enable_input_b          = \\\"ALTERNATE\\\";\\n   parameter clock_enable_input_a          = \\\"ALTERNATE\\\";\\n   parameter clock_enable_output_b         = \\\"NORMAL\\\";\\n   parameter clock_enable_output_a         = \\\"NORMAL\\\";\\n   parameter wrcontrol_aclr_a              = \\\"NONE\\\";\\n   parameter indata_aclr_a                 = \\\"NONE\\\";\\n   parameter address_aclr_a                = \\\"NONE\\\";\\n   parameter outdata_aclr_a                = \\\"NONE\\\";\\n   parameter outdata_reg_a                 = \\\"UNREGISTERED\\\";\\n   parameter operation_mode                = \\\"SINGLE_PORT\\\";\\n   parameter intended_device_family        = \\\"MAX 10 FPGA\\\";\\n   parameter outdata_reg_b                 = \\\"UNREGISTERED\\\";\\n   parameter lpm_type                      = \\\"altsyncram\\\";\\n   parameter init_type                     = \\\"unused\\\";\\n   parameter ram_block_type                = \\\"AUTO\\\";\\n   parameter lpm_hint                      = \\\"ENABLE_RUNTIME_MOD=NO\\\";\\n   parameter power_up_uninitialized        = \\\"FALSE\\\";\\n   parameter read_during_write_mode_port_a = \\\"NEW_DATA_NO_NBE_READ\\\";\\n   parameter width_byteena_a               = 1;\\n   parameter numwords_b                    = 0;\\n   parameter numwords_a                    = 0;\\n   parameter widthad_b                     = 1;\\n   parameter width_b                       = 1;\\n   parameter widthad_a                     = 1;\\n   parameter width_a                       = 1;\\n\\n   // Port A declarations\\n   output [35:0] q_a;\\n   input [35:0]  data_a;\\n   input [7:0]   address_a;\\n   input         wren_a;\\n   input         rden_a;\\n   // Port B declarations\\n   output [35:0] q_b;\\n   input [35:0]  data_b;\\n   input [7:0]   address_b;\\n   input         wren_b;\\n   input         rden_b;\\n   // Control signals\\n   input         clock0, clock1;\\n   input         clocken0, clocken1, clocken2, clocken3;\\n   input         aclr0, aclr1;\\n   input         addressstall_a;\\n   input         addressstall_b;\\n   // TODO: Implement the correct simulation model\\n\\nendmodule // altsyncram\\n\",\n            },\n            \"cyclone10lp\": {\n                \"cells_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n// > c60k28 (Viacheslav, VT) [at] yandex [dot] com\\n// > Intel FPGA technology mapping. User must first simulate the generated \\\\\\n// > netlist before going to test it on board.\\n\\n// Input buffer map\\nmodule \\\\$__inpad (input I, output O);\\n   cyclone10lp_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));\\nendmodule\\n\\n// Output buffer map\\nmodule \\\\$__outpad (input I, output O);\\n   cyclone10lp_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));\\nendmodule\\n\\n// LUT Map\\n/* 0 -> datac\\n 1 -> cin */\\nmodule \\\\$lut (A, Y);\\n   parameter WIDTH  = 0;\\n   parameter LUT    = 0;\\n   (* force_downto *)\\n   input [WIDTH-1:0] A;\\n   output            Y;\\n   generate\\n      if (WIDTH == 1) begin\\n\\t assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function\\n      end else\\n        if (WIDTH == 2) begin\\n           cyclone10lp_lcell_comb #(.lut_mask({4{LUT}}),\\n                                   .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y),\\n                                                                                .dataa(A[0]),\\n                                                                                .datab(A[1]),\\n                                                                                .datac(1'b1),\\n                                                                                .datad(1'b1));\\n        end else\\n          if(WIDTH == 3) begin\\n\\t     cyclone10lp_lcell_comb #(.lut_mask({2{LUT}}),\\n                                     .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y),\\n                                                                                  .dataa(A[0]),\\n                                                                                  .datab(A[1]),\\n                                                                                  .datac(A[2]),\\n                                                                                  .datad(1'b1));\\n          end else\\n            if(WIDTH == 4) begin\\n\\t       cyclone10lp_lcell_comb #(.lut_mask(LUT),\\n                                       .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y),\\n                                                                                    .dataa(A[0]),\\n                                                                                    .datab(A[1]),\\n                                                                                    .datac(A[2]),\\n                                                                                    .datad(A[3]));\\n            end else\\n\\t             wire _TECHMAP_FAIL_ = 1;\\n   endgenerate\\n\\nendmodule\\n\\n\\n\",\n                \"cells_sim.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\nmodule VCC (output V);\\n   assign V = 1'b1;\\nendmodule // VCC\\n\\nmodule GND (output G);\\n   assign G = 1'b0;\\nendmodule // GND\\n\\n/* Altera Cyclone 10 LP devices Input Buffer Primitive */\\nmodule cyclone10lp_io_ibuf\\n  (output o, input i, input ibar);\\n   assign ibar = ibar;\\n   assign o    = i;\\nendmodule // cyclone10lp_io_ibuf\\n\\n/* Altera Cyclone 10 LP devices Output Buffer Primitive */\\nmodule cyclone10lp_io_obuf\\n  (output o, input i, input oe);\\n   assign o  = i;\\n   assign oe = oe;\\nendmodule // cyclone10lp_io_obuf\\n\\n/* Altera Cyclone IV (E) 4-input non-fracturable LUT Primitive */\\nmodule cyclone10lp_lcell_comb\\n  (output combout, cout,\\n   input dataa, datab, datac, datad, cin);\\n\\n   /* Internal parameters which define the behaviour\\n    of the LUT primitive.\\n    lut_mask define the lut function, can be expressed in 16-digit bin or hex.\\n    sum_lutc_input define the type of LUT (combinational | arithmetic).\\n    dont_touch for retiming || carry options.\\n    lpm_type for WYSIWYG */\\n\\n   parameter lut_mask   = 16'hFFFF;\\n   parameter dont_touch = \\\"off\\\";\\n   parameter lpm_type   = \\\"cyclone10lp_lcell_comb\\\";\\n   parameter sum_lutc_input = \\\"datac\\\";\\n\\n   reg [1:0]                        lut_type;\\n   reg                              cout_rt;\\n   reg                              combout_rt;\\n   wire                             dataa_w;\\n   wire                             datab_w;\\n   wire                             datac_w;\\n   wire                             datad_w;\\n   wire                             cin_w;\\n\\n   assign dataa_w = dataa;\\n   assign datab_w = datab;\\n   assign datac_w = datac;\\n   assign datad_w = datad;\\n\\n   function lut_data;\\n      input [15:0]                  mask;\\n      input                         dataa, datab, datac, datad;\\n      reg [7:0]                     s3;\\n      reg [3:0]                     s2;\\n      reg [1:0]                     s1;\\n      begin\\n         s3 = datad ? mask[15:8] : mask[7:0];\\n         s2 = datac ?   s3[7:4]  :   s3[3:0];\\n         s1 = datab ?   s2[3:2]  :   s2[1:0];\\n         lut_data = dataa ? s1[1] : s1[0];\\n      end\\n\\n   endfunction\\n\\n   initial begin\\n      if (sum_lutc_input == \\\"datac\\\") lut_type = 0;\\n      else\\n        if (sum_lutc_input == \\\"cin\\\")   lut_type = 1;\\n        else begin\\n           $error(\\\"Error in sum_lutc_input. Parameter %s is not a valid value.\\\\n\\\", sum_lutc_input);\\n           $finish();\\n        end\\n   end\\n\\n   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin\\n      if (lut_type == 0) begin // logic function\\n         combout_rt = lut_data(lut_mask, dataa_w, datab_w,\\n                               datac_w, datad_w);\\n      end\\n      else if (lut_type == 1) begin // arithmetic function\\n         combout_rt = lut_data(lut_mask, dataa_w, datab_w,\\n                               cin_w, datad_w);\\n      end\\n      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);\\n   end\\n\\n   assign combout = combout_rt & 1'b1;\\n   assign cout = cout_rt & 1'b1;\\n\\nendmodule // cyclone10lp_lcell_comb\\n\\n/* Altera D Flip-Flop Primitive */\\nmodule dffeas\\n  (output q,\\n   input d, clk, clrn, prn, ena,\\n   input asdata, aload, sclr, sload);\\n\\n   // Timing simulation is not covered\\n   parameter power_up=\\\"dontcare\\\";\\n   parameter is_wysiwyg=\\\"false\\\";\\n\\n   reg   q_tmp;\\n   wire  reset;\\n   reg [7:0] debug_net;\\n\\n   assign reset       = (prn && sclr && ~clrn && ena);\\n   assign q           = q_tmp & 1'b1;\\n\\n   always @(posedge clk, posedge aload) begin\\n      if(reset)        q_tmp <= 0;\\n      else q_tmp <= d;\\n   end\\n   assign q = q_tmp;\\n\\nendmodule // dffeas\\n\",\n            },\n            \"cycloneiv\": {\n                \"cells_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n// > c60k28 (Viacheslav, VT) [at] yandex [dot] com\\n// > Intel FPGA technology mapping. User must first simulate the generated \\\\\\n// > netlist before going to test it on board.\\n\\n// Input buffer map\\nmodule \\\\$__inpad (input I, output O);\\n    cycloneiv_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));\\nendmodule\\n\\n// Output buffer map\\nmodule \\\\$__outpad (input I, output O);\\n    cycloneiv_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));\\nendmodule\\n\\n// LUT Map\\n/* 0 -> datac\\n   1 -> cin */\\nmodule \\\\$lut (A, Y);\\n   parameter WIDTH  = 0;\\n   parameter LUT    = 0;\\n   (* force_downto *)\\n   input [WIDTH-1:0] A;\\n   output            Y;\\n   generate\\n      if (WIDTH == 1) begin\\n\\t   assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function\\n      end else\\n      if (WIDTH == 2) begin\\n           cycloneiv_lcell_comb #(.lut_mask({4{LUT}}), .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(1'b1),.datad(1'b1));\\n      end else\\n      if(WIDTH == 3) begin\\n\\t   cycloneiv_lcell_comb #(.lut_mask({2{LUT}}), .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(1'b1));\\n      end else\\n      if(WIDTH == 4) begin\\n\\t   cycloneiv_lcell_comb #(.lut_mask(LUT), .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(A[3]));\\n      end else\\n\\t   wire _TECHMAP_FAIL_ = 1;\\n   endgenerate\\nendmodule //\\n\\n\\n\",\n                \"cells_sim.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\nmodule VCC (output V);\\n   assign V = 1'b1;\\nendmodule // VCC\\n\\nmodule GND (output G);\\n   assign G = 1'b0;\\nendmodule // GND\\n\\n/* Altera Cyclone IV (GX) devices Input Buffer Primitive */\\nmodule cycloneiv_io_ibuf\\n  (output o, input i, input ibar);\\n   assign ibar = ibar;\\n   assign o    = i;\\nendmodule // fiftyfivenm_io_ibuf\\n\\n/* Altera Cyclone IV (GX)  devices Output Buffer Primitive */\\nmodule cycloneiv_io_obuf\\n  (output o, input i, input oe);\\n   assign o  = i;\\n   assign oe = oe;\\nendmodule // fiftyfivenm_io_obuf\\n\\n/* Altera Cyclone IV (GX) 4-input non-fracturable LUT Primitive */\\nmodule cycloneiv_lcell_comb\\n  (output combout, cout,\\n   input dataa, datab, datac, datad, cin);\\n\\n   /* Internal parameters which define the behaviour\\n    of the LUT primitive.\\n    lut_mask define the lut function, can be expressed in 16-digit bin or hex.\\n    sum_lutc_input define the type of LUT (combinational | arithmetic).\\n    dont_touch for retiming || carry options.\\n    lpm_type for WYSIWYG */\\n\\n   parameter lut_mask = 16'hFFFF;\\n   parameter dont_touch = \\\"off\\\";\\n   parameter lpm_type = \\\"cycloneiv_lcell_comb\\\";\\n   parameter sum_lutc_input = \\\"datac\\\";\\n\\n   reg [1:0] lut_type;\\n   reg       cout_rt;\\n   reg       combout_rt;\\n   wire      dataa_w;\\n   wire      datab_w;\\n   wire      datac_w;\\n   wire      datad_w;\\n   wire      cin_w;\\n\\n   assign dataa_w = dataa;\\n   assign datab_w = datab;\\n   assign datac_w = datac;\\n   assign datad_w = datad;\\n\\n   function lut_data;\\n      input [15:0] mask;\\n      input        dataa, datab, datac, datad;\\n      reg [7:0]    s3;\\n      reg [3:0]    s2;\\n      reg [1:0]    s1;\\n      begin\\n         s3 = datad ? mask[15:8] : mask[7:0];\\n         s2 = datac ?   s3[7:4]  :   s3[3:0];\\n         s1 = datab ?   s2[3:2]  :   s2[1:0];\\n         lut_data = dataa ? s1[1] : s1[0];\\n      end\\n\\n   endfunction\\n\\n   initial begin\\n      if (sum_lutc_input == \\\"datac\\\") lut_type = 0;\\n      else\\n        if (sum_lutc_input == \\\"cin\\\")   lut_type = 1;\\n        else begin\\n           $error(\\\"Error in sum_lutc_input. Parameter %s is not a valid value.\\\\n\\\", sum_lutc_input);\\n           $finish();\\n        end\\n   end\\n\\n   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin\\n      if (lut_type == 0) begin // logic function\\n         combout_rt = lut_data(lut_mask, dataa_w, datab_w,\\n                               datac_w, datad_w);\\n      end\\n      else if (lut_type == 1) begin // arithmetic function\\n         combout_rt = lut_data(lut_mask, dataa_w, datab_w,\\n                               cin_w, datad_w);\\n      end\\n      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);\\n   end\\n\\n   assign combout = combout_rt & 1'b1;\\n   assign cout = cout_rt & 1'b1;\\n\\nendmodule // cycloneiv_lcell_comb\\n\\n/* Altera D Flip-Flop Primitive */\\nmodule dffeas\\n  (output q,\\n   input d, clk, clrn, prn, ena,\\n   input asdata, aload, sclr, sload);\\n\\n   // Timing simulation is not covered\\n   parameter power_up=\\\"dontcare\\\";\\n   parameter is_wysiwyg=\\\"false\\\";\\n\\n   reg   q_tmp;\\n   wire  reset;\\n   reg [7:0] debug_net;\\n\\n   assign reset       = (prn && sclr && ~clrn && ena);\\n   assign q           = q_tmp & 1'b1;\\n\\n   always @(posedge clk, posedge aload) begin\\n      if(reset)        q_tmp <= 0;\\n      else q_tmp <= d;\\n   end\\n   assign q = q_tmp;\\n\\nendmodule // dffeas\\n\\n/* Cyclone IV GX altpll clearbox model */\\n(* blackbox *)\\nmodule cycloneiv_pll\\n  (inclk,\\n   fbin,\\n   fbout,\\n   clkswitch,\\n   areset,\\n   pfdena,\\n   scanclk,\\n   scandata,\\n   scanclkena,\\n   configupdate,\\n   clk,\\n   phasecounterselect,\\n   phaseupdown,\\n   phasestep,\\n   clkbad,\\n   activeclock,\\n   locked,\\n   scandataout,\\n   scandone,\\n   phasedone,\\n   vcooverrange,\\n   vcounderrange,\\n   fref,\\n   icdrclk);\\n\\n   parameter operation_mode                = \\\"normal\\\";\\n   parameter pll_type                      = \\\"auto\\\";\\n   parameter compensate_clock              = \\\"clock0\\\";\\n   parameter inclk0_input_frequency        = 0;\\n   parameter inclk1_input_frequency        = 0;\\n   parameter self_reset_on_loss_lock       = \\\"off\\\";\\n   parameter switch_over_type              = \\\"auto\\\";\\n   parameter switch_over_counter           = 1;\\n   parameter enable_switch_over_counter    = \\\"off\\\";\\n   parameter bandwidth                     = 0;\\n   parameter bandwidth_type                = \\\"auto\\\";\\n   parameter use_dc_coupling               = \\\"false\\\";\\n   parameter lock_high = 0;\\n   parameter lock_low = 0;\\n   parameter lock_window_ui                = \\\"0.05\\\";\\n   parameter test_bypass_lock_detect       = \\\"off\\\";\\n   parameter clk0_output_frequency         = 0;\\n   parameter clk0_multiply_by              = 0;\\n   parameter clk0_divide_by                = 0;\\n   parameter clk0_phase_shift              = \\\"0\\\";\\n   parameter clk0_duty_cycle               = 50;\\n   parameter clk1_output_frequency         = 0;\\n   parameter clk1_multiply_by              = 0;\\n   parameter clk1_divide_by                = 0;\\n   parameter clk1_phase_shift              = \\\"0\\\";\\n   parameter clk1_duty_cycle               = 50;\\n   parameter clk2_output_frequency         = 0;\\n   parameter clk2_multiply_by              = 0;\\n   parameter clk2_divide_by                = 0;\\n   parameter clk2_phase_shift              = \\\"0\\\";\\n   parameter clk2_duty_cycle               = 50;\\n   parameter clk3_output_frequency         = 0;\\n   parameter clk3_multiply_by              = 0;\\n   parameter clk3_divide_by                = 0;\\n   parameter clk3_phase_shift              = \\\"0\\\";\\n   parameter clk3_duty_cycle               = 50;\\n   parameter clk4_output_frequency         = 0;\\n   parameter clk4_multiply_by              = 0;\\n   parameter clk4_divide_by                = 0;\\n   parameter clk4_phase_shift              = \\\"0\\\";\\n   parameter clk4_duty_cycle               = 50;\\n   parameter pfd_min                       = 0;\\n   parameter pfd_max                       = 0;\\n   parameter vco_min                       = 0;\\n   parameter vco_max                       = 0;\\n   parameter vco_center                    = 0;\\n   // Advanced user parameters\\n   parameter m_initial = 1;\\n   parameter m = 0;\\n   parameter n = 1;\\n   parameter c0_high = 1;\\n   parameter c0_low = 1;\\n   parameter c0_initial = 1;\\n   parameter c0_mode = \\\"bypass\\\";\\n   parameter c0_ph = 0;\\n   parameter c1_high = 1;\\n   parameter c1_low = 1;\\n   parameter c1_initial = 1;\\n   parameter c1_mode = \\\"bypass\\\";\\n   parameter c1_ph = 0;\\n   parameter c2_high = 1;\\n   parameter c2_low = 1;\\n   parameter c2_initial = 1;\\n   parameter c2_mode = \\\"bypass\\\";\\n   parameter c2_ph = 0;\\n   parameter c3_high = 1;\\n   parameter c3_low = 1;\\n   parameter c3_initial = 1;\\n   parameter c3_mode = \\\"bypass\\\";\\n   parameter c3_ph = 0;\\n   parameter c4_high = 1;\\n   parameter c4_low = 1;\\n   parameter c4_initial = 1;\\n   parameter c4_mode = \\\"bypass\\\";\\n   parameter c4_ph = 0;\\n   parameter m_ph = 0;\\n   parameter clk0_counter = \\\"unused\\\";\\n   parameter clk1_counter = \\\"unused\\\";\\n   parameter clk2_counter = \\\"unused\\\";\\n   parameter clk3_counter = \\\"unused\\\";\\n   parameter clk4_counter = \\\"unused\\\";\\n   parameter c1_use_casc_in = \\\"off\\\";\\n   parameter c2_use_casc_in = \\\"off\\\";\\n   parameter c3_use_casc_in = \\\"off\\\";\\n   parameter c4_use_casc_in = \\\"off\\\";\\n   parameter m_test_source  = -1;\\n   parameter c0_test_source = -1;\\n   parameter c1_test_source = -1;\\n   parameter c2_test_source = -1;\\n   parameter c3_test_source = -1;\\n   parameter c4_test_source = -1;\\n   parameter vco_multiply_by = 0;\\n   parameter vco_divide_by = 0;\\n   parameter vco_post_scale = 1;\\n   parameter vco_frequency_control = \\\"auto\\\";\\n   parameter vco_phase_shift_step = 0;\\n   parameter charge_pump_current = 10;\\n   parameter loop_filter_r = \\\"1.0\\\";\\n   parameter loop_filter_c = 0;\\n   parameter pll_compensation_delay = 0;\\n   parameter lpm_type = \\\"cycloneiv_pll\\\";\\n   parameter phase_counter_select_width = 3;\\n\\n   input [1:0] inclk;\\n   input       fbin;\\n   input       clkswitch;\\n   input       areset;\\n   input       pfdena;\\n   input [phase_counter_select_width - 1:0] phasecounterselect;\\n   input                                    phaseupdown;\\n   input                                    phasestep;\\n   input                                    scanclk;\\n   input                                    scanclkena;\\n   input                                    scandata;\\n   input                                    configupdate;\\n\\n   output [4:0]                             clk;\\n   output [1:0]                             clkbad;\\n   output                                   activeclock;\\n   output                                   locked;\\n   output                                   scandataout;\\n   output                                   scandone;\\n   output                                   fbout;\\n   output                                   phasedone;\\n   output                                   vcooverrange;\\n   output                                   vcounderrange;\\n   output                                   fref;\\n   output                                   icdrclk;\\n\\nendmodule // cycloneive_pll\\n\\n\\n\",\n            },\n            \"cycloneive\": {\n                \"cells_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n// > c60k28 (Viacheslav, VT) [at] yandex [dot] com\\n// > Intel FPGA technology mapping. User must first simulate the generated \\\\\\n// > netlist before going to test it on board.\\n\\n// Input buffer map\\nmodule \\\\$__inpad (input I, output O);\\n   cycloneive_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));\\nendmodule\\n\\n// Output buffer map\\nmodule \\\\$__outpad (input I, output O);\\n   cycloneive_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));\\nendmodule\\n\\n// LUT Map\\n/* 0 -> datac\\n 1 -> cin */\\nmodule \\\\$lut (A, Y);\\n   parameter WIDTH  = 0;\\n   parameter LUT    = 0;\\n   (* force_downto *)\\n   input [WIDTH-1:0] A;\\n   output            Y;\\n   generate\\n      if (WIDTH == 1) begin\\n\\t assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function\\n      end else\\n        if (WIDTH == 2) begin\\n           cycloneive_lcell_comb #(.lut_mask({4{LUT}}),\\n                                   .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y),\\n                                                                                .dataa(A[0]),\\n                                                                                .datab(A[1]),\\n                                                                                .datac(1'b1),\\n                                                                                .datad(1'b1));\\n        end else\\n          if(WIDTH == 3) begin\\n\\t     cycloneive_lcell_comb #(.lut_mask({2{LUT}}),\\n                                     .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y),\\n                                                                                  .dataa(A[0]),\\n                                                                                  .datab(A[1]),\\n                                                                                  .datac(A[2]),\\n                                                                                  .datad(1'b1));\\n          end else\\n            if(WIDTH == 4) begin\\n\\t       cycloneive_lcell_comb #(.lut_mask(LUT),\\n                                       .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y),\\n                                                                                    .dataa(A[0]),\\n                                                                                    .datab(A[1]),\\n                                                                                    .datac(A[2]),\\n                                                                                    .datad(A[3]));\\n            end else\\n\\t             wire _TECHMAP_FAIL_ = 1;\\n   endgenerate\\n\\nendmodule\\n\\n\\n\",\n                \"cells_sim.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\nmodule VCC (output V);\\n   assign V = 1'b1;\\nendmodule // VCC\\n\\nmodule GND (output G);\\n   assign G = 1'b0;\\nendmodule // GND\\n\\n/* Altera Cyclone IV (E) devices Input Buffer Primitive */\\nmodule cycloneive_io_ibuf\\n  (output o, input i, input ibar);\\n   assign ibar = ibar;\\n   assign o    = i;\\nendmodule // fiftyfivenm_io_ibuf\\n\\n/* Altera Cyclone IV (E)  devices Output Buffer Primitive */\\nmodule cycloneive_io_obuf\\n  (output o, input i, input oe);\\n   assign o  = i;\\n   assign oe = oe;\\nendmodule // fiftyfivenm_io_obuf\\n\\n/* Altera Cyclone IV (E) 4-input non-fracturable LUT Primitive */\\nmodule cycloneive_lcell_comb\\n  (output combout, cout,\\n   input dataa, datab, datac, datad, cin);\\n\\n   /* Internal parameters which define the behaviour\\n    of the LUT primitive.\\n    lut_mask define the lut function, can be expressed in 16-digit bin or hex.\\n    sum_lutc_input define the type of LUT (combinational | arithmetic).\\n    dont_touch for retiming || carry options.\\n    lpm_type for WYSIWYG */\\n\\n   parameter lut_mask   = 16'hFFFF;\\n   parameter dont_touch = \\\"off\\\";\\n   parameter lpm_type   = \\\"cycloneive_lcell_comb\\\";\\n   parameter sum_lutc_input = \\\"datac\\\";\\n\\n   reg [1:0]                        lut_type;\\n   reg                              cout_rt;\\n   reg                              combout_rt;\\n   wire                             dataa_w;\\n   wire                             datab_w;\\n   wire                             datac_w;\\n   wire                             datad_w;\\n   wire                             cin_w;\\n\\n   assign dataa_w = dataa;\\n   assign datab_w = datab;\\n   assign datac_w = datac;\\n   assign datad_w = datad;\\n\\n   function lut_data;\\n      input [15:0]                  mask;\\n      input                         dataa, datab, datac, datad;\\n      reg [7:0]                     s3;\\n      reg [3:0]                     s2;\\n      reg [1:0]                     s1;\\n      begin\\n         s3 = datad ? mask[15:8] : mask[7:0];\\n         s2 = datac ?   s3[7:4]  :   s3[3:0];\\n         s1 = datab ?   s2[3:2]  :   s2[1:0];\\n         lut_data = dataa ? s1[1] : s1[0];\\n      end\\n\\n   endfunction\\n\\n   initial begin\\n      if (sum_lutc_input == \\\"datac\\\") lut_type = 0;\\n      else\\n        if (sum_lutc_input == \\\"cin\\\")   lut_type = 1;\\n        else begin\\n           $error(\\\"Error in sum_lutc_input. Parameter %s is not a valid value.\\\\n\\\", sum_lutc_input);\\n           $finish();\\n        end\\n   end\\n\\n   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin\\n      if (lut_type == 0) begin // logic function\\n         combout_rt = lut_data(lut_mask, dataa_w, datab_w,\\n                               datac_w, datad_w);\\n      end\\n      else if (lut_type == 1) begin // arithmetic function\\n         combout_rt = lut_data(lut_mask, dataa_w, datab_w,\\n                               cin_w, datad_w);\\n      end\\n      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);\\n   end\\n\\n   assign combout = combout_rt & 1'b1;\\n   assign cout = cout_rt & 1'b1;\\n\\nendmodule // cycloneive_lcell_comb\\n\\n/* Altera D Flip-Flop Primitive */\\nmodule dffeas\\n  (output q,\\n   input d, clk, clrn, prn, ena,\\n   input asdata, aload, sclr, sload);\\n\\n   // Timing simulation is not covered\\n   parameter power_up=\\\"dontcare\\\";\\n   parameter is_wysiwyg=\\\"false\\\";\\n\\n   reg   q_tmp;\\n   wire  reset;\\n   reg [7:0] debug_net;\\n\\n   assign reset       = (prn && sclr && ~clrn && ena);\\n   assign q           = q_tmp & 1'b1;\\n\\n   always @(posedge clk, posedge aload) begin\\n      if(reset)        q_tmp <= 0;\\n      else q_tmp <= d;\\n   end\\n   assign q = q_tmp;\\n\\nendmodule // dffeas\\n\\n/* Cyclone IV E altpll clearbox model */\\n(* blackbox *)\\nmodule cycloneive_pll\\n  (inclk,\\n   fbin,\\n   fbout,\\n   clkswitch,\\n   areset,\\n   pfdena,\\n   scanclk,\\n   scandata,\\n   scanclkena,\\n   configupdate,\\n   clk,\\n   phasecounterselect,\\n   phaseupdown,\\n   phasestep,\\n   clkbad,\\n   activeclock,\\n   locked,\\n   scandataout,\\n   scandone,\\n   phasedone,\\n   vcooverrange,\\n   vcounderrange);\\n\\n   parameter operation_mode                = \\\"normal\\\";\\n   parameter pll_type                      = \\\"auto\\\";\\n   parameter compensate_clock              = \\\"clock0\\\";\\n   parameter inclk0_input_frequency        = 0;\\n   parameter inclk1_input_frequency        = 0;\\n   parameter self_reset_on_loss_lock       = \\\"off\\\";\\n   parameter switch_over_type              = \\\"auto\\\";\\n   parameter switch_over_counter           = 1;\\n   parameter enable_switch_over_counter    = \\\"off\\\";\\n   parameter bandwidth                     = 0;\\n   parameter bandwidth_type                = \\\"auto\\\";\\n   parameter use_dc_coupling               = \\\"false\\\";\\n   parameter lock_high = 0;\\n   parameter lock_low = 0;\\n   parameter lock_window_ui                = \\\"0.05\\\";\\n   parameter test_bypass_lock_detect       = \\\"off\\\";\\n   parameter clk0_output_frequency         = 0;\\n   parameter clk0_multiply_by              = 0;\\n   parameter clk0_divide_by                = 0;\\n   parameter clk0_phase_shift              = \\\"0\\\";\\n   parameter clk0_duty_cycle               = 50;\\n   parameter clk1_output_frequency         = 0;\\n   parameter clk1_multiply_by              = 0;\\n   parameter clk1_divide_by                = 0;\\n   parameter clk1_phase_shift              = \\\"0\\\";\\n   parameter clk1_duty_cycle               = 50;\\n   parameter clk2_output_frequency         = 0;\\n   parameter clk2_multiply_by              = 0;\\n   parameter clk2_divide_by                = 0;\\n   parameter clk2_phase_shift              = \\\"0\\\";\\n   parameter clk2_duty_cycle               = 50;\\n   parameter clk3_output_frequency         = 0;\\n   parameter clk3_multiply_by              = 0;\\n   parameter clk3_divide_by                = 0;\\n   parameter clk3_phase_shift              = \\\"0\\\";\\n   parameter clk3_duty_cycle               = 50;\\n   parameter clk4_output_frequency         = 0;\\n   parameter clk4_multiply_by              = 0;\\n   parameter clk4_divide_by                = 0;\\n   parameter clk4_phase_shift              = \\\"0\\\";\\n   parameter clk4_duty_cycle               = 50;\\n   parameter pfd_min                       = 0;\\n   parameter pfd_max                       = 0;\\n   parameter vco_min                       = 0;\\n   parameter vco_max                       = 0;\\n   parameter vco_center                    = 0;\\n   // Advanced user parameters\\n   parameter m_initial = 1;\\n   parameter m = 0;\\n   parameter n = 1;\\n   parameter c0_high = 1;\\n   parameter c0_low = 1;\\n   parameter c0_initial = 1;\\n   parameter c0_mode = \\\"bypass\\\";\\n   parameter c0_ph = 0;\\n   parameter c1_high = 1;\\n   parameter c1_low = 1;\\n   parameter c1_initial = 1;\\n   parameter c1_mode = \\\"bypass\\\";\\n   parameter c1_ph = 0;\\n   parameter c2_high = 1;\\n   parameter c2_low = 1;\\n   parameter c2_initial = 1;\\n   parameter c2_mode = \\\"bypass\\\";\\n   parameter c2_ph = 0;\\n   parameter c3_high = 1;\\n   parameter c3_low = 1;\\n   parameter c3_initial = 1;\\n   parameter c3_mode = \\\"bypass\\\";\\n   parameter c3_ph = 0;\\n   parameter c4_high = 1;\\n   parameter c4_low = 1;\\n   parameter c4_initial = 1;\\n   parameter c4_mode = \\\"bypass\\\";\\n   parameter c4_ph = 0;\\n   parameter m_ph = 0;\\n   parameter clk0_counter = \\\"unused\\\";\\n   parameter clk1_counter = \\\"unused\\\";\\n   parameter clk2_counter = \\\"unused\\\";\\n   parameter clk3_counter = \\\"unused\\\";\\n   parameter clk4_counter = \\\"unused\\\";\\n   parameter c1_use_casc_in = \\\"off\\\";\\n   parameter c2_use_casc_in = \\\"off\\\";\\n   parameter c3_use_casc_in = \\\"off\\\";\\n   parameter c4_use_casc_in = \\\"off\\\";\\n   parameter m_test_source  = -1;\\n   parameter c0_test_source = -1;\\n   parameter c1_test_source = -1;\\n   parameter c2_test_source = -1;\\n   parameter c3_test_source = -1;\\n   parameter c4_test_source = -1;\\n   parameter vco_multiply_by = 0;\\n   parameter vco_divide_by = 0;\\n   parameter vco_post_scale = 1;\\n   parameter vco_frequency_control = \\\"auto\\\";\\n   parameter vco_phase_shift_step = 0;\\n   parameter charge_pump_current = 10;\\n   parameter loop_filter_r = \\\"1.0\\\";\\n   parameter loop_filter_c = 0;\\n   parameter pll_compensation_delay = 0;\\n   parameter lpm_type = \\\"cycloneive_pll\\\";\\n   parameter phase_counter_select_width = 3;\\n\\n   input [1:0] inclk;\\n   input       fbin;\\n   input       clkswitch;\\n   input       areset;\\n   input       pfdena;\\n   input [phase_counter_select_width - 1:0] phasecounterselect;\\n   input                                    phaseupdown;\\n   input                                    phasestep;\\n   input                                    scanclk;\\n   input                                    scanclkena;\\n   input                                    scandata;\\n   input                                    configupdate;\\n\\n   output [4:0]                             clk;\\n   output [1:0]                             clkbad;\\n   output                                   activeclock;\\n   output                                   locked;\\n   output                                   scandataout;\\n   output                                   scandone;\\n   output                                   fbout;\\n   output                                   phasedone;\\n   output                                   vcooverrange;\\n   output                                   vcounderrange;\\n\\nendmodule // cycloneive_pll\\n\",\n            },\n            \"max10\": {\n                \"cells_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n// > c60k28 (Viacheslav, VT) [at] yandex [dot] com\\n// > Intel FPGA technology mapping. User must first simulate the generated \\\\\\n// > netlist before going to test it on board.\\n\\n// Input buffer map\\nmodule \\\\$__inpad (input I, output O);\\n   fiftyfivenm_io_ibuf _TECHMAP_REPLACE_ (.o(O), .i(I), .ibar(1'b0));\\nendmodule\\n\\n// Output buffer map\\nmodule \\\\$__outpad (input I, output O);\\n   fiftyfivenm_io_obuf _TECHMAP_REPLACE_ (.o(O), .i(I), .oe(1'b1));\\nendmodule\\n\\n// LUT Map\\n/* 0 -> datac\\n   1 -> cin */\\nmodule \\\\$lut (A, Y);\\n   parameter WIDTH  = 0;\\n   parameter LUT    = 0;\\n   (* force_downto *)\\n   input [WIDTH-1:0] A;\\n   output            Y;\\n   generate\\n      if (WIDTH == 1) begin\\n\\t   assign Y = ~A[0]; // Not need to spend 1 logic cell for such an easy function\\n      end else\\n      if (WIDTH == 2) begin\\n           fiftyfivenm_lcell_comb #(.lut_mask({4{LUT}}), .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(1'b1),.datad(1'b1));\\n      end else\\n      if(WIDTH == 3) begin\\n\\t      fiftyfivenm_lcell_comb #(.lut_mask({2{LUT}}), .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(1'b1));\\n      end else\\n      if(WIDTH == 4) begin\\n         fiftyfivenm_lcell_comb #(.lut_mask(LUT), .sum_lutc_input(\\\"datac\\\")) _TECHMAP_REPLACE_ (.combout(Y), .dataa(A[0]), .datab(A[1]), .datac(A[2]),.datad(A[3]));\\n      end else\\n\\t   wire _TECHMAP_FAIL_ = 1;\\n   endgenerate\\nendmodule //\\n\\n\\n\",\n                \"cells_sim.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\nmodule VCC (output V);\\n   assign V = 1'b1;\\nendmodule // VCC\\n\\nmodule GND (output G);\\n   assign G = 1'b0;\\nendmodule // GND\\n\\n/* Altera MAX10 devices Input Buffer Primitive */\\nmodule fiftyfivenm_io_ibuf\\n  (output o, input i, input ibar);\\n   assign ibar = ibar;\\n   assign o    = i;\\nendmodule // fiftyfivenm_io_ibuf\\n\\n/* Altera MAX10 devices Output Buffer Primitive */\\nmodule fiftyfivenm_io_obuf\\n  (output o, input i, input oe);\\n   assign o  = i;\\n   assign oe = oe;\\nendmodule // fiftyfivenm_io_obuf\\n\\n/* Altera MAX10 4-input non-fracturable LUT Primitive */\\nmodule fiftyfivenm_lcell_comb\\n  (output combout, cout,\\n   input dataa, datab, datac, datad, cin);\\n\\n   /* Internal parameters which define the behaviour\\n    of the LUT primitive.\\n    lut_mask define the lut function, can be expressed in 16-digit bin or hex.\\n    sum_lutc_input define the type of LUT (combinational | arithmetic).\\n    dont_touch for retiming || carry options.\\n    lpm_type for WYSIWYG */\\n\\n   parameter lut_mask = 16'hFFFF;\\n   parameter dont_touch = \\\"off\\\";\\n   parameter lpm_type = \\\"fiftyfivenm_lcell_comb\\\";\\n   parameter sum_lutc_input = \\\"datac\\\";\\n\\n   reg [1:0] lut_type;\\n   reg       cout_rt;\\n   reg       combout_rt;\\n   wire      dataa_w;\\n   wire      datab_w;\\n   wire      datac_w;\\n   wire      datad_w;\\n   wire      cin_w;\\n\\n   assign dataa_w = dataa;\\n   assign datab_w = datab;\\n   assign datac_w = datac;\\n   assign datad_w = datad;\\n\\n   function lut_data;\\n      input [15:0] mask;\\n      input        dataa, datab, datac, datad;\\n      reg [7:0]    s3;\\n      reg [3:0]    s2;\\n      reg [1:0]    s1;\\n      begin\\n         s3 = datad ? mask[15:8] : mask[7:0];\\n         s2 = datac ?   s3[7:4]  :   s3[3:0];\\n         s1 = datab ?   s2[3:2]  :   s2[1:0];\\n         lut_data = dataa ? s1[1] : s1[0];\\n      end\\n\\n   endfunction\\n\\n   initial begin\\n      if (sum_lutc_input == \\\"datac\\\") lut_type = 0;\\n      else\\n        if (sum_lutc_input == \\\"cin\\\")   lut_type = 1;\\n        else begin\\n           $error(\\\"Error in sum_lutc_input. Parameter %s is not a valid value.\\\\n\\\", sum_lutc_input);\\n           $finish();\\n        end\\n   end\\n\\n   always @(dataa_w or datab_w or datac_w or datad_w or cin_w) begin\\n      if (lut_type == 0) begin // logic function\\n         combout_rt = lut_data(lut_mask, dataa_w, datab_w,\\n                               datac_w, datad_w);\\n      end\\n      else if (lut_type == 1) begin // arithmetic function\\n         combout_rt = lut_data(lut_mask, dataa_w, datab_w,\\n                               cin_w, datad_w);\\n      end\\n      cout_rt = lut_data(lut_mask, dataa_w, datab_w, cin_w, 'b0);\\n   end\\n\\n   assign combout = combout_rt & 1'b1;\\n   assign cout = cout_rt & 1'b1;\\n\\nendmodule // fiftyfivenm_lcell_comb\\n\\n/* Altera D Flip-Flop Primitive */\\nmodule dffeas\\n  (output q,\\n   input d, clk, clrn, prn, ena,\\n   input asdata, aload, sclr, sload);\\n\\n   // Timing simulation is not covered\\n   parameter power_up=\\\"dontcare\\\";\\n   parameter is_wysiwyg=\\\"false\\\";\\n\\n   reg   q_tmp;\\n   wire  reset;\\n   reg [7:0] debug_net;\\n\\n   assign reset       = (prn && sclr && ~clrn && ena);\\n   assign q           = q_tmp & 1'b1;\\n\\n   always @(posedge clk, posedge aload) begin\\n      if(reset)        q_tmp <= 0;\\n      else q_tmp <= d;\\n   end\\n   assign q = q_tmp;\\n\\nendmodule // dffeas\\n\\n/* MAX10 altpll clearbox model */\\n(* blackbox *)\\nmodule fiftyfivenm_pll\\n  (inclk,\\n   fbin,\\n   fbout,\\n   clkswitch,\\n   areset,\\n   pfdena,\\n   scanclk,\\n   scandata,\\n   scanclkena,\\n   configupdate,\\n   clk,\\n   phasecounterselect,\\n   phaseupdown,\\n   phasestep,\\n   clkbad,\\n   activeclock,\\n   locked,\\n   scandataout,\\n   scandone,\\n   phasedone,\\n   vcooverrange,\\n   vcounderrange);\\n\\n   parameter operation_mode                = \\\"normal\\\";\\n   parameter pll_type                      = \\\"auto\\\";\\n   parameter compensate_clock              = \\\"clock0\\\";\\n   parameter inclk0_input_frequency        = 0;\\n   parameter inclk1_input_frequency        = 0;\\n   parameter self_reset_on_loss_lock       = \\\"off\\\";\\n   parameter switch_over_type              = \\\"auto\\\";\\n   parameter switch_over_counter           = 1;\\n   parameter enable_switch_over_counter    = \\\"off\\\";\\n   parameter bandwidth                     = 0;\\n   parameter bandwidth_type                = \\\"auto\\\";\\n   parameter use_dc_coupling               = \\\"false\\\";\\n   parameter lock_high = 0;\\n   parameter lock_low = 0;\\n   parameter lock_window_ui                = \\\"0.05\\\";\\n   parameter test_bypass_lock_detect       = \\\"off\\\";\\n   parameter clk0_output_frequency         = 0;\\n   parameter clk0_multiply_by              = 0;\\n   parameter clk0_divide_by                = 0;\\n   parameter clk0_phase_shift              = \\\"0\\\";\\n   parameter clk0_duty_cycle               = 50;\\n   parameter clk1_output_frequency         = 0;\\n   parameter clk1_multiply_by              = 0;\\n   parameter clk1_divide_by                = 0;\\n   parameter clk1_phase_shift              = \\\"0\\\";\\n   parameter clk1_duty_cycle               = 50;\\n   parameter clk2_output_frequency         = 0;\\n   parameter clk2_multiply_by              = 0;\\n   parameter clk2_divide_by                = 0;\\n   parameter clk2_phase_shift              = \\\"0\\\";\\n   parameter clk2_duty_cycle               = 50;\\n   parameter clk3_output_frequency         = 0;\\n   parameter clk3_multiply_by              = 0;\\n   parameter clk3_divide_by                = 0;\\n   parameter clk3_phase_shift              = \\\"0\\\";\\n   parameter clk3_duty_cycle               = 50;\\n   parameter clk4_output_frequency         = 0;\\n   parameter clk4_multiply_by              = 0;\\n   parameter clk4_divide_by                = 0;\\n   parameter clk4_phase_shift              = \\\"0\\\";\\n   parameter clk4_duty_cycle               = 50;\\n   parameter pfd_min                       = 0;\\n   parameter pfd_max                       = 0;\\n   parameter vco_min                       = 0;\\n   parameter vco_max                       = 0;\\n   parameter vco_center                    = 0;\\n   // Advanced user parameters\\n   parameter m_initial = 1;\\n   parameter m = 0;\\n   parameter n = 1;\\n   parameter c0_high = 1;\\n   parameter c0_low = 1;\\n   parameter c0_initial = 1;\\n   parameter c0_mode = \\\"bypass\\\";\\n   parameter c0_ph = 0;\\n   parameter c1_high = 1;\\n   parameter c1_low = 1;\\n   parameter c1_initial = 1;\\n   parameter c1_mode = \\\"bypass\\\";\\n   parameter c1_ph = 0;\\n   parameter c2_high = 1;\\n   parameter c2_low = 1;\\n   parameter c2_initial = 1;\\n   parameter c2_mode = \\\"bypass\\\";\\n   parameter c2_ph = 0;\\n   parameter c3_high = 1;\\n   parameter c3_low = 1;\\n   parameter c3_initial = 1;\\n   parameter c3_mode = \\\"bypass\\\";\\n   parameter c3_ph = 0;\\n   parameter c4_high = 1;\\n   parameter c4_low = 1;\\n   parameter c4_initial = 1;\\n   parameter c4_mode = \\\"bypass\\\";\\n   parameter c4_ph = 0;\\n   parameter m_ph = 0;\\n   parameter clk0_counter = \\\"unused\\\";\\n   parameter clk1_counter = \\\"unused\\\";\\n   parameter clk2_counter = \\\"unused\\\";\\n   parameter clk3_counter = \\\"unused\\\";\\n   parameter clk4_counter = \\\"unused\\\";\\n   parameter c1_use_casc_in = \\\"off\\\";\\n   parameter c2_use_casc_in = \\\"off\\\";\\n   parameter c3_use_casc_in = \\\"off\\\";\\n   parameter c4_use_casc_in = \\\"off\\\";\\n   parameter m_test_source  = -1;\\n   parameter c0_test_source = -1;\\n   parameter c1_test_source = -1;\\n   parameter c2_test_source = -1;\\n   parameter c3_test_source = -1;\\n   parameter c4_test_source = -1;\\n   parameter vco_multiply_by = 0;\\n   parameter vco_divide_by = 0;\\n   parameter vco_post_scale = 1;\\n   parameter vco_frequency_control = \\\"auto\\\";\\n   parameter vco_phase_shift_step = 0;\\n   parameter charge_pump_current = 10;\\n   parameter loop_filter_r = \\\"1.0\\\";\\n   parameter loop_filter_c = 0;\\n   parameter pll_compensation_delay = 0;\\n   parameter lpm_type = \\\"fiftyfivenm_pll\\\";\\n   parameter phase_counter_select_width = 3;\\n\\n   input [1:0] inclk;\\n   input       fbin;\\n   input       clkswitch;\\n   input       areset;\\n   input       pfdena;\\n   input [phase_counter_select_width - 1:0] phasecounterselect;\\n   input                                    phaseupdown;\\n   input                                    phasestep;\\n   input                                    scanclk;\\n   input                                    scanclkena;\\n   input                                    scandata;\\n   input                                    configupdate;\\n   output [4:0]                             clk;\\n   output [1:0]                             clkbad;\\n   output                                   activeclock;\\n   output                                   locked;\\n   output                                   scandataout;\\n   output                                   scandone;\\n   output                                   fbout;\\n   output                                   phasedone;\\n   output                                   vcooverrange;\\n   output                                   vcounderrange;\\n\\nendmodule // cycloneive_pll\\n\",\n            },\n        },\n        \"intel_alm\": {\n            \"common\": {\n                \"abc9_map.v\": \"// This file exists to map purely-synchronous flops to ABC9 flops, while \\n// mapping flops with asynchronous-clear as boxes, this is because ABC9 \\n// doesn't support asynchronous-clear flops in sequential synthesis.\\n\\nmodule MISTRAL_FF(\\n    input DATAIN, CLK, ACLR, ENA, SCLR, SLOAD, SDATA,\\n    output reg Q\\n);\\n\\nparameter _TECHMAP_CONSTMSK_ACLR_ = 1'b0;\\n\\n// If the async-clear is constant, we assume it's disabled.\\nif (_TECHMAP_CONSTMSK_ACLR_ != 1'b0)\\n    $__MISTRAL_FF_SYNCONLY _TECHMAP_REPLACE_ (.DATAIN(DATAIN), .CLK(CLK), .ENA(ENA), .SCLR(SCLR), .SLOAD(SLOAD), .SDATA(SDATA), .Q(Q));\\nelse\\n    wire _TECHMAP_FAIL_ = 1;\\n\\nendmodule\\n\",\n                \"abc9_model.v\": \"// This is a purely-synchronous flop, that ABC9 can use for sequential synthesis.\\n(* abc9_flop, lib_whitebox *)\\nmodule $__MISTRAL_FF_SYNCONLY (\\n    input DATAIN, CLK, ENA, SCLR, SLOAD, SDATA,\\n    output reg Q\\n);\\n\\nMISTRAL_FF ff (.DATAIN(DATAIN), .CLK(CLK), .ENA(ENA), .ACLR(1'b1), .SCLR(SCLR), .SLOAD(SLOAD), .SDATA(SDATA), .Q(Q));\\n\\nendmodule\\n\",\n                \"abc9_unmap.v\": \"// After performing sequential synthesis, map the synchronous flops back to\\n// standard MISTRAL_FF flops.\\n\\nmodule $__MISTRAL_FF_SYNCONLY (\\n    input DATAIN, CLK, ENA, SCLR, SLOAD, SDATA,\\n    output reg Q\\n);\\n\\nMISTRAL_FF _TECHMAP_REPLACE_ (.DATAIN(DATAIN), .CLK(CLK), .ACLR(1'b1), .ENA(ENA), .SCLR(SCLR), .SLOAD(SLOAD), .SDATA(SDATA), .Q(Q));\\n\\nendmodule\\n\",\n                \"alm_map.v\": \"module \\\\$lut (A, Y);\\n\\nparameter WIDTH = 1;\\nparameter LUT = 0;\\n\\n(* force_downto *)\\ninput [WIDTH-1:0] A;\\noutput Y;\\n\\ngenerate\\n    if (WIDTH == 1) begin\\n        generate\\n            if (LUT == 2'b00) begin\\n                assign Y = 1'b0;\\n            end\\n            else if (LUT == 2'b01) begin\\n                MISTRAL_NOT _TECHMAP_REPLACE_(\\n                    .A(A[0]), .Q(Y)\\n                );\\n            end\\n            else if (LUT == 2'b10) begin\\n                assign Y = A;\\n            end\\n            else if (LUT == 2'b11) begin\\n                assign Y = 1'b1;\\n            end\\n        endgenerate\\n    end else\\n    if (WIDTH == 2) begin\\n        MISTRAL_ALUT2 #(.LUT(LUT)) _TECHMAP_REPLACE_(\\n            .A(A[0]), .B(A[1]), .Q(Y)\\n        );\\n    end else\\n    if (WIDTH == 3) begin\\n        MISTRAL_ALUT3 #(.LUT(LUT)) _TECHMAP_REPLACE_(\\n            .A(A[0]), .B(A[1]), .C(A[2]), .Q(Y)\\n        );\\n    end else\\n    if (WIDTH == 4) begin\\n        MISTRAL_ALUT4 #(.LUT(LUT)) _TECHMAP_REPLACE_(\\n            .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .Q(Y)\\n        );\\n    end else\\n    if (WIDTH == 5) begin\\n        MISTRAL_ALUT5 #(.LUT(LUT)) _TECHMAP_REPLACE_ (\\n            .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .E(A[4]), .Q(Y)\\n        );\\n    end else\\n    if (WIDTH == 6) begin\\n        MISTRAL_ALUT6 #(.LUT(LUT)) _TECHMAP_REPLACE_ (\\n            .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]), .E(A[4]), .F(A[5]), .Q(Y)\\n        );\\n    end else begin\\n        wire _TECHMAP_FAIL_ = 1'b1;\\n    end\\nendgenerate\\nendmodule\\n\",\n                \"alm_sim.v\": \"// The core logic primitive of the Cyclone V/10GX is the Adaptive Logic Module\\n// (ALM). Each ALM is made up of an 8-input, 2-output look-up table, covered\\n// in this file, connected to combinational outputs, a carry chain, and four\\n// D flip-flops (which are covered as MISTRAL_FF in dff_sim.v).\\n//\\n// The ALM is vertically symmetric, so I find it helps to think in terms of\\n// half-ALMs, as that's predominantly the unit that synth_intel_alm uses.\\n//\\n// ALMs are quite flexible, having multiple modes.\\n//\\n// Normal (combinational) mode\\n// ---------------------------\\n// The ALM can implement:\\n// - a single 6-input function (with the other inputs usable for flip-flop access)\\n// - two 5-input functions that share two inputs\\n// - a 5-input and a 4-input function that share one input\\n// - a 5-input and a 3-or-less-input function that share no inputs\\n// - two 4-or-less-input functions that share no inputs\\n//\\n// Normal-mode functions are represented as MISTRAL_ALUTN cells with N inputs.\\n// It would be possible to represent a normal mode function as a single cell -\\n// the vendor cyclone{v,10gx}_lcell_comb cell does exactly that - but I felt\\n// it was more user-friendly to print out the specific function sizes\\n// separately.\\n//\\n// With the exception of MISTRAL_ALUT6, you can think of two normal-mode cells\\n// fitting inside a single ALM.\\n//\\n// Extended (7-input) mode\\n// -----------------------\\n// The ALM can also fit a 7-input function made of two 5-input functions that\\n// share four inputs, multiplexed by another input.\\n//\\n// Because this can't accept arbitrary 7-input functions, Yosys can't handle\\n// it, so it doesn't have a cell, but I would likely call it MISTRAL_ALUT7(E?)\\n// if it did, and it would take up a full ALM.\\n//\\n// It might be possible to add an extraction pass to examine all ALUT5 cells\\n// that feed into ALUT3 cells to see if they can be combined into an extended\\n// ALM, but I don't think it will be worth it.\\n//\\n// Arithmetic mode\\n// ---------------\\n// In arithmetic mode, each half-ALM uses its carry chain to perform fast addition\\n// of two four-input functions that share three inputs. Oddly, the result of\\n// one of the functions is inverted before being added (you can see this as\\n// the dot on a full-adder input of Figure 1-8 in the Handbook).\\n//\\n// The cell for an arithmetic-mode half-ALM is MISTRAL_ALM_ARITH. One idea\\n// I've had (or rather was suggested by mwk) is that functions that feed into\\n// arithmetic-mode cells could be packed directly into the arithmetic-mode\\n// cell as a function, which reduces the number of ALMs needed.\\n//\\n// Shared arithmetic mode\\n// ----------------------\\n// Shared arithmetic mode looks a lot like arithmetic mode, but here the\\n// output of every other four-input function goes to the input of the adder\\n// the next bit along. What this means is that adding three bits together can\\n// be done in an ALM, because functions can be used to implement addition that\\n// then feeds into the carry chain. This means that three bits can be added per\\n// ALM, as opposed to two in the arithmetic mode.\\n//\\n// Shared arithmetic mode doesn't currently have a cell, but I intend to add\\n// it as MISTRAL_ALM_SHARED, and have it occupy a full ALM. Because it adds\\n// three bits per cell, it makes addition shorter and use less ALMs, but\\n// I don't know enough to tell whether it's more efficient to use shared\\n// arithmetic mode to shorten the carry chain, or plain arithmetic mode with\\n// the functions packed in.\\n\\n`default_nettype none\\n\\n// Cyclone V LUT output timings (picoseconds):\\n//\\n//          CARRY   A    B    C   D   E    F   G\\n//  COMBOUT    -  605  583  510 512   -   97 400 (LUT6)\\n//  COMBOUT    -  602  583  457 510 302   93 483 (LUT7)\\n//   SUMOUT  368 1342 1323  887 927   -  785   -\\n// CARRYOUT   71 1082 1062  866 813   - 1198   -\\n\\n// Arria V LUT output timings (picoseconds):\\n//\\n//          CARRY   A    B    C   D   E    F   G\\n//  COMBOUT    -  387  375  316 317   -   76 319 (LUT6)\\n//  COMBOUT    -  387  375  316 317 218   76 319 (LUT7)\\n//   SUMOUT  249  744  732  562 576   -  511   -\\n// CARRYOUT   19  629  623  530 514   -  696   -\\n\\n(* abc9_lut=2, lib_whitebox *)\\nmodule MISTRAL_ALUT6(input A, B, C, D, E, F, output Q);\\n\\nparameter [63:0] LUT = 64'h0000_0000_0000_0000;\\n\\n`ifdef cyclonev\\nspecify\\n    (A => Q) = 605;\\n    (B => Q) = 583;\\n    (C => Q) = 510;\\n    (D => Q) = 512;\\n    (E => Q) = 400;\\n    (F => Q) = 97;\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    (A => Q) = 387;\\n    (B => Q) = 375;\\n    (C => Q) = 316;\\n    (D => Q) = 317;\\n    (E => Q) = 319;\\n    (F => Q) = 76;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\nspecify\\n    (A => Q) = 275;\\n    (B => Q) = 272;\\n    (C => Q) = 175;\\n    (D => Q) = 165;\\n    (E => Q) = 162;\\n    (F => Q) = 53;\\nendspecify\\n`endif\\n\\nassign Q = LUT >> {F, E, D, C, B, A};\\n\\nendmodule\\n\\n\\n(* abc9_lut=1, lib_whitebox *)\\nmodule MISTRAL_ALUT5(input A, B, C, D, E, output Q);\\n\\nparameter [31:0] LUT = 32'h0000_0000;\\n\\n`ifdef cyclonev\\nspecify\\n    (A => Q) = 583;\\n    (B => Q) = 510;\\n    (C => Q) = 512;\\n    (D => Q) = 400;\\n    (E => Q) = 97;\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    (A => Q) = 375;\\n    (B => Q) = 316;\\n    (C => Q) = 317;\\n    (D => Q) = 319;\\n    (E => Q) = 76;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\nspecify\\n    (A => Q) = 272;\\n    (B => Q) = 175;\\n    (C => Q) = 165;\\n    (D => Q) = 162;\\n    (E => Q) = 53;\\nendspecify\\n`endif\\n\\nassign Q = LUT >> {E, D, C, B, A};\\n\\nendmodule\\n\\n\\n(* abc9_lut=1, lib_whitebox *)\\nmodule MISTRAL_ALUT4(input A, B, C, D, output Q);\\n\\nparameter [15:0] LUT = 16'h0000;\\n\\n`ifdef cyclonev\\nspecify\\n    (A => Q) = 510;\\n    (B => Q) = 512;\\n    (C => Q) = 400;\\n    (D => Q) = 97;\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    (A => Q) = 316;\\n    (B => Q) = 317;\\n    (C => Q) = 319;\\n    (D => Q) = 76;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\nspecify\\n    (A => Q) = 175;\\n    (B => Q) = 165;\\n    (C => Q) = 162;\\n    (D => Q) = 53;\\nendspecify\\n`endif\\n\\nassign Q = LUT >> {D, C, B, A};\\n\\nendmodule\\n\\n\\n(* abc9_lut=1, lib_whitebox *)\\nmodule MISTRAL_ALUT3(input A, B, C, output Q);\\n\\nparameter [7:0] LUT = 8'h00;\\n\\n`ifdef cyclonev\\nspecify\\n    (A => Q) = 510;\\n    (B => Q) = 400;\\n    (C => Q) = 97;\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    (A => Q) = 316;\\n    (B => Q) = 317;\\n    (C => Q) = 76;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\nspecify\\n    (A => Q) = 165;\\n    (B => Q) = 162;\\n    (C => Q) = 53;\\nendspecify\\n`endif\\n\\nassign Q = LUT >> {C, B, A};\\n\\nendmodule\\n\\n\\n(* abc9_lut=1, lib_whitebox *)\\nmodule MISTRAL_ALUT2(input A, B, output Q);\\n\\nparameter [3:0] LUT = 4'h0;\\n\\n`ifdef cyclonev\\nspecify\\n    (A => Q) = 400;\\n    (B => Q) = 97;\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    (A => Q) = 316;\\n    (B => Q) = 76;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\nspecify\\n    (A => Q) = 162;\\n    (B => Q) = 53;\\nendspecify\\n`endif\\n\\nassign Q = LUT >> {B, A};\\n\\nendmodule\\n\\n\\n(* abc9_lut=1, lib_whitebox *)\\nmodule MISTRAL_NOT(input A, output Q);\\n\\n`ifdef cyclonev\\nspecify\\n    (A => Q) = 97;\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    (A => Q) = 76;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\nspecify\\n    (A => Q) = 53;\\nendspecify\\n`endif\\n\\nassign Q = ~A;\\n\\nendmodule\\n\\n(* abc9_box, lib_whitebox *)\\nmodule MISTRAL_ALUT_ARITH(input A, B, C, D0, D1, (* abc9_carry *) input CI, output SO, (* abc9_carry *) output CO);\\n\\nparameter LUT0 = 16'h0000;\\nparameter LUT1 = 16'h0000;\\n\\n`ifdef cyclonev\\nspecify\\n    (A  => SO) = 1342;\\n    (B  => SO) = 1323;\\n    (C  => SO) = 927;\\n    (D0 => SO) = 887;\\n    (D1 => SO) = 785;\\n    (CI => SO) = 368;\\n\\n    (A  => CO) = 1082;\\n    (B  => CO) = 1062;\\n    (C  => CO) = 813;\\n    (D0 => CO) = 866;\\n    (D1 => CO) = 1198;\\n    (CI => CO) = 36; // Divided by 2 to account for there being two ALUT_ARITHs in an ALM)\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    (A  => SO) = 744;\\n    (B  => SO) = 732;\\n    (C  => SO) = 562;\\n    (D0 => SO) = 576;\\n    (D1 => SO) = 511;\\n    (CI => SO) = 249;\\n\\n    (A  => CO) = 629;\\n    (B  => CO) = 623;\\n    (C  => CO) = 530;\\n    (D0 => CO) = 514;\\n    (D1 => CO) = 696;\\n    (CI => CO) = 10; // Divided by 2 to account for there being two ALUT_ARITHs in an ALM)\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\nspecify\\n    (A  => SO) = 644;\\n    (B  => SO) = 477;\\n    (C  => SO) = 416;\\n    (D0 => SO) = 380;\\n    (D1 => SO) = 431;\\n    (CI => SO) = 276;\\n\\n    (A  => CO) = 525;\\n    (B  => CO) = 433;\\n    (C  => CO) = 712;\\n    (D0 => CO) = 653;\\n    (D1 => CO) = 593;\\n    (CI => CO) = 16;\\nendspecify\\n`endif\\n\\nwire q0, q1;\\n\\nassign q0 = LUT0 >> {D0, C, B, A};\\nassign q1 = LUT1 >> {D1, C, B, A};\\n\\nassign {CO, SO} = q0 + !q1 + CI;\\n\\nendmodule\\n\\n\\n/*\\n// A, B, C0, C1, E0, E1, F0, F1: data inputs\\n// CARRYIN: carry input\\n// SHAREIN: shared-arithmetic input\\n// CLK0, CLK1, CLK2: clock inputs\\n//\\n// COMB0, COMB1: combinational outputs\\n// FF0, FF1, FF2, FF3: DFF outputs\\n// SUM0, SUM1: adder outputs\\n// CARRYOUT: carry output\\n// SHAREOUT: shared-arithmetic output\\nmodule MISTRAL_ALM(\\n    input A, B, C0, C1, E0, E1, F0, F1, CARRYIN, SHAREIN, // LUT path\\n    input CLK0, CLK1, CLK2, AC0, AC1,                     // FF path\\n    output COMB0, COMB1, SUM0, SUM1, CARRYOUT, SHAREOUT,\\n    output FF0, FF1, FF2, FF3\\n);\\n\\nparameter LUT0 = 16'b0000;\\nparameter LUT1 = 16'b0000;\\nparameter LUT2 = 16'b0000;\\nparameter LUT3 = 16'b0000;\\n\\nparameter INIT0 = 1'b0;\\nparameter INIT1 = 1'b0;\\nparameter INIT2 = 1'b0;\\nparameter INIT3 = 1'b0;\\n\\nparameter C0_MUX = \\\"C0\\\";\\nparameter C1_MUX = \\\"C1\\\";\\n\\nparameter F0_MUX = \\\"VCC\\\";\\nparameter F1_MUX = \\\"GND\\\";\\n\\nparameter FEEDBACK0 = \\\"FF0\\\";\\nparameter FEEDBACK1 = \\\"FF2\\\";\\n\\nparameter ADD_MUX = \\\"LUT\\\";\\n\\nparameter DFF01_DATA_MUX = \\\"COMB\\\";\\nparameter DFF23_DATA_MUX = \\\"COMB\\\";\\n\\nparameter DFF0_CLK = \\\"CLK0\\\";\\nparameter DFF1_CLK = \\\"CLK0\\\";\\nparameter DFF2_CLK = \\\"CLK0\\\";\\nparameter DFF3_CLK = \\\"CLK0\\\";\\n\\nparameter DFF0_AC  = \\\"AC0\\\";\\nparameter DFF1_AC  = \\\"AC0\\\";\\nparameter DFF2_AC  = \\\"AC0\\\";\\nparameter DFF3_AC  = \\\"AC0\\\";\\n\\n// Feedback muxes from the flip-flop outputs.\\nwire ff_feedback_mux0, ff_feedback_mux1;\\n\\n// C-input muxes which can be set to also use the F-input.\\nwire c0_input_mux, c1_input_mux;\\n\\n// F-input muxes which can be set to a constant to allow LUT5 use.\\nwire f0_input_mux, f1_input_mux;\\n\\n// Adder input muxes to select between shared-arithmetic mode and arithmetic mode.\\nwire add0_input_mux, add1_input_mux;\\n\\n// Combinational-output muxes for LUT #1 and LUT #3\\nwire lut1_comb_mux, lut3_comb_mux;\\n\\n// Sum-output muxes for LUT #1 and LUT #3\\nwire lut1_sum_mux, lut3_sum_mux;\\n\\n// DFF data-input muxes\\nwire dff01_data_mux, dff23_data_mux;\\n\\n// DFF clock selectors\\nwire dff0_clk, dff1_clk, dff2_clk, dff3_clk;\\n\\n// DFF asynchronous-clear selectors\\nwire dff0_ac, dff1_ac, dff2_ac, dff3_ac;\\n\\n// LUT, DFF and adder output wires for routing.\\nwire lut0_out, lut1a_out, lut1b_out, lut2_out, lut3a_out, lut3b_out;\\nwire dff0_out, dff1_out, dff2_out, dff3_out;\\nwire add0_sum, add1_sum, add0_carry, add1_carry;\\n\\ngenerate\\n    if (FEEDBACK0 === \\\"FF0\\\")\\n        assign ff_feedback_mux0 = dff0_out;\\n    else if (FEEDBACK0 === \\\"FF1\\\")\\n        assign ff_feedback_mux0 = dff1_out;\\n    else\\n        $error(\\\"Invalid FEEDBACK0 setting!\\\");\\n\\n    if (FEEDBACK1 == \\\"FF2\\\")\\n        assign ff_feedback_mux1 = dff2_out;\\n    else if (FEEDBACK1 == \\\"FF3\\\")\\n        assign ff_feedback_mux1 = dff3_out;\\n    else\\n        $error(\\\"Invalid FEEDBACK1 setting!\\\");\\n\\n    if (C0_MUX === \\\"C0\\\")\\n        assign c0_input_mux = C0;\\n    else if (C0_MUX === \\\"F1\\\")\\n        assign c0_input_mux = F1;\\n    else if (C0_MUX === \\\"FEEDBACK1\\\")\\n        assign c0_input_mux = ff_feedback_mux1;\\n    else\\n        $error(\\\"Invalid C0_MUX setting!\\\");\\n\\n    if (C1_MUX === \\\"C1\\\")\\n        assign c1_input_mux = C1;\\n    else if (C1_MUX === \\\"F0\\\")\\n        assign c1_input_mux = F0;\\n    else if (C1_MUX === \\\"FEEDBACK0\\\")\\n        assign c1_input_mux = ff_feedback_mux0;\\n    else\\n        $error(\\\"Invalid C1_MUX setting!\\\");\\n\\n    // F0 == VCC is LUT5\\n    // F0 == F0 is LUT6\\n    // F0 == FEEDBACK is unknown\\n    if (F0_MUX === \\\"VCC\\\")\\n        assign f0_input_mux = 1'b1;\\n    else if (F0_MUX === \\\"F0\\\")\\n        assign f0_input_mux = F0;\\n    else if (F0_MUX === \\\"FEEDBACK0\\\")\\n        assign f0_input_mux = ff_feedback_mux0;\\n    else\\n        $error(\\\"Invalid F0_MUX setting!\\\");\\n\\n    // F1 == GND is LUT5\\n    // F1 == F1 is LUT6\\n    // F1 == FEEDBACK is unknown\\n    if (F1_MUX === \\\"GND\\\")\\n        assign f1_input_mux = 1'b0;\\n    else if (F1_MUX === \\\"F1\\\")\\n        assign f1_input_mux = F1;\\n    else if (F1_MUX === \\\"FEEDBACK1\\\")\\n        assign f1_input_mux = ff_feedback_mux1;\\n    else\\n        $error(\\\"Invalid F1_MUX setting!\\\");\\n\\n    if (ADD_MUX === \\\"LUT\\\") begin\\n        assign add0_input_mux = ~lut1_sum_mux;\\n        assign add1_input_mux = ~lut3_sum_mux;\\n    end else if (ADD_MUX === \\\"SHARE\\\") begin\\n        assign add0_input_mux = SHAREIN;\\n        assign add1_input_mux = lut1_comb_mux;\\n    end else\\n        $error(\\\"Invalid ADD_MUX setting!\\\");\\n\\n    if (DFF01_DATA_MUX === \\\"COMB\\\")\\n        assign dff01_data_mux = COMB0;\\n    else if (DFF01_DATA_MUX === \\\"SUM\\\")\\n        assign dff01_data_mux = SUM0;\\n    else\\n        $error(\\\"Invalid DFF01_DATA_MUX setting!\\\");\\n\\n    if (DFF23_DATA_MUX === \\\"COMB\\\")\\n        assign dff23_data_mux = COMB0;\\n    else if (DFF23_DATA_MUX === \\\"SUM\\\")\\n        assign dff23_data_mux = SUM0;\\n    else\\n        $error(\\\"Invalid DFF23_DATA_MUX setting!\\\");\\n\\n    if (DFF0_CLK === \\\"CLK0\\\")\\n        assign dff0_clk = CLK0;\\n    else if (DFF0_CLK === \\\"CLK1\\\")\\n        assign dff0_clk = CLK1;\\n    else if (DFF0_CLK === \\\"CLK2\\\")\\n        assign dff0_clk = CLK2;\\n    else\\n        $error(\\\"Invalid DFF0_CLK setting!\\\");\\n\\n    if (DFF1_CLK === \\\"CLK0\\\")\\n        assign dff1_clk = CLK0;\\n    else if (DFF1_CLK === \\\"CLK1\\\")\\n        assign dff1_clk = CLK1;\\n    else if (DFF1_CLK === \\\"CLK2\\\")\\n        assign dff1_clk = CLK2;\\n    else\\n        $error(\\\"Invalid DFF1_CLK setting!\\\");\\n\\n    if (DFF2_CLK === \\\"CLK0\\\")\\n        assign dff2_clk = CLK0;\\n    else if (DFF2_CLK === \\\"CLK1\\\")\\n        assign dff2_clk = CLK1;\\n    else if (DFF2_CLK === \\\"CLK2\\\")\\n        assign dff2_clk = CLK2;\\n    else\\n        $error(\\\"Invalid DFF2_CLK setting!\\\");\\n\\n    if (DFF3_CLK === \\\"CLK0\\\")\\n        assign dff3_clk = CLK0;\\n    else if (DFF3_CLK === \\\"CLK1\\\")\\n        assign dff3_clk = CLK1;\\n    else if (DFF3_CLK === \\\"CLK2\\\")\\n        assign dff3_clk = CLK2;\\n    else\\n        $error(\\\"Invalid DFF3_CLK setting!\\\");\\n\\n    if (DFF0_AC === \\\"AC0\\\")\\n        assign dff0_ac = AC0;\\n    else if (DFF0_AC === \\\"AC1\\\")\\n        assign dff0_ac = AC1;\\n    else\\n        $error(\\\"Invalid DFF0_AC setting!\\\");\\n\\n    if (DFF1_AC === \\\"AC0\\\")\\n        assign dff1_ac = AC0;\\n    else if (DFF1_AC === \\\"AC1\\\")\\n        assign dff1_ac = AC1;\\n    else\\n        $error(\\\"Invalid DFF1_AC setting!\\\");\\n\\n    if (DFF2_AC === \\\"AC0\\\")\\n        assign dff2_ac = AC0;\\n    else if (DFF2_AC === \\\"AC1\\\")\\n        assign dff2_ac = AC1;\\n    else\\n        $error(\\\"Invalid DFF2_AC setting!\\\");\\n\\n    if (DFF3_AC === \\\"AC0\\\")\\n        assign dff3_ac = AC0;\\n    else if (DFF3_AC === \\\"AC1\\\")\\n        assign dff3_ac = AC1;\\n    else\\n        $error(\\\"Invalid DFF3_AC setting!\\\");\\n\\nendgenerate\\n\\n// F0 on the Quartus diagram\\nMISTRAL_ALUT4 #(.LUT(LUT0)) lut0 (.A(A), .B(B), .C(C0), .D(c1_input_mux), .Q(lut0_out));\\n\\n// F2 on the Quartus diagram\\nMISTRAL_ALUT4 #(.LUT(LUT1)) lut1_comb (.A(A), .B(B), .C(C0), .D(c1_input_mux), .Q(lut1_comb_mux));\\nMISTRAL_ALUT4 #(.LUT(LUT1)) lut1_sum  (.A(A), .B(B), .C(C0), .D(E0), .Q(lut1_sum_mux));\\n\\n// F1 on the Quartus diagram\\nMISTRAL_ALUT4 #(.LUT(LUT2)) lut2 (.A(A), .B(B), .C(C1), .D(c0_input_mux), .Q(lut2_out));\\n\\n// F3 on the Quartus diagram\\nMISTRAL_ALUT4 #(.LUT(LUT3)) lut3_comb (.A(A), .B(B), .C(C1), .D(c0_input_mux), .Q(lut3_comb_mux));\\nMISTRAL_ALUT4 #(.LUT(LUT3)) lut3_sum  (.A(A), .B(B), .C(C1), .D(E1), .Q(lut3_sum_mux));\\n\\nMISTRAL_FF #(.INIT(INIT0)) dff0 (.D(dff01_data_mux), .CLK(dff0_clk), .ACn(dff0_ac), .Q(dff0_out));\\nMISTRAL_FF #(.INIT(INIT1)) dff1 (.D(dff01_data_mux), .CLK(dff1_clk), .ACn(dff1_ac), .Q(dff1_out));\\nMISTRAL_FF #(.INIT(INIT2)) dff2 (.D(dff23_data_mux), .CLK(dff2_clk), .ACn(dff2_ac), .Q(dff2_out));\\nMISTRAL_FF #(.INIT(INIT3)) dff3 (.D(dff23_data_mux), .CLK(dff3_clk), .ACn(dff3_ac), .Q(dff3_out));\\n\\n// Adders\\nassign {add0_carry, add0_sum} = CARRYIN + lut0_out + lut1_sum_mux;\\nassign {add1_carry, add1_sum} = add0_carry + lut2_out + lut3_sum_mux;\\n\\n// COMBOUT outputs on the Quartus diagram\\nassign COMB0 = E0 ? (f0_input_mux ? lut3_comb_mux : lut1_comb_mux)\\n                    : (f0_input_mux ? lut2_out : lut0_out);\\n\\nassign COMB1 = E1 ? (f1_input_mux ? lut3_comb_mux : lut1_comb_mux)\\n                    : (f1_input_mux ? lut2_out : lut0_out);\\n\\n// SUMOUT output on the Quartus diagram\\nassign SUM0 = add0_sum;\\nassign SUM1 = add1_sum;\\n\\n// COUT output on the Quartus diagram\\nassign CARRYOUT = add1_carry;\\n\\n// SHAREOUT output on the Quartus diagram\\nassign SHAREOUT = lut3_comb_mux;\\n\\n// REGOUT outputs on the Quartus diagram\\nassign FF0 = dff0_out;\\nassign FF1 = dff1_out;\\nassign FF2 = dff2_out;\\nassign FF3 = dff3_out;\\n\\nendmodule\\n*/\\n\",\n                \"arith_alm_map.v\": \"`default_nettype none\\n\\nmodule \\\\$alu (A, B, CI, BI, X, Y, CO);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 1;\\nparameter B_WIDTH = 1;\\nparameter Y_WIDTH = 1;\\n\\nparameter _TECHMAP_CONSTMSK_CI_ = 0;\\nparameter _TECHMAP_CONSTVAL_CI_ = 0;\\n\\n(* force_downto *)\\ninput [A_WIDTH-1:0] A;\\n(* force_downto *)\\ninput [B_WIDTH-1:0] B;\\ninput CI, BI;\\n(* force_downto *)\\noutput [Y_WIDTH-1:0] X, Y, CO;\\n\\n(* force_downto *)\\nwire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n(* force_downto *)\\nwire [Y_WIDTH-1:0] AA = A_buf;\\n(* force_downto *)\\nwire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\\n(* force_downto *)\\nwire [Y_WIDTH-1:0] BX = B_buf;\\nwire [Y_WIDTH:0] ALM_CARRY;\\n\\n// Start of carry chain\\ngenerate\\n    if (_TECHMAP_CONSTMSK_CI_ == 1 && _TECHMAP_CONSTVAL_CI_ == 1'b0) begin\\n        assign ALM_CARRY[0] = _TECHMAP_CONSTVAL_CI_;\\n    end else begin\\n        MISTRAL_ALUT_ARITH #(\\n            .LUT0(16'b1010_1010_1010_1010), // Q = A\\n            .LUT1(16'b0000_0000_0000_0000), // Q = 0 (LUT1's input to the adder is inverted)\\n        ) alm_start (\\n            .A(CI), .B(1'b1), .C(1'b1), .D0(1'b1), .D1(1'b1),\\n            .CI(1'b0),\\n            .CO(ALM_CARRY[0])\\n        );\\n    end\\nendgenerate\\n\\n// Carry chain\\ngenvar i;\\ngenerate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice\\n    // TODO: mwk suggests that a pass could merge pre-adder logic into this.\\n    MISTRAL_ALUT_ARITH #(\\n        .LUT0(16'b1010_1010_1010_1010), // Q = A\\n        .LUT1(16'b1100_0011_1100_0011), // Q = C ? B : ~B (LUT1's input to the adder is inverted)\\n    ) alm_i (\\n        .A(AA[i]), .B(BX[i]), .C(BI), .D0(1'b1), .D1(1'b1),\\n        .CI(ALM_CARRY[i]),\\n        .SO(Y[i]),\\n        .CO(ALM_CARRY[i+1])\\n    );\\n\\n    // ALM carry chain is not directly accessible, so calculate the carry through soft logic if really needed.\\n    assign CO[i] = (AA[i] && BB[i]) || ((Y[i] ^ AA[i] ^ BB[i]) && (AA[i] || BB[i]));\\nend endgenerate\\n\\nassign X = AA ^ BB;\\n\\nendmodule\\n\",\n                \"bram_m10k.txt\": \"bram $__MISTRAL_M10K\\n    init   1\\n    abits 13   @D8192x1\\n    dbits  1   @D8192x1\\n    abits 12   @D4096x2\\n    dbits  2   @D4096x2\\n    abits 11   @D2048x5\\n    dbits  5   @D2048x5\\n    abits 10   @D1024x10\\n    dbits 10   @D1024x10\\n    abits  9   @D512x20\\n    dbits 20   @D512x20\\n    abits  8   @D256x40\\n    dbits 40   @D256x40\\n    groups 2\\n    ports  1 1\\n    wrmode 1 0\\n    # read enable; write enable + byte enables (only for multiples of 8)\\n    enable 1 1\\n    transp 0 0\\n    clocks 1 1\\n    clkpol 1 1\\nendbram\\n\\n\\nmatch $__MISTRAL_M10K\\n    min efficiency 5\\n    make_transp\\nendmatch\\n\",\n                \"bram_m10k_map.v\": \"// Stub to invert M10K write-enable.\\n\\nmodule \\\\$__MISTRAL_M10K (CLK1, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);\\n\\nparameter INIT = 0;\\n\\nparameter CFG_ABITS = 10;\\nparameter CFG_DBITS = 10;\\n\\ninput CLK1;\\ninput [CFG_ABITS-1:0] A1ADDR, B1ADDR;\\ninput [CFG_DBITS-1:0] A1DATA;\\ninput A1EN, B1EN;\\noutput reg [CFG_DBITS-1:0] B1DATA;\\n\\n// Normal M10K configs use WREN[1], which is negative-true.\\n// However, 8x40-bit mode uses WREN[0], which is positive-true.\\nwire a1en;\\nif (CFG_DBITS == 40)\\n    assign a1en = A1EN;\\nelse\\n    assign a1en = !A1EN;\\n\\nMISTRAL_M10K #(.INIT(INIT), .CFG_ABITS(CFG_ABITS), .CFG_DBITS(CFG_DBITS)) _TECHMAP_REPLACE_ (.CLK1(CLK1), .A1ADDR(A1ADDR), .A1DATA(A1DATA), .A1EN(a1en), .B1ADDR(B1ADDR), .B1DATA(B1DATA), .B1EN(B1EN));\\n\\nendmodule\\n\",\n                \"bram_m20k.txt\": \"bram __MISTRAL_M20K_SDP\\n    init   1   # TODO: Re-enable when I figure out how BRAM init works\\n    abits 14   @D16384x1\\n    dbits  1   @D16384x1\\n    abits 13   @D8192x2\\n    dbits  2   @D8192x2\\n    abits 12   @D4096x4 @D4096x5\\n    dbits  4   @D4096x4\\n    dbits  5   @D4096x5\\n    abits 11   @D2048x8 @D2048x10\\n    dbits  8   @D2048x8\\n    dbits 10   @D2048x10\\n    abits 10   @D1024x16 @D1024x20\\n    dbits 16   @D1024x16\\n    dbits 20   @D1024x20\\n    abits  9   @D512x32 @D512x40\\n    dbits 32   @D512x32\\n    dbits 40   @D512x40\\n    groups 2\\n    ports  1 1\\n    wrmode 1 0\\n    # read enable; write enable + byte enables (only for multiples of 8)\\n    enable 1 1\\n    transp 0 0\\n    clocks 1 1\\n    clkpol 1 1\\nendbram\\n\\n\\nmatch __MISTRAL_M20K_SDP\\n    min efficiency 5\\n    make_transp\\nendmatch\\n\",\n                \"bram_m20k_map.v\": \"module __MISTRAL_M20K_SDP(CLK1, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);\\n\\nparameter CFG_ABITS = 10;\\nparameter CFG_DBITS = 20;\\nparameter CFG_ENABLE_A = 1;\\nparameter CFG_ENABLE_B = 1;\\n\\ninput CLK1;\\ninput [CFG_ABITS-1:0] A1ADDR, B1ADDR;\\ninput [CFG_DBITS-1:0] A1DATA;\\noutput [CFG_DBITS-1:0] B1DATA;\\ninput [CFG_ENABLE_A-1:0] A1EN, B1EN;\\n\\naltsyncram #(\\n    .operation_mode(\\\"dual_port\\\"),\\n    .ram_block_type(\\\"m20k\\\"),\\n    .widthad_a(CFG_ABITS),\\n    .width_a(CFG_DBITS),\\n    .widthad_b(CFG_ABITS),\\n    .width_b(CFG_DBITS),\\n) _TECHMAP_REPLACE_ (\\n    .address_a(A1ADDR),\\n    .data_a(A1DATA),\\n    .wren_a(A1EN),\\n    .address_b(B1ADDR),\\n    .q_b(B1DATA),\\n    .clock0(CLK1),\\n    .clock1(CLK1)\\n);\\n\\nendmodule\\n\",\n                \"dff_map.v\": \"`default_nettype none\\n\\n// D flip-flop with async reset and enable\\nmodule \\\\$_DFFE_PN0P_ (input D, C, R, E, output Q);\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\n    MISTRAL_FF _TECHMAP_REPLACE_(.DATAIN(D), .CLK(C), .ACLR(R), .ENA(E), .SCLR(1'b0), .SLOAD(1'b0), .SDATA(1'b0), .Q(Q));\\nendmodule\\n\\n// D flip-flop with sync reset and enable (enable has priority)\\nmodule \\\\$_SDFFCE_PP0P_ (input D, C, R, E, output Q);\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\n    MISTRAL_FF _TECHMAP_REPLACE_(.DATAIN(D), .CLK(C), .ACLR(1'b1), .ENA(E), .SCLR(R), .SLOAD(1'b0), .SDATA(1'b0), .Q(Q));\\nendmodule\\n\",\n                \"dff_sim.v\": \"// The four D flip-flops (DFFs) in a Cyclone V/10GX Adaptive Logic Module (ALM)\\n// act as one-bit memory cells that can be placed very flexibly (wherever there's\\n// an ALM); each flop is represented by a MISTRAL_FF cell.\\n//\\n// The flops in these chips are rather flexible in some ways, but in practice\\n// quite crippled by FPGA standards.\\n//\\n// What the flops can do\\n// ---------------------\\n// The core flop acts as a single-bit memory that initialises to zero at chip\\n// reset. It takes in data on the rising edge of CLK if ENA is high,\\n// and outputs it to Q. The ENA (clock enable) pin can therefore be used to\\n// capture the input only if a condition is true.\\n//\\n// The data itself is zero if SCLR (synchronous clear) is high, else it comes\\n// from SDATA (synchronous data) if SLOAD (synchronous load) is high, or DATAIN\\n// if SLOAD is low.\\n//\\n// If ACLR (asynchronous clear) is low then Q is forced to zero, regardless of\\n// the synchronous inputs or CLK edge. This is most often used for an FPGA-wide\\n// power-on reset.\\n//\\n// An asynchronous set that sets Q to one can be emulated by inverting the input\\n// and output of the flop, resulting in ACLR forcing Q to zero, which then gets\\n// inverted to produce one. Likewise, logic can operate on the falling edge of\\n// CLK if CLK is inverted before being passed as an input.\\n//\\n// What the flops *can't* do\\n// -------------------------\\n// The trickiest part of the above capabilities is the lack of configurable\\n// initialisation state. For example, it isn't possible to implement a flop with\\n// asynchronous clear that initialises to one, because the hardware initialises\\n// to zero. Likewise, you can't emulate a flop with asynchronous set that\\n// initialises to zero, because the inverters mean the flop initialises to one.\\n//\\n// If the input design requires one of these cells (which appears to be rare\\n// in practice) then synth_intel_alm will fail to synthesize the design where\\n// other Yosys synthesis scripts might succeed.\\n//\\n// This stands in notable contrast to e.g. Xilinx flip-flops, which have\\n// configurable initialisation state and native synchronous/asynchronous\\n// set/clear (although not at the same time), which means they can generally\\n// implement a much wider variety of logic.\\n\\n// DATAIN: synchronous data input\\n// CLK: clock input (positive edge)\\n// ACLR: asynchronous clear (negative-true)\\n// ENA: clock-enable\\n// SCLR: synchronous clear\\n// SLOAD: synchronous load\\n// SDATA: synchronous load data\\n//\\n// Q: data output\\n//\\n// Note: the DFFEAS primitive is mostly emulated; it does not reflect what the hardware implements.\\n\\n(* abc9_box, lib_whitebox *)\\nmodule MISTRAL_FF(\\n    input DATAIN,\\n    (* clkbuf_sink *) input CLK,\\n    input ACLR, ENA, SCLR, SLOAD, SDATA,\\n    output reg Q\\n);\\n\\n`ifdef cyclonev\\nspecify\\n    if (ENA && ACLR !== 1'b0 && !SCLR && !SLOAD) (posedge CLK => (Q : DATAIN)) = 731;\\n    if (ENA && SCLR) (posedge CLK => (Q : 1'b0)) = 890;\\n    if (ENA && !SCLR && SLOAD) (posedge CLK => (Q : SDATA)) = 618;\\n\\n    $setup(DATAIN, posedge CLK, /* -196 */ 0);\\n    $setup(ENA, posedge CLK, /* -196 */ 0);\\n    $setup(SCLR, posedge CLK, /* -196 */ 0);\\n    $setup(SLOAD, posedge CLK, /* -196 */ 0);\\n    $setup(SDATA, posedge CLK, /* -196 */ 0);\\n\\n    if (ACLR === 1'b0) (ACLR => Q) = 282;\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    if (ENA && ACLR !== 1'b0 && !SCLR && !SLOAD) (posedge CLK => (Q : DATAIN)) = 470;\\n    if (ENA && SCLR) (posedge CLK => (Q : 1'b0)) = 633;\\n    if (ENA && !SCLR && SLOAD) (posedge CLK => (Q : SDATA)) = 439;\\n\\n    $setup(DATAIN, posedge CLK, /* -170 */ 0);\\n    $setup(ENA, posedge CLK, /* -170 */ 0);\\n    $setup(SCLR, posedge CLK, /* -170 */ 0);\\n    $setup(SLOAD, posedge CLK, /* -170 */ 0);\\n    $setup(SDATA, posedge CLK, /* -170 */ 0);\\n\\n    if (ACLR === 1'b0) (ACLR => Q) = 215;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\nspecify\\n    // TODO (long-term): investigate these numbers.\\n    // It seems relying on the Quartus Timing Analyzer was not the best idea; it's too fiddly.\\n    if (ENA && ACLR !== 1'b0 && !SCLR && !SLOAD) (posedge CLK => (Q : DATAIN)) = 219;\\n    if (ENA && SCLR) (posedge CLK => (Q : 1'b0)) = 219;\\n    if (ENA && !SCLR && SLOAD) (posedge CLK => (Q : SDATA)) = 219;\\n\\n    $setup(DATAIN, posedge CLK, 268);\\n    $setup(ENA, posedge CLK, 268);\\n    $setup(SCLR, posedge CLK, 268);\\n    $setup(SLOAD, posedge CLK, 268);\\n    $setup(SDATA, posedge CLK, 268);\\n\\n    if (ACLR === 1'b0) (ACLR => Q) = 0;\\nendspecify\\n`endif\\n\\ninitial begin\\n    // Altera flops initialise to zero.\\n\\tQ = 0;\\nend\\n\\nalways @(posedge CLK, negedge ACLR) begin\\n    // Asynchronous clear\\n    if (!ACLR) Q <= 0;\\n    // Clock-enable\\n\\telse if (ENA) begin\\n        // Synchronous clear\\n        if (SCLR) Q <= 0;\\n        // Synchronous load\\n        else if (SLOAD) Q <= SDATA;\\n        else Q <= DATAIN;\\n    end\\nend\\n\\nendmodule\\n\",\n                \"dsp_map.v\": \"`default_nettype none\\n\\nmodule __MUL27X27(A, B, Y);\\n\\nparameter A_SIGNED = 1;\\nparameter B_SIGNED = 1;\\nparameter A_WIDTH = 27;\\nparameter B_WIDTH = 27;\\nparameter Y_WIDTH = 54;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\nMISTRAL_MUL27X27 _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));\\n\\nendmodule\\n\\n\\nmodule __MUL18X18(A, B, Y);\\n\\nparameter A_SIGNED = 1;\\nparameter B_SIGNED = 1;\\nparameter A_WIDTH = 18;\\nparameter B_WIDTH = 18;\\nparameter Y_WIDTH = 36;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\nMISTRAL_MUL18X18 _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));\\n\\nendmodule\\n\\n\\nmodule __MUL9X9(A, B, Y);\\n\\nparameter A_SIGNED = 1;\\nparameter B_SIGNED = 1;\\nparameter A_WIDTH = 9;\\nparameter B_WIDTH = 9;\\nparameter Y_WIDTH = 18;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\nMISTRAL_MUL9X9 _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));\\n\\nendmodule\\n\",\n                \"dsp_sim.v\": \"`default_nettype none\\n\\n(* abc9_box *)\\nmodule MISTRAL_MUL27X27(input [26:0] A, input [26:0] B, output [53:0] Y);\\n\\nparameter A_SIGNED = 1;\\nparameter B_SIGNED = 1;\\n\\n`ifdef cyclonev\\nspecify\\n    (A *> Y) = 3732;\\n    (B *> Y) = 3928;\\nendspecify\\n`endif\\n`ifdef arriav\\n// NOTE: Arria V appears to have only one set of timings for all DSP modes...\\nspecify\\n    (A *> Y) = 1895;\\n    (B *> Y) = 2053;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\n// TODO: Cyclone 10 GX timings; the below are for Cyclone V\\nspecify\\n    (A *> Y) = 3732;\\n    (B *> Y) = 3928;\\nendspecify\\n`endif\\n\\nwire [53:0] A_, B_;\\n\\nif (A_SIGNED)\\n    assign A_ = $signed(A);\\nelse\\n    assign A_ = $unsigned(A);\\n\\nif (B_SIGNED)\\n    assign B_ = $signed(B);\\nelse\\n    assign B_ = $unsigned(B);\\n\\nassign Y = A_ * B_;\\n\\nendmodule\\n\\n(* abc9_box *)\\nmodule MISTRAL_MUL18X18(input [17:0] A, input [17:0] B, output [35:0] Y);\\n\\nparameter A_SIGNED = 1;\\nparameter B_SIGNED = 1;\\n\\n`ifdef cyclonev\\nspecify\\n    (A *> Y) = 3180;\\n    (B *> Y) = 3982;\\nendspecify\\n`endif\\n`ifdef arriav\\n// NOTE: Arria V appears to have only one set of timings for all DSP modes...\\nspecify\\n    (A *> Y) = 1895;\\n    (B *> Y) = 2053;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\n// TODO: Cyclone 10 GX timings; the below are for Cyclone V\\nspecify\\n    (A *> Y) = 3180;\\n    (B *> Y) = 3982;\\nendspecify\\n`endif\\n\\nwire [35:0] A_, B_;\\n\\nif (A_SIGNED)\\n    assign A_ = $signed(A);\\nelse\\n    assign A_ = $unsigned(A);\\n\\nif (B_SIGNED)\\n    assign B_ = $signed(B);\\nelse\\n    assign B_ = $unsigned(B);\\n\\nassign Y = A_ * B_;\\n\\nendmodule\\n\\n(* abc9_box *)\\nmodule MISTRAL_MUL9X9(input [8:0] A, input [8:0] B, output [17:0] Y);\\n\\nparameter A_SIGNED = 1;\\nparameter B_SIGNED = 1;\\n\\n`ifdef cyclonev\\nspecify\\n    (A *> Y) = 2818;\\n    (B *> Y) = 3051;\\nendspecify\\n`endif\\n`ifdef arriav\\n// NOTE: Arria V appears to have only one set of timings for all DSP modes...\\nspecify\\n    (A *> Y) = 1895;\\n    (B *> Y) = 2053;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\n// TODO: Cyclone 10 GX timings; the below are for Cyclone V\\nspecify\\n    (A *> Y) = 2818;\\n    (B *> Y) = 3051;\\nendspecify\\n`endif\\n\\nwire [17:0] A_, B_;\\n\\nif (A_SIGNED)\\n    assign A_ = $signed(A);\\nelse\\n    assign A_ = $unsigned(A);\\n\\nif (B_SIGNED)\\n    assign B_ = $signed(B);\\nelse\\n    assign B_ = $unsigned(B);\\n\\nassign Y = A_ * B_;\\n\\nendmodule\\n\",\n                \"lutram_mlab.txt\": \"bram MISTRAL_MLAB\\n    init   0   # TODO: Re-enable when Yosys remembers the original filename.\\n    abits  5\\n    dbits  1\\n    groups 2\\n    ports  1 1\\n    wrmode 1 0\\n    # write enable\\n    enable 1 0\\n    transp 0 0\\n    clocks 1 0\\n    clkpol 1 1\\nendbram\\n\\nmatch MISTRAL_MLAB\\n    min efficiency 5\\n    make_outreg\\nendmatch\",\n                \"megafunction_bb.v\": \"// Intel megafunction declarations, to avoid Yosys complaining.\\n`default_nettype none\\n\\n(* blackbox *)\\nmodule altera_pll\\n#(\\n    parameter reference_clock_frequency       = \\\"0 ps\\\",\\n\\tparameter fractional_vco_multiplier       = \\\"false\\\",\\n    parameter pll_type                        = \\\"General\\\",\\n    parameter pll_subtype                     = \\\"General\\\",\\n    parameter number_of_clocks                   = 1,\\n    parameter operation_mode                  = \\\"internal feedback\\\",\\n    parameter deserialization_factor           = 4,\\n    parameter data_rate                       = 0,\\n    \\n    parameter sim_additional_refclk_cycles_to_lock      = 0,\\n    parameter output_clock_frequency0           = \\\"0 ps\\\",\\n    parameter phase_shift0                      = \\\"0 ps\\\",\\n    parameter duty_cycle0                      = 50,\\n    \\n    parameter output_clock_frequency1           = \\\"0 ps\\\",\\n    parameter phase_shift1                      = \\\"0 ps\\\",\\n    parameter duty_cycle1                      = 50,\\n    \\n    parameter output_clock_frequency2           = \\\"0 ps\\\",\\n    parameter phase_shift2                      = \\\"0 ps\\\",\\n    parameter duty_cycle2                      = 50,\\n    \\n    parameter output_clock_frequency3           = \\\"0 ps\\\",\\n    parameter phase_shift3                      = \\\"0 ps\\\",\\n    parameter duty_cycle3                      = 50,\\n    \\n    parameter output_clock_frequency4           = \\\"0 ps\\\",\\n    parameter phase_shift4                      = \\\"0 ps\\\",\\n    parameter duty_cycle4                      = 50,\\n    \\n    parameter output_clock_frequency5           = \\\"0 ps\\\",\\n    parameter phase_shift5                      = \\\"0 ps\\\",\\n    parameter duty_cycle5                      = 50,\\n    \\n    parameter output_clock_frequency6           = \\\"0 ps\\\",\\n    parameter phase_shift6                      = \\\"0 ps\\\",\\n    parameter duty_cycle6                      = 50,\\n    \\n    parameter output_clock_frequency7           = \\\"0 ps\\\",\\n    parameter phase_shift7                      = \\\"0 ps\\\",\\n    parameter duty_cycle7                      = 50,\\n    \\n    parameter output_clock_frequency8           = \\\"0 ps\\\",\\n    parameter phase_shift8                      = \\\"0 ps\\\",\\n    parameter duty_cycle8                      = 50,\\n    \\n    parameter output_clock_frequency9           = \\\"0 ps\\\",\\n    parameter phase_shift9                      = \\\"0 ps\\\",\\n    parameter duty_cycle9                      = 50,    \\n\\n    \\n    parameter output_clock_frequency10           = \\\"0 ps\\\",\\n    parameter phase_shift10                      = \\\"0 ps\\\",\\n    parameter duty_cycle10                      = 50,\\n    \\n    parameter output_clock_frequency11           = \\\"0 ps\\\",\\n    parameter phase_shift11                      = \\\"0 ps\\\",\\n    parameter duty_cycle11                      = 50,\\n    \\n    parameter output_clock_frequency12           = \\\"0 ps\\\",\\n    parameter phase_shift12                      = \\\"0 ps\\\",\\n    parameter duty_cycle12                      = 50,\\n    \\n    parameter output_clock_frequency13           = \\\"0 ps\\\",\\n    parameter phase_shift13                      = \\\"0 ps\\\",\\n    parameter duty_cycle13                      = 50,\\n    \\n    parameter output_clock_frequency14           = \\\"0 ps\\\",\\n    parameter phase_shift14                      = \\\"0 ps\\\",\\n    parameter duty_cycle14                      = 50,\\n    \\n    parameter output_clock_frequency15           = \\\"0 ps\\\",\\n    parameter phase_shift15                      = \\\"0 ps\\\",\\n    parameter duty_cycle15                      = 50,\\n    \\n    parameter output_clock_frequency16           = \\\"0 ps\\\",\\n    parameter phase_shift16                      = \\\"0 ps\\\",\\n    parameter duty_cycle16                      = 50,\\n    \\n    parameter output_clock_frequency17           = \\\"0 ps\\\",\\n    parameter phase_shift17                      = \\\"0 ps\\\",\\n    parameter duty_cycle17                      = 50,\\n    \\n    parameter clock_name_0 = \\\"\\\",\\n    parameter clock_name_1 = \\\"\\\",\\n    parameter clock_name_2 = \\\"\\\",\\n    parameter clock_name_3 = \\\"\\\",\\n    parameter clock_name_4 = \\\"\\\",\\n    parameter clock_name_5 = \\\"\\\",\\n    parameter clock_name_6 = \\\"\\\",\\n    parameter clock_name_7 = \\\"\\\",\\n    parameter clock_name_8 = \\\"\\\",\\n\\n    parameter clock_name_global_0 = \\\"false\\\",\\n    parameter clock_name_global_1 = \\\"false\\\",\\n    parameter clock_name_global_2 = \\\"false\\\",\\n    parameter clock_name_global_3 = \\\"false\\\",\\n    parameter clock_name_global_4 = \\\"false\\\",\\n    parameter clock_name_global_5 = \\\"false\\\",\\n    parameter clock_name_global_6 = \\\"false\\\",\\n    parameter clock_name_global_7 = \\\"false\\\",\\n    parameter clock_name_global_8 = \\\"false\\\",\\n\\n    parameter m_cnt_hi_div                       = 1,\\n    parameter m_cnt_lo_div                       = 1,\\n    parameter m_cnt_bypass_en                   = \\\"false\\\",\\n    parameter m_cnt_odd_div_duty_en           = \\\"false\\\",\\n    parameter n_cnt_hi_div                       = 1,\\n    parameter n_cnt_lo_div                       = 1,\\n    parameter n_cnt_bypass_en                   = \\\"false\\\",\\n    parameter n_cnt_odd_div_duty_en           = \\\"false\\\",\\n    parameter c_cnt_hi_div0                      = 1, \\n    parameter c_cnt_lo_div0                      = 1,\\n    parameter c_cnt_bypass_en0                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src0                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en0              = \\\"false\\\",\\n    parameter c_cnt_prst0                  = 1,\\n    parameter c_cnt_ph_mux_prst0                  = 0,\\n    parameter c_cnt_hi_div1                      = 1, \\n    parameter c_cnt_lo_div1                      = 1,\\n    parameter c_cnt_bypass_en1                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src1                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en1              = \\\"false\\\",\\n    parameter c_cnt_prst1                  = 1,\\n    parameter c_cnt_ph_mux_prst1                  = 0,\\n    parameter c_cnt_hi_div2                      = 1, \\n    parameter c_cnt_lo_div2                                              = 1,\\n    parameter c_cnt_bypass_en2                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src2                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en2 = \\\"false\\\",\\n    parameter c_cnt_prst2                  = 1,\\n    parameter c_cnt_ph_mux_prst2                  = 0,\\n    parameter c_cnt_hi_div3                      = 1, \\n    parameter c_cnt_lo_div3                                              = 1,\\n    parameter c_cnt_bypass_en3                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src3                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en3 = \\\"false\\\",\\n    parameter c_cnt_prst3                  = 1,\\n    parameter c_cnt_ph_mux_prst3                  = 0,\\n    parameter c_cnt_hi_div4                      = 1, \\n    parameter c_cnt_lo_div4                                              = 1,\\n    parameter c_cnt_bypass_en4                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src4                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en4 = \\\"false\\\",\\n    parameter c_cnt_prst4                  = 1,\\n    parameter c_cnt_ph_mux_prst4                  = 0,\\n    parameter c_cnt_hi_div5                      = 1, \\n    parameter c_cnt_lo_div5                                              = 1,\\n    parameter c_cnt_bypass_en5                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src5                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en5 = \\\"false\\\",\\n    parameter c_cnt_prst5                  = 1,\\n    parameter c_cnt_ph_mux_prst5                  = 0,\\n    parameter c_cnt_hi_div6                      = 1, \\n    parameter c_cnt_lo_div6                                              = 1,\\n    parameter c_cnt_bypass_en6                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src6                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en6 = \\\"false\\\",\\n    parameter c_cnt_prst6                  = 1,\\n    parameter c_cnt_ph_mux_prst6                  = 0,\\n    parameter c_cnt_hi_div7                      = 1, \\n    parameter c_cnt_lo_div7                                              = 1,\\n    parameter c_cnt_bypass_en7                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src7                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en7 = \\\"false\\\",\\n    parameter c_cnt_prst7                  = 1,\\n    parameter c_cnt_ph_mux_prst7                  = 0,\\n    parameter c_cnt_hi_div8                      = 1, \\n    parameter c_cnt_lo_div8                                              = 1,\\n    parameter c_cnt_bypass_en8                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src8                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en8 = \\\"false\\\",\\n    parameter c_cnt_prst8                  = 1,\\n    parameter c_cnt_ph_mux_prst8                  = 0,\\n    parameter c_cnt_hi_div9                      = 1, \\n    parameter c_cnt_lo_div9                                              = 1,\\n    parameter c_cnt_bypass_en9                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src9                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en9 = \\\"false\\\",\\n    parameter c_cnt_prst9                  = 1,\\n    parameter c_cnt_ph_mux_prst9                  = 0,\\n    parameter c_cnt_hi_div10                      = 1, \\n    parameter c_cnt_lo_div10                                              = 1,\\n    parameter c_cnt_bypass_en10                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src10                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en10 = \\\"false\\\",\\n    parameter c_cnt_prst10                  = 1,\\n    parameter c_cnt_ph_mux_prst10                  = 0,\\n    parameter c_cnt_hi_div11                      = 1, \\n    parameter c_cnt_lo_div11                                              = 1,\\n    parameter c_cnt_bypass_en11                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src11                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en11 = \\\"false\\\",\\n    parameter c_cnt_prst11                  = 1,\\n    parameter c_cnt_ph_mux_prst11                  = 0,\\n    parameter c_cnt_hi_div12                      = 1, \\n    parameter c_cnt_lo_div12                                              = 1,\\n    parameter c_cnt_bypass_en12                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src12                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en12 = \\\"false\\\",\\n    parameter c_cnt_prst12                  = 1,\\n    parameter c_cnt_ph_mux_prst12                  = 0,\\n    parameter c_cnt_hi_div13                      = 1, \\n    parameter c_cnt_lo_div13                                              = 1,\\n    parameter c_cnt_bypass_en13                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src13                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en13 = \\\"false\\\",\\n    parameter c_cnt_prst13                  = 1,\\n    parameter c_cnt_ph_mux_prst13                  = 0,\\n    parameter c_cnt_hi_div14                      = 1, \\n    parameter c_cnt_lo_div14                                              = 1,\\n    parameter c_cnt_bypass_en14                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src14                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en14 = \\\"false\\\",\\n    parameter c_cnt_prst14                  = 1,\\n    parameter c_cnt_ph_mux_prst14                  = 0,\\n    parameter c_cnt_hi_div15                      = 1, \\n    parameter c_cnt_lo_div15                                              = 1,\\n    parameter c_cnt_bypass_en15                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src15                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en15 = \\\"false\\\",\\n    parameter c_cnt_prst15                  = 1,\\n    parameter c_cnt_ph_mux_prst15                  = 0,\\n    parameter c_cnt_hi_div16                      = 1, \\n    parameter c_cnt_lo_div16                                              = 1,\\n    parameter c_cnt_bypass_en16                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src16                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en16 = \\\"false\\\",\\n    parameter c_cnt_prst16                  = 1,\\n    parameter c_cnt_ph_mux_prst16                  = 0,\\n    parameter c_cnt_hi_div17                      = 1, \\n    parameter c_cnt_lo_div17                                              = 1,\\n    parameter c_cnt_bypass_en17                  = \\\"false\\\",\\n\\tparameter c_cnt_in_src17                     = \\\"ph_mux_clk\\\",\\n    parameter c_cnt_odd_div_duty_en17 = \\\"false\\\",\\n    parameter c_cnt_prst17                  = 1,\\n    parameter c_cnt_ph_mux_prst17                  = 0,\\n    parameter pll_vco_div = 1,\\n\\tparameter pll_slf_rst = \\\"false\\\",\\n\\tparameter pll_bw_sel = \\\"low\\\",\\n    parameter pll_output_clk_frequency = \\\"0 MHz\\\",\\n    parameter pll_cp_current = 0,\\n    parameter pll_bwctrl = 0,\\n    parameter pll_fractional_division = 1,\\n    parameter pll_fractional_cout = 24,\\n    parameter pll_dsm_out_sel = \\\"1st_order\\\",\\n    parameter mimic_fbclk_type = \\\"gclk\\\",\\n    parameter pll_fbclk_mux_1 = \\\"glb\\\",\\n    parameter pll_fbclk_mux_2 = \\\"fb_1\\\",\\n    parameter pll_m_cnt_in_src = \\\"ph_mux_clk\\\",\\n\\tparameter pll_vcoph_div = 1,\\n    parameter refclk1_frequency = \\\"0 MHz\\\",\\n    parameter pll_clkin_0_src = \\\"clk_0\\\",\\n    parameter pll_clkin_1_src = \\\"clk_0\\\",\\n    parameter pll_clk_loss_sw_en = \\\"false\\\",\\n    parameter pll_auto_clk_sw_en = \\\"false\\\",\\n    parameter pll_manu_clk_sw_en = \\\"false\\\", \\n    parameter pll_clk_sw_dly = 0,\\n    parameter pll_extclk_0_cnt_src = \\\"pll_extclk_cnt_src_vss\\\",\\t\\n    parameter pll_extclk_1_cnt_src = \\\"pll_extclk_cnt_src_vss\\\"\\n) (\\n    //input\\n    input    refclk,\\n    input    refclk1,\\n    input    fbclk,\\n    input    rst,\\n    input    phase_en,\\n    input    updn,\\n    input    [2:0] num_phase_shifts,\\n    input    scanclk,\\n    input    [4:0] cntsel,\\n    input    [63:0] reconfig_to_pll,\\n    input    extswitch,\\n    input    adjpllin,\\n    input    cclk,\\n    \\n    //output\\n    output    [ number_of_clocks -1 : 0] outclk,\\n    output    fboutclk,\\n    output    locked,\\n    output    phase_done,\\n    output    [63:0]    reconfig_from_pll,\\n    output    activeclk,\\n    output    [1:0] clkbad,\\n\\toutput    [7:0] phout,\\n\\toutput\\t  [1:0] lvds_clk,\\n\\toutput\\t  [1:0] loaden,\\n\\toutput    [1:0] extclk_out,\\n    output    [ number_of_clocks -1 : 0] cascade_out,\\n\\n    //inout\\n    inout zdbfbclk\\n);\\n\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule altera_std_synchronizer(clk, din, dout, reset_n);\\n\\nparameter depth = 2;\\n\\ninput clk;\\ninput reset_n;\\ninput din;\\noutput dout;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule altddio_in (\\n    datain,    // required port, DDR input data\\n    inclock,   // required port, input reference clock to sample data by\\n    inclocken, // enable data clock\\n    aset,      // asynchronous set\\n    aclr,      // asynchronous clear\\n    sset,      // synchronous set\\n    sclr,      // synchronous clear\\n    dataout_h, // data sampled at the rising edge of inclock\\n    dataout_l  // data sampled at the falling edge of inclock\\n);\\n\\nparameter width = 1;\\nparameter power_up_high = \\\"OFF\\\";\\nparameter invert_input_clocks = \\\"OFF\\\";\\nparameter intended_device_family = \\\"Stratix\\\";\\nparameter lpm_type = \\\"altddio_in\\\";\\nparameter lpm_hint = \\\"UNUSED\\\";\\n\\ninput [width-1:0] datain;\\ninput inclock;\\ninput inclocken;\\ninput aset;\\ninput aclr;\\ninput sset;\\ninput sclr;\\n\\noutput [width-1:0] dataout_h;\\noutput [width-1:0] dataout_l;\\n\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule altddio_out (\\n    datain_h,\\n    datain_l,\\n    outclock,\\n    outclocken,\\n    aset,\\n    aclr,\\n    sset,\\n    sclr,\\n    oe,\\n    dataout,\\n    oe_out\\n);\\n\\nparameter width = 1;\\nparameter power_up_high = \\\"OFF\\\";\\nparameter oe_reg = \\\"UNUSED\\\";\\nparameter extend_oe_disable = \\\"UNUSED\\\";\\nparameter intended_device_family = \\\"Stratix\\\";\\nparameter invert_output = \\\"OFF\\\";\\nparameter lpm_type = \\\"altddio_out\\\";\\nparameter lpm_hint = \\\"UNUSED\\\";\\n\\ninput [width-1:0] datain_h;\\ninput [width-1:0] datain_l;\\ninput outclock;\\ninput outclocken;\\ninput aset;\\ninput aclr;\\ninput sset;\\ninput sclr;\\ninput oe;\\n\\noutput [width-1:0] dataout;\\noutput [width-1:0] oe_out;\\n\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule altddio_bidir (\\n    datain_h,\\n    datain_l,\\n    inclock,\\n    inclocken,\\n    outclock,\\n    outclocken,\\n    aset,\\n    aclr,\\n    sset,\\n    sclr,\\n    oe,\\n    dataout_h,\\n    dataout_l,\\n    combout,\\n    oe_out,\\n    dqsundelayedout,\\n    padio\\n);\\n\\n// GLOBAL PARAMETER DECLARATION\\nparameter width = 1; // required parameter\\nparameter power_up_high = \\\"OFF\\\";\\nparameter oe_reg = \\\"UNUSED\\\";\\nparameter extend_oe_disable = \\\"UNUSED\\\";\\nparameter implement_input_in_lcell = \\\"UNUSED\\\";\\nparameter invert_output = \\\"OFF\\\";\\nparameter intended_device_family = \\\"Stratix\\\";\\nparameter lpm_type = \\\"altddio_bidir\\\";\\nparameter lpm_hint = \\\"UNUSED\\\";\\n\\n// INPUT PORT DECLARATION\\ninput [width-1:0] datain_h;\\ninput [width-1:0] datain_l;\\ninput inclock;\\ninput inclocken;\\ninput outclock;\\ninput outclocken;\\ninput aset;\\ninput aclr;\\ninput sset;\\ninput sclr;\\ninput oe;\\n\\n// OUTPUT PORT DECLARATION\\noutput [width-1:0] dataout_h;\\noutput [width-1:0] dataout_l;\\noutput [width-1:0] combout;\\noutput [width-1:0] oe_out;\\noutput [width-1:0] dqsundelayedout;\\n// BIDIRECTIONAL PORT DECLARATION\\ninout  [width-1:0] padio;\\n\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule altiobuf_in(datain, dataout);\\n\\nparameter enable_bus_hold = \\\"FALSE\\\";\\nparameter use_differential_mode = \\\"FALSE\\\";\\nparameter number_of_channels = 1;\\n\\ninput [number_of_channels-1:0] datain;\\noutput [number_of_channels-1:0] dataout;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule altiobuf_out(datain, dataout);\\n\\nparameter enable_bus_hold = \\\"FALSE\\\";\\nparameter use_differential_mode = \\\"FALSE\\\";\\nparameter use_oe = \\\"FALSE\\\";\\nparameter number_of_channels = 1;\\n\\ninput [number_of_channels-1:0] datain;\\noutput [number_of_channels-1:0] dataout;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule altiobuf_bidir(dataio, oe, datain, dataout);\\n\\nparameter number_of_channels = 1;\\nparameter enable_bus_hold = \\\"OFF\\\";\\n\\ninout [number_of_channels-1:0] dataio;\\ninput [number_of_channels-1:0] datain;\\noutput [number_of_channels-1:0] dataout;\\ninput [number_of_channels-1:0] oe;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule altsyncram(clock0, clock1, address_a, data_a, rden_a, wren_a, byteena_a, q_a, addressstall_a, address_b, data_b, rden_b, wren_b, byteena_b, q_b, addressstall_b, clocken0, clocken1, clocken2, clocken3, aclr0, aclr1, eccstatus);\\n\\nparameter lpm_type = \\\"altsyncram\\\";\\nparameter operation_mode = \\\"dual_port\\\";\\nparameter ram_block_type = \\\"auto\\\";\\nparameter intended_device_family = \\\"auto\\\";\\nparameter power_up_uninitialized = \\\"false\\\";\\nparameter read_during_write_mode_mixed_ports = \\\"dontcare\\\";\\nparameter byte_size = 8;\\nparameter widthad_a = 1;\\nparameter width_a = 1;\\nparameter width_byteena_a = 1;\\nparameter numwords_a = 1;\\nparameter clock_enable_input_a = \\\"clocken0\\\";\\nparameter widthad_b = 1;\\nparameter width_b = 1;\\nparameter numwords_b = 1;\\nparameter address_aclr_b = \\\"aclr0\\\";\\nparameter address_reg_b = \\\"\\\";\\nparameter outdata_aclr_b = \\\"aclr0\\\";\\nparameter outdata_reg_b = \\\"\\\";\\nparameter clock_enable_input_b = \\\"clocken0\\\";\\nparameter clock_enable_output_b = \\\"clocken0\\\";\\n\\ninput clock0, clock1;\\ninput [widthad_a-1:0] address_a;\\ninput [width_a-1:0] data_a;\\ninput rden_a;\\ninput wren_a;\\ninput [(width_a/8)-1:0] byteena_a;\\ninput addressstall_a;\\n\\noutput [width_a-1:0] q_a;\\n\\ninput wren_b;\\ninput rden_b;\\ninput [widthad_b-1:0] address_b;\\ninput [width_b-1:0] data_b;\\ninput [(width_b/8)-1:0] byteena_b;\\ninput addressstall_b;\\n\\noutput [width_b-1:0] q_b;\\n\\ninput clocken0;\\ninput clocken1;\\ninput clocken2;\\ninput clocken3;\\n\\ninput aclr0;\\ninput aclr1;\\n\\noutput eccstatus;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule cyclonev_mlab_cell(portaaddr, portadatain, portbaddr, portbdataout, ena0, clk0, clk1);\\n\\nparameter logical_ram_name = \\\"\\\";\\nparameter logical_ram_depth = 32;\\nparameter logical_ram_width = 20;\\nparameter mixed_port_feed_through_mode = \\\"new\\\";\\nparameter first_bit_number = 0;\\nparameter first_address = 0;\\nparameter last_address = 31;\\nparameter address_width = 5;\\nparameter data_width = 1;\\nparameter byte_enable_mask_width = 1;\\nparameter port_b_data_out_clock = \\\"NONE\\\";\\nparameter [639:0] mem_init0 = 640'b0;\\n\\ninput [address_width-1:0] portaaddr, portbaddr;\\ninput [data_width-1:0] portadatain;\\noutput [data_width-1:0] portbdataout;\\ninput ena0, clk0, clk1;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule cyclonev_mac(ax, ay, resulta);\\n\\nparameter ax_width = 9;\\nparameter signed_max = \\\"true\\\";\\nparameter ay_scan_in_width = 9;\\nparameter signed_may = \\\"true\\\";\\nparameter result_a_width = 18;\\nparameter operation_mode = \\\"M9x9\\\";\\n\\ninput [ax_width-1:0] ax;\\ninput [ay_scan_in_width-1:0] ay;\\noutput [result_a_width-1:0] resulta;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule cyclone10gx_mac(ax, ay, resulta);\\n\\nparameter ax_width = 18;\\nparameter signed_max = \\\"true\\\";\\nparameter ay_scan_in_width = 18;\\nparameter signed_may = \\\"true\\\";\\nparameter result_a_width = 36;\\nparameter operation_mode = \\\"M18X18_FULL\\\";\\n\\ninput [ax_width-1:0] ax;\\ninput [ay_scan_in_width-1:0] ay;\\noutput [result_a_width-1:0] resulta;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule cyclonev_ram_block(portaaddr, portadatain, portawe, portbaddr, portbdataout, portbre, clk0);\\n\\nparameter operation_mode = \\\"dual_port\\\";\\nparameter logical_ram_name = \\\"\\\";\\nparameter port_a_address_width = 10;\\nparameter port_a_data_width = 10;\\nparameter port_a_logical_ram_depth = 1024;\\nparameter port_a_logical_ram_width = 10;\\nparameter port_a_first_address = 0;\\nparameter port_a_last_address = 1023;\\nparameter port_a_first_bit_number = 0;\\nparameter port_b_address_width = 10;\\nparameter port_b_data_width = 10;\\nparameter port_b_logical_ram_depth = 1024;\\nparameter port_b_logical_ram_width = 10;\\nparameter port_b_first_address = 0;\\nparameter port_b_last_address = 1023;\\nparameter port_b_first_bit_number = 0;\\nparameter port_b_address_clock = \\\"clock0\\\";\\nparameter port_b_read_enable_clock = \\\"clock0\\\";\\nparameter mem_init0 = \\\"\\\";\\nparameter mem_init1 = \\\"\\\";\\nparameter mem_init2 = \\\"\\\";\\nparameter mem_init3 = \\\"\\\";\\nparameter mem_init4 = \\\"\\\";\\n\\ninput [port_a_address_width-1:0] portaaddr;\\ninput [port_b_address_width-1:0] portbaddr;\\ninput [port_a_data_width-1:0] portadatain;\\noutput [port_b_data_width-1:0] portbdataout;\\ninput clk0, portawe, portbre;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule cyclone10gx_io_ibuf(i, ibar, dynamicterminationcontrol, o);\\n\\nparameter differential_mode =\\\"false\\\";\\nparameter bus_hold = \\\"false\\\";\\nparameter simulate_z_as = \\\"Z\\\";\\nparameter lpm_type = \\\"cyclone10gx_io_ibuf\\\";\\n\\n(* iopad_external_pin *) input i;\\n(* iopad_external_pin *) input ibar;\\ninput dynamicterminationcontrol;\\noutput o;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule cyclone10gx_io_obuf(i, oe, dynamicterminationcontrol, seriesterminationcontrol, parallelterminationcontrol, devoe, o, obar);\\n\\nparameter open_drain_output = \\\"false\\\";\\nparameter bus_hold = \\\"false\\\";\\nparameter shift_series_termination_control = \\\"false\\\";\\nparameter sim_dynamic_termination_control_is_connected = \\\"false\\\";\\nparameter lpm_type = \\\"cyclone10gx_io_obuf\\\";\\n\\ninput i;\\ninput oe;\\ninput devoe;\\ninput dynamicterminationcontrol;\\ninput [15:0] seriesterminationcontrol;\\ninput [15:0] parallelterminationcontrol;\\n(* iopad_external_pin *) output o;\\n(* iopad_external_pin *) output obar;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule cyclonev_clkena(inclk, ena, enaout, outclk);\\n\\nparameter clock_type = \\\"auto\\\";\\nparameter ena_register_mode = \\\"always enabled\\\";\\nparameter lpm_type = \\\"cyclonev_clkena\\\";\\nparameter ena_register_power_up = \\\"high\\\";\\nparameter disable_mode = \\\"low\\\";\\nparameter test_syn = \\\"high\\\";\\n\\ninput inclk;\\ninput ena;\\noutput enaout;\\noutput outclk;\\n\\nendmodule\\n\\n(* blackbox *)\\nmodule cyclone10gx_clkena(inclk, ena, enaout, outclk);\\n\\nparameter clock_type = \\\"auto\\\";\\nparameter ena_register_mode = \\\"always enabled\\\";\\nparameter lpm_type = \\\"cyclone10gx_clkena\\\";\\nparameter ena_register_power_up = \\\"high\\\";\\nparameter disable_mode = \\\"low\\\";\\nparameter test_syn = \\\"high\\\";\\n\\ninput inclk;\\ninput ena;\\noutput enaout;\\noutput outclk;\\n\\nendmodule\\n\\n// Internal interfaces\\n(* keep *)\\nmodule cyclonev_oscillator(oscena, clkout, clkout1);\\n\\ninput oscena;\\noutput clkout;\\noutput clkout1;\\n\\nendmodule\\n\\n// HPS interfaces\\n(* keep *)\\nmodule cyclonev_hps_interface_mpu_general_purpose(gp_in, gp_out);\\n\\ninput [31:0] gp_in;\\noutput [31:0] gp_out;\\n\\nendmodule\\n\",\n                \"mem_sim.v\": \"// The MLAB\\n// --------\\n// In addition to Logic Array Blocks (LABs) that contain ten Adaptive Logic\\n// Modules (ALMs, see alm_sim.v), the Cyclone V/10GX also contain\\n// Memory/Logic Array Blocks (MLABs) that can act as either ten ALMs, or utilise\\n// the memory the ALM uses to store the look-up table data for general usage,\\n// producing a 32 address by 20-bit block of memory. MLABs are spread out\\n// around the chip, so they can be placed near where they are needed, rather than\\n// being comparatively limited in placement for a deep but narrow memory such as\\n// the M10K memory block.\\n//\\n// MLABs are used mainly for shallow but wide memories, such as CPU register\\n// files (which have perhaps 32 registers that are comparatively wide (16/32-bit))\\n// or shift registers (by using the output of the Nth bit as input for the N+1th\\n// bit).\\n//\\n// Oddly, instead of providing a block 32 address by 20-bit cell, Quartus asks\\n// synthesis tools to build MLABs out of 32 address by 1-bit cells, and tries\\n// to put these cells in the same MLAB during cell placement. Because of this\\n// a MISTRAL_MLAB cell represents one of these 32 address by 1-bit cells, and\\n// 20 of them represent a physical MLAB.\\n//\\n// How the MLAB works\\n// ------------------\\n// MLABs are poorly documented, so the following information is based mainly\\n// on the simulation model and my knowledge of how memories like these work.\\n// Additionally, note that the ports of MISTRAL_MLAB are the ones auto-generated\\n// by the Yosys `memory_bram` pass, and it doesn't make sense to me to use\\n// `techmap` just for the sake of renaming the cell ports.\\n//\\n// The MLAB can be initialised to any value, but unfortunately Quartus only\\n// allows memory initialisation from a file. Since Yosys doesn't preserve input\\n// file information, or write the contents of an `initial` block to a file,\\n// Yosys can't currently initialise the MLAB in a way Quartus will accept.\\n//\\n// The MLAB takes in data from A1DATA at the rising edge of CLK1, and if A1EN\\n// is high, writes it to the address in A1ADDR. A1EN can therefore be used to\\n// conditionally write data to the MLAB.\\n//\\n// Simultaneously, the MLAB reads data from B1ADDR, and outputs it to B1DATA,\\n// asynchronous to CLK1 and ignoring A1EN. If a synchronous read is needed\\n// then the output can be fed to embedded flops. Presently, Yosys assumes\\n// Quartus will pack external flops into the MLAB, but this is an assumption\\n// that needs testing.\\n\\n// The vendor sim model outputs 'x for a very short period (a few\\n// combinational delta cycles) after each write. This has been omitted from\\n// the following model because it's very difficult to trigger this in practice\\n// as clock cycles will be much longer than any potential blip of 'x, so the\\n// model can be treated as always returning a defined result.\\n\\n(* abc9_box, lib_whitebox *)\\nmodule MISTRAL_MLAB(input [4:0] A1ADDR, input A1DATA, A1EN,\\n    (* clkbuf_sink *) input CLK1,\\n    input [4:0] B1ADDR, output B1DATA);\\n\\nreg [31:0] mem = 32'b0;\\n\\n`ifdef cyclonev\\nspecify\\n    $setup(A1ADDR, posedge CLK1, 86);\\n    $setup(A1DATA, posedge CLK1, 86);\\n    $setup(A1EN, posedge CLK1, 86);\\n\\n    (B1ADDR[0] => B1DATA) = 487;\\n    (B1ADDR[1] => B1DATA) = 475;\\n    (B1ADDR[2] => B1DATA) = 382;\\n    (B1ADDR[3] => B1DATA) = 284;\\n    (B1ADDR[4] => B1DATA) = 96;\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    $setup(A1ADDR, posedge CLK1, 62);\\n    $setup(A1DATA, posedge CLK1, 62);\\n    $setup(A1EN, posedge CLK1, 62);\\n\\n    (B1ADDR[0] => B1DATA) = 370;\\n    (B1ADDR[1] => B1DATA) = 292;\\n    (B1ADDR[2] => B1DATA) = 218;\\n    (B1ADDR[3] => B1DATA) = 74;\\n    (B1ADDR[4] => B1DATA) = 177;\\nendspecify\\n`endif\\n`ifdef cyclone10gx\\n// TODO: Cyclone 10 GX timings; the below timings are for Cyclone V\\nspecify\\n    $setup(A1ADDR, posedge CLK1, 86);\\n    $setup(A1DATA, posedge CLK1, 86);\\n    $setup(A1EN, posedge CLK1, 86);\\n\\n    (B1ADDR[0] => B1DATA) = 487;\\n    (B1ADDR[1] => B1DATA) = 475;\\n    (B1ADDR[2] => B1DATA) = 382;\\n    (B1ADDR[3] => B1DATA) = 284;\\n    (B1ADDR[4] => B1DATA) = 96;\\nendspecify\\n`endif\\n\\nalways @(posedge CLK1)\\n    if (A1EN) mem[A1ADDR] <= A1DATA;\\n\\nassign B1DATA = mem[B1ADDR];\\n\\nendmodule\\n\\n// The M10K\\n// --------\\n// TODO\\n\\nmodule MISTRAL_M10K(CLK1, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);\\n\\nparameter INIT = 0;\\n\\nparameter CFG_ABITS = 10;\\nparameter CFG_DBITS = 10;\\n\\n(* clkbuf_sink *) input CLK1;\\ninput [CFG_ABITS-1:0] A1ADDR, B1ADDR;\\ninput [CFG_DBITS-1:0] A1DATA;\\ninput A1EN, B1EN;\\noutput reg [CFG_DBITS-1:0] B1DATA;\\n\\nreg [2**CFG_ABITS * CFG_DBITS - 1 : 0] mem = INIT;\\n\\n`ifdef cyclonev\\nspecify\\n    $setup(A1ADDR, posedge CLK1, 125);\\n    $setup(A1DATA, posedge CLK1, 97);\\n    $setup(A1EN, posedge CLK1, 140);\\n    $setup(B1ADDR, posedge CLK1, 125);\\n    $setup(B1EN, posedge CLK1, 161);\\n\\n    if (B1EN) (posedge CLK1 => (B1DATA : A1DATA)) = 1004;\\nendspecify\\n`endif\\n`ifdef arriav\\nspecify\\n    $setup(A1ADDR, posedge CLK1, 97);\\n    $setup(A1DATA, posedge CLK1, 74);\\n    $setup(A1EN, posedge CLK1, 109);\\n    $setup(B1ADDR, posedge CLK1, 97);\\n    $setup(B1EN, posedge CLK1, 126);\\n\\n    if (B1EN) (posedge CLK1 => (B1DATA : A1DATA)) = 787;\\nendspecify\\n`endif\\n\\nalways @(posedge CLK1) begin\\n    if (!A1EN)\\n        mem[(A1ADDR + 1) * CFG_DBITS - 1 : A1ADDR * CFG_DBITS] <= A1DATA;\\n\\n    if (B1EN)\\n        B1DATA <= mem[(B1ADDR + 1) * CFG_DBITS - 1 : B1ADDR * CFG_DBITS];\\nend\\n\\nendmodule\\n\",\n                \"misc_sim.v\": \"module MISTRAL_IB((* iopad_external_pin *)  input PAD, output O);\\n\\tassign O = PAD;\\nendmodule\\n\\nmodule MISTRAL_OB((* iopad_external_pin *)  output PAD, input I);\\n\\tassign PAD = I;\\nendmodule\\n\\nmodule MISTRAL_IO((* iopad_external_pin *)  inout PAD, input I, input OE, output O);\\n\\tassign PAD = OE ? I : 1'bz;\\n\\tassign O = PAD;\\nendmodule\\n\\n// Eventually, we should support clock enables and model them here too.\\n// For now, CLKENA is used as a basic entry point to global routing.\\nmodule MISTRAL_CLKBUF (\\n\\tinput A,\\n\\t(* clkbuf_driver *) output Q\\n);\\n\\tassign Q = A;\\nendmodule\",\n                \"quartus_rename.v\": \"`ifdef cyclonev\\n`define LCELL cyclonev_lcell_comb\\n`define MAC cyclonev_mac\\n`define MLAB cyclonev_mlab_cell\\n`define RAM_BLOCK cyclonev_ram_block\\n`define IBUF cyclonev_io_ibuf\\n`define OBUF cyclonev_io_obuf\\n`define CLKENA cyclonev_clkena\\n`endif\\n`ifdef arriav\\n`define LCELL arriav_lcell_comb\\n`define MAC arriav_mac\\n`define MLAB arriav_mlab_cell\\n`define RAM_BLOCK arriav_ram_block\\n`define IBUF arriav_io_ibuf\\n`define OBUF arriav_io_obuf\\n`define CLKENA arriav_clkena\\n`endif\\n`ifdef cyclone10gx\\n`define LCELL cyclone10gx_lcell_comb\\n`define MAC cyclone10gx_mac\\n`define MLAB cyclone10gx_mlab_cell\\n`define RAM_BLOCK cyclone10gx_ram_block\\n`define IBUF cyclone10gx_io_ibuf\\n`define OBUF cyclone10gx_io_obuf\\n`define CLKENA cyclone10gx_clkena\\n`endif\\n\\nmodule __MISTRAL_VCC(output Q);\\n\\nMISTRAL_ALUT2 #(.LUT(4'b1111)) _TECHMAP_REPLACE_ (.A(1'b1), .B(1'b1), .Q(Q));\\n\\nendmodule\\n\\n\\nmodule __MISTRAL_GND(output Q);\\n\\nMISTRAL_ALUT2 #(.LUT(4'b0000)) _TECHMAP_REPLACE_ (.A(1'b1), .B(1'b1), .Q(Q));\\n\\nendmodule\\n\\n\\nmodule MISTRAL_FF(input DATAIN, CLK, ACLR, ENA, SCLR, SLOAD, SDATA, output reg Q);\\n\\ndffeas #(.power_up(\\\"low\\\"), .is_wysiwyg(\\\"true\\\")) _TECHMAP_REPLACE_ (.d(DATAIN), .clk(CLK), .clrn(ACLR), .ena(ENA), .sclr(SCLR), .sload(SLOAD), .asdata(SDATA), .q(Q));\\n\\nendmodule\\n\\n\\nmodule MISTRAL_ALUT6(input A, B, C, D, E, F, output Q);\\nparameter [63:0] LUT = 64'h0000_0000_0000_0000;\\n\\n`LCELL #(.lut_mask(LUT)) _TECHMAP_REPLACE_ (.dataa(A), .datab(B), .datac(C), .datad(D), .datae(E), .dataf(F), .combout(Q));\\n\\nendmodule\\n\\n\\nmodule MISTRAL_ALUT5(input A, B, C, D, E, output Q);\\nparameter [31:0] LUT = 32'h0000_0000;\\n\\n`LCELL #(.lut_mask({2{LUT}})) _TECHMAP_REPLACE_ (.dataa(A), .datab(B), .datac(C), .datad(D), .datae(E), .combout(Q));\\n\\nendmodule\\n\\n\\nmodule MISTRAL_ALUT4(input A, B, C, D, output Q);\\nparameter [15:0] LUT = 16'h0000;\\n\\n`LCELL #(.lut_mask({4{LUT}})) _TECHMAP_REPLACE_ (.dataa(A), .datab(B), .datac(C), .datad(D), .combout(Q));\\n\\nendmodule\\n\\n\\nmodule MISTRAL_ALUT3(input A, B, C, output Q);\\nparameter [7:0] LUT = 8'h00;\\n\\n`LCELL #(.lut_mask({8{LUT}})) _TECHMAP_REPLACE_ (.dataa(A), .datab(B), .datac(C), .combout(Q));\\n\\nendmodule\\n\\n\\nmodule MISTRAL_ALUT2(input A, B, output Q);\\nparameter [3:0] LUT = 4'h0;\\n\\n`LCELL #(.lut_mask({16{LUT}})) _TECHMAP_REPLACE_ (.dataa(A), .datab(B), .combout(Q));\\n\\nendmodule\\n\\n\\nmodule MISTRAL_NOT(input A, output Q);\\n\\nNOT _TECHMAP_REPLACE_ (.IN(A), .OUT(Q));\\n\\nendmodule\\n\\n\\nmodule MISTRAL_ALUT_ARITH(input A, B, C, D0, D1, CI, output SO, CO);\\nparameter LUT0 = 16'h0000;\\nparameter LUT1 = 16'h0000;\\n\\n`LCELL #(.lut_mask({16'h0, LUT1, 16'h0, LUT0})) _TECHMAP_REPLACE_ (.dataa(A), .datab(B), .datac(C), .datad(D0), .dataf(D1), .cin(CI), .sumout(SO), .cout(CO));\\n\\nendmodule\\n\\n\\nmodule MISTRAL_MLAB(input [4:0] A1ADDR, input A1DATA, A1EN, CLK1, input [4:0] B1ADDR, output B1DATA);\\n\\nparameter _TECHMAP_CELLNAME_ = \\\"\\\";\\n\\n// Here we get to an unfortunate situation. The cell has a mem_init0 parameter,\\n// which takes in a hexadecimal string that could be used to initialise RAM.\\n// In the vendor simulation models, this appears to work fine, but Quartus,\\n// either intentionally or not, forgets about this parameter and initialises the\\n// RAM to zero.\\n//\\n// Because of this, RAM initialisation is presently disabled, but the source\\n// used to generate mem_init0 is kept (commented out) in case this gets fixed\\n// or an undocumented way to get Quartus to initialise from mem_init0 is found.\\n\\n`MLAB #(\\n    .logical_ram_name(_TECHMAP_CELLNAME_),\\n    .logical_ram_depth(32),\\n    .logical_ram_width(1),\\n    .mixed_port_feed_through_mode(\\\"Dont Care\\\"),\\n    .first_bit_number(0),\\n    .first_address(0),\\n    .last_address(31),\\n    .address_width(5),\\n    .data_width(1),\\n    .byte_enable_mask_width(1),\\n    .port_b_data_out_clock(\\\"NONE\\\"),\\n    // .mem_init0($sformatf(\\\"%08x\\\", INIT))\\n) _TECHMAP_REPLACE_ (\\n    .portaaddr(A1ADDR),\\n    .portadatain(A1DATA),\\n    .portbaddr(B1ADDR),\\n    .portbdataout(B1DATA),\\n    .ena0(A1EN),\\n    .clk0(CLK1)\\n);\\n\\nendmodule\\n\\n\\nmodule MISTRAL_M10K(A1ADDR, A1DATA, A1EN, CLK1, B1ADDR, B1DATA, B1EN);\\n\\nparameter CFG_ABITS = 10;\\nparameter CFG_DBITS = 10;\\n\\nparameter _TECHMAP_CELLNAME_ = \\\"\\\";\\n\\ninput [CFG_ABITS-1:0] A1ADDR, B1ADDR;\\ninput [CFG_DBITS-1:0] A1DATA;\\ninput CLK1, A1EN, B1EN;\\noutput [CFG_DBITS-1:0] B1DATA;\\n\\n// Much like the MLAB, the M10K has mem_init[01234] parameters which would let\\n// you initialise the RAM cell via hex literals. If they were implemented.\\n\\n// Since the MISTRAL_M10K block has an inverted write-enable (like the real hardware)\\n// but the Quartus primitive expects a normal write-enable, we add an inverter.\\nwire A1EN_N;\\nNOT wren_inv (.IN(A1EN), .OUT(A1EN_N));\\n\\n`RAM_BLOCK #(\\n    .operation_mode(\\\"dual_port\\\"),\\n    .logical_ram_name(_TECHMAP_CELLNAME_),\\n    .port_a_address_width(CFG_ABITS),\\n    .port_a_data_width(CFG_DBITS),\\n    .port_a_logical_ram_depth(2**CFG_ABITS),\\n    .port_a_logical_ram_width(CFG_DBITS),\\n    .port_a_first_address(0),\\n    .port_a_last_address(2**CFG_ABITS - 1),\\n    .port_a_first_bit_number(0),\\n    .port_b_address_width(CFG_ABITS),\\n    .port_b_data_width(CFG_DBITS),\\n    .port_b_logical_ram_depth(2**CFG_ABITS),\\n    .port_b_logical_ram_width(CFG_DBITS),\\n    .port_b_first_address(0),\\n    .port_b_last_address(2**CFG_ABITS - 1),\\n    .port_b_first_bit_number(0),\\n    .port_b_address_clock(\\\"clock0\\\"),\\n    .port_b_read_enable_clock(\\\"clock0\\\")\\n) ram_block (\\n    .portaaddr(A1ADDR),\\n    .portadatain(A1DATA),\\n    .portawe(A1EN_N),\\n    .portbaddr(B1ADDR),\\n    .portbdataout(B1DATA),\\n    .portbre(B1EN),\\n    .clk0(CLK1)\\n);\\n\\nendmodule\\n\\n\\nmodule MISTRAL_MUL27X27(input [26:0] A, B, output [53:0] Y);\\n\\nparameter A_SIGNED = 1;\\nparameter B_SIGNED = 1;\\n\\n`MAC #(\\n    .ax_width(27),\\n    .signed_max(A_SIGNED ? \\\"true\\\" : \\\"false\\\"),\\n    .ay_scan_in_width(27),\\n    .signed_may(B_SIGNED ? \\\"true\\\" : \\\"false\\\"),\\n    .result_a_width(54),\\n    .operation_mode(\\\"M27x27\\\")\\n) _TECHMAP_REPLACE_ (\\n    .ax(A),\\n    .ay(B),\\n    .resulta(Y)\\n);\\n\\nendmodule\\n\\n\\nmodule MISTRAL_MUL18X18(input [17:0] A, B, output [35:0] Y);\\n\\nparameter A_SIGNED = 1;\\nparameter B_SIGNED = 1;\\n\\n`MAC #(\\n    .ax_width(18),\\n    .signed_max(A_SIGNED ? \\\"true\\\" : \\\"false\\\"),\\n    .ay_scan_in_width(18),\\n    .signed_may(B_SIGNED ? \\\"true\\\" : \\\"false\\\"),\\n    .result_a_width(36),\\n    .operation_mode(\\\"M18x18_FULL\\\")\\n) _TECHMAP_REPLACE_ (\\n    .ax(A),\\n    .ay(B),\\n    .resulta(Y)\\n);\\n\\nendmodule\\n\\n\\nmodule MISTRAL_MUL9X9(input [8:0] A, B, output [17:0] Y);\\n\\nparameter A_SIGNED = 1;\\nparameter B_SIGNED = 1;\\n\\n`MAC #(\\n    .ax_width(9),\\n    .signed_max(A_SIGNED ? \\\"true\\\" : \\\"false\\\"),\\n    .ay_scan_in_width(9),\\n    .signed_may(B_SIGNED ? \\\"true\\\" : \\\"false\\\"),\\n    .result_a_width(18),\\n    .operation_mode(\\\"M9x9\\\")\\n) _TECHMAP_REPLACE_ (\\n    .ax(A),\\n    .ay(B),\\n    .resulta(Y)\\n);\\n\\nendmodule\\n\\nmodule MISTRAL_IB(input PAD, output O);\\n`IBUF #(\\n    .bus_hold(\\\"false\\\"),\\n    .differential_mode(\\\"false\\\")\\n) _TECHMAP_REPLACE_ (\\n    .i(PAD),\\n    .o(O)\\n);\\nendmodule\\n\\nmodule MISTRAL_OB(output PAD, input I, OE);\\n`OBUF #(\\n    .bus_hold(\\\"false\\\"),\\n    .differential_mode(\\\"false\\\")\\n) _TECHMAP_REPLACE_ (\\n    .i(I),\\n    .o(PAD),\\n    .oe(OE)\\n);\\nendmodule\\n\\nmodule MISTRAL_IO(output PAD, input I, OE, output O);\\n`IBUF #(\\n    .bus_hold(\\\"false\\\"),\\n    .differential_mode(\\\"false\\\")\\n) ibuf (\\n    .i(PAD),\\n    .o(O)\\n);\\n\\n`OBUF #(\\n    .bus_hold(\\\"false\\\"),\\n    .differential_mode(\\\"false\\\")\\n) obuf (\\n    .i(I),\\n    .o(PAD),\\n    .oe(OE)\\n);\\nendmodule\\n\\nmodule MISTRAL_CLKBUF (input A, output Q);\\n`CLKENA #(\\n    .clock_type(\\\"auto\\\"),\\n    .ena_register_mode(\\\"always enabled\\\"),\\n    .ena_register_power_up(\\\"high\\\"),\\n    .disable_mode(\\\"low\\\"),\\n    .test_syn(\\\"high\\\")\\n) _TECHMAP_REPLACE_ (\\n    .inclk(A),\\n    .ena(1'b1),\\n    .outclk(Q)\\n);\\nendmodule\\n\",\n            },\n            \"cyclonev\": {\n                \"cells_sim.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\nmodule VCC (output V);\\n   assign V = 1'b1;\\nendmodule // VCC\\n\\nmodule GND (output G);\\n   assign G = 1'b0;\\nendmodule // GND\\n\\n/* Altera Cyclone V devices Input Buffer Primitive */\\nmodule cyclonev_io_ibuf\\n  (output o,\\n   (* iopad_external_pin *) input i,\\n   (* iopad_external_pin *) input ibar,\\n   input dynamicterminationcontrol);\\n\\n   parameter differential_mode = \\\"false\\\";\\n   parameter bus_hold = \\\"false\\\";\\n   parameter simulate_z_as = \\\"Z\\\";\\n   parameter lpm_type = \\\"cyclonev_io_ibuf\\\";\\n\\n   assign o    = i;\\nendmodule // cyclonev_io_ibuf\\n\\n/* Altera Cyclone V devices Output Buffer Primitive */\\nmodule cyclonev_io_obuf\\n  ((* iopad_external_pin *) output o,\\n   input i, oe, dynamicterminationcontrol,\\n   input [15:0] seriesterminationcontrol, parallelterminationcontrol,\\n   input devoe,\\n   (* iopad_external_pin *) output obar);\\n\\n   parameter open_drain_output = \\\"false\\\";\\n   parameter bus_hold = \\\"false\\\";\\n   parameter shift_series_termination_control = \\\"false\\\";\\n   parameter sim_dynamic_termination_control_is_connected = \\\"false\\\";\\n   parameter lpm_type = \\\"cyclonev_io_obuf\\\";\\n\\n   assign o  = oe ? i : 1'bz;\\nendmodule // cyclonev_io_obuf\\n\\n/* Altera Cyclone V LUT Primitive */\\nmodule cyclonev_lcell_comb\\n  (output combout, cout, sumout, shareout,\\n   input dataa, datab, datac, datad,\\n   input datae, dataf, datag, cin,\\n   input sharein);\\n\\n   parameter lut_mask      = 64'hFFFFFFFFFFFFFFFF;\\n   parameter dont_touch    = \\\"off\\\";\\n   parameter lpm_type      = \\\"cyclonev_lcell_comb\\\";\\n   parameter shared_arith  = \\\"off\\\";\\n   parameter extended_lut  = \\\"off\\\";\\n\\n   // Internal variables\\n   // Sub mask for fragmented LUTs\\n   wire [15:0] mask_a, mask_b, mask_c, mask_d;\\n   // Independent output for fragmented LUTs\\n   wire        output_0, output_1, output_2, output_3;\\n   // Extended mode uses mux to define the output\\n   wire        mux_0, mux_1;\\n   // Input for hold the shared LUT mode value\\n   wire        shared_lut_alm;\\n\\n   // Simulation model of 4-input LUT\\n   function lut4;\\n      input [15:0] mask;\\n      input        dataa, datab, datac, datad;\\n      reg [7:0]    s3;\\n      reg [3:0]    s2;\\n      reg [1:0]    s1;\\n      begin\\n         s3   = datad ? mask[15:8] : mask[7:0];\\n         s2   = datac ?   s3[7:4]  :   s3[3:0];\\n         s1   = datab ?   s2[3:2]  :   s2[1:0];\\n         lut4 = dataa ? s1[1] : s1[0];\\n      end\\n   endfunction // lut4\\n\\n   // Simulation model of 5-input LUT\\n   function lut5;\\n      input [31:0] mask; // wp-01003.pdf, page 3: \\\"a 5-LUT can be built with two 4-LUTs and a multiplexer.\\n      input        dataa, datab, datac, datad, datae;\\n      reg          upper_lut_value;\\n      reg          lower_lut_value;\\n      begin\\n         upper_lut_value = lut4(mask[31:16], dataa, datab, datac, datad);\\n         lower_lut_value = lut4(mask[15:0], dataa, datab, datac, datad);\\n         lut5            = (datae) ? upper_lut_value : lower_lut_value;\\n      end\\n   endfunction // lut5\\n\\n   // Simulation model of 6-input LUT\\n   function lut6;\\n      input [63:0] mask;\\n      input        dataa, datab, datac, datad, datae, dataf;\\n      reg          upper_lut_value;\\n      reg          lower_lut_value;\\n      reg          out_0, out_1, out_2, out_3;\\n      begin\\n         upper_lut_value = lut5(mask[63:32], dataa, datab, datac, datad, datae);\\n         lower_lut_value = lut5(mask[31:0], dataa, datab, datac, datad, datae);\\n         lut6            = (dataf) ?  upper_lut_value : lower_lut_value;\\n      end\\n   endfunction // lut6\\n\\n   assign {mask_a, mask_b, mask_c, mask_d} = {lut_mask[15:0], lut_mask[31:16], lut_mask[47:32], lut_mask[63:48]};\\n`ifdef ADVANCED_ALM\\n   always @(*) begin\\n      if(extended_lut == \\\"on\\\")\\n        shared_lut_alm = datag;\\n      else\\n        shared_lut_alm = datac;\\n      // Build the ALM behaviour\\n      out_0 = lut4(mask_a, dataa, datab, datac, datad);\\n      out_1 = lut4(mask_b, dataa, datab, shared_lut_alm, datad);\\n      out_2 = lut4(mask_c, dataa, datab, datac, datad);\\n      out_3 = lut4(mask_d, dataa, datab, shared_lut_alm, datad);\\n   end\\n`else\\n   `ifdef DEBUG\\n       initial $display(\\\"Advanced ALM lut combine is not implemented yet\\\");\\n   `endif\\n`endif\\nendmodule // cyclonev_lcell_comb\\n\\n\\n/* Altera D Flip-Flop Primitive */\\nmodule dffeas\\n  (output q,\\n   input d, clk, clrn, prn, ena,\\n   input asdata, aload, sclr, sload);\\n\\n   // Timing simulation is not covered\\n   parameter power_up=\\\"dontcare\\\";\\n   parameter is_wysiwyg=\\\"false\\\";\\n\\n   reg   q_tmp;\\n   wire  reset;\\n   reg [7:0] debug_net;\\n\\n   assign reset       = (prn && sclr && ~clrn && ena);\\n   assign q           = q_tmp & 1'b1;\\n\\n   always @(posedge clk, posedge aload) begin\\n      if(reset)        q_tmp <= 0;\\n      else q_tmp <= d;\\n   end\\n   assign q = q_tmp;\\n\\nendmodule // dffeas\\n\",\n            },\n        },\n        \"lattice\": {\n            \"arith_map_ccu2c.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *  Copyright (C) 2018  gatecat <gatecat@ds0.me>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_ccu2c_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 4;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\tfunction integer round_up2;\\n\\t\\tinput integer N;\\n\\t\\tbegin\\n\\t\\t\\tround_up2 = ((N + 1) / 2) * 2;\\n\\t\\tend\\n\\tendfunction\\n\\n\\tlocalparam Y_WIDTH2 = round_up2(Y_WIDTH);\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] BX = B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] C = {CO, CI};\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] FCO, Y1;\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice\\n\\t\\tCCU2C #(\\n\\t\\t\\t.INIT0(16'b1001011010101010),\\n\\t\\t\\t.INIT1(16'b1001011010101010),\\n\\t\\t\\t.INJECT1_0(\\\"NO\\\"),\\n\\t\\t\\t.INJECT1_1(\\\"NO\\\")\\n\\t   ) ccu2c_i (\\n\\t\\t\\t.CIN(C[i]),\\n\\t\\t\\t.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b1),\\n\\t\\t\\t.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b1),\\n\\t\\t\\t.S0(Y[i]), .S1(Y1[i]),\\n\\t\\t\\t.COUT(FCO[i])\\n\\t\\t);\\n\\n\\t\\tassign CO[i] = (AA[i] && BB[i]) || (C[i] && (AA[i] || BB[i]));\\n\\t\\tif (i+1 < Y_WIDTH) begin\\n\\t\\t\\tassign CO[i+1] = FCO[i];\\n\\t\\t\\tassign Y[i+1] = Y1[i];\\n\\t\\tend\\n\\tend endgenerate\\n\\n\\tassign X = AA ^ BB;\\nendmodule\\n\",\n            \"arith_map_ccu2d.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *  Copyright (C) 2018  gatecat <gatecat@ds0.me>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_ccu2d_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 4;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\tfunction integer round_up2;\\n\\t\\tinput integer N;\\n\\t\\tbegin\\n\\t\\t\\tround_up2 = ((N + 1) / 2) * 2;\\n\\t\\tend\\n\\tendfunction\\n\\n\\tlocalparam Y_WIDTH2 = round_up2(Y_WIDTH);\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] BX = B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] C = {CO, CI};\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] FCO, Y1;\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice\\n\\t\\tCCU2D #(\\n\\t\\t\\t.INIT0(16'b0101_1010_1001_0110),\\n\\t\\t\\t.INIT1(16'b0101_1010_1001_0110),\\n\\t\\t\\t.INJECT1_0(\\\"NO\\\"),\\n\\t\\t\\t.INJECT1_1(\\\"NO\\\")\\n\\t\\t) ccu2d_i (\\n\\t\\t\\t.CIN(C[i]),\\n\\t\\t\\t.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b0),\\n\\t\\t\\t.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b0),\\n\\t\\t\\t.S0(Y[i]), .S1(Y1[i]),\\n\\t\\t\\t.COUT(FCO[i])\\n\\t\\t);\\n\\n\\t\\tassign CO[i] = (AA[i] && BB[i]) || (C[i] && (AA[i] || BB[i]));\\n\\t\\tif (i+1 < Y_WIDTH) begin\\n\\t\\t\\tassign CO[i+1] = FCO[i];\\n\\t\\t\\tassign Y[i+1] = Y1[i];\\n\\t\\tend\\n\\tend endgenerate\\n\\n\\tassign X = AA ^ BB;\\nendmodule\\n\",\n            \"brams_16kd.txt\": \"ram block $__DP16KD_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 per_port;\\n\\tbyte 9;\\n\\tcost 128;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\twrbe_separate;\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"NORMAL\\\" {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"WRITETHROUGH\\\" {\\n\\t\\t\\trdwr new;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"READBEFOREWRITE\\\" {\\n\\t\\t\\trdwr old;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated block_wr;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n}\\n\\nram block $__PDPW16KD_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 36 per_port;\\n\\tbyte 9;\\n\\tcost 128;\\n\\tinit no_undef;\\n\\tport sr \\\"R\\\" {\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t\\toption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n\\tport sw \\\"W\\\" {\\n\\t\\twidth 36;\\n\\t\\tclock anyedge;\\n\\t\\tclken;\\n\\t}\\n}\\n\",\n            \"brams_8kc.txt\": \"ram block $__DP8KC_ {\\n\\tabits 13;\\n\\twidths 1 2 4 9 per_port;\\n\\tcost 64;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"NORMAL\\\" {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"WRITETHROUGH\\\" {\\n\\t\\t\\trdwr new;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITEMODE\\\" \\\"READBEFOREWRITE\\\" {\\n\\t\\t\\trdwr old;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated block_wr;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n}\\n\\nram block $__PDPW8KC_ {\\n\\tabits 13;\\n\\twidths 1 2 4 9 18 per_port;\\n\\tbyte 9;\\n\\tcost 64;\\n\\tinit no_undef;\\n\\tport sr \\\"R\\\" {\\n\\t\\t# width 2 cannot be supported because of quirks\\n\\t\\t# of the primitive, and memlib requires us to\\n\\t\\t# remove width 1 as well\\n\\t\\twidth 4 9 18;\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t\\toption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n\\tport sw \\\"W\\\" {\\n\\t\\twidth 18;\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t}\\n}\\n\",\n            \"brams_map_16kd.v\": \"module $__DP16KD_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESETMODE = \\\"SYNC\\\";\\n\\nparameter PORT_A_WIDTH = 18;\\nparameter PORT_A_WR_BE_WIDTH = 2;\\nparameter PORT_A_CLK_POL = 1;\\nparameter PORT_A_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput PORT_A_WR_EN;\\ninput PORT_A_RD_SRST;\\ninput PORT_A_RD_ARST;\\ninput [13:0] PORT_A_ADDR;\\ninput [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\n\\nparameter PORT_B_WIDTH = 18;\\nparameter PORT_B_WR_BE_WIDTH = 2;\\nparameter PORT_B_CLK_POL = 1;\\nparameter PORT_B_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput PORT_B_WR_EN;\\ninput PORT_B_RD_SRST;\\ninput PORT_B_RD_ARST;\\ninput [13:0] PORT_B_ADDR;\\ninput [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\n\\nfunction [319:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i, j;\\n\\tinit_slice = 0;\\n\\tfor (i = 0; i < 16; i = i + 1) begin\\n\\t\\tinit_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];\\n\\tend\\nendfunction\\n\\nwire [17:0] DOA;\\nwire [17:0] DOB;\\nwire [17:0] DIA = PORT_A_WR_DATA;\\nwire [17:0] DIB = PORT_B_WR_DATA;\\n\\nassign PORT_A_RD_DATA = DOA;\\nassign PORT_B_RD_DATA = DOB;\\n\\nDP16KD #(\\n\\t.INITVAL_00(init_slice('h00)),\\n\\t.INITVAL_01(init_slice('h01)),\\n\\t.INITVAL_02(init_slice('h02)),\\n\\t.INITVAL_03(init_slice('h03)),\\n\\t.INITVAL_04(init_slice('h04)),\\n\\t.INITVAL_05(init_slice('h05)),\\n\\t.INITVAL_06(init_slice('h06)),\\n\\t.INITVAL_07(init_slice('h07)),\\n\\t.INITVAL_08(init_slice('h08)),\\n\\t.INITVAL_09(init_slice('h09)),\\n\\t.INITVAL_0A(init_slice('h0a)),\\n\\t.INITVAL_0B(init_slice('h0b)),\\n\\t.INITVAL_0C(init_slice('h0c)),\\n\\t.INITVAL_0D(init_slice('h0d)),\\n\\t.INITVAL_0E(init_slice('h0e)),\\n\\t.INITVAL_0F(init_slice('h0f)),\\n\\t.INITVAL_10(init_slice('h10)),\\n\\t.INITVAL_11(init_slice('h11)),\\n\\t.INITVAL_12(init_slice('h12)),\\n\\t.INITVAL_13(init_slice('h13)),\\n\\t.INITVAL_14(init_slice('h14)),\\n\\t.INITVAL_15(init_slice('h15)),\\n\\t.INITVAL_16(init_slice('h16)),\\n\\t.INITVAL_17(init_slice('h17)),\\n\\t.INITVAL_18(init_slice('h18)),\\n\\t.INITVAL_19(init_slice('h19)),\\n\\t.INITVAL_1A(init_slice('h1a)),\\n\\t.INITVAL_1B(init_slice('h1b)),\\n\\t.INITVAL_1C(init_slice('h1c)),\\n\\t.INITVAL_1D(init_slice('h1d)),\\n\\t.INITVAL_1E(init_slice('h1e)),\\n\\t.INITVAL_1F(init_slice('h1f)),\\n\\t.INITVAL_20(init_slice('h20)),\\n\\t.INITVAL_21(init_slice('h21)),\\n\\t.INITVAL_22(init_slice('h22)),\\n\\t.INITVAL_23(init_slice('h23)),\\n\\t.INITVAL_24(init_slice('h24)),\\n\\t.INITVAL_25(init_slice('h25)),\\n\\t.INITVAL_26(init_slice('h26)),\\n\\t.INITVAL_27(init_slice('h27)),\\n\\t.INITVAL_28(init_slice('h28)),\\n\\t.INITVAL_29(init_slice('h29)),\\n\\t.INITVAL_2A(init_slice('h2a)),\\n\\t.INITVAL_2B(init_slice('h2b)),\\n\\t.INITVAL_2C(init_slice('h2c)),\\n\\t.INITVAL_2D(init_slice('h2d)),\\n\\t.INITVAL_2E(init_slice('h2e)),\\n\\t.INITVAL_2F(init_slice('h2f)),\\n\\t.INITVAL_30(init_slice('h30)),\\n\\t.INITVAL_31(init_slice('h31)),\\n\\t.INITVAL_32(init_slice('h32)),\\n\\t.INITVAL_33(init_slice('h33)),\\n\\t.INITVAL_34(init_slice('h34)),\\n\\t.INITVAL_35(init_slice('h35)),\\n\\t.INITVAL_36(init_slice('h36)),\\n\\t.INITVAL_37(init_slice('h37)),\\n\\t.INITVAL_38(init_slice('h38)),\\n\\t.INITVAL_39(init_slice('h39)),\\n\\t.INITVAL_3A(init_slice('h3a)),\\n\\t.INITVAL_3B(init_slice('h3b)),\\n\\t.INITVAL_3C(init_slice('h3c)),\\n\\t.INITVAL_3D(init_slice('h3d)),\\n\\t.INITVAL_3E(init_slice('h3e)),\\n\\t.INITVAL_3F(init_slice('h3f)),\\n\\t.DATA_WIDTH_A(PORT_A_WIDTH),\\n\\t.DATA_WIDTH_B(PORT_B_WIDTH),\\n\\t.REGMODE_A(\\\"NOREG\\\"),\\n\\t.REGMODE_B(\\\"NOREG\\\"),\\n\\t.RESETMODE(OPTION_RESETMODE),\\n\\t.ASYNC_RESET_RELEASE(OPTION_RESETMODE),\\n\\t.CSDECODE_A(\\\"0b000\\\"),\\n\\t.CSDECODE_B(\\\"0b000\\\"),\\n\\t.CLKAMUX(PORT_A_CLK_POL ? \\\"CLKA\\\" : \\\"INV\\\"),\\n\\t.CLKBMUX(PORT_B_CLK_POL ? \\\"CLKB\\\" : \\\"INV\\\"),\\n\\t.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),\\n\\t.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),\\n\\t.GSR(\\\"AUTO\\\")\\n) _TECHMAP_REPLACE_ (\\n\\t.CLKA(PORT_A_CLK),\\n\\t.WEA(PORT_A_WIDTH == 18 ? PORT_A_WR_EN : (PORT_A_WR_EN | PORT_A_WR_BE[0])),\\n\\t.CEA(PORT_A_CLK_EN),\\n\\t.OCEA(1'b1),\\n\\t.RSTA(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST),\\n\\t.CSA0(1'b0),\\n\\t.CSA1(1'b0),\\n\\t.CSA2(1'b0),\\n\\t.ADA0(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[0] : PORT_A_ADDR[0]),\\n\\t.ADA1(PORT_A_WIDTH == 18 ? PORT_A_WR_BE[1] : PORT_A_ADDR[1]),\\n\\t.ADA2(PORT_A_ADDR[2]),\\n\\t.ADA3(PORT_A_ADDR[3]),\\n\\t.ADA4(PORT_A_ADDR[4]),\\n\\t.ADA5(PORT_A_ADDR[5]),\\n\\t.ADA6(PORT_A_ADDR[6]),\\n\\t.ADA7(PORT_A_ADDR[7]),\\n\\t.ADA8(PORT_A_ADDR[8]),\\n\\t.ADA9(PORT_A_ADDR[9]),\\n\\t.ADA10(PORT_A_ADDR[10]),\\n\\t.ADA11(PORT_A_ADDR[11]),\\n\\t.ADA12(PORT_A_ADDR[12]),\\n\\t.ADA13(PORT_A_ADDR[13]),\\n\\t.DIA0(DIA[0]),\\n\\t.DIA1(DIA[1]),\\n\\t.DIA2(DIA[2]),\\n\\t.DIA3(DIA[3]),\\n\\t.DIA4(DIA[4]),\\n\\t.DIA5(DIA[5]),\\n\\t.DIA6(DIA[6]),\\n\\t.DIA7(DIA[7]),\\n\\t.DIA8(DIA[8]),\\n\\t.DIA9(DIA[9]),\\n\\t.DIA10(DIA[10]),\\n\\t.DIA11(DIA[11]),\\n\\t.DIA12(DIA[12]),\\n\\t.DIA13(DIA[13]),\\n\\t.DIA14(DIA[14]),\\n\\t.DIA15(DIA[15]),\\n\\t.DIA16(DIA[16]),\\n\\t.DIA17(DIA[17]),\\n\\t.DOA0(DOA[0]),\\n\\t.DOA1(DOA[1]),\\n\\t.DOA2(DOA[2]),\\n\\t.DOA3(DOA[3]),\\n\\t.DOA4(DOA[4]),\\n\\t.DOA5(DOA[5]),\\n\\t.DOA6(DOA[6]),\\n\\t.DOA7(DOA[7]),\\n\\t.DOA8(DOA[8]),\\n\\t.DOA9(DOA[9]),\\n\\t.DOA10(DOA[10]),\\n\\t.DOA11(DOA[11]),\\n\\t.DOA12(DOA[12]),\\n\\t.DOA13(DOA[13]),\\n\\t.DOA14(DOA[14]),\\n\\t.DOA15(DOA[15]),\\n\\t.DOA16(DOA[16]),\\n\\t.DOA17(DOA[17]),\\n\\n\\t.CLKB(PORT_B_CLK),\\n\\t.WEB(PORT_B_WIDTH == 18 ? PORT_B_WR_EN : (PORT_B_WR_EN | PORT_B_WR_BE[0])),\\n\\t.CEB(PORT_B_CLK_EN),\\n\\t.OCEB(1'b1),\\n\\t.RSTB(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_B_RD_SRST : PORT_B_RD_ARST),\\n\\t.CSB0(1'b0),\\n\\t.CSB1(1'b0),\\n\\t.CSB2(1'b0),\\n\\t.ADB0(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[0] : PORT_B_ADDR[0]),\\n\\t.ADB1(PORT_B_WIDTH == 18 ? PORT_B_WR_BE[1] : PORT_B_ADDR[1]),\\n\\t.ADB2(PORT_B_ADDR[2]),\\n\\t.ADB3(PORT_B_ADDR[3]),\\n\\t.ADB4(PORT_B_ADDR[4]),\\n\\t.ADB5(PORT_B_ADDR[5]),\\n\\t.ADB6(PORT_B_ADDR[6]),\\n\\t.ADB7(PORT_B_ADDR[7]),\\n\\t.ADB8(PORT_B_ADDR[8]),\\n\\t.ADB9(PORT_B_ADDR[9]),\\n\\t.ADB10(PORT_B_ADDR[10]),\\n\\t.ADB11(PORT_B_ADDR[11]),\\n\\t.ADB12(PORT_B_ADDR[12]),\\n\\t.ADB13(PORT_B_ADDR[13]),\\n\\t.DIB0(DIB[0]),\\n\\t.DIB1(DIB[1]),\\n\\t.DIB2(DIB[2]),\\n\\t.DIB3(DIB[3]),\\n\\t.DIB4(DIB[4]),\\n\\t.DIB5(DIB[5]),\\n\\t.DIB6(DIB[6]),\\n\\t.DIB7(DIB[7]),\\n\\t.DIB8(DIB[8]),\\n\\t.DIB9(DIB[9]),\\n\\t.DIB10(DIB[10]),\\n\\t.DIB11(DIB[11]),\\n\\t.DIB12(DIB[12]),\\n\\t.DIB13(DIB[13]),\\n\\t.DIB14(DIB[14]),\\n\\t.DIB15(DIB[15]),\\n\\t.DIB16(DIB[16]),\\n\\t.DIB17(DIB[17]),\\n\\t.DOB0(DOB[0]),\\n\\t.DOB1(DOB[1]),\\n\\t.DOB2(DOB[2]),\\n\\t.DOB3(DOB[3]),\\n\\t.DOB4(DOB[4]),\\n\\t.DOB5(DOB[5]),\\n\\t.DOB6(DOB[6]),\\n\\t.DOB7(DOB[7]),\\n\\t.DOB8(DOB[8]),\\n\\t.DOB9(DOB[9]),\\n\\t.DOB10(DOB[10]),\\n\\t.DOB11(DOB[11]),\\n\\t.DOB12(DOB[12]),\\n\\t.DOB13(DOB[13]),\\n\\t.DOB14(DOB[14]),\\n\\t.DOB15(DOB[15]),\\n\\t.DOB16(DOB[16]),\\n\\t.DOB17(DOB[17]),\\n);\\n\\nendmodule\\n\\n\\nmodule $__PDPW16KD_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESETMODE = \\\"SYNC\\\";\\n\\nparameter PORT_R_WIDTH = 36;\\nparameter PORT_R_CLK_POL = 1;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput PORT_R_RD_SRST;\\ninput PORT_R_RD_ARST;\\ninput [13:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\n\\nparameter PORT_W_WIDTH = 36;\\nparameter PORT_W_WR_EN_WIDTH = 4;\\nparameter PORT_W_CLK_POL = 1;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput [13:0] PORT_W_ADDR;\\ninput [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\n\\nfunction [319:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i, j;\\n\\tinit_slice = 0;\\n\\tfor (i = 0; i < 16; i = i + 1) begin\\n\\t\\tinit_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];\\n\\tend\\nendfunction\\n\\nwire [35:0] DI = PORT_W_WR_DATA;\\nwire [35:0] DO;\\n\\nassign PORT_R_RD_DATA = PORT_R_WIDTH == 36 ? DO : DO[35:18];\\n\\nDP16KD #(\\n\\t.INITVAL_00(init_slice('h00)),\\n\\t.INITVAL_01(init_slice('h01)),\\n\\t.INITVAL_02(init_slice('h02)),\\n\\t.INITVAL_03(init_slice('h03)),\\n\\t.INITVAL_04(init_slice('h04)),\\n\\t.INITVAL_05(init_slice('h05)),\\n\\t.INITVAL_06(init_slice('h06)),\\n\\t.INITVAL_07(init_slice('h07)),\\n\\t.INITVAL_08(init_slice('h08)),\\n\\t.INITVAL_09(init_slice('h09)),\\n\\t.INITVAL_0A(init_slice('h0a)),\\n\\t.INITVAL_0B(init_slice('h0b)),\\n\\t.INITVAL_0C(init_slice('h0c)),\\n\\t.INITVAL_0D(init_slice('h0d)),\\n\\t.INITVAL_0E(init_slice('h0e)),\\n\\t.INITVAL_0F(init_slice('h0f)),\\n\\t.INITVAL_10(init_slice('h10)),\\n\\t.INITVAL_11(init_slice('h11)),\\n\\t.INITVAL_12(init_slice('h12)),\\n\\t.INITVAL_13(init_slice('h13)),\\n\\t.INITVAL_14(init_slice('h14)),\\n\\t.INITVAL_15(init_slice('h15)),\\n\\t.INITVAL_16(init_slice('h16)),\\n\\t.INITVAL_17(init_slice('h17)),\\n\\t.INITVAL_18(init_slice('h18)),\\n\\t.INITVAL_19(init_slice('h19)),\\n\\t.INITVAL_1A(init_slice('h1a)),\\n\\t.INITVAL_1B(init_slice('h1b)),\\n\\t.INITVAL_1C(init_slice('h1c)),\\n\\t.INITVAL_1D(init_slice('h1d)),\\n\\t.INITVAL_1E(init_slice('h1e)),\\n\\t.INITVAL_1F(init_slice('h1f)),\\n\\t.INITVAL_20(init_slice('h20)),\\n\\t.INITVAL_21(init_slice('h21)),\\n\\t.INITVAL_22(init_slice('h22)),\\n\\t.INITVAL_23(init_slice('h23)),\\n\\t.INITVAL_24(init_slice('h24)),\\n\\t.INITVAL_25(init_slice('h25)),\\n\\t.INITVAL_26(init_slice('h26)),\\n\\t.INITVAL_27(init_slice('h27)),\\n\\t.INITVAL_28(init_slice('h28)),\\n\\t.INITVAL_29(init_slice('h29)),\\n\\t.INITVAL_2A(init_slice('h2a)),\\n\\t.INITVAL_2B(init_slice('h2b)),\\n\\t.INITVAL_2C(init_slice('h2c)),\\n\\t.INITVAL_2D(init_slice('h2d)),\\n\\t.INITVAL_2E(init_slice('h2e)),\\n\\t.INITVAL_2F(init_slice('h2f)),\\n\\t.INITVAL_30(init_slice('h30)),\\n\\t.INITVAL_31(init_slice('h31)),\\n\\t.INITVAL_32(init_slice('h32)),\\n\\t.INITVAL_33(init_slice('h33)),\\n\\t.INITVAL_34(init_slice('h34)),\\n\\t.INITVAL_35(init_slice('h35)),\\n\\t.INITVAL_36(init_slice('h36)),\\n\\t.INITVAL_37(init_slice('h37)),\\n\\t.INITVAL_38(init_slice('h38)),\\n\\t.INITVAL_39(init_slice('h39)),\\n\\t.INITVAL_3A(init_slice('h3a)),\\n\\t.INITVAL_3B(init_slice('h3b)),\\n\\t.INITVAL_3C(init_slice('h3c)),\\n\\t.INITVAL_3D(init_slice('h3d)),\\n\\t.INITVAL_3E(init_slice('h3e)),\\n\\t.INITVAL_3F(init_slice('h3f)),\\n\\t.DATA_WIDTH_A(PORT_W_WIDTH),\\n\\t.DATA_WIDTH_B(PORT_R_WIDTH),\\n\\t.REGMODE_A(\\\"NOREG\\\"),\\n\\t.REGMODE_B(\\\"NOREG\\\"),\\n\\t.RESETMODE(OPTION_RESETMODE),\\n\\t.ASYNC_RESET_RELEASE(OPTION_RESETMODE),\\n\\t.CSDECODE_A(\\\"0b000\\\"),\\n\\t.CSDECODE_B(\\\"0b000\\\"),\\n\\t.CLKAMUX(PORT_W_CLK_POL ? \\\"CLKA\\\" : \\\"INV\\\"),\\n\\t.CLKBMUX(PORT_R_CLK_POL ? \\\"CLKB\\\" : \\\"INV\\\"),\\n\\t.GSR(\\\"AUTO\\\")\\n) _TECHMAP_REPLACE_ (\\n\\t.CLKA(PORT_W_CLK),\\n\\t.WEA(PORT_W_WIDTH >= 18 ? 1'b1 : PORT_W_WR_EN[0]),\\n\\t.CEA(PORT_W_CLK_EN),\\n\\t.OCEA(1'b0),\\n\\t.RSTA(1'b0),\\n\\t.CSA0(1'b0),\\n\\t.CSA1(1'b0),\\n\\t.CSA2(1'b0),\\n\\t.ADA0(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[0] : PORT_W_ADDR[0]),\\n\\t.ADA1(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[1] : PORT_W_ADDR[1]),\\n\\t.ADA2(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[2] : PORT_W_ADDR[2]),\\n\\t.ADA3(PORT_W_WIDTH >= 36 ? PORT_W_WR_EN[3] : PORT_W_ADDR[3]),\\n\\t.ADA4(PORT_W_ADDR[4]),\\n\\t.ADA5(PORT_W_ADDR[5]),\\n\\t.ADA6(PORT_W_ADDR[6]),\\n\\t.ADA7(PORT_W_ADDR[7]),\\n\\t.ADA8(PORT_W_ADDR[8]),\\n\\t.ADA9(PORT_W_ADDR[9]),\\n\\t.ADA10(PORT_W_ADDR[10]),\\n\\t.ADA11(PORT_W_ADDR[11]),\\n\\t.ADA12(PORT_W_ADDR[12]),\\n\\t.ADA13(PORT_W_ADDR[13]),\\n\\t.DIA0(DI[0]),\\n\\t.DIA1(DI[1]),\\n\\t.DIA2(DI[2]),\\n\\t.DIA3(DI[3]),\\n\\t.DIA4(DI[4]),\\n\\t.DIA5(DI[5]),\\n\\t.DIA6(DI[6]),\\n\\t.DIA7(DI[7]),\\n\\t.DIA8(DI[8]),\\n\\t.DIA9(DI[9]),\\n\\t.DIA10(DI[10]),\\n\\t.DIA11(DI[11]),\\n\\t.DIA12(DI[12]),\\n\\t.DIA13(DI[13]),\\n\\t.DIA14(DI[14]),\\n\\t.DIA15(DI[15]),\\n\\t.DIA16(DI[16]),\\n\\t.DIA17(DI[17]),\\n\\t.DIB0(DI[18]),\\n\\t.DIB1(DI[19]),\\n\\t.DIB2(DI[20]),\\n\\t.DIB3(DI[21]),\\n\\t.DIB4(DI[22]),\\n\\t.DIB5(DI[23]),\\n\\t.DIB6(DI[24]),\\n\\t.DIB7(DI[25]),\\n\\t.DIB8(DI[26]),\\n\\t.DIB9(DI[27]),\\n\\t.DIB10(DI[28]),\\n\\t.DIB11(DI[29]),\\n\\t.DIB12(DI[30]),\\n\\t.DIB13(DI[31]),\\n\\t.DIB14(DI[32]),\\n\\t.DIB15(DI[33]),\\n\\t.DIB16(DI[34]),\\n\\t.DIB17(DI[35]),\\n\\n\\t.CLKB(PORT_R_CLK),\\n\\t.WEB(1'b0),\\n\\t.CEB(PORT_R_CLK_EN),\\n\\t.OCEB(1'b1),\\n\\t.RSTB(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_R_RD_SRST : PORT_R_RD_ARST),\\n\\t.CSB0(1'b0),\\n\\t.CSB1(1'b0),\\n\\t.CSB2(1'b0),\\n\\t.ADB0(PORT_R_ADDR[0]),\\n\\t.ADB1(PORT_R_ADDR[1]),\\n\\t.ADB2(PORT_R_ADDR[2]),\\n\\t.ADB3(PORT_R_ADDR[3]),\\n\\t.ADB4(PORT_R_ADDR[4]),\\n\\t.ADB5(PORT_R_ADDR[5]),\\n\\t.ADB6(PORT_R_ADDR[6]),\\n\\t.ADB7(PORT_R_ADDR[7]),\\n\\t.ADB8(PORT_R_ADDR[8]),\\n\\t.ADB9(PORT_R_ADDR[9]),\\n\\t.ADB10(PORT_R_ADDR[10]),\\n\\t.ADB11(PORT_R_ADDR[11]),\\n\\t.ADB12(PORT_R_ADDR[12]),\\n\\t.ADB13(PORT_R_ADDR[13]),\\n\\t.DOA0(DO[0]),\\n\\t.DOA1(DO[1]),\\n\\t.DOA2(DO[2]),\\n\\t.DOA3(DO[3]),\\n\\t.DOA4(DO[4]),\\n\\t.DOA5(DO[5]),\\n\\t.DOA6(DO[6]),\\n\\t.DOA7(DO[7]),\\n\\t.DOA8(DO[8]),\\n\\t.DOA9(DO[9]),\\n\\t.DOA10(DO[10]),\\n\\t.DOA11(DO[11]),\\n\\t.DOA12(DO[12]),\\n\\t.DOA13(DO[13]),\\n\\t.DOA14(DO[14]),\\n\\t.DOA15(DO[15]),\\n\\t.DOA16(DO[16]),\\n\\t.DOA17(DO[17]),\\n\\t.DOB0(DO[18]),\\n\\t.DOB1(DO[19]),\\n\\t.DOB2(DO[20]),\\n\\t.DOB3(DO[21]),\\n\\t.DOB4(DO[22]),\\n\\t.DOB5(DO[23]),\\n\\t.DOB6(DO[24]),\\n\\t.DOB7(DO[25]),\\n\\t.DOB8(DO[26]),\\n\\t.DOB9(DO[27]),\\n\\t.DOB10(DO[28]),\\n\\t.DOB11(DO[29]),\\n\\t.DOB12(DO[30]),\\n\\t.DOB13(DO[31]),\\n\\t.DOB14(DO[32]),\\n\\t.DOB15(DO[33]),\\n\\t.DOB16(DO[34]),\\n\\t.DOB17(DO[35]),\\n);\\n\\nendmodule\\n\",\n            \"brams_map_8kc.v\": \"module $__DP8KC_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESETMODE = \\\"SYNC\\\";\\n\\nparameter PORT_A_WIDTH = 18;\\nparameter PORT_A_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput PORT_A_WR_EN;\\ninput PORT_A_RD_SRST;\\ninput PORT_A_RD_ARST;\\ninput [12:0] PORT_A_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\n\\nparameter PORT_B_WIDTH = 18;\\nparameter PORT_B_OPTION_WRITEMODE = \\\"NORMAL\\\";\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput PORT_B_WR_EN;\\ninput PORT_B_RD_SRST;\\ninput PORT_B_RD_ARST;\\ninput [12:0] PORT_B_ADDR;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\n\\nfunction [319:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i, j;\\n\\tinit_slice = 0;\\n\\tfor (i = 0; i < 16; i = i + 1) begin\\n\\t\\tinit_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];\\n\\tend\\nendfunction\\n\\nwire [8:0] DOA;\\nwire [8:0] DOB;\\nwire [8:0] DIA;\\nwire [8:0] DIB;\\n\\ncase(PORT_A_WIDTH)\\n\\t1: assign DIA = {7'bx, PORT_A_WR_DATA[0], 1'bx};\\n\\t2: assign DIA = {3'bx, PORT_A_WR_DATA[1], 2'bx, PORT_A_WR_DATA[0], 2'bx};\\n\\tdefault: assign DIA = PORT_A_WR_DATA;\\nendcase\\n\\ncase(PORT_B_WIDTH)\\n\\t1: assign DIB = {7'bx, PORT_B_WR_DATA[0], 1'bx};\\n\\t2: assign DIB = {3'bx, PORT_B_WR_DATA[1], 2'bx, PORT_B_WR_DATA[0], 2'bx};\\n\\tdefault: assign DIB = PORT_B_WR_DATA;\\nendcase\\n\\nassign PORT_A_RD_DATA = DOA;\\nassign PORT_B_RD_DATA = DOB;\\n\\nDP8KC #(\\n\\t.INITVAL_00(init_slice('h00)),\\n\\t.INITVAL_01(init_slice('h01)),\\n\\t.INITVAL_02(init_slice('h02)),\\n\\t.INITVAL_03(init_slice('h03)),\\n\\t.INITVAL_04(init_slice('h04)),\\n\\t.INITVAL_05(init_slice('h05)),\\n\\t.INITVAL_06(init_slice('h06)),\\n\\t.INITVAL_07(init_slice('h07)),\\n\\t.INITVAL_08(init_slice('h08)),\\n\\t.INITVAL_09(init_slice('h09)),\\n\\t.INITVAL_0A(init_slice('h0a)),\\n\\t.INITVAL_0B(init_slice('h0b)),\\n\\t.INITVAL_0C(init_slice('h0c)),\\n\\t.INITVAL_0D(init_slice('h0d)),\\n\\t.INITVAL_0E(init_slice('h0e)),\\n\\t.INITVAL_0F(init_slice('h0f)),\\n\\t.INITVAL_10(init_slice('h10)),\\n\\t.INITVAL_11(init_slice('h11)),\\n\\t.INITVAL_12(init_slice('h12)),\\n\\t.INITVAL_13(init_slice('h13)),\\n\\t.INITVAL_14(init_slice('h14)),\\n\\t.INITVAL_15(init_slice('h15)),\\n\\t.INITVAL_16(init_slice('h16)),\\n\\t.INITVAL_17(init_slice('h17)),\\n\\t.INITVAL_18(init_slice('h18)),\\n\\t.INITVAL_19(init_slice('h19)),\\n\\t.INITVAL_1A(init_slice('h1a)),\\n\\t.INITVAL_1B(init_slice('h1b)),\\n\\t.INITVAL_1C(init_slice('h1c)),\\n\\t.INITVAL_1D(init_slice('h1d)),\\n\\t.INITVAL_1E(init_slice('h1e)),\\n\\t.INITVAL_1F(init_slice('h1f)),\\n\\t.DATA_WIDTH_A(PORT_A_WIDTH),\\n\\t.DATA_WIDTH_B(PORT_B_WIDTH),\\n\\t.REGMODE_A(\\\"NOREG\\\"),\\n\\t.REGMODE_B(\\\"NOREG\\\"),\\n\\t.RESETMODE(OPTION_RESETMODE),\\n\\t.ASYNC_RESET_RELEASE(OPTION_RESETMODE),\\n\\t.CSDECODE_A(\\\"0b000\\\"),\\n\\t.CSDECODE_B(\\\"0b000\\\"),\\n\\t.WRITEMODE_A(PORT_A_OPTION_WRITEMODE),\\n\\t.WRITEMODE_B(PORT_B_OPTION_WRITEMODE),\\n\\t.GSR(\\\"AUTO\\\")\\n) _TECHMAP_REPLACE_ (\\n\\t.CLKA(PORT_A_CLK),\\n\\t.WEA(PORT_A_WR_EN),\\n\\t.CEA(PORT_A_CLK_EN),\\n\\t.OCEA(1'b1),\\n\\t.RSTA(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST),\\n\\t.CSA0(1'b0),\\n\\t.CSA1(1'b0),\\n\\t.CSA2(1'b0),\\n\\t.ADA0(PORT_A_WIDTH == 9 ? 1'b1 : PORT_A_ADDR[0]),\\n\\t.ADA1(PORT_A_ADDR[1]),\\n\\t.ADA2(PORT_A_ADDR[2]),\\n\\t.ADA3(PORT_A_ADDR[3]),\\n\\t.ADA4(PORT_A_ADDR[4]),\\n\\t.ADA5(PORT_A_ADDR[5]),\\n\\t.ADA6(PORT_A_ADDR[6]),\\n\\t.ADA7(PORT_A_ADDR[7]),\\n\\t.ADA8(PORT_A_ADDR[8]),\\n\\t.ADA9(PORT_A_ADDR[9]),\\n\\t.ADA10(PORT_A_ADDR[10]),\\n\\t.ADA11(PORT_A_ADDR[11]),\\n\\t.ADA12(PORT_A_ADDR[12]),\\n\\t.DIA0(DIA[0]),\\n\\t.DIA1(DIA[1]),\\n\\t.DIA2(DIA[2]),\\n\\t.DIA3(DIA[3]),\\n\\t.DIA4(DIA[4]),\\n\\t.DIA5(DIA[5]),\\n\\t.DIA6(DIA[6]),\\n\\t.DIA7(DIA[7]),\\n\\t.DIA8(DIA[8]),\\n\\t.DOA0(DOA[0]),\\n\\t.DOA1(DOA[1]),\\n\\t.DOA2(DOA[2]),\\n\\t.DOA3(DOA[3]),\\n\\t.DOA4(DOA[4]),\\n\\t.DOA5(DOA[5]),\\n\\t.DOA6(DOA[6]),\\n\\t.DOA7(DOA[7]),\\n\\t.DOA8(DOA[8]),\\n\\n\\t.CLKB(PORT_B_CLK),\\n\\t.WEB(PORT_B_WR_EN),\\n\\t.CEB(PORT_B_CLK_EN),\\n\\t.OCEB(1'b1),\\n\\t.RSTB(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_B_RD_SRST : PORT_B_RD_ARST),\\n\\t.CSB0(1'b0),\\n\\t.CSB1(1'b0),\\n\\t.CSB2(1'b0),\\n\\t.ADB0(PORT_B_WIDTH == 9 ? 1'b1 : PORT_B_ADDR[0]),\\n\\t.ADB1(PORT_B_ADDR[1]),\\n\\t.ADB2(PORT_B_ADDR[2]),\\n\\t.ADB3(PORT_B_ADDR[3]),\\n\\t.ADB4(PORT_B_ADDR[4]),\\n\\t.ADB5(PORT_B_ADDR[5]),\\n\\t.ADB6(PORT_B_ADDR[6]),\\n\\t.ADB7(PORT_B_ADDR[7]),\\n\\t.ADB8(PORT_B_ADDR[8]),\\n\\t.ADB9(PORT_B_ADDR[9]),\\n\\t.ADB10(PORT_B_ADDR[10]),\\n\\t.ADB11(PORT_B_ADDR[11]),\\n\\t.ADB12(PORT_B_ADDR[12]),\\n\\t.DIB0(DIB[0]),\\n\\t.DIB1(DIB[1]),\\n\\t.DIB2(DIB[2]),\\n\\t.DIB3(DIB[3]),\\n\\t.DIB4(DIB[4]),\\n\\t.DIB5(DIB[5]),\\n\\t.DIB6(DIB[6]),\\n\\t.DIB7(DIB[7]),\\n\\t.DIB8(DIB[8]),\\n\\t.DOB0(DOB[0]),\\n\\t.DOB1(DOB[1]),\\n\\t.DOB2(DOB[2]),\\n\\t.DOB3(DOB[3]),\\n\\t.DOB4(DOB[4]),\\n\\t.DOB5(DOB[5]),\\n\\t.DOB6(DOB[6]),\\n\\t.DOB7(DOB[7]),\\n\\t.DOB8(DOB[8]),\\n);\\n\\nendmodule\\n\\n\\nmodule $__PDPW8KC_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESETMODE = \\\"SYNC\\\";\\n\\nparameter PORT_R_WIDTH = 18;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput PORT_R_RD_SRST;\\ninput PORT_R_RD_ARST;\\ninput [12:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\n\\nparameter PORT_W_WIDTH = 18;\\nparameter PORT_W_WR_EN_WIDTH = 2;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput [12:0] PORT_W_ADDR;\\ninput [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\n\\nfunction [319:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i, j;\\n\\tinit_slice = 0;\\n\\tfor (i = 0; i < 16; i = i + 1) begin\\n\\t\\tinit_slice[i*20+:18] = INIT[(idx * 16 + i) * 18+:18];\\n\\tend\\nendfunction\\n\\nwire [17:0] DI = PORT_W_WR_DATA;\\nwire [17:0] DO;\\n\\nassign PORT_R_RD_DATA = PORT_R_WIDTH == 18 ? DO : DO[17:9];\\n\\nDP8KC #(\\n\\t.INITVAL_00(init_slice('h00)),\\n\\t.INITVAL_01(init_slice('h01)),\\n\\t.INITVAL_02(init_slice('h02)),\\n\\t.INITVAL_03(init_slice('h03)),\\n\\t.INITVAL_04(init_slice('h04)),\\n\\t.INITVAL_05(init_slice('h05)),\\n\\t.INITVAL_06(init_slice('h06)),\\n\\t.INITVAL_07(init_slice('h07)),\\n\\t.INITVAL_08(init_slice('h08)),\\n\\t.INITVAL_09(init_slice('h09)),\\n\\t.INITVAL_0A(init_slice('h0a)),\\n\\t.INITVAL_0B(init_slice('h0b)),\\n\\t.INITVAL_0C(init_slice('h0c)),\\n\\t.INITVAL_0D(init_slice('h0d)),\\n\\t.INITVAL_0E(init_slice('h0e)),\\n\\t.INITVAL_0F(init_slice('h0f)),\\n\\t.INITVAL_10(init_slice('h10)),\\n\\t.INITVAL_11(init_slice('h11)),\\n\\t.INITVAL_12(init_slice('h12)),\\n\\t.INITVAL_13(init_slice('h13)),\\n\\t.INITVAL_14(init_slice('h14)),\\n\\t.INITVAL_15(init_slice('h15)),\\n\\t.INITVAL_16(init_slice('h16)),\\n\\t.INITVAL_17(init_slice('h17)),\\n\\t.INITVAL_18(init_slice('h18)),\\n\\t.INITVAL_19(init_slice('h19)),\\n\\t.INITVAL_1A(init_slice('h1a)),\\n\\t.INITVAL_1B(init_slice('h1b)),\\n\\t.INITVAL_1C(init_slice('h1c)),\\n\\t.INITVAL_1D(init_slice('h1d)),\\n\\t.INITVAL_1E(init_slice('h1e)),\\n\\t.INITVAL_1F(init_slice('h1f)),\\n\\t.DATA_WIDTH_A(PORT_W_WIDTH),\\n\\t.DATA_WIDTH_B(PORT_R_WIDTH),\\n\\t.REGMODE_A(\\\"NOREG\\\"),\\n\\t.REGMODE_B(\\\"NOREG\\\"),\\n\\t.RESETMODE(OPTION_RESETMODE),\\n\\t.ASYNC_RESET_RELEASE(OPTION_RESETMODE),\\n\\t.CSDECODE_A(\\\"0b000\\\"),\\n\\t.CSDECODE_B(\\\"0b000\\\"),\\n\\t.GSR(\\\"AUTO\\\")\\n) _TECHMAP_REPLACE_ (\\n\\t.CLKA(PORT_W_CLK),\\n\\t.WEA(PORT_W_WIDTH >= 9 ? 1'b1 : PORT_W_WR_EN[0]),\\n\\t.CEA(PORT_W_CLK_EN),\\n\\t.OCEA(1'b0),\\n\\t.RSTA(1'b0),\\n\\t.CSA0(1'b0),\\n\\t.CSA1(1'b0),\\n\\t.CSA2(1'b0),\\n\\t.ADA0(PORT_W_WIDTH >= 9 ? PORT_W_WR_EN[0] : PORT_W_ADDR[0]),\\n\\t.ADA1(PORT_W_WIDTH >= 18 ? PORT_W_WR_EN[1] : PORT_W_ADDR[1]),\\n\\t.ADA2(PORT_W_ADDR[2]),\\n\\t.ADA3(PORT_W_ADDR[3]),\\n\\t.ADA4(PORT_W_ADDR[4]),\\n\\t.ADA5(PORT_W_ADDR[5]),\\n\\t.ADA6(PORT_W_ADDR[6]),\\n\\t.ADA7(PORT_W_ADDR[7]),\\n\\t.ADA8(PORT_W_ADDR[8]),\\n\\t.ADA9(PORT_W_ADDR[9]),\\n\\t.ADA10(PORT_W_ADDR[10]),\\n\\t.ADA11(PORT_W_ADDR[11]),\\n\\t.ADA12(PORT_W_ADDR[12]),\\n\\t.DIA0(DI[0]),\\n\\t.DIA1(DI[1]),\\n\\t.DIA2(DI[2]),\\n\\t.DIA3(DI[3]),\\n\\t.DIA4(DI[4]),\\n\\t.DIA5(DI[5]),\\n\\t.DIA6(DI[6]),\\n\\t.DIA7(DI[7]),\\n\\t.DIA8(DI[8]),\\n\\t.DIB0(DI[9]),\\n\\t.DIB1(DI[10]),\\n\\t.DIB2(DI[11]),\\n\\t.DIB3(DI[12]),\\n\\t.DIB4(DI[13]),\\n\\t.DIB5(DI[14]),\\n\\t.DIB6(DI[15]),\\n\\t.DIB7(DI[16]),\\n\\t.DIB8(DI[17]),\\n\\n\\t.CLKB(PORT_R_CLK),\\n\\t.WEB(1'b0),\\n\\t.CEB(PORT_R_CLK_EN),\\n\\t.OCEB(1'b1),\\n\\t.RSTB(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_R_RD_SRST : PORT_R_RD_ARST),\\n\\t.CSB0(1'b0),\\n\\t.CSB1(1'b0),\\n\\t.CSB2(1'b0),\\n\\t.ADB0(PORT_R_ADDR[0]),\\n\\t.ADB1(PORT_R_ADDR[1]),\\n\\t.ADB2(PORT_R_ADDR[2]),\\n\\t.ADB3(PORT_R_ADDR[3]),\\n\\t.ADB4(PORT_R_ADDR[4]),\\n\\t.ADB5(PORT_R_ADDR[5]),\\n\\t.ADB6(PORT_R_ADDR[6]),\\n\\t.ADB7(PORT_R_ADDR[7]),\\n\\t.ADB8(PORT_R_ADDR[8]),\\n\\t.ADB9(PORT_R_ADDR[9]),\\n\\t.ADB10(PORT_R_ADDR[10]),\\n\\t.ADB11(PORT_R_ADDR[11]),\\n\\t.ADB12(PORT_R_ADDR[12]),\\n\\t.DOA0(DO[0]),\\n\\t.DOA1(DO[1]),\\n\\t.DOA2(DO[2]),\\n\\t.DOA3(DO[3]),\\n\\t.DOA4(DO[4]),\\n\\t.DOA5(DO[5]),\\n\\t.DOA6(DO[6]),\\n\\t.DOA7(DO[7]),\\n\\t.DOA8(DO[8]),\\n\\t.DOB0(DO[9]),\\n\\t.DOB1(DO[10]),\\n\\t.DOB2(DO[11]),\\n\\t.DOB3(DO[12]),\\n\\t.DOB4(DO[13]),\\n\\t.DOB5(DO[14]),\\n\\t.DOB6(DO[15]),\\n\\t.DOB7(DO[16]),\\n\\t.DOB8(DO[17]),\\n);\\n\\nendmodule\\n\",\n            \"ccu2c_sim.vh\": \"// ---------------------------------------\\n(* abc9_box, lib_whitebox *)\\nmodule CCU2C(\\n\\t(* abc9_carry *)\\n\\tinput  CIN,\\n\\tinput  A0, B0, C0, D0, A1, B1, C1, D1,\\n\\toutput S0, S1,\\n\\t(* abc9_carry *)\\n\\toutput COUT\\n);\\n\\tparameter [15:0] INIT0 = 16'h0000;\\n\\tparameter [15:0] INIT1 = 16'h0000;\\n\\tparameter INJECT1_0 = \\\"YES\\\";\\n\\tparameter INJECT1_1 = \\\"YES\\\";\\n\\n\\t// First half\\n\\twire LUT4_0, LUT2_0;\\n\\tLUT4 #(.INIT(INIT0)) lut4_0(.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0));\\n\\tLUT2 #(.INIT(INIT0[3:0])) lut2_0(.A(A0), .B(B0), .Z(LUT2_0));\\n\\twire gated_cin_0 = (INJECT1_0 == \\\"YES\\\") ? 1'b0 : CIN;\\n\\tassign S0 = LUT4_0 ^ gated_cin_0;\\n\\n\\twire gated_lut2_0 = (INJECT1_0 == \\\"YES\\\") ? 1'b0 : LUT2_0;\\n\\twire cout_0 = (~LUT4_0 & gated_lut2_0) | (LUT4_0 & CIN);\\n\\n\\t// Second half\\n\\twire LUT4_1, LUT2_1;\\n\\tLUT4 #(.INIT(INIT1)) lut4_1(.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1));\\n\\tLUT2 #(.INIT(INIT1[3:0])) lut2_1(.A(A1), .B(B1), .Z(LUT2_1));\\n\\twire gated_cin_1 = (INJECT1_1 == \\\"YES\\\") ? 1'b0 : cout_0;\\n\\tassign S1 = LUT4_1 ^ gated_cin_1;\\n\\n\\twire gated_lut2_1 = (INJECT1_1 == \\\"YES\\\") ? 1'b0 : LUT2_1;\\n\\tassign COUT = (~LUT4_1 & gated_lut2_1) | (LUT4_1 & cout_0);\\n\\n\\tspecify\\n\\t\\t(A0 => S0) = 379;\\n\\t\\t(B0 => S0) = 379;\\n\\t\\t(C0 => S0) = 275;\\n\\t\\t(D0 => S0) = 141;\\n\\t\\t(CIN => S0) = 257;\\n\\t\\t(A0 => S1) = 630;\\n\\t\\t(B0 => S1) = 630;\\n\\t\\t(C0 => S1) = 526;\\n\\t\\t(D0 => S1) = 392;\\n\\t\\t(A1 => S1) = 379;\\n\\t\\t(B1 => S1) = 379;\\n\\t\\t(C1 => S1) = 275;\\n\\t\\t(D1 => S1) = 141;\\n\\t\\t(CIN => S1) = 273;\\n\\t\\t(A0 => COUT) = 516;\\n\\t\\t(B0 => COUT) = 516;\\n\\t\\t(C0 => COUT) = 412;\\n\\t\\t(D0 => COUT) = 278;\\n\\t\\t(A1 => COUT) = 516;\\n\\t\\t(B1 => COUT) = 516;\\n\\t\\t(C1 => COUT) = 412;\\n\\t\\t(D1 => COUT) = 278;\\n\\t\\t(CIN => COUT) = 43;\\n\\tendspecify\\nendmodule\\n\",\n            \"ccu2d_sim.vh\": \"// ---------------------------------------\\n(* lib_whitebox *)\\nmodule CCU2D (\\n\\tinput  CIN,\\n\\tinput  A0, B0, C0, D0, A1, B1, C1, D1,\\n\\toutput S0, S1,\\n\\toutput COUT\\n);\\n\\tparameter [15:0] INIT0 = 16'h0000;\\n\\tparameter [15:0] INIT1 = 16'h0000;\\n\\tparameter INJECT1_0 = \\\"YES\\\";\\n\\tparameter INJECT1_1 = \\\"YES\\\";\\n\\n\\t// First half\\n\\twire LUT4_0, LUT2_0;\\n\\tLUT4 #(.INIT(INIT0)) lut4_0(.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0));\\n\\tLUT2 #(.INIT(~INIT0[15:12])) lut2_0(.A(A0), .B(B0), .Z(LUT2_0));\\n\\twire gated_cin_0 = (INJECT1_0 == \\\"YES\\\") ? 1'b0 : CIN;\\n\\tassign S0 = LUT4_0 ^ gated_cin_0;\\n\\n\\twire gated_lut2_0 = (INJECT1_0 == \\\"YES\\\") ? 1'b0 : LUT2_0;\\n\\twire cout_0 = (~LUT4_0 & gated_lut2_0) | (LUT4_0 & CIN);\\n\\n\\t// Second half\\n\\twire LUT4_1, LUT2_1;\\n\\tLUT4 #(.INIT(INIT1)) lut4_1(.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1));\\n\\tLUT2 #(.INIT(~INIT1[15:12])) lut2_1(.A(A1), .B(B1), .Z(LUT2_1));\\n\\twire gated_cin_1 = (INJECT1_1 == \\\"YES\\\") ? 1'b0 : cout_0;\\n\\tassign S1 = LUT4_1 ^ gated_cin_1;\\n\\n\\twire gated_lut2_1 = (INJECT1_1 == \\\"YES\\\") ? 1'b0 : LUT2_1;\\n\\tassign COUT = (~LUT4_1 & gated_lut2_1) | (LUT4_1 & cout_0);\\nendmodule\\n\",\n            \"cells_bb_ecp5.v\": \"// Created by cells_xtra.py from Lattice models\\n\\n(* blackbox *) (* keep *)\\nmodule GSR (...);\\n    input GSR;\\nendmodule\\n\\n(* blackbox *)\\nmodule PUR (...);\\n    parameter RST_PULSE = 1;\\n    input PUR;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule SGSR (...);\\n    input GSR;\\n    input CLK;\\nendmodule\\n\\n(* blackbox *)\\nmodule DP16KD (...);\\n    parameter DATA_WIDTH_A = 18;\\n    parameter DATA_WIDTH_B = 18;\\n    parameter REGMODE_A = \\\"NOREG\\\";\\n    parameter REGMODE_B = \\\"NOREG\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter WRITEMODE_A = \\\"NORMAL\\\";\\n    parameter WRITEMODE_B = \\\"NORMAL\\\";\\n    parameter CSDECODE_A = \\\"0b000\\\";\\n    parameter CSDECODE_B = \\\"0b000\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    input DIA17;\\n    input DIA16;\\n    input DIA15;\\n    input DIA14;\\n    input DIA13;\\n    input DIA12;\\n    input DIA11;\\n    input DIA10;\\n    input DIA9;\\n    input DIA8;\\n    input DIA7;\\n    input DIA6;\\n    input DIA5;\\n    input DIA4;\\n    input DIA3;\\n    input DIA2;\\n    input DIA1;\\n    input DIA0;\\n    input ADA13;\\n    input ADA12;\\n    input ADA11;\\n    input ADA10;\\n    input ADA9;\\n    input ADA8;\\n    input ADA7;\\n    input ADA6;\\n    input ADA5;\\n    input ADA4;\\n    input ADA3;\\n    input ADA2;\\n    input ADA1;\\n    input ADA0;\\n    input CEA;\\n    input OCEA;\\n    input CLKA;\\n    input WEA;\\n    input CSA2;\\n    input CSA1;\\n    input CSA0;\\n    input RSTA;\\n    input DIB17;\\n    input DIB16;\\n    input DIB15;\\n    input DIB14;\\n    input DIB13;\\n    input DIB12;\\n    input DIB11;\\n    input DIB10;\\n    input DIB9;\\n    input DIB8;\\n    input DIB7;\\n    input DIB6;\\n    input DIB5;\\n    input DIB4;\\n    input DIB3;\\n    input DIB2;\\n    input DIB1;\\n    input DIB0;\\n    input ADB13;\\n    input ADB12;\\n    input ADB11;\\n    input ADB10;\\n    input ADB9;\\n    input ADB8;\\n    input ADB7;\\n    input ADB6;\\n    input ADB5;\\n    input ADB4;\\n    input ADB3;\\n    input ADB2;\\n    input ADB1;\\n    input ADB0;\\n    input CEB;\\n    input OCEB;\\n    input CLKB;\\n    input WEB;\\n    input CSB2;\\n    input CSB1;\\n    input CSB0;\\n    input RSTB;\\n    output DOA17;\\n    output DOA16;\\n    output DOA15;\\n    output DOA14;\\n    output DOA13;\\n    output DOA12;\\n    output DOA11;\\n    output DOA10;\\n    output DOA9;\\n    output DOA8;\\n    output DOA7;\\n    output DOA6;\\n    output DOA5;\\n    output DOA4;\\n    output DOA3;\\n    output DOA2;\\n    output DOA1;\\n    output DOA0;\\n    output DOB17;\\n    output DOB16;\\n    output DOB15;\\n    output DOB14;\\n    output DOB13;\\n    output DOB12;\\n    output DOB11;\\n    output DOB10;\\n    output DOB9;\\n    output DOB8;\\n    output DOB7;\\n    output DOB6;\\n    output DOB5;\\n    output DOB4;\\n    output DOB3;\\n    output DOB2;\\n    output DOB1;\\n    output DOB0;\\nendmodule\\n\\n(* blackbox *)\\nmodule PDPW16KD (...);\\n    parameter DATA_WIDTH_W = 36;\\n    parameter DATA_WIDTH_R = 36;\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter CSDECODE_W = \\\"0b000\\\";\\n    parameter CSDECODE_R = \\\"0b000\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_20 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_21 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_22 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_23 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_24 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_25 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_26 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_27 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_28 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_29 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_2F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_30 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_31 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_32 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_33 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_34 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_35 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_36 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_37 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_38 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_39 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_3F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    input DI35;\\n    input DI34;\\n    input DI33;\\n    input DI32;\\n    input DI31;\\n    input DI30;\\n    input DI29;\\n    input DI28;\\n    input DI27;\\n    input DI26;\\n    input DI25;\\n    input DI24;\\n    input DI23;\\n    input DI22;\\n    input DI21;\\n    input DI20;\\n    input DI19;\\n    input DI18;\\n    input DI17;\\n    input DI16;\\n    input DI15;\\n    input DI14;\\n    input DI13;\\n    input DI12;\\n    input DI11;\\n    input DI10;\\n    input DI9;\\n    input DI8;\\n    input DI7;\\n    input DI6;\\n    input DI5;\\n    input DI4;\\n    input DI3;\\n    input DI2;\\n    input DI1;\\n    input DI0;\\n    input ADW8;\\n    input ADW7;\\n    input ADW6;\\n    input ADW5;\\n    input ADW4;\\n    input ADW3;\\n    input ADW2;\\n    input ADW1;\\n    input ADW0;\\n    input BE3;\\n    input BE2;\\n    input BE1;\\n    input BE0;\\n    input CEW;\\n    input CLKW;\\n    input CSW2;\\n    input CSW1;\\n    input CSW0;\\n    input ADR13;\\n    input ADR12;\\n    input ADR11;\\n    input ADR10;\\n    input ADR9;\\n    input ADR8;\\n    input ADR7;\\n    input ADR6;\\n    input ADR5;\\n    input ADR4;\\n    input ADR3;\\n    input ADR2;\\n    input ADR1;\\n    input ADR0;\\n    input CER;\\n    input OCER;\\n    input CLKR;\\n    input CSR2;\\n    input CSR1;\\n    input CSR0;\\n    input RST;\\n    output DO35;\\n    output DO34;\\n    output DO33;\\n    output DO32;\\n    output DO31;\\n    output DO30;\\n    output DO29;\\n    output DO28;\\n    output DO27;\\n    output DO26;\\n    output DO25;\\n    output DO24;\\n    output DO23;\\n    output DO22;\\n    output DO21;\\n    output DO20;\\n    output DO19;\\n    output DO18;\\n    output DO17;\\n    output DO16;\\n    output DO15;\\n    output DO14;\\n    output DO13;\\n    output DO12;\\n    output DO11;\\n    output DO10;\\n    output DO9;\\n    output DO8;\\n    output DO7;\\n    output DO6;\\n    output DO5;\\n    output DO4;\\n    output DO3;\\n    output DO2;\\n    output DO1;\\n    output DO0;\\nendmodule\\n\\n(* blackbox *)\\nmodule MULT18X18D (...);\\n    parameter REG_INPUTA_CLK = \\\"NONE\\\";\\n    parameter REG_INPUTA_CE = \\\"CE0\\\";\\n    parameter REG_INPUTA_RST = \\\"RST0\\\";\\n    parameter REG_INPUTB_CLK = \\\"NONE\\\";\\n    parameter REG_INPUTB_CE = \\\"CE0\\\";\\n    parameter REG_INPUTB_RST = \\\"RST0\\\";\\n    parameter REG_INPUTC_CLK = \\\"NONE\\\";\\n    parameter REG_INPUTC_CE = \\\"CE0\\\";\\n    parameter REG_INPUTC_RST = \\\"RST0\\\";\\n    parameter REG_PIPELINE_CLK = \\\"NONE\\\";\\n    parameter REG_PIPELINE_CE = \\\"CE0\\\";\\n    parameter REG_PIPELINE_RST = \\\"RST0\\\";\\n    parameter REG_OUTPUT_CLK = \\\"NONE\\\";\\n    parameter REG_OUTPUT_CE = \\\"CE0\\\";\\n    parameter REG_OUTPUT_RST = \\\"RST0\\\";\\n    parameter CLK0_DIV = \\\"ENABLED\\\";\\n    parameter CLK1_DIV = \\\"ENABLED\\\";\\n    parameter CLK2_DIV = \\\"ENABLED\\\";\\n    parameter CLK3_DIV = \\\"ENABLED\\\";\\n    parameter HIGHSPEED_CLK = \\\"NONE\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter CAS_MATCH_REG = \\\"FALSE\\\";\\n    parameter SOURCEB_MODE = \\\"B_SHIFT\\\";\\n    parameter MULT_BYPASS = \\\"DISABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    input A17;\\n    input A16;\\n    input A15;\\n    input A14;\\n    input A13;\\n    input A12;\\n    input A11;\\n    input A10;\\n    input A9;\\n    input A8;\\n    input A7;\\n    input A6;\\n    input A5;\\n    input A4;\\n    input A3;\\n    input A2;\\n    input A1;\\n    input A0;\\n    input B17;\\n    input B16;\\n    input B15;\\n    input B14;\\n    input B13;\\n    input B12;\\n    input B11;\\n    input B10;\\n    input B9;\\n    input B8;\\n    input B7;\\n    input B6;\\n    input B5;\\n    input B4;\\n    input B3;\\n    input B2;\\n    input B1;\\n    input B0;\\n    input C17;\\n    input C16;\\n    input C15;\\n    input C14;\\n    input C13;\\n    input C12;\\n    input C11;\\n    input C10;\\n    input C9;\\n    input C8;\\n    input C7;\\n    input C6;\\n    input C5;\\n    input C4;\\n    input C3;\\n    input C2;\\n    input C1;\\n    input C0;\\n    input SIGNEDA;\\n    input SIGNEDB;\\n    input SOURCEA;\\n    input SOURCEB;\\n    input CLK3;\\n    input CLK2;\\n    input CLK1;\\n    input CLK0;\\n    input CE3;\\n    input CE2;\\n    input CE1;\\n    input CE0;\\n    input RST3;\\n    input RST2;\\n    input RST1;\\n    input RST0;\\n    input SRIA17;\\n    input SRIA16;\\n    input SRIA15;\\n    input SRIA14;\\n    input SRIA13;\\n    input SRIA12;\\n    input SRIA11;\\n    input SRIA10;\\n    input SRIA9;\\n    input SRIA8;\\n    input SRIA7;\\n    input SRIA6;\\n    input SRIA5;\\n    input SRIA4;\\n    input SRIA3;\\n    input SRIA2;\\n    input SRIA1;\\n    input SRIA0;\\n    input SRIB17;\\n    input SRIB16;\\n    input SRIB15;\\n    input SRIB14;\\n    input SRIB13;\\n    input SRIB12;\\n    input SRIB11;\\n    input SRIB10;\\n    input SRIB9;\\n    input SRIB8;\\n    input SRIB7;\\n    input SRIB6;\\n    input SRIB5;\\n    input SRIB4;\\n    input SRIB3;\\n    input SRIB2;\\n    input SRIB1;\\n    input SRIB0;\\n    output SROA17;\\n    output SROA16;\\n    output SROA15;\\n    output SROA14;\\n    output SROA13;\\n    output SROA12;\\n    output SROA11;\\n    output SROA10;\\n    output SROA9;\\n    output SROA8;\\n    output SROA7;\\n    output SROA6;\\n    output SROA5;\\n    output SROA4;\\n    output SROA3;\\n    output SROA2;\\n    output SROA1;\\n    output SROA0;\\n    output SROB17;\\n    output SROB16;\\n    output SROB15;\\n    output SROB14;\\n    output SROB13;\\n    output SROB12;\\n    output SROB11;\\n    output SROB10;\\n    output SROB9;\\n    output SROB8;\\n    output SROB7;\\n    output SROB6;\\n    output SROB5;\\n    output SROB4;\\n    output SROB3;\\n    output SROB2;\\n    output SROB1;\\n    output SROB0;\\n    output ROA17;\\n    output ROA16;\\n    output ROA15;\\n    output ROA14;\\n    output ROA13;\\n    output ROA12;\\n    output ROA11;\\n    output ROA10;\\n    output ROA9;\\n    output ROA8;\\n    output ROA7;\\n    output ROA6;\\n    output ROA5;\\n    output ROA4;\\n    output ROA3;\\n    output ROA2;\\n    output ROA1;\\n    output ROA0;\\n    output ROB17;\\n    output ROB16;\\n    output ROB15;\\n    output ROB14;\\n    output ROB13;\\n    output ROB12;\\n    output ROB11;\\n    output ROB10;\\n    output ROB9;\\n    output ROB8;\\n    output ROB7;\\n    output ROB6;\\n    output ROB5;\\n    output ROB4;\\n    output ROB3;\\n    output ROB2;\\n    output ROB1;\\n    output ROB0;\\n    output ROC17;\\n    output ROC16;\\n    output ROC15;\\n    output ROC14;\\n    output ROC13;\\n    output ROC12;\\n    output ROC11;\\n    output ROC10;\\n    output ROC9;\\n    output ROC8;\\n    output ROC7;\\n    output ROC6;\\n    output ROC5;\\n    output ROC4;\\n    output ROC3;\\n    output ROC2;\\n    output ROC1;\\n    output ROC0;\\n    output P35;\\n    output P34;\\n    output P33;\\n    output P32;\\n    output P31;\\n    output P30;\\n    output P29;\\n    output P28;\\n    output P27;\\n    output P26;\\n    output P25;\\n    output P24;\\n    output P23;\\n    output P22;\\n    output P21;\\n    output P20;\\n    output P19;\\n    output P18;\\n    output P17;\\n    output P16;\\n    output P15;\\n    output P14;\\n    output P13;\\n    output P12;\\n    output P11;\\n    output P10;\\n    output P9;\\n    output P8;\\n    output P7;\\n    output P6;\\n    output P5;\\n    output P4;\\n    output P3;\\n    output P2;\\n    output P1;\\n    output P0;\\n    output SIGNEDP;\\nendmodule\\n\\n(* blackbox *)\\nmodule ALU54B (...);\\n    parameter REG_INPUTC0_CLK = \\\"NONE\\\";\\n    parameter REG_INPUTC0_CE = \\\"CE0\\\";\\n    parameter REG_INPUTC0_RST = \\\"RST0\\\";\\n    parameter REG_INPUTC1_CLK = \\\"NONE\\\";\\n    parameter REG_INPUTC1_CE = \\\"CE0\\\";\\n    parameter REG_INPUTC1_RST = \\\"RST0\\\";\\n    parameter REG_OPCODEOP0_0_CLK = \\\"NONE\\\";\\n    parameter REG_OPCODEOP0_0_CE = \\\"CE0\\\";\\n    parameter REG_OPCODEOP0_0_RST = \\\"RST0\\\";\\n    parameter REG_OPCODEOP1_0_CLK = \\\"NONE\\\";\\n    parameter REG_OPCODEOP0_1_CLK = \\\"NONE\\\";\\n    parameter REG_OPCODEOP0_1_CE = \\\"CE0\\\";\\n    parameter REG_OPCODEOP0_1_RST = \\\"RST0\\\";\\n    parameter REG_OPCODEOP1_1_CLK = \\\"NONE\\\";\\n    parameter REG_OPCODEIN_0_CLK = \\\"NONE\\\";\\n    parameter REG_OPCODEIN_0_CE = \\\"CE0\\\";\\n    parameter REG_OPCODEIN_0_RST = \\\"RST0\\\";\\n    parameter REG_OPCODEIN_1_CLK = \\\"NONE\\\";\\n    parameter REG_OPCODEIN_1_CE = \\\"CE0\\\";\\n    parameter REG_OPCODEIN_1_RST = \\\"RST0\\\";\\n    parameter REG_OUTPUT0_CLK = \\\"NONE\\\";\\n    parameter REG_OUTPUT0_CE = \\\"CE0\\\";\\n    parameter REG_OUTPUT0_RST = \\\"RST0\\\";\\n    parameter REG_OUTPUT1_CLK = \\\"NONE\\\";\\n    parameter REG_OUTPUT1_CE = \\\"CE0\\\";\\n    parameter REG_OUTPUT1_RST = \\\"RST0\\\";\\n    parameter REG_FLAG_CLK = \\\"NONE\\\";\\n    parameter REG_FLAG_CE = \\\"CE0\\\";\\n    parameter REG_FLAG_RST = \\\"RST0\\\";\\n    parameter MCPAT_SOURCE = \\\"STATIC\\\";\\n    parameter MASKPAT_SOURCE = \\\"STATIC\\\";\\n    parameter MASK01 = \\\"0x00000000000000\\\";\\n    parameter REG_INPUTCFB_CLK = \\\"NONE\\\";\\n    parameter REG_INPUTCFB_CE = \\\"CE0\\\";\\n    parameter REG_INPUTCFB_RST = \\\"RST0\\\";\\n    parameter CLK0_DIV = \\\"ENABLED\\\";\\n    parameter CLK1_DIV = \\\"ENABLED\\\";\\n    parameter CLK2_DIV = \\\"ENABLED\\\";\\n    parameter CLK3_DIV = \\\"ENABLED\\\";\\n    parameter MCPAT = \\\"0x00000000000000\\\";\\n    parameter MASKPAT = \\\"0x00000000000000\\\";\\n    parameter RNDPAT = \\\"0x00000000000000\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter MULT9_MODE = \\\"DISABLED\\\";\\n    parameter FORCE_ZERO_BARREL_SHIFT = \\\"DISABLED\\\";\\n    parameter LEGACY = \\\"DISABLED\\\";\\n    input CE3;\\n    input CE2;\\n    input CE1;\\n    input CE0;\\n    input CLK3;\\n    input CLK2;\\n    input CLK1;\\n    input CLK0;\\n    input RST3;\\n    input RST2;\\n    input RST1;\\n    input RST0;\\n    input SIGNEDIA;\\n    input SIGNEDIB;\\n    input SIGNEDCIN;\\n    input A35;\\n    input A34;\\n    input A33;\\n    input A32;\\n    input A31;\\n    input A30;\\n    input A29;\\n    input A28;\\n    input A27;\\n    input A26;\\n    input A25;\\n    input A24;\\n    input A23;\\n    input A22;\\n    input A21;\\n    input A20;\\n    input A19;\\n    input A18;\\n    input A17;\\n    input A16;\\n    input A15;\\n    input A14;\\n    input A13;\\n    input A12;\\n    input A11;\\n    input A10;\\n    input A9;\\n    input A8;\\n    input A7;\\n    input A6;\\n    input A5;\\n    input A4;\\n    input A3;\\n    input A2;\\n    input A1;\\n    input A0;\\n    input B35;\\n    input B34;\\n    input B33;\\n    input B32;\\n    input B31;\\n    input B30;\\n    input B29;\\n    input B28;\\n    input B27;\\n    input B26;\\n    input B25;\\n    input B24;\\n    input B23;\\n    input B22;\\n    input B21;\\n    input B20;\\n    input B19;\\n    input B18;\\n    input B17;\\n    input B16;\\n    input B15;\\n    input B14;\\n    input B13;\\n    input B12;\\n    input B11;\\n    input B10;\\n    input B9;\\n    input B8;\\n    input B7;\\n    input B6;\\n    input B5;\\n    input B4;\\n    input B3;\\n    input B2;\\n    input B1;\\n    input B0;\\n    input C53;\\n    input C52;\\n    input C51;\\n    input C50;\\n    input C49;\\n    input C48;\\n    input C47;\\n    input C46;\\n    input C45;\\n    input C44;\\n    input C43;\\n    input C42;\\n    input C41;\\n    input C40;\\n    input C39;\\n    input C38;\\n    input C37;\\n    input C36;\\n    input C35;\\n    input C34;\\n    input C33;\\n    input C32;\\n    input C31;\\n    input C30;\\n    input C29;\\n    input C28;\\n    input C27;\\n    input C26;\\n    input C25;\\n    input C24;\\n    input C23;\\n    input C22;\\n    input C21;\\n    input C20;\\n    input C19;\\n    input C18;\\n    input C17;\\n    input C16;\\n    input C15;\\n    input C14;\\n    input C13;\\n    input C12;\\n    input C11;\\n    input C10;\\n    input C9;\\n    input C8;\\n    input C7;\\n    input C6;\\n    input C5;\\n    input C4;\\n    input C3;\\n    input C2;\\n    input C1;\\n    input C0;\\n    input CFB53;\\n    input CFB52;\\n    input CFB51;\\n    input CFB50;\\n    input CFB49;\\n    input CFB48;\\n    input CFB47;\\n    input CFB46;\\n    input CFB45;\\n    input CFB44;\\n    input CFB43;\\n    input CFB42;\\n    input CFB41;\\n    input CFB40;\\n    input CFB39;\\n    input CFB38;\\n    input CFB37;\\n    input CFB36;\\n    input CFB35;\\n    input CFB34;\\n    input CFB33;\\n    input CFB32;\\n    input CFB31;\\n    input CFB30;\\n    input CFB29;\\n    input CFB28;\\n    input CFB27;\\n    input CFB26;\\n    input CFB25;\\n    input CFB24;\\n    input CFB23;\\n    input CFB22;\\n    input CFB21;\\n    input CFB20;\\n    input CFB19;\\n    input CFB18;\\n    input CFB17;\\n    input CFB16;\\n    input CFB15;\\n    input CFB14;\\n    input CFB13;\\n    input CFB12;\\n    input CFB11;\\n    input CFB10;\\n    input CFB9;\\n    input CFB8;\\n    input CFB7;\\n    input CFB6;\\n    input CFB5;\\n    input CFB4;\\n    input CFB3;\\n    input CFB2;\\n    input CFB1;\\n    input CFB0;\\n    input MA35;\\n    input MA34;\\n    input MA33;\\n    input MA32;\\n    input MA31;\\n    input MA30;\\n    input MA29;\\n    input MA28;\\n    input MA27;\\n    input MA26;\\n    input MA25;\\n    input MA24;\\n    input MA23;\\n    input MA22;\\n    input MA21;\\n    input MA20;\\n    input MA19;\\n    input MA18;\\n    input MA17;\\n    input MA16;\\n    input MA15;\\n    input MA14;\\n    input MA13;\\n    input MA12;\\n    input MA11;\\n    input MA10;\\n    input MA9;\\n    input MA8;\\n    input MA7;\\n    input MA6;\\n    input MA5;\\n    input MA4;\\n    input MA3;\\n    input MA2;\\n    input MA1;\\n    input MA0;\\n    input MB35;\\n    input MB34;\\n    input MB33;\\n    input MB32;\\n    input MB31;\\n    input MB30;\\n    input MB29;\\n    input MB28;\\n    input MB27;\\n    input MB26;\\n    input MB25;\\n    input MB24;\\n    input MB23;\\n    input MB22;\\n    input MB21;\\n    input MB20;\\n    input MB19;\\n    input MB18;\\n    input MB17;\\n    input MB16;\\n    input MB15;\\n    input MB14;\\n    input MB13;\\n    input MB12;\\n    input MB11;\\n    input MB10;\\n    input MB9;\\n    input MB8;\\n    input MB7;\\n    input MB6;\\n    input MB5;\\n    input MB4;\\n    input MB3;\\n    input MB2;\\n    input MB1;\\n    input MB0;\\n    input CIN53;\\n    input CIN52;\\n    input CIN51;\\n    input CIN50;\\n    input CIN49;\\n    input CIN48;\\n    input CIN47;\\n    input CIN46;\\n    input CIN45;\\n    input CIN44;\\n    input CIN43;\\n    input CIN42;\\n    input CIN41;\\n    input CIN40;\\n    input CIN39;\\n    input CIN38;\\n    input CIN37;\\n    input CIN36;\\n    input CIN35;\\n    input CIN34;\\n    input CIN33;\\n    input CIN32;\\n    input CIN31;\\n    input CIN30;\\n    input CIN29;\\n    input CIN28;\\n    input CIN27;\\n    input CIN26;\\n    input CIN25;\\n    input CIN24;\\n    input CIN23;\\n    input CIN22;\\n    input CIN21;\\n    input CIN20;\\n    input CIN19;\\n    input CIN18;\\n    input CIN17;\\n    input CIN16;\\n    input CIN15;\\n    input CIN14;\\n    input CIN13;\\n    input CIN12;\\n    input CIN11;\\n    input CIN10;\\n    input CIN9;\\n    input CIN8;\\n    input CIN7;\\n    input CIN6;\\n    input CIN5;\\n    input CIN4;\\n    input CIN3;\\n    input CIN2;\\n    input CIN1;\\n    input CIN0;\\n    input OP10;\\n    input OP9;\\n    input OP8;\\n    input OP7;\\n    input OP6;\\n    input OP5;\\n    input OP4;\\n    input OP3;\\n    input OP2;\\n    input OP1;\\n    input OP0;\\n    output R53;\\n    output R52;\\n    output R51;\\n    output R50;\\n    output R49;\\n    output R48;\\n    output R47;\\n    output R46;\\n    output R45;\\n    output R44;\\n    output R43;\\n    output R42;\\n    output R41;\\n    output R40;\\n    output R39;\\n    output R38;\\n    output R37;\\n    output R36;\\n    output R35;\\n    output R34;\\n    output R33;\\n    output R32;\\n    output R31;\\n    output R30;\\n    output R29;\\n    output R28;\\n    output R27;\\n    output R26;\\n    output R25;\\n    output R24;\\n    output R23;\\n    output R22;\\n    output R21;\\n    output R20;\\n    output R19;\\n    output R18;\\n    output R17;\\n    output R16;\\n    output R15;\\n    output R14;\\n    output R13;\\n    output R12;\\n    output R11;\\n    output R10;\\n    output R9;\\n    output R8;\\n    output R7;\\n    output R6;\\n    output R5;\\n    output R4;\\n    output R3;\\n    output R2;\\n    output R1;\\n    output R0;\\n    output CO53;\\n    output CO52;\\n    output CO51;\\n    output CO50;\\n    output CO49;\\n    output CO48;\\n    output CO47;\\n    output CO46;\\n    output CO45;\\n    output CO44;\\n    output CO43;\\n    output CO42;\\n    output CO41;\\n    output CO40;\\n    output CO39;\\n    output CO38;\\n    output CO37;\\n    output CO36;\\n    output CO35;\\n    output CO34;\\n    output CO33;\\n    output CO32;\\n    output CO31;\\n    output CO30;\\n    output CO29;\\n    output CO28;\\n    output CO27;\\n    output CO26;\\n    output CO25;\\n    output CO24;\\n    output CO23;\\n    output CO22;\\n    output CO21;\\n    output CO20;\\n    output CO19;\\n    output CO18;\\n    output CO17;\\n    output CO16;\\n    output CO15;\\n    output CO14;\\n    output CO13;\\n    output CO12;\\n    output CO11;\\n    output CO10;\\n    output CO9;\\n    output CO8;\\n    output CO7;\\n    output CO6;\\n    output CO5;\\n    output CO4;\\n    output CO3;\\n    output CO2;\\n    output CO1;\\n    output CO0;\\n    output EQZ;\\n    output EQZM;\\n    output EQOM;\\n    output EQPAT;\\n    output EQPATB;\\n    output OVER;\\n    output UNDER;\\n    output OVERUNDER;\\n    output SIGNEDR;\\nendmodule\\n\\n(* blackbox *)\\nmodule CLKDIVF (...);\\n    parameter GSR = \\\"DISABLED\\\";\\n    parameter DIV = \\\"2.0\\\";\\n    input CLKI;\\n    input RST;\\n    input ALIGNWD;\\n    output CDIVX;\\nendmodule\\n\\n(* blackbox *)\\nmodule PCSCLKDIV (...);\\n    parameter GSR = \\\"DISABLED\\\";\\n    input CLKI;\\n    input RST;\\n    input SEL2;\\n    input SEL1;\\n    input SEL0;\\n    output CDIV1;\\n    output CDIVX;\\nendmodule\\n\\n(* blackbox *)\\nmodule DCSC (...);\\n    parameter DCSMODE = \\\"POS\\\";\\n    input CLK1;\\n    input CLK0;\\n    input SEL1;\\n    input SEL0;\\n    input MODESEL;\\n    output DCSOUT;\\nendmodule\\n\\n(* blackbox *)\\nmodule DCCA (...);\\n    input CLKI;\\n    input CE;\\n    output CLKO;\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKSYNCB (...);\\n    input ECLKI;\\n    input STOP;\\n    output ECLKO;\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKBRIDGECS (...);\\n    input CLK0;\\n    input CLK1;\\n    input SEL;\\n    output ECSOUT;\\nendmodule\\n\\n(* blackbox *)\\nmodule DELAYF (...);\\n    parameter DEL_MODE = \\\"USER_DEFINED\\\";\\n    parameter DEL_VALUE = 0;\\n    input A;\\n    input LOADN;\\n    input MOVE;\\n    input DIRECTION;\\n    output Z;\\n    output CFLAG;\\nendmodule\\n\\n(* blackbox *)\\nmodule DELAYG (...);\\n    parameter DEL_MODE = \\\"USER_DEFINED\\\";\\n    parameter DEL_VALUE = 0;\\n    input A;\\n    output Z;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule USRMCLK (...);\\n    input USRMCLKI;\\n    input USRMCLKTS;\\nendmodule\\n\\n(* blackbox *)\\nmodule DQSBUFM (...);\\n    parameter DQS_LI_DEL_VAL = 4;\\n    parameter DQS_LI_DEL_ADJ = \\\"FACTORYONLY\\\";\\n    parameter DQS_LO_DEL_VAL = 0;\\n    parameter DQS_LO_DEL_ADJ = \\\"FACTORYONLY\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    input DQSI;\\n    input READ1;\\n    input READ0;\\n    input READCLKSEL2;\\n    input READCLKSEL1;\\n    input READCLKSEL0;\\n    input DDRDEL;\\n    input ECLK;\\n    input SCLK;\\n    input RST;\\n    input DYNDELAY7;\\n    input DYNDELAY6;\\n    input DYNDELAY5;\\n    input DYNDELAY4;\\n    input DYNDELAY3;\\n    input DYNDELAY2;\\n    input DYNDELAY1;\\n    input DYNDELAY0;\\n    input PAUSE;\\n    input RDLOADN;\\n    input RDMOVE;\\n    input RDDIRECTION;\\n    input WRLOADN;\\n    input WRMOVE;\\n    input WRDIRECTION;\\n    output DQSR90;\\n    output DQSW;\\n    output DQSW270;\\n    output RDPNTR2;\\n    output RDPNTR1;\\n    output RDPNTR0;\\n    output WRPNTR2;\\n    output WRPNTR1;\\n    output WRPNTR0;\\n    output DATAVALID;\\n    output BURSTDET;\\n    output RDCFLAG;\\n    output WRCFLAG;\\nendmodule\\n\\n(* blackbox *)\\nmodule DDRDLLA (...);\\n    parameter FORCE_MAX_DELAY = \\\"NO\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    input CLK;\\n    input RST;\\n    input UDDCNTLN;\\n    input FREEZE;\\n    output DDRDEL;\\n    output LOCK;\\n    output DCNTL7;\\n    output DCNTL6;\\n    output DCNTL5;\\n    output DCNTL4;\\n    output DCNTL3;\\n    output DCNTL2;\\n    output DCNTL1;\\n    output DCNTL0;\\nendmodule\\n\\n(* blackbox *)\\nmodule DLLDELD (...);\\n    input A;\\n    input DDRDEL;\\n    input LOADN;\\n    input MOVE;\\n    input DIRECTION;\\n    output Z;\\n    output CFLAG;\\nendmodule\\n\\n(* blackbox *)\\nmodule IDDRX1F (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input D;\\n    input SCLK;\\n    input RST;\\n    output Q0;\\n    output Q1;\\nendmodule\\n\\n(* blackbox *)\\nmodule IDDRX2F (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input D;\\n    input SCLK;\\n    input ECLK;\\n    input RST;\\n    input ALIGNWD;\\n    output Q3;\\n    output Q2;\\n    output Q1;\\n    output Q0;\\nendmodule\\n\\n(* blackbox *)\\nmodule IDDR71B (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input D;\\n    input SCLK;\\n    input ECLK;\\n    input RST;\\n    input ALIGNWD;\\n    output Q6;\\n    output Q5;\\n    output Q4;\\n    output Q3;\\n    output Q2;\\n    output Q1;\\n    output Q0;\\nendmodule\\n\\n(* blackbox *)\\nmodule IDDRX2DQA (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input SCLK;\\n    input ECLK;\\n    input DQSR90;\\n    input D;\\n    input RST;\\n    input RDPNTR2;\\n    input RDPNTR1;\\n    input RDPNTR0;\\n    input WRPNTR2;\\n    input WRPNTR1;\\n    input WRPNTR0;\\n    output Q3;\\n    output Q2;\\n    output Q1;\\n    output Q0;\\n    output QWL;\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDRX1F (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input SCLK;\\n    input RST;\\n    input D0;\\n    input D1;\\n    output Q;\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDRX2F (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input SCLK;\\n    input ECLK;\\n    input RST;\\n    input D3;\\n    input D2;\\n    input D1;\\n    input D0;\\n    output Q;\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDR71B (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input SCLK;\\n    input ECLK;\\n    input RST;\\n    input D6;\\n    input D5;\\n    input D4;\\n    input D3;\\n    input D2;\\n    input D1;\\n    input D0;\\n    output Q;\\nendmodule\\n\\n(* blackbox *)\\nmodule OSHX2A (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input D1;\\n    input D0;\\n    input SCLK;\\n    input ECLK;\\n    input RST;\\n    output Q;\\nendmodule\\n\\n(* blackbox *)\\nmodule TSHX2DQA (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter REGSET = \\\"SET\\\";\\n    input T1;\\n    input T0;\\n    input SCLK;\\n    input ECLK;\\n    input DQSW270;\\n    input RST;\\n    output Q;\\nendmodule\\n\\n(* blackbox *)\\nmodule TSHX2DQSA (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter REGSET = \\\"SET\\\";\\n    input T1;\\n    input T0;\\n    input SCLK;\\n    input ECLK;\\n    input DQSW;\\n    input RST;\\n    output Q;\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDRX2DQA (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input D3;\\n    input D2;\\n    input D1;\\n    input D0;\\n    input DQSW270;\\n    input SCLK;\\n    input ECLK;\\n    input RST;\\n    output Q;\\nendmodule\\n\\n(* blackbox *)\\nmodule ODDRX2DQSB (...);\\n    parameter GSR = \\\"ENABLED\\\";\\n    input D3;\\n    input D2;\\n    input D1;\\n    input D0;\\n    input SCLK;\\n    input ECLK;\\n    input DQSW;\\n    input RST;\\n    output Q;\\nendmodule\\n\\n(* blackbox *)\\nmodule EHXPLLL (...);\\n    parameter CLKI_DIV = 1;\\n    parameter CLKFB_DIV = 1;\\n    parameter CLKOP_DIV = 8;\\n    parameter CLKOS_DIV = 8;\\n    parameter CLKOS2_DIV = 8;\\n    parameter CLKOS3_DIV = 8;\\n    parameter CLKOP_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS_ENABLE = \\\"DISABLED\\\";\\n    parameter CLKOS2_ENABLE = \\\"DISABLED\\\";\\n    parameter CLKOS3_ENABLE = \\\"DISABLED\\\";\\n    parameter CLKOP_CPHASE = 0;\\n    parameter CLKOS_CPHASE = 0;\\n    parameter CLKOS2_CPHASE = 0;\\n    parameter CLKOS3_CPHASE = 0;\\n    parameter CLKOP_FPHASE = 0;\\n    parameter CLKOS_FPHASE = 0;\\n    parameter CLKOS2_FPHASE = 0;\\n    parameter CLKOS3_FPHASE = 0;\\n    parameter FEEDBK_PATH = \\\"CLKOP\\\";\\n    parameter CLKOP_TRIM_POL = \\\"RISING\\\";\\n    parameter CLKOP_TRIM_DELAY = 0;\\n    parameter CLKOS_TRIM_POL = \\\"RISING\\\";\\n    parameter CLKOS_TRIM_DELAY = 0;\\n    parameter OUTDIVIDER_MUXA = \\\"DIVA\\\";\\n    parameter OUTDIVIDER_MUXB = \\\"DIVB\\\";\\n    parameter OUTDIVIDER_MUXC = \\\"DIVC\\\";\\n    parameter OUTDIVIDER_MUXD = \\\"DIVD\\\";\\n    parameter PLL_LOCK_MODE = 0;\\n    parameter PLL_LOCK_DELAY = 200;\\n    parameter STDBY_ENABLE = \\\"DISABLED\\\";\\n    parameter REFIN_RESET = \\\"DISABLED\\\";\\n    parameter SYNC_ENABLE = \\\"DISABLED\\\";\\n    parameter INT_LOCK_STICKY = \\\"ENABLED\\\";\\n    parameter DPHASE_SOURCE = \\\"DISABLED\\\";\\n    parameter PLLRST_ENA = \\\"DISABLED\\\";\\n    parameter INTFB_WAKE = \\\"DISABLED\\\";\\n    input CLKI;\\n    input CLKFB;\\n    input PHASESEL1;\\n    input PHASESEL0;\\n    input PHASEDIR;\\n    input PHASESTEP;\\n    input PHASELOADREG;\\n    input STDBY;\\n    input PLLWAKESYNC;\\n    input RST;\\n    input ENCLKOP;\\n    input ENCLKOS;\\n    input ENCLKOS2;\\n    input ENCLKOS3;\\n    output CLKOP;\\n    output CLKOS;\\n    output CLKOS2;\\n    output CLKOS3;\\n    output LOCK;\\n    output INTLOCK;\\n    output REFCLK;\\n    output CLKINTFB;\\nendmodule\\n\\n(* blackbox *)\\nmodule DTR (...);\\n    parameter DTR_TEMP = 25;\\n    input STARTPULSE;\\n    output DTROUT7;\\n    output DTROUT6;\\n    output DTROUT5;\\n    output DTROUT4;\\n    output DTROUT3;\\n    output DTROUT2;\\n    output DTROUT1;\\n    output DTROUT0;\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCG (...);\\n    parameter DIV = 128;\\n    output OSC;\\nendmodule\\n\\n(* blackbox *)\\nmodule EXTREFB (...);\\n    parameter REFCK_PWDNB = \\\"DONTCARE\\\";\\n    parameter REFCK_RTERM = \\\"DONTCARE\\\";\\n    parameter REFCK_DCBIAS_EN = \\\"DONTCARE\\\";\\n    (* iopad_external_pin *)\\n    input REFCLKP;\\n    (* iopad_external_pin *)\\n    input REFCLKN;\\n    output REFCLKO;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule JTAGG (...);\\n    parameter ER1 = \\\"ENABLED\\\";\\n    parameter ER2 = \\\"ENABLED\\\";\\n    (* iopad_external_pin *)\\n    input TCK;\\n    (* iopad_external_pin *)\\n    input TMS;\\n    (* iopad_external_pin *)\\n    input TDI;\\n    input JTDO2;\\n    input JTDO1;\\n    (* iopad_external_pin *)\\n    output TDO;\\n    output JTDI;\\n    output JTCK;\\n    output JRTI2;\\n    output JRTI1;\\n    output JSHIFT;\\n    output JUPDATE;\\n    output JRSTN;\\n    output JCE2;\\n    output JCE1;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule DCUA (...);\\n    parameter D_MACROPDB = \\\"DONTCARE\\\";\\n    parameter D_IB_PWDNB = \\\"DONTCARE\\\";\\n    parameter D_XGE_MODE = \\\"DONTCARE\\\";\\n    parameter D_LOW_MARK = \\\"DONTCARE\\\";\\n    parameter D_HIGH_MARK = \\\"DONTCARE\\\";\\n    parameter D_BUS8BIT_SEL = \\\"DONTCARE\\\";\\n    parameter D_CDR_LOL_SET = \\\"DONTCARE\\\";\\n    parameter D_BITCLK_LOCAL_EN = \\\"DONTCARE\\\";\\n    parameter D_BITCLK_ND_EN = \\\"DONTCARE\\\";\\n    parameter D_BITCLK_FROM_ND_EN = \\\"DONTCARE\\\";\\n    parameter D_SYNC_LOCAL_EN = \\\"DONTCARE\\\";\\n    parameter D_SYNC_ND_EN = \\\"DONTCARE\\\";\\n    parameter CH0_UC_MODE = \\\"DONTCARE\\\";\\n    parameter CH1_UC_MODE = \\\"DONTCARE\\\";\\n    parameter CH0_PCIE_MODE = \\\"DONTCARE\\\";\\n    parameter CH1_PCIE_MODE = \\\"DONTCARE\\\";\\n    parameter CH0_RIO_MODE = \\\"DONTCARE\\\";\\n    parameter CH1_RIO_MODE = \\\"DONTCARE\\\";\\n    parameter CH0_WA_MODE = \\\"DONTCARE\\\";\\n    parameter CH1_WA_MODE = \\\"DONTCARE\\\";\\n    parameter CH0_INVERT_RX = \\\"DONTCARE\\\";\\n    parameter CH1_INVERT_RX = \\\"DONTCARE\\\";\\n    parameter CH0_INVERT_TX = \\\"DONTCARE\\\";\\n    parameter CH1_INVERT_TX = \\\"DONTCARE\\\";\\n    parameter CH0_PRBS_SELECTION = \\\"DONTCARE\\\";\\n    parameter CH1_PRBS_SELECTION = \\\"DONTCARE\\\";\\n    parameter CH0_GE_AN_ENABLE = \\\"DONTCARE\\\";\\n    parameter CH1_GE_AN_ENABLE = \\\"DONTCARE\\\";\\n    parameter CH0_PRBS_LOCK = \\\"DONTCARE\\\";\\n    parameter CH1_PRBS_LOCK = \\\"DONTCARE\\\";\\n    parameter CH0_PRBS_ENABLE = \\\"DONTCARE\\\";\\n    parameter CH1_PRBS_ENABLE = \\\"DONTCARE\\\";\\n    parameter CH0_ENABLE_CG_ALIGN = \\\"DONTCARE\\\";\\n    parameter CH1_ENABLE_CG_ALIGN = \\\"DONTCARE\\\";\\n    parameter CH0_TX_GEAR_MODE = \\\"DONTCARE\\\";\\n    parameter CH1_TX_GEAR_MODE = \\\"DONTCARE\\\";\\n    parameter CH0_RX_GEAR_MODE = \\\"DONTCARE\\\";\\n    parameter CH1_RX_GEAR_MODE = \\\"DONTCARE\\\";\\n    parameter CH0_PCS_DET_TIME_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_PCS_DET_TIME_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_PCIE_EI_EN = \\\"DONTCARE\\\";\\n    parameter CH1_PCIE_EI_EN = \\\"DONTCARE\\\";\\n    parameter CH0_TX_GEAR_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH1_TX_GEAR_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH0_ENC_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH1_ENC_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH0_SB_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH1_SB_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH0_RX_SB_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH1_RX_SB_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH0_WA_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH1_WA_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH0_DEC_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH1_DEC_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH0_CTC_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH1_CTC_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH0_RX_GEAR_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH1_RX_GEAR_BYPASS = \\\"DONTCARE\\\";\\n    parameter CH0_LSM_DISABLE = \\\"DONTCARE\\\";\\n    parameter CH1_LSM_DISABLE = \\\"DONTCARE\\\";\\n    parameter CH0_MATCH_2_ENABLE = \\\"DONTCARE\\\";\\n    parameter CH1_MATCH_2_ENABLE = \\\"DONTCARE\\\";\\n    parameter CH0_MATCH_4_ENABLE = \\\"DONTCARE\\\";\\n    parameter CH1_MATCH_4_ENABLE = \\\"DONTCARE\\\";\\n    parameter CH0_MIN_IPG_CNT = \\\"DONTCARE\\\";\\n    parameter CH1_MIN_IPG_CNT = \\\"DONTCARE\\\";\\n    parameter CH0_CC_MATCH_1 = \\\"DONTCARE\\\";\\n    parameter CH1_CC_MATCH_1 = \\\"DONTCARE\\\";\\n    parameter CH0_CC_MATCH_2 = \\\"DONTCARE\\\";\\n    parameter CH1_CC_MATCH_2 = \\\"DONTCARE\\\";\\n    parameter CH0_CC_MATCH_3 = \\\"DONTCARE\\\";\\n    parameter CH1_CC_MATCH_3 = \\\"DONTCARE\\\";\\n    parameter CH0_CC_MATCH_4 = \\\"DONTCARE\\\";\\n    parameter CH1_CC_MATCH_4 = \\\"DONTCARE\\\";\\n    parameter CH0_UDF_COMMA_MASK = \\\"DONTCARE\\\";\\n    parameter CH1_UDF_COMMA_MASK = \\\"DONTCARE\\\";\\n    parameter CH0_UDF_COMMA_A = \\\"DONTCARE\\\";\\n    parameter CH1_UDF_COMMA_A = \\\"DONTCARE\\\";\\n    parameter CH0_UDF_COMMA_B = \\\"DONTCARE\\\";\\n    parameter CH1_UDF_COMMA_B = \\\"DONTCARE\\\";\\n    parameter CH0_RX_DCO_CK_DIV = \\\"DONTCARE\\\";\\n    parameter CH1_RX_DCO_CK_DIV = \\\"DONTCARE\\\";\\n    parameter CH0_RCV_DCC_EN = \\\"DONTCARE\\\";\\n    parameter CH1_RCV_DCC_EN = \\\"DONTCARE\\\";\\n    parameter CH0_REQ_LVL_SET = \\\"DONTCARE\\\";\\n    parameter CH1_REQ_LVL_SET = \\\"DONTCARE\\\";\\n    parameter CH0_REQ_EN = \\\"DONTCARE\\\";\\n    parameter CH1_REQ_EN = \\\"DONTCARE\\\";\\n    parameter CH0_RTERM_RX = \\\"DONTCARE\\\";\\n    parameter CH1_RTERM_RX = \\\"DONTCARE\\\";\\n    parameter CH0_PDEN_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_PDEN_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_LDR_RX2CORE_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_LDR_RX2CORE_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_LDR_CORE2TX_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_LDR_CORE2TX_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TPWDNB = \\\"DONTCARE\\\";\\n    parameter CH1_TPWDNB = \\\"DONTCARE\\\";\\n    parameter CH0_RATE_MODE_TX = \\\"DONTCARE\\\";\\n    parameter CH1_RATE_MODE_TX = \\\"DONTCARE\\\";\\n    parameter CH0_RTERM_TX = \\\"DONTCARE\\\";\\n    parameter CH1_RTERM_TX = \\\"DONTCARE\\\";\\n    parameter CH0_TX_CM_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_TX_CM_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_PRE_EN = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_PRE_EN = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE0_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE0_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE1_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE1_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE2_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE2_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE3_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE3_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE4_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE4_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE5_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE5_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE0_CUR = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE0_CUR = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE1_CUR = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE1_CUR = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE2_CUR = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE2_CUR = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE3_CUR = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE3_CUR = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE4_CUR = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE4_CUR = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_SLICE5_CUR = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_SLICE5_CUR = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_DAT_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_DAT_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TX_DIV11_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_TX_DIV11_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_RPWDNB = \\\"DONTCARE\\\";\\n    parameter CH1_RPWDNB = \\\"DONTCARE\\\";\\n    parameter CH0_RATE_MODE_RX = \\\"DONTCARE\\\";\\n    parameter CH1_RATE_MODE_RX = \\\"DONTCARE\\\";\\n    parameter CH0_RLOS_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_RLOS_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_RX_LOS_LVL = \\\"DONTCARE\\\";\\n    parameter CH1_RX_LOS_LVL = \\\"DONTCARE\\\";\\n    parameter CH0_RX_LOS_CEQ = \\\"DONTCARE\\\";\\n    parameter CH1_RX_LOS_CEQ = \\\"DONTCARE\\\";\\n    parameter CH0_RX_LOS_HYST_EN = \\\"DONTCARE\\\";\\n    parameter CH1_RX_LOS_HYST_EN = \\\"DONTCARE\\\";\\n    parameter CH0_RX_LOS_EN = \\\"DONTCARE\\\";\\n    parameter CH1_RX_LOS_EN = \\\"DONTCARE\\\";\\n    parameter CH0_RX_DIV11_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_RX_DIV11_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_SEL_SD_RX_CLK = \\\"DONTCARE\\\";\\n    parameter CH1_SEL_SD_RX_CLK = \\\"DONTCARE\\\";\\n    parameter CH0_FF_RX_H_CLK_EN = \\\"DONTCARE\\\";\\n    parameter CH1_FF_RX_H_CLK_EN = \\\"DONTCARE\\\";\\n    parameter CH0_FF_RX_F_CLK_DIS = \\\"DONTCARE\\\";\\n    parameter CH1_FF_RX_F_CLK_DIS = \\\"DONTCARE\\\";\\n    parameter CH0_FF_TX_H_CLK_EN = \\\"DONTCARE\\\";\\n    parameter CH1_FF_TX_H_CLK_EN = \\\"DONTCARE\\\";\\n    parameter CH0_FF_TX_F_CLK_DIS = \\\"DONTCARE\\\";\\n    parameter CH1_FF_TX_F_CLK_DIS = \\\"DONTCARE\\\";\\n    parameter CH0_RX_RATE_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_RX_RATE_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_TDRV_POST_EN = \\\"DONTCARE\\\";\\n    parameter CH1_TDRV_POST_EN = \\\"DONTCARE\\\";\\n    parameter CH0_TX_POST_SIGN = \\\"DONTCARE\\\";\\n    parameter CH1_TX_POST_SIGN = \\\"DONTCARE\\\";\\n    parameter CH0_TX_PRE_SIGN = \\\"DONTCARE\\\";\\n    parameter CH1_TX_PRE_SIGN = \\\"DONTCARE\\\";\\n    parameter CH0_RXTERM_CM = \\\"DONTCARE\\\";\\n    parameter CH1_RXTERM_CM = \\\"DONTCARE\\\";\\n    parameter CH0_RXIN_CM = \\\"DONTCARE\\\";\\n    parameter CH1_RXIN_CM = \\\"DONTCARE\\\";\\n    parameter CH0_LEQ_OFFSET_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_LEQ_OFFSET_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_LEQ_OFFSET_TRIM = \\\"DONTCARE\\\";\\n    parameter CH1_LEQ_OFFSET_TRIM = \\\"DONTCARE\\\";\\n    parameter D_TX_MAX_RATE = \\\"DONTCARE\\\";\\n    parameter CH0_CDR_MAX_RATE = \\\"DONTCARE\\\";\\n    parameter CH1_CDR_MAX_RATE = \\\"DONTCARE\\\";\\n    parameter CH0_TXAMPLITUDE = \\\"DONTCARE\\\";\\n    parameter CH1_TXAMPLITUDE = \\\"DONTCARE\\\";\\n    parameter CH0_TXDEPRE = \\\"DONTCARE\\\";\\n    parameter CH1_TXDEPRE = \\\"DONTCARE\\\";\\n    parameter CH0_TXDEPOST = \\\"DONTCARE\\\";\\n    parameter CH1_TXDEPOST = \\\"DONTCARE\\\";\\n    parameter CH0_PROTOCOL = \\\"DONTCARE\\\";\\n    parameter CH1_PROTOCOL = \\\"DONTCARE\\\";\\n    parameter D_ISETLOS = \\\"DONTCARE\\\";\\n    parameter D_SETIRPOLY_AUX = \\\"DONTCARE\\\";\\n    parameter D_SETICONST_AUX = \\\"DONTCARE\\\";\\n    parameter D_SETIRPOLY_CH = \\\"DONTCARE\\\";\\n    parameter D_SETICONST_CH = \\\"DONTCARE\\\";\\n    parameter D_REQ_ISET = \\\"DONTCARE\\\";\\n    parameter D_PD_ISET = \\\"DONTCARE\\\";\\n    parameter D_DCO_CALIB_TIME_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_DCOCTLGI = \\\"DONTCARE\\\";\\n    parameter CH1_DCOCTLGI = \\\"DONTCARE\\\";\\n    parameter CH0_DCOATDDLY = \\\"DONTCARE\\\";\\n    parameter CH1_DCOATDDLY = \\\"DONTCARE\\\";\\n    parameter CH0_DCOATDCFG = \\\"DONTCARE\\\";\\n    parameter CH1_DCOATDCFG = \\\"DONTCARE\\\";\\n    parameter CH0_DCOBYPSATD = \\\"DONTCARE\\\";\\n    parameter CH1_DCOBYPSATD = \\\"DONTCARE\\\";\\n    parameter CH0_DCOSCALEI = \\\"DONTCARE\\\";\\n    parameter CH1_DCOSCALEI = \\\"DONTCARE\\\";\\n    parameter CH0_DCOITUNE4LSB = \\\"DONTCARE\\\";\\n    parameter CH1_DCOITUNE4LSB = \\\"DONTCARE\\\";\\n    parameter CH0_DCOIOSTUNE = \\\"DONTCARE\\\";\\n    parameter CH1_DCOIOSTUNE = \\\"DONTCARE\\\";\\n    parameter CH0_DCODISBDAVOID = \\\"DONTCARE\\\";\\n    parameter CH1_DCODISBDAVOID = \\\"DONTCARE\\\";\\n    parameter CH0_DCOCALDIV = \\\"DONTCARE\\\";\\n    parameter CH1_DCOCALDIV = \\\"DONTCARE\\\";\\n    parameter CH0_DCONUOFLSB = \\\"DONTCARE\\\";\\n    parameter CH1_DCONUOFLSB = \\\"DONTCARE\\\";\\n    parameter CH0_DCOIUPDNX2 = \\\"DONTCARE\\\";\\n    parameter CH1_DCOIUPDNX2 = \\\"DONTCARE\\\";\\n    parameter CH0_DCOSTEP = \\\"DONTCARE\\\";\\n    parameter CH1_DCOSTEP = \\\"DONTCARE\\\";\\n    parameter CH0_DCOSTARTVAL = \\\"DONTCARE\\\";\\n    parameter CH1_DCOSTARTVAL = \\\"DONTCARE\\\";\\n    parameter CH0_DCOFLTDAC = \\\"DONTCARE\\\";\\n    parameter CH1_DCOFLTDAC = \\\"DONTCARE\\\";\\n    parameter CH0_DCOITUNE = \\\"DONTCARE\\\";\\n    parameter CH1_DCOITUNE = \\\"DONTCARE\\\";\\n    parameter CH0_DCOFTNRG = \\\"DONTCARE\\\";\\n    parameter CH1_DCOFTNRG = \\\"DONTCARE\\\";\\n    parameter CH0_CDR_CNT4SEL = \\\"DONTCARE\\\";\\n    parameter CH1_CDR_CNT4SEL = \\\"DONTCARE\\\";\\n    parameter CH0_CDR_CNT8SEL = \\\"DONTCARE\\\";\\n    parameter CH1_CDR_CNT8SEL = \\\"DONTCARE\\\";\\n    parameter CH0_BAND_THRESHOLD = \\\"DONTCARE\\\";\\n    parameter CH1_BAND_THRESHOLD = \\\"DONTCARE\\\";\\n    parameter CH0_AUTO_FACQ_EN = \\\"DONTCARE\\\";\\n    parameter CH1_AUTO_FACQ_EN = \\\"DONTCARE\\\";\\n    parameter CH0_AUTO_CALIB_EN = \\\"DONTCARE\\\";\\n    parameter CH1_AUTO_CALIB_EN = \\\"DONTCARE\\\";\\n    parameter CH0_CALIB_CK_MODE = \\\"DONTCARE\\\";\\n    parameter CH1_CALIB_CK_MODE = \\\"DONTCARE\\\";\\n    parameter CH0_REG_BAND_OFFSET = \\\"DONTCARE\\\";\\n    parameter CH1_REG_BAND_OFFSET = \\\"DONTCARE\\\";\\n    parameter CH0_REG_BAND_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_REG_BAND_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_REG_IDAC_SEL = \\\"DONTCARE\\\";\\n    parameter CH1_REG_IDAC_SEL = \\\"DONTCARE\\\";\\n    parameter CH0_REG_IDAC_EN = \\\"DONTCARE\\\";\\n    parameter CH1_REG_IDAC_EN = \\\"DONTCARE\\\";\\n    parameter D_TXPLL_PWDNB = \\\"DONTCARE\\\";\\n    parameter D_SETPLLRC = \\\"DONTCARE\\\";\\n    parameter D_REFCK_MODE = \\\"DONTCARE\\\";\\n    parameter D_TX_VCO_CK_DIV = \\\"DONTCARE\\\";\\n    parameter D_PLL_LOL_SET = \\\"DONTCARE\\\";\\n    parameter D_RG_EN = \\\"DONTCARE\\\";\\n    parameter D_RG_SET = \\\"DONTCARE\\\";\\n    parameter D_CMUSETISCL4VCO = \\\"DONTCARE\\\";\\n    parameter D_CMUSETI4VCO = \\\"DONTCARE\\\";\\n    parameter D_CMUSETINITVCT = \\\"DONTCARE\\\";\\n    parameter D_CMUSETZGM = \\\"DONTCARE\\\";\\n    parameter D_CMUSETP2AGM = \\\"DONTCARE\\\";\\n    parameter D_CMUSETP1GM = \\\"DONTCARE\\\";\\n    parameter D_CMUSETI4CPZ = \\\"DONTCARE\\\";\\n    parameter D_CMUSETI4CPP = \\\"DONTCARE\\\";\\n    parameter D_CMUSETICP4Z = \\\"DONTCARE\\\";\\n    parameter D_CMUSETICP4P = \\\"DONTCARE\\\";\\n    parameter D_CMUSETBIASI = \\\"DONTCARE\\\";\\n    (* iopad_external_pin *)\\n    (* iopad_external_pin *)\\n    input CH0_HDINP;\\n    (* iopad_external_pin *)\\n    input CH1_HDINP;\\n    (* iopad_external_pin *)\\n    input CH0_HDINN;\\n    (* iopad_external_pin *)\\n    input CH1_HDINN;\\n    input D_TXBIT_CLKP_FROM_ND;\\n    input D_TXBIT_CLKN_FROM_ND;\\n    input D_SYNC_ND;\\n    input D_TXPLL_LOL_FROM_ND;\\n    input CH0_RX_REFCLK;\\n    input CH1_RX_REFCLK;\\n    input CH0_FF_RXI_CLK;\\n    input CH1_FF_RXI_CLK;\\n    input CH0_FF_TXI_CLK;\\n    input CH1_FF_TXI_CLK;\\n    input CH0_FF_EBRD_CLK;\\n    input CH1_FF_EBRD_CLK;\\n    input CH0_FF_TX_D_0;\\n    input CH1_FF_TX_D_0;\\n    input CH0_FF_TX_D_1;\\n    input CH1_FF_TX_D_1;\\n    input CH0_FF_TX_D_2;\\n    input CH1_FF_TX_D_2;\\n    input CH0_FF_TX_D_3;\\n    input CH1_FF_TX_D_3;\\n    input CH0_FF_TX_D_4;\\n    input CH1_FF_TX_D_4;\\n    input CH0_FF_TX_D_5;\\n    input CH1_FF_TX_D_5;\\n    input CH0_FF_TX_D_6;\\n    input CH1_FF_TX_D_6;\\n    input CH0_FF_TX_D_7;\\n    input CH1_FF_TX_D_7;\\n    input CH0_FF_TX_D_8;\\n    input CH1_FF_TX_D_8;\\n    input CH0_FF_TX_D_9;\\n    input CH1_FF_TX_D_9;\\n    input CH0_FF_TX_D_10;\\n    input CH1_FF_TX_D_10;\\n    input CH0_FF_TX_D_11;\\n    input CH1_FF_TX_D_11;\\n    input CH0_FF_TX_D_12;\\n    input CH1_FF_TX_D_12;\\n    input CH0_FF_TX_D_13;\\n    input CH1_FF_TX_D_13;\\n    input CH0_FF_TX_D_14;\\n    input CH1_FF_TX_D_14;\\n    input CH0_FF_TX_D_15;\\n    input CH1_FF_TX_D_15;\\n    input CH0_FF_TX_D_16;\\n    input CH1_FF_TX_D_16;\\n    input CH0_FF_TX_D_17;\\n    input CH1_FF_TX_D_17;\\n    input CH0_FF_TX_D_18;\\n    input CH1_FF_TX_D_18;\\n    input CH0_FF_TX_D_19;\\n    input CH1_FF_TX_D_19;\\n    input CH0_FF_TX_D_20;\\n    input CH1_FF_TX_D_20;\\n    input CH0_FF_TX_D_21;\\n    input CH1_FF_TX_D_21;\\n    input CH0_FF_TX_D_22;\\n    input CH1_FF_TX_D_22;\\n    input CH0_FF_TX_D_23;\\n    input CH1_FF_TX_D_23;\\n    input CH0_FFC_EI_EN;\\n    input CH1_FFC_EI_EN;\\n    input CH0_FFC_PCIE_DET_EN;\\n    input CH1_FFC_PCIE_DET_EN;\\n    input CH0_FFC_PCIE_CT;\\n    input CH1_FFC_PCIE_CT;\\n    input CH0_FFC_SB_INV_RX;\\n    input CH1_FFC_SB_INV_RX;\\n    input CH0_FFC_ENABLE_CGALIGN;\\n    input CH1_FFC_ENABLE_CGALIGN;\\n    input CH0_FFC_SIGNAL_DETECT;\\n    input CH1_FFC_SIGNAL_DETECT;\\n    input CH0_FFC_FB_LOOPBACK;\\n    input CH1_FFC_FB_LOOPBACK;\\n    input CH0_FFC_SB_PFIFO_LP;\\n    input CH1_FFC_SB_PFIFO_LP;\\n    input CH0_FFC_PFIFO_CLR;\\n    input CH1_FFC_PFIFO_CLR;\\n    input CH0_FFC_RATE_MODE_RX;\\n    input CH1_FFC_RATE_MODE_RX;\\n    input CH0_FFC_RATE_MODE_TX;\\n    input CH1_FFC_RATE_MODE_TX;\\n    input CH0_FFC_DIV11_MODE_RX;\\n    input CH1_FFC_DIV11_MODE_RX;\\n    input CH0_FFC_RX_GEAR_MODE;\\n    input CH1_FFC_RX_GEAR_MODE;\\n    input CH0_FFC_TX_GEAR_MODE;\\n    input CH1_FFC_TX_GEAR_MODE;\\n    input CH0_FFC_DIV11_MODE_TX;\\n    input CH1_FFC_DIV11_MODE_TX;\\n    input CH0_FFC_LDR_CORE2TX_EN;\\n    input CH1_FFC_LDR_CORE2TX_EN;\\n    input CH0_FFC_LANE_TX_RST;\\n    input CH1_FFC_LANE_TX_RST;\\n    input CH0_FFC_LANE_RX_RST;\\n    input CH1_FFC_LANE_RX_RST;\\n    input CH0_FFC_RRST;\\n    input CH1_FFC_RRST;\\n    input CH0_FFC_TXPWDNB;\\n    input CH1_FFC_TXPWDNB;\\n    input CH0_FFC_RXPWDNB;\\n    input CH1_FFC_RXPWDNB;\\n    input CH0_LDR_CORE2TX;\\n    input CH1_LDR_CORE2TX;\\n    input D_SCIWDATA0;\\n    input D_SCIWDATA1;\\n    input D_SCIWDATA2;\\n    input D_SCIWDATA3;\\n    input D_SCIWDATA4;\\n    input D_SCIWDATA5;\\n    input D_SCIWDATA6;\\n    input D_SCIWDATA7;\\n    input D_SCIADDR0;\\n    input D_SCIADDR1;\\n    input D_SCIADDR2;\\n    input D_SCIADDR3;\\n    input D_SCIADDR4;\\n    input D_SCIADDR5;\\n    input D_SCIENAUX;\\n    input D_SCISELAUX;\\n    input CH0_SCIEN;\\n    input CH1_SCIEN;\\n    input CH0_SCISEL;\\n    input CH1_SCISEL;\\n    input D_SCIRD;\\n    input D_SCIWSTN;\\n    input D_CYAWSTN;\\n    input D_FFC_SYNC_TOGGLE;\\n    input D_FFC_DUAL_RST;\\n    input D_FFC_MACRO_RST;\\n    input D_FFC_MACROPDB;\\n    input D_FFC_TRST;\\n    input CH0_FFC_CDR_EN_BITSLIP;\\n    input CH1_FFC_CDR_EN_BITSLIP;\\n    input D_SCAN_ENABLE;\\n    input D_SCAN_IN_0;\\n    input D_SCAN_IN_1;\\n    input D_SCAN_IN_2;\\n    input D_SCAN_IN_3;\\n    input D_SCAN_IN_4;\\n    input D_SCAN_IN_5;\\n    input D_SCAN_IN_6;\\n    input D_SCAN_IN_7;\\n    input D_SCAN_MODE;\\n    input D_SCAN_RESET;\\n    input D_CIN0;\\n    input D_CIN1;\\n    input D_CIN2;\\n    input D_CIN3;\\n    input D_CIN4;\\n    input D_CIN5;\\n    input D_CIN6;\\n    input D_CIN7;\\n    input D_CIN8;\\n    input D_CIN9;\\n    input D_CIN10;\\n    input D_CIN11;\\n    output CH0_HDOUTP;\\n    output CH1_HDOUTP;\\n    output CH0_HDOUTN;\\n    output CH1_HDOUTN;\\n    output D_TXBIT_CLKP_TO_ND;\\n    output D_TXBIT_CLKN_TO_ND;\\n    output D_SYNC_PULSE2ND;\\n    output D_TXPLL_LOL_TO_ND;\\n    output CH0_FF_RX_F_CLK;\\n    output CH1_FF_RX_F_CLK;\\n    output CH0_FF_RX_H_CLK;\\n    output CH1_FF_RX_H_CLK;\\n    output CH0_FF_TX_F_CLK;\\n    output CH1_FF_TX_F_CLK;\\n    output CH0_FF_TX_H_CLK;\\n    output CH1_FF_TX_H_CLK;\\n    output CH0_FF_RX_PCLK;\\n    output CH1_FF_RX_PCLK;\\n    output CH0_FF_TX_PCLK;\\n    output CH1_FF_TX_PCLK;\\n    output CH0_FF_RX_D_0;\\n    output CH1_FF_RX_D_0;\\n    output CH0_FF_RX_D_1;\\n    output CH1_FF_RX_D_1;\\n    output CH0_FF_RX_D_2;\\n    output CH1_FF_RX_D_2;\\n    output CH0_FF_RX_D_3;\\n    output CH1_FF_RX_D_3;\\n    output CH0_FF_RX_D_4;\\n    output CH1_FF_RX_D_4;\\n    output CH0_FF_RX_D_5;\\n    output CH1_FF_RX_D_5;\\n    output CH0_FF_RX_D_6;\\n    output CH1_FF_RX_D_6;\\n    output CH0_FF_RX_D_7;\\n    output CH1_FF_RX_D_7;\\n    output CH0_FF_RX_D_8;\\n    output CH1_FF_RX_D_8;\\n    output CH0_FF_RX_D_9;\\n    output CH1_FF_RX_D_9;\\n    output CH0_FF_RX_D_10;\\n    output CH1_FF_RX_D_10;\\n    output CH0_FF_RX_D_11;\\n    output CH1_FF_RX_D_11;\\n    output CH0_FF_RX_D_12;\\n    output CH1_FF_RX_D_12;\\n    output CH0_FF_RX_D_13;\\n    output CH1_FF_RX_D_13;\\n    output CH0_FF_RX_D_14;\\n    output CH1_FF_RX_D_14;\\n    output CH0_FF_RX_D_15;\\n    output CH1_FF_RX_D_15;\\n    output CH0_FF_RX_D_16;\\n    output CH1_FF_RX_D_16;\\n    output CH0_FF_RX_D_17;\\n    output CH1_FF_RX_D_17;\\n    output CH0_FF_RX_D_18;\\n    output CH1_FF_RX_D_18;\\n    output CH0_FF_RX_D_19;\\n    output CH1_FF_RX_D_19;\\n    output CH0_FF_RX_D_20;\\n    output CH1_FF_RX_D_20;\\n    output CH0_FF_RX_D_21;\\n    output CH1_FF_RX_D_21;\\n    output CH0_FF_RX_D_22;\\n    output CH1_FF_RX_D_22;\\n    output CH0_FF_RX_D_23;\\n    output CH1_FF_RX_D_23;\\n    output CH0_FFS_PCIE_DONE;\\n    output CH1_FFS_PCIE_DONE;\\n    output CH0_FFS_PCIE_CON;\\n    output CH1_FFS_PCIE_CON;\\n    output CH0_FFS_RLOS;\\n    output CH1_FFS_RLOS;\\n    output CH0_FFS_LS_SYNC_STATUS;\\n    output CH1_FFS_LS_SYNC_STATUS;\\n    output CH0_FFS_CC_UNDERRUN;\\n    output CH1_FFS_CC_UNDERRUN;\\n    output CH0_FFS_CC_OVERRUN;\\n    output CH1_FFS_CC_OVERRUN;\\n    output CH0_FFS_RXFBFIFO_ERROR;\\n    output CH1_FFS_RXFBFIFO_ERROR;\\n    output CH0_FFS_TXFBFIFO_ERROR;\\n    output CH1_FFS_TXFBFIFO_ERROR;\\n    output CH0_FFS_RLOL;\\n    output CH1_FFS_RLOL;\\n    output CH0_FFS_SKP_ADDED;\\n    output CH1_FFS_SKP_ADDED;\\n    output CH0_FFS_SKP_DELETED;\\n    output CH1_FFS_SKP_DELETED;\\n    output CH0_LDR_RX2CORE;\\n    output CH1_LDR_RX2CORE;\\n    output D_SCIRDATA0;\\n    output D_SCIRDATA1;\\n    output D_SCIRDATA2;\\n    output D_SCIRDATA3;\\n    output D_SCIRDATA4;\\n    output D_SCIRDATA5;\\n    output D_SCIRDATA6;\\n    output D_SCIRDATA7;\\n    output D_SCIINT;\\n    output D_SCAN_OUT_0;\\n    output D_SCAN_OUT_1;\\n    output D_SCAN_OUT_2;\\n    output D_SCAN_OUT_3;\\n    output D_SCAN_OUT_4;\\n    output D_SCAN_OUT_5;\\n    output D_SCAN_OUT_6;\\n    output D_SCAN_OUT_7;\\n    output D_COUT0;\\n    output D_COUT1;\\n    output D_COUT2;\\n    output D_COUT3;\\n    output D_COUT4;\\n    output D_COUT5;\\n    output D_COUT6;\\n    output D_COUT7;\\n    output D_COUT8;\\n    output D_COUT9;\\n    output D_COUT10;\\n    output D_COUT11;\\n    output D_COUT12;\\n    output D_COUT13;\\n    output D_COUT14;\\n    output D_COUT15;\\n    output D_COUT16;\\n    output D_COUT17;\\n    output D_COUT18;\\n    output D_COUT19;\\n    input D_REFCLKI;\\n    output D_FFS_PLOL;\\nendmodule\\n\\n\",\n            \"cells_bb_xo2.v\": \"// Created by cells_xtra.py from Lattice models\\n\\n(* blackbox *) (* keep *)\\nmodule GSR (...);\\n    input GSR;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule SGSR (...);\\n    input GSR;\\n    input CLK;\\nendmodule\\n\\n(* blackbox *)\\nmodule DP8KC (...);\\n    parameter DATA_WIDTH_A = 9;\\n    parameter DATA_WIDTH_B = 9;\\n    parameter REGMODE_A = \\\"NOREG\\\";\\n    parameter REGMODE_B = \\\"NOREG\\\";\\n    parameter CSDECODE_A = \\\"0b000\\\";\\n    parameter CSDECODE_B = \\\"0b000\\\";\\n    parameter WRITEMODE_A = \\\"NORMAL\\\";\\n    parameter WRITEMODE_B = \\\"NORMAL\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    input DIA8;\\n    input DIA7;\\n    input DIA6;\\n    input DIA5;\\n    input DIA4;\\n    input DIA3;\\n    input DIA2;\\n    input DIA1;\\n    input DIA0;\\n    input ADA12;\\n    input ADA11;\\n    input ADA10;\\n    input ADA9;\\n    input ADA8;\\n    input ADA7;\\n    input ADA6;\\n    input ADA5;\\n    input ADA4;\\n    input ADA3;\\n    input ADA2;\\n    input ADA1;\\n    input ADA0;\\n    input CEA;\\n    input OCEA;\\n    input CLKA;\\n    input WEA;\\n    input CSA2;\\n    input CSA1;\\n    input CSA0;\\n    input RSTA;\\n    input DIB8;\\n    input DIB7;\\n    input DIB6;\\n    input DIB5;\\n    input DIB4;\\n    input DIB3;\\n    input DIB2;\\n    input DIB1;\\n    input DIB0;\\n    input ADB12;\\n    input ADB11;\\n    input ADB10;\\n    input ADB9;\\n    input ADB8;\\n    input ADB7;\\n    input ADB6;\\n    input ADB5;\\n    input ADB4;\\n    input ADB3;\\n    input ADB2;\\n    input ADB1;\\n    input ADB0;\\n    input CEB;\\n    input OCEB;\\n    input CLKB;\\n    input WEB;\\n    input CSB2;\\n    input CSB1;\\n    input CSB0;\\n    input RSTB;\\n    output DOA8;\\n    output DOA7;\\n    output DOA6;\\n    output DOA5;\\n    output DOA4;\\n    output DOA3;\\n    output DOA2;\\n    output DOA1;\\n    output DOA0;\\n    output DOB8;\\n    output DOB7;\\n    output DOB6;\\n    output DOB5;\\n    output DOB4;\\n    output DOB3;\\n    output DOB2;\\n    output DOB1;\\n    output DOB0;\\nendmodule\\n\\n(* blackbox *)\\nmodule PDPW8KC (...);\\n    parameter DATA_WIDTH_W = 18;\\n    parameter DATA_WIDTH_R = 9;\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter CSDECODE_W = \\\"0b000\\\";\\n    parameter CSDECODE_R = \\\"0b000\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    input DI17;\\n    input DI16;\\n    input DI15;\\n    input DI14;\\n    input DI13;\\n    input DI12;\\n    input DI11;\\n    input DI10;\\n    input DI9;\\n    input DI8;\\n    input DI7;\\n    input DI6;\\n    input DI5;\\n    input DI4;\\n    input DI3;\\n    input DI2;\\n    input DI1;\\n    input DI0;\\n    input ADW8;\\n    input ADW7;\\n    input ADW6;\\n    input ADW5;\\n    input ADW4;\\n    input ADW3;\\n    input ADW2;\\n    input ADW1;\\n    input ADW0;\\n    input BE1;\\n    input BE0;\\n    input CEW;\\n    input CLKW;\\n    input CSW2;\\n    input CSW1;\\n    input CSW0;\\n    input ADR12;\\n    input ADR11;\\n    input ADR10;\\n    input ADR9;\\n    input ADR8;\\n    input ADR7;\\n    input ADR6;\\n    input ADR5;\\n    input ADR4;\\n    input ADR3;\\n    input ADR2;\\n    input ADR1;\\n    input ADR0;\\n    input CER;\\n    input OCER;\\n    input CLKR;\\n    input CSR2;\\n    input CSR1;\\n    input CSR0;\\n    input RST;\\n    output DO17;\\n    output DO16;\\n    output DO15;\\n    output DO14;\\n    output DO13;\\n    output DO12;\\n    output DO11;\\n    output DO10;\\n    output DO9;\\n    output DO8;\\n    output DO7;\\n    output DO6;\\n    output DO5;\\n    output DO4;\\n    output DO3;\\n    output DO2;\\n    output DO1;\\n    output DO0;\\nendmodule\\n\\n(* blackbox *)\\nmodule SP8KC (...);\\n    parameter DATA_WIDTH = 9;\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter CSDECODE = \\\"0b000\\\";\\n    parameter WRITEMODE = \\\"NORMAL\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    input DI8;\\n    input DI7;\\n    input DI6;\\n    input DI5;\\n    input DI4;\\n    input DI3;\\n    input DI2;\\n    input DI1;\\n    input DI0;\\n    input AD12;\\n    input AD11;\\n    input AD10;\\n    input AD9;\\n    input AD8;\\n    input AD7;\\n    input AD6;\\n    input AD5;\\n    input AD4;\\n    input AD3;\\n    input AD2;\\n    input AD1;\\n    input AD0;\\n    input CE;\\n    input OCE;\\n    input CLK;\\n    input WE;\\n    input CS2;\\n    input CS1;\\n    input CS0;\\n    input RST;\\n    output DO8;\\n    output DO7;\\n    output DO6;\\n    output DO5;\\n    output DO4;\\n    output DO3;\\n    output DO2;\\n    output DO1;\\n    output DO0;\\nendmodule\\n\\n(* blackbox *)\\nmodule FIFO8KB (...);\\n    parameter DATA_WIDTH_W = 18;\\n    parameter DATA_WIDTH_R = 18;\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter RESETMODE = \\\"ASYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter CSDECODE_W = \\\"0b00\\\";\\n    parameter CSDECODE_R = \\\"0b00\\\";\\n    parameter AEPOINTER = \\\"0b00000000000000\\\";\\n    parameter AEPOINTER1 = \\\"0b00000000000000\\\";\\n    parameter AFPOINTER = \\\"0b00000000000000\\\";\\n    parameter AFPOINTER1 = \\\"0b00000000000000\\\";\\n    parameter FULLPOINTER = \\\"0b00000000000000\\\";\\n    parameter FULLPOINTER1 = \\\"0b00000000000000\\\";\\n    parameter GSR = \\\"DISABLED\\\";\\n    input DI0;\\n    input DI1;\\n    input DI2;\\n    input DI3;\\n    input DI4;\\n    input DI5;\\n    input DI6;\\n    input DI7;\\n    input DI8;\\n    input DI9;\\n    input DI10;\\n    input DI11;\\n    input DI12;\\n    input DI13;\\n    input DI14;\\n    input DI15;\\n    input DI16;\\n    input DI17;\\n    input CSW0;\\n    input CSW1;\\n    input CSR0;\\n    input CSR1;\\n    input WE;\\n    input RE;\\n    input ORE;\\n    input CLKW;\\n    input CLKR;\\n    input RST;\\n    input RPRST;\\n    input FULLI;\\n    input EMPTYI;\\n    output DO0;\\n    output DO1;\\n    output DO2;\\n    output DO3;\\n    output DO4;\\n    output DO5;\\n    output DO6;\\n    output DO7;\\n    output DO8;\\n    output DO9;\\n    output DO10;\\n    output DO11;\\n    output DO12;\\n    output DO13;\\n    output DO14;\\n    output DO15;\\n    output DO16;\\n    output DO17;\\n    output EF;\\n    output AEF;\\n    output AFF;\\n    output FF;\\nendmodule\\n\\n(* blackbox *)\\nmodule CLKDIVC (...);\\n    parameter GSR = \\\"DISABLED\\\";\\n    parameter DIV = \\\"2.0\\\";\\n    input RST;\\n    input CLKI;\\n    input ALIGNWD;\\n    output CDIV1;\\n    output CDIVX;\\nendmodule\\n\\n(* blackbox *)\\nmodule DCMA (...);\\n    input CLK0;\\n    input CLK1;\\n    input SEL;\\n    output DCMOUT;\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKSYNCA (...);\\n    input ECLKI;\\n    input STOP;\\n    output ECLKO;\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKBRIDGECS (...);\\n    input CLK0;\\n    input CLK1;\\n    input SEL;\\n    output ECSOUT;\\nendmodule\\n\\n(* blackbox *)\\nmodule DCCA (...);\\n    input CLKI;\\n    input CE;\\n    output CLKO;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule START (...);\\n    input STARTCLK;\\nendmodule\\n\\n(* blackbox *)\\nmodule EHXPLLJ (...);\\n    parameter CLKI_DIV = 1;\\n    parameter CLKFB_DIV = 1;\\n    parameter CLKOP_DIV = 8;\\n    parameter CLKOS_DIV = 8;\\n    parameter CLKOS2_DIV = 8;\\n    parameter CLKOS3_DIV = 8;\\n    parameter CLKOP_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS2_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS3_ENABLE = \\\"ENABLED\\\";\\n    parameter VCO_BYPASS_A0 = \\\"DISABLED\\\";\\n    parameter VCO_BYPASS_B0 = \\\"DISABLED\\\";\\n    parameter VCO_BYPASS_C0 = \\\"DISABLED\\\";\\n    parameter VCO_BYPASS_D0 = \\\"DISABLED\\\";\\n    parameter CLKOP_CPHASE = 0;\\n    parameter CLKOS_CPHASE = 0;\\n    parameter CLKOS2_CPHASE = 0;\\n    parameter CLKOS3_CPHASE = 0;\\n    parameter CLKOP_FPHASE = 0;\\n    parameter CLKOS_FPHASE = 0;\\n    parameter CLKOS2_FPHASE = 0;\\n    parameter CLKOS3_FPHASE = 0;\\n    parameter FEEDBK_PATH = \\\"CLKOP\\\";\\n    parameter FRACN_ENABLE = \\\"DISABLED\\\";\\n    parameter FRACN_DIV = 0;\\n    parameter CLKOP_TRIM_POL = \\\"RISING\\\";\\n    parameter CLKOP_TRIM_DELAY = 0;\\n    parameter CLKOS_TRIM_POL = \\\"RISING\\\";\\n    parameter CLKOS_TRIM_DELAY = 0;\\n    parameter PLL_USE_WB = \\\"DISABLED\\\";\\n    parameter PREDIVIDER_MUXA1 = 0;\\n    parameter PREDIVIDER_MUXB1 = 0;\\n    parameter PREDIVIDER_MUXC1 = 0;\\n    parameter PREDIVIDER_MUXD1 = 0;\\n    parameter OUTDIVIDER_MUXA2 = \\\"DIVA\\\";\\n    parameter OUTDIVIDER_MUXB2 = \\\"DIVB\\\";\\n    parameter OUTDIVIDER_MUXC2 = \\\"DIVC\\\";\\n    parameter OUTDIVIDER_MUXD2 = \\\"DIVD\\\";\\n    parameter PLL_LOCK_MODE = 0;\\n    parameter STDBY_ENABLE = \\\"DISABLED\\\";\\n    parameter DPHASE_SOURCE = \\\"DISABLED\\\";\\n    parameter PLLRST_ENA = \\\"DISABLED\\\";\\n    parameter MRST_ENA = \\\"DISABLED\\\";\\n    parameter DCRST_ENA = \\\"DISABLED\\\";\\n    parameter DDRST_ENA = \\\"DISABLED\\\";\\n    parameter INTFB_WAKE = \\\"DISABLED\\\";\\n    input CLKI;\\n    input CLKFB;\\n    input PHASESEL1;\\n    input PHASESEL0;\\n    input PHASEDIR;\\n    input PHASESTEP;\\n    input LOADREG;\\n    input STDBY;\\n    input PLLWAKESYNC;\\n    input RST;\\n    input RESETM;\\n    input RESETC;\\n    input RESETD;\\n    input ENCLKOP;\\n    input ENCLKOS;\\n    input ENCLKOS2;\\n    input ENCLKOS3;\\n    input PLLCLK;\\n    input PLLRST;\\n    input PLLSTB;\\n    input PLLWE;\\n    input PLLDATI7;\\n    input PLLDATI6;\\n    input PLLDATI5;\\n    input PLLDATI4;\\n    input PLLDATI3;\\n    input PLLDATI2;\\n    input PLLDATI1;\\n    input PLLDATI0;\\n    input PLLADDR4;\\n    input PLLADDR3;\\n    input PLLADDR2;\\n    input PLLADDR1;\\n    input PLLADDR0;\\n    output CLKOP;\\n    output CLKOS;\\n    output CLKOS2;\\n    output CLKOS3;\\n    output LOCK;\\n    output INTLOCK;\\n    output REFCLK;\\n    output PLLDATO7;\\n    output PLLDATO6;\\n    output PLLDATO5;\\n    output PLLDATO4;\\n    output PLLDATO3;\\n    output PLLDATO2;\\n    output PLLDATO1;\\n    output PLLDATO0;\\n    output PLLACK;\\n    output DPHSRC;\\n    output CLKINTFB;\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCH (...);\\n    parameter NOM_FREQ = \\\"2.08\\\";\\n    input STDBY;\\n    output OSC;\\n    output SEDSTDBY;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule TSALL (...);\\n    input TSALL;\\nendmodule\\n\\n\",\n            \"cells_bb_xo3.v\": \"// Created by cells_xtra.py from Lattice models\\n\\n(* blackbox *) (* keep *)\\nmodule GSR (...);\\n    input GSR;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule SGSR (...);\\n    input GSR;\\n    input CLK;\\nendmodule\\n\\n(* blackbox *)\\nmodule DP8KC (...);\\n    parameter DATA_WIDTH_A = 9;\\n    parameter DATA_WIDTH_B = 9;\\n    parameter REGMODE_A = \\\"NOREG\\\";\\n    parameter REGMODE_B = \\\"NOREG\\\";\\n    parameter CSDECODE_A = \\\"0b000\\\";\\n    parameter CSDECODE_B = \\\"0b000\\\";\\n    parameter WRITEMODE_A = \\\"NORMAL\\\";\\n    parameter WRITEMODE_B = \\\"NORMAL\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    input DIA8;\\n    input DIA7;\\n    input DIA6;\\n    input DIA5;\\n    input DIA4;\\n    input DIA3;\\n    input DIA2;\\n    input DIA1;\\n    input DIA0;\\n    input ADA12;\\n    input ADA11;\\n    input ADA10;\\n    input ADA9;\\n    input ADA8;\\n    input ADA7;\\n    input ADA6;\\n    input ADA5;\\n    input ADA4;\\n    input ADA3;\\n    input ADA2;\\n    input ADA1;\\n    input ADA0;\\n    input CEA;\\n    input OCEA;\\n    input CLKA;\\n    input WEA;\\n    input CSA2;\\n    input CSA1;\\n    input CSA0;\\n    input RSTA;\\n    input DIB8;\\n    input DIB7;\\n    input DIB6;\\n    input DIB5;\\n    input DIB4;\\n    input DIB3;\\n    input DIB2;\\n    input DIB1;\\n    input DIB0;\\n    input ADB12;\\n    input ADB11;\\n    input ADB10;\\n    input ADB9;\\n    input ADB8;\\n    input ADB7;\\n    input ADB6;\\n    input ADB5;\\n    input ADB4;\\n    input ADB3;\\n    input ADB2;\\n    input ADB1;\\n    input ADB0;\\n    input CEB;\\n    input OCEB;\\n    input CLKB;\\n    input WEB;\\n    input CSB2;\\n    input CSB1;\\n    input CSB0;\\n    input RSTB;\\n    output DOA8;\\n    output DOA7;\\n    output DOA6;\\n    output DOA5;\\n    output DOA4;\\n    output DOA3;\\n    output DOA2;\\n    output DOA1;\\n    output DOA0;\\n    output DOB8;\\n    output DOB7;\\n    output DOB6;\\n    output DOB5;\\n    output DOB4;\\n    output DOB3;\\n    output DOB2;\\n    output DOB1;\\n    output DOB0;\\nendmodule\\n\\n(* blackbox *)\\nmodule PDPW8KC (...);\\n    parameter DATA_WIDTH_W = 18;\\n    parameter DATA_WIDTH_R = 9;\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter CSDECODE_W = \\\"0b000\\\";\\n    parameter CSDECODE_R = \\\"0b000\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    input DI17;\\n    input DI16;\\n    input DI15;\\n    input DI14;\\n    input DI13;\\n    input DI12;\\n    input DI11;\\n    input DI10;\\n    input DI9;\\n    input DI8;\\n    input DI7;\\n    input DI6;\\n    input DI5;\\n    input DI4;\\n    input DI3;\\n    input DI2;\\n    input DI1;\\n    input DI0;\\n    input ADW8;\\n    input ADW7;\\n    input ADW6;\\n    input ADW5;\\n    input ADW4;\\n    input ADW3;\\n    input ADW2;\\n    input ADW1;\\n    input ADW0;\\n    input BE1;\\n    input BE0;\\n    input CEW;\\n    input CLKW;\\n    input CSW2;\\n    input CSW1;\\n    input CSW0;\\n    input ADR12;\\n    input ADR11;\\n    input ADR10;\\n    input ADR9;\\n    input ADR8;\\n    input ADR7;\\n    input ADR6;\\n    input ADR5;\\n    input ADR4;\\n    input ADR3;\\n    input ADR2;\\n    input ADR1;\\n    input ADR0;\\n    input CER;\\n    input OCER;\\n    input CLKR;\\n    input CSR2;\\n    input CSR1;\\n    input CSR0;\\n    input RST;\\n    output DO17;\\n    output DO16;\\n    output DO15;\\n    output DO14;\\n    output DO13;\\n    output DO12;\\n    output DO11;\\n    output DO10;\\n    output DO9;\\n    output DO8;\\n    output DO7;\\n    output DO6;\\n    output DO5;\\n    output DO4;\\n    output DO3;\\n    output DO2;\\n    output DO1;\\n    output DO0;\\nendmodule\\n\\n(* blackbox *)\\nmodule SP8KC (...);\\n    parameter DATA_WIDTH = 9;\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter CSDECODE = \\\"0b000\\\";\\n    parameter WRITEMODE = \\\"NORMAL\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    input DI8;\\n    input DI7;\\n    input DI6;\\n    input DI5;\\n    input DI4;\\n    input DI3;\\n    input DI2;\\n    input DI1;\\n    input DI0;\\n    input AD12;\\n    input AD11;\\n    input AD10;\\n    input AD9;\\n    input AD8;\\n    input AD7;\\n    input AD6;\\n    input AD5;\\n    input AD4;\\n    input AD3;\\n    input AD2;\\n    input AD1;\\n    input AD0;\\n    input CE;\\n    input OCE;\\n    input CLK;\\n    input WE;\\n    input CS2;\\n    input CS1;\\n    input CS0;\\n    input RST;\\n    output DO8;\\n    output DO7;\\n    output DO6;\\n    output DO5;\\n    output DO4;\\n    output DO3;\\n    output DO2;\\n    output DO1;\\n    output DO0;\\nendmodule\\n\\n(* blackbox *)\\nmodule FIFO8KB (...);\\n    parameter DATA_WIDTH_W = 18;\\n    parameter DATA_WIDTH_R = 18;\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter RESETMODE = \\\"ASYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter CSDECODE_W = \\\"0b00\\\";\\n    parameter CSDECODE_R = \\\"0b00\\\";\\n    parameter AEPOINTER = \\\"0b00000000000000\\\";\\n    parameter AEPOINTER1 = \\\"0b00000000000000\\\";\\n    parameter AFPOINTER = \\\"0b00000000000000\\\";\\n    parameter AFPOINTER1 = \\\"0b00000000000000\\\";\\n    parameter FULLPOINTER = \\\"0b00000000000000\\\";\\n    parameter FULLPOINTER1 = \\\"0b00000000000000\\\";\\n    parameter GSR = \\\"DISABLED\\\";\\n    input DI0;\\n    input DI1;\\n    input DI2;\\n    input DI3;\\n    input DI4;\\n    input DI5;\\n    input DI6;\\n    input DI7;\\n    input DI8;\\n    input DI9;\\n    input DI10;\\n    input DI11;\\n    input DI12;\\n    input DI13;\\n    input DI14;\\n    input DI15;\\n    input DI16;\\n    input DI17;\\n    input CSW0;\\n    input CSW1;\\n    input CSR0;\\n    input CSR1;\\n    input WE;\\n    input RE;\\n    input ORE;\\n    input CLKW;\\n    input CLKR;\\n    input RST;\\n    input RPRST;\\n    input FULLI;\\n    input EMPTYI;\\n    output DO0;\\n    output DO1;\\n    output DO2;\\n    output DO3;\\n    output DO4;\\n    output DO5;\\n    output DO6;\\n    output DO7;\\n    output DO8;\\n    output DO9;\\n    output DO10;\\n    output DO11;\\n    output DO12;\\n    output DO13;\\n    output DO14;\\n    output DO15;\\n    output DO16;\\n    output DO17;\\n    output EF;\\n    output AEF;\\n    output AFF;\\n    output FF;\\nendmodule\\n\\n(* blackbox *)\\nmodule CLKDIVC (...);\\n    parameter GSR = \\\"DISABLED\\\";\\n    parameter DIV = \\\"2.0\\\";\\n    input RST;\\n    input CLKI;\\n    input ALIGNWD;\\n    output CDIV1;\\n    output CDIVX;\\nendmodule\\n\\n(* blackbox *)\\nmodule DCMA (...);\\n    input CLK0;\\n    input CLK1;\\n    input SEL;\\n    output DCMOUT;\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKSYNCA (...);\\n    input ECLKI;\\n    input STOP;\\n    output ECLKO;\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKBRIDGECS (...);\\n    input CLK0;\\n    input CLK1;\\n    input SEL;\\n    output ECSOUT;\\nendmodule\\n\\n(* blackbox *)\\nmodule DCCA (...);\\n    input CLKI;\\n    input CE;\\n    output CLKO;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule START (...);\\n    input STARTCLK;\\nendmodule\\n\\n(* blackbox *)\\nmodule EHXPLLJ (...);\\n    parameter CLKI_DIV = 1;\\n    parameter CLKFB_DIV = 1;\\n    parameter CLKOP_DIV = 8;\\n    parameter CLKOS_DIV = 8;\\n    parameter CLKOS2_DIV = 8;\\n    parameter CLKOS3_DIV = 8;\\n    parameter CLKOP_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS2_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS3_ENABLE = \\\"ENABLED\\\";\\n    parameter VCO_BYPASS_A0 = \\\"DISABLED\\\";\\n    parameter VCO_BYPASS_B0 = \\\"DISABLED\\\";\\n    parameter VCO_BYPASS_C0 = \\\"DISABLED\\\";\\n    parameter VCO_BYPASS_D0 = \\\"DISABLED\\\";\\n    parameter CLKOP_CPHASE = 0;\\n    parameter CLKOS_CPHASE = 0;\\n    parameter CLKOS2_CPHASE = 0;\\n    parameter CLKOS3_CPHASE = 0;\\n    parameter CLKOP_FPHASE = 0;\\n    parameter CLKOS_FPHASE = 0;\\n    parameter CLKOS2_FPHASE = 0;\\n    parameter CLKOS3_FPHASE = 0;\\n    parameter FEEDBK_PATH = \\\"CLKOP\\\";\\n    parameter FRACN_ENABLE = \\\"DISABLED\\\";\\n    parameter FRACN_DIV = 0;\\n    parameter CLKOP_TRIM_POL = \\\"RISING\\\";\\n    parameter CLKOP_TRIM_DELAY = 0;\\n    parameter CLKOS_TRIM_POL = \\\"RISING\\\";\\n    parameter CLKOS_TRIM_DELAY = 0;\\n    parameter PLL_USE_WB = \\\"DISABLED\\\";\\n    parameter PREDIVIDER_MUXA1 = 0;\\n    parameter PREDIVIDER_MUXB1 = 0;\\n    parameter PREDIVIDER_MUXC1 = 0;\\n    parameter PREDIVIDER_MUXD1 = 0;\\n    parameter OUTDIVIDER_MUXA2 = \\\"DIVA\\\";\\n    parameter OUTDIVIDER_MUXB2 = \\\"DIVB\\\";\\n    parameter OUTDIVIDER_MUXC2 = \\\"DIVC\\\";\\n    parameter OUTDIVIDER_MUXD2 = \\\"DIVD\\\";\\n    parameter PLL_LOCK_MODE = 0;\\n    parameter STDBY_ENABLE = \\\"DISABLED\\\";\\n    parameter DPHASE_SOURCE = \\\"DISABLED\\\";\\n    parameter PLLRST_ENA = \\\"DISABLED\\\";\\n    parameter MRST_ENA = \\\"DISABLED\\\";\\n    parameter DCRST_ENA = \\\"DISABLED\\\";\\n    parameter DDRST_ENA = \\\"DISABLED\\\";\\n    parameter INTFB_WAKE = \\\"DISABLED\\\";\\n    input CLKI;\\n    input CLKFB;\\n    input PHASESEL1;\\n    input PHASESEL0;\\n    input PHASEDIR;\\n    input PHASESTEP;\\n    input LOADREG;\\n    input STDBY;\\n    input PLLWAKESYNC;\\n    input RST;\\n    input RESETM;\\n    input RESETC;\\n    input RESETD;\\n    input ENCLKOP;\\n    input ENCLKOS;\\n    input ENCLKOS2;\\n    input ENCLKOS3;\\n    input PLLCLK;\\n    input PLLRST;\\n    input PLLSTB;\\n    input PLLWE;\\n    input PLLDATI7;\\n    input PLLDATI6;\\n    input PLLDATI5;\\n    input PLLDATI4;\\n    input PLLDATI3;\\n    input PLLDATI2;\\n    input PLLDATI1;\\n    input PLLDATI0;\\n    input PLLADDR4;\\n    input PLLADDR3;\\n    input PLLADDR2;\\n    input PLLADDR1;\\n    input PLLADDR0;\\n    output CLKOP;\\n    output CLKOS;\\n    output CLKOS2;\\n    output CLKOS3;\\n    output LOCK;\\n    output INTLOCK;\\n    output REFCLK;\\n    output PLLDATO7;\\n    output PLLDATO6;\\n    output PLLDATO5;\\n    output PLLDATO4;\\n    output PLLDATO3;\\n    output PLLDATO2;\\n    output PLLDATO1;\\n    output PLLDATO0;\\n    output PLLACK;\\n    output DPHSRC;\\n    output CLKINTFB;\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCH (...);\\n    parameter NOM_FREQ = \\\"2.08\\\";\\n    input STDBY;\\n    output OSC;\\n    output SEDSTDBY;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule TSALL (...);\\n    input TSALL;\\nendmodule\\n\\n\",\n            \"cells_bb_xo3d.v\": \"// Created by cells_xtra.py from Lattice models\\n\\n(* blackbox *) (* keep *)\\nmodule GSR (...);\\n    input GSR;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule SGSR (...);\\n    input GSR;\\n    input CLK;\\nendmodule\\n\\n(* blackbox *)\\nmodule DP8KC (...);\\n    parameter DATA_WIDTH_A = 9;\\n    parameter DATA_WIDTH_B = 9;\\n    parameter REGMODE_A = \\\"NOREG\\\";\\n    parameter REGMODE_B = \\\"NOREG\\\";\\n    parameter CSDECODE_A = \\\"0b000\\\";\\n    parameter CSDECODE_B = \\\"0b000\\\";\\n    parameter WRITEMODE_A = \\\"NORMAL\\\";\\n    parameter WRITEMODE_B = \\\"NORMAL\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    input DIA8;\\n    input DIA7;\\n    input DIA6;\\n    input DIA5;\\n    input DIA4;\\n    input DIA3;\\n    input DIA2;\\n    input DIA1;\\n    input DIA0;\\n    input ADA12;\\n    input ADA11;\\n    input ADA10;\\n    input ADA9;\\n    input ADA8;\\n    input ADA7;\\n    input ADA6;\\n    input ADA5;\\n    input ADA4;\\n    input ADA3;\\n    input ADA2;\\n    input ADA1;\\n    input ADA0;\\n    input CEA;\\n    input OCEA;\\n    input CLKA;\\n    input WEA;\\n    input CSA2;\\n    input CSA1;\\n    input CSA0;\\n    input RSTA;\\n    input DIB8;\\n    input DIB7;\\n    input DIB6;\\n    input DIB5;\\n    input DIB4;\\n    input DIB3;\\n    input DIB2;\\n    input DIB1;\\n    input DIB0;\\n    input ADB12;\\n    input ADB11;\\n    input ADB10;\\n    input ADB9;\\n    input ADB8;\\n    input ADB7;\\n    input ADB6;\\n    input ADB5;\\n    input ADB4;\\n    input ADB3;\\n    input ADB2;\\n    input ADB1;\\n    input ADB0;\\n    input CEB;\\n    input OCEB;\\n    input CLKB;\\n    input WEB;\\n    input CSB2;\\n    input CSB1;\\n    input CSB0;\\n    input RSTB;\\n    output DOA8;\\n    output DOA7;\\n    output DOA6;\\n    output DOA5;\\n    output DOA4;\\n    output DOA3;\\n    output DOA2;\\n    output DOA1;\\n    output DOA0;\\n    output DOB8;\\n    output DOB7;\\n    output DOB6;\\n    output DOB5;\\n    output DOB4;\\n    output DOB3;\\n    output DOB2;\\n    output DOB1;\\n    output DOB0;\\nendmodule\\n\\n(* blackbox *)\\nmodule PDPW8KC (...);\\n    parameter DATA_WIDTH_W = 18;\\n    parameter DATA_WIDTH_R = 9;\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter CSDECODE_W = \\\"0b000\\\";\\n    parameter CSDECODE_R = \\\"0b000\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    input DI17;\\n    input DI16;\\n    input DI15;\\n    input DI14;\\n    input DI13;\\n    input DI12;\\n    input DI11;\\n    input DI10;\\n    input DI9;\\n    input DI8;\\n    input DI7;\\n    input DI6;\\n    input DI5;\\n    input DI4;\\n    input DI3;\\n    input DI2;\\n    input DI1;\\n    input DI0;\\n    input ADW8;\\n    input ADW7;\\n    input ADW6;\\n    input ADW5;\\n    input ADW4;\\n    input ADW3;\\n    input ADW2;\\n    input ADW1;\\n    input ADW0;\\n    input BE1;\\n    input BE0;\\n    input CEW;\\n    input CLKW;\\n    input CSW2;\\n    input CSW1;\\n    input CSW0;\\n    input ADR12;\\n    input ADR11;\\n    input ADR10;\\n    input ADR9;\\n    input ADR8;\\n    input ADR7;\\n    input ADR6;\\n    input ADR5;\\n    input ADR4;\\n    input ADR3;\\n    input ADR2;\\n    input ADR1;\\n    input ADR0;\\n    input CER;\\n    input OCER;\\n    input CLKR;\\n    input CSR2;\\n    input CSR1;\\n    input CSR0;\\n    input RST;\\n    output DO17;\\n    output DO16;\\n    output DO15;\\n    output DO14;\\n    output DO13;\\n    output DO12;\\n    output DO11;\\n    output DO10;\\n    output DO9;\\n    output DO8;\\n    output DO7;\\n    output DO6;\\n    output DO5;\\n    output DO4;\\n    output DO3;\\n    output DO2;\\n    output DO1;\\n    output DO0;\\nendmodule\\n\\n(* blackbox *)\\nmodule SP8KC (...);\\n    parameter DATA_WIDTH = 9;\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter CSDECODE = \\\"0b000\\\";\\n    parameter WRITEMODE = \\\"NORMAL\\\";\\n    parameter GSR = \\\"ENABLED\\\";\\n    parameter RESETMODE = \\\"SYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter INIT_DATA = \\\"STATIC\\\";\\n    parameter INITVAL_00 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_01 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_02 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_03 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_04 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_05 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_06 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_07 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_08 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_09 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_0F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_10 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_11 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_12 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_13 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_14 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_15 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_16 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_17 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_18 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_19 = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1A = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1B = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1C = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1D = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1E = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    parameter INITVAL_1F = 320'h00000000000000000000000000000000000000000000000000000000000000000000000000000000;\\n    input DI8;\\n    input DI7;\\n    input DI6;\\n    input DI5;\\n    input DI4;\\n    input DI3;\\n    input DI2;\\n    input DI1;\\n    input DI0;\\n    input AD12;\\n    input AD11;\\n    input AD10;\\n    input AD9;\\n    input AD8;\\n    input AD7;\\n    input AD6;\\n    input AD5;\\n    input AD4;\\n    input AD3;\\n    input AD2;\\n    input AD1;\\n    input AD0;\\n    input CE;\\n    input OCE;\\n    input CLK;\\n    input WE;\\n    input CS2;\\n    input CS1;\\n    input CS0;\\n    input RST;\\n    output DO8;\\n    output DO7;\\n    output DO6;\\n    output DO5;\\n    output DO4;\\n    output DO3;\\n    output DO2;\\n    output DO1;\\n    output DO0;\\nendmodule\\n\\n(* blackbox *)\\nmodule FIFO8KB (...);\\n    parameter DATA_WIDTH_W = 18;\\n    parameter DATA_WIDTH_R = 18;\\n    parameter REGMODE = \\\"NOREG\\\";\\n    parameter RESETMODE = \\\"ASYNC\\\";\\n    parameter ASYNC_RESET_RELEASE = \\\"SYNC\\\";\\n    parameter CSDECODE_W = \\\"0b00\\\";\\n    parameter CSDECODE_R = \\\"0b00\\\";\\n    parameter AEPOINTER = \\\"0b00000000000000\\\";\\n    parameter AEPOINTER1 = \\\"0b00000000000000\\\";\\n    parameter AFPOINTER = \\\"0b00000000000000\\\";\\n    parameter AFPOINTER1 = \\\"0b00000000000000\\\";\\n    parameter FULLPOINTER = \\\"0b00000000000000\\\";\\n    parameter FULLPOINTER1 = \\\"0b00000000000000\\\";\\n    parameter GSR = \\\"DISABLED\\\";\\n    input DI0;\\n    input DI1;\\n    input DI2;\\n    input DI3;\\n    input DI4;\\n    input DI5;\\n    input DI6;\\n    input DI7;\\n    input DI8;\\n    input DI9;\\n    input DI10;\\n    input DI11;\\n    input DI12;\\n    input DI13;\\n    input DI14;\\n    input DI15;\\n    input DI16;\\n    input DI17;\\n    input CSW0;\\n    input CSW1;\\n    input CSR0;\\n    input CSR1;\\n    input WE;\\n    input RE;\\n    input ORE;\\n    input CLKW;\\n    input CLKR;\\n    input RST;\\n    input RPRST;\\n    input FULLI;\\n    input EMPTYI;\\n    output DO0;\\n    output DO1;\\n    output DO2;\\n    output DO3;\\n    output DO4;\\n    output DO5;\\n    output DO6;\\n    output DO7;\\n    output DO8;\\n    output DO9;\\n    output DO10;\\n    output DO11;\\n    output DO12;\\n    output DO13;\\n    output DO14;\\n    output DO15;\\n    output DO16;\\n    output DO17;\\n    output EF;\\n    output AEF;\\n    output AFF;\\n    output FF;\\nendmodule\\n\\n(* blackbox *)\\nmodule CLKDIVC (...);\\n    parameter GSR = \\\"DISABLED\\\";\\n    parameter DIV = \\\"2.0\\\";\\n    input RST;\\n    input CLKI;\\n    input ALIGNWD;\\n    output CDIV1;\\n    output CDIVX;\\nendmodule\\n\\n(* blackbox *)\\nmodule DCMA (...);\\n    input CLK0;\\n    input CLK1;\\n    input SEL;\\n    output DCMOUT;\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKSYNCA (...);\\n    input ECLKI;\\n    input STOP;\\n    output ECLKO;\\nendmodule\\n\\n(* blackbox *)\\nmodule ECLKBRIDGECS (...);\\n    input CLK0;\\n    input CLK1;\\n    input SEL;\\n    output ECSOUT;\\nendmodule\\n\\n(* blackbox *)\\nmodule DCCA (...);\\n    input CLKI;\\n    input CE;\\n    output CLKO;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule START (...);\\n    input STARTCLK;\\nendmodule\\n\\n(* blackbox *)\\nmodule EHXPLLJ (...);\\n    parameter CLKI_DIV = 1;\\n    parameter CLKFB_DIV = 1;\\n    parameter CLKOP_DIV = 8;\\n    parameter CLKOS_DIV = 8;\\n    parameter CLKOS2_DIV = 8;\\n    parameter CLKOS3_DIV = 8;\\n    parameter CLKOP_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS2_ENABLE = \\\"ENABLED\\\";\\n    parameter CLKOS3_ENABLE = \\\"ENABLED\\\";\\n    parameter VCO_BYPASS_A0 = \\\"DISABLED\\\";\\n    parameter VCO_BYPASS_B0 = \\\"DISABLED\\\";\\n    parameter VCO_BYPASS_C0 = \\\"DISABLED\\\";\\n    parameter VCO_BYPASS_D0 = \\\"DISABLED\\\";\\n    parameter CLKOP_CPHASE = 0;\\n    parameter CLKOS_CPHASE = 0;\\n    parameter CLKOS2_CPHASE = 0;\\n    parameter CLKOS3_CPHASE = 0;\\n    parameter CLKOP_FPHASE = 0;\\n    parameter CLKOS_FPHASE = 0;\\n    parameter CLKOS2_FPHASE = 0;\\n    parameter CLKOS3_FPHASE = 0;\\n    parameter FEEDBK_PATH = \\\"CLKOP\\\";\\n    parameter FRACN_ENABLE = \\\"DISABLED\\\";\\n    parameter FRACN_DIV = 0;\\n    parameter CLKOP_TRIM_POL = \\\"RISING\\\";\\n    parameter CLKOP_TRIM_DELAY = 0;\\n    parameter CLKOS_TRIM_POL = \\\"RISING\\\";\\n    parameter CLKOS_TRIM_DELAY = 0;\\n    parameter PLL_USE_WB = \\\"DISABLED\\\";\\n    parameter PREDIVIDER_MUXA1 = 0;\\n    parameter PREDIVIDER_MUXB1 = 0;\\n    parameter PREDIVIDER_MUXC1 = 0;\\n    parameter PREDIVIDER_MUXD1 = 0;\\n    parameter OUTDIVIDER_MUXA2 = \\\"DIVA\\\";\\n    parameter OUTDIVIDER_MUXB2 = \\\"DIVB\\\";\\n    parameter OUTDIVIDER_MUXC2 = \\\"DIVC\\\";\\n    parameter OUTDIVIDER_MUXD2 = \\\"DIVD\\\";\\n    parameter PLL_LOCK_MODE = 0;\\n    parameter STDBY_ENABLE = \\\"DISABLED\\\";\\n    parameter DPHASE_SOURCE = \\\"DISABLED\\\";\\n    parameter PLLRST_ENA = \\\"DISABLED\\\";\\n    parameter MRST_ENA = \\\"DISABLED\\\";\\n    parameter DCRST_ENA = \\\"DISABLED\\\";\\n    parameter DDRST_ENA = \\\"DISABLED\\\";\\n    parameter INTFB_WAKE = \\\"DISABLED\\\";\\n    input CLKI;\\n    input CLKFB;\\n    input PHASESEL1;\\n    input PHASESEL0;\\n    input PHASEDIR;\\n    input PHASESTEP;\\n    input LOADREG;\\n    input STDBY;\\n    input PLLWAKESYNC;\\n    input RST;\\n    input RESETM;\\n    input RESETC;\\n    input RESETD;\\n    input ENCLKOP;\\n    input ENCLKOS;\\n    input ENCLKOS2;\\n    input ENCLKOS3;\\n    input PLLCLK;\\n    input PLLRST;\\n    input PLLSTB;\\n    input PLLWE;\\n    input PLLDATI7;\\n    input PLLDATI6;\\n    input PLLDATI5;\\n    input PLLDATI4;\\n    input PLLDATI3;\\n    input PLLDATI2;\\n    input PLLDATI1;\\n    input PLLDATI0;\\n    input PLLADDR4;\\n    input PLLADDR3;\\n    input PLLADDR2;\\n    input PLLADDR1;\\n    input PLLADDR0;\\n    output CLKOP;\\n    output CLKOS;\\n    output CLKOS2;\\n    output CLKOS3;\\n    output LOCK;\\n    output INTLOCK;\\n    output REFCLK;\\n    output PLLDATO7;\\n    output PLLDATO6;\\n    output PLLDATO5;\\n    output PLLDATO4;\\n    output PLLDATO3;\\n    output PLLDATO2;\\n    output PLLDATO1;\\n    output PLLDATO0;\\n    output PLLACK;\\n    output DPHSRC;\\n    output CLKINTFB;\\nendmodule\\n\\n(* blackbox *)\\nmodule OSCJ (...);\\n    parameter NOM_FREQ = \\\"2.08\\\";\\n    input STDBY;\\n    output OSC;\\n    output SEDSTDBY;\\n    output OSCESB;\\nendmodule\\n\\n(* blackbox *) (* keep *)\\nmodule TSALL (...);\\n    input TSALL;\\nendmodule\\n\\n\",\n            \"cells_ff.vh\": \"// Diamond flip-flops\\nmodule FD1P3AX(input     D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3AY(input     D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3BX(input PD, D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3DX(input CD, D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3IX(input CD, D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1P3JX(input PD, D, SP, CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule FD1S3AX(input     D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3AY(input     D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(|0),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3BX(input PD, D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3DX(input CD, D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))        _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3IX(input CD, D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(CD),          .DI(D), .Q(Q)); endmodule\\nmodule FD1S3JX(input PD, D,     CK, output Q); parameter GSR = \\\"ENABLED\\\"; TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"1\\\"),  .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(CK), .LSR(PD),          .DI(D), .Q(Q)); endmodule\\n\\n// TODO: Diamond latches\\n// module FL1P3AY(); endmodule\\n// module FL1P3AZ(); endmodule\\n// module FL1P3BX(); endmodule\\n// module FL1P3DX(); endmodule\\n// module FL1P3IY(); endmodule\\n// module FL1P3JY(); endmodule\\n// module FL1S3AX(); endmodule\\n// module FL1S3AY(); endmodule\\n\\n// Diamond I/O registers\\nmodule IFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"input\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule IFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"input\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule IFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"input\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule IFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"input\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"LSR_OVER_CE\\\")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\n\\nmodule OFS1P3BX(input PD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"output\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"ASYNC\\\"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule OFS1P3DX(input CD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"output\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))       _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule OFS1P3IX(input CD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"output\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(CD), .CE(SP), .DI(D), .Q(Q)); endmodule\\nmodule OFS1P3JX(input PD, D, SP, SCLK, output Q); parameter GSR = \\\"ENABLED\\\"; (* syn_useioff, ioff_dir=\\\"output\\\" *) TRELLIS_FF #(.GSR(GSR), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"),   .SRMODE(\\\"LSR_OVER_CE\\\")) _TECHMAP_REPLACE_ (.CLK(SCLK), .LSR(PD), .CE(SP), .DI(D), .Q(Q)); endmodule\\n\\n// TODO: Diamond I/O latches\\n// module IFS1S1B(input PD, D, SCLK, output Q); endmodule\\n// module IFS1S1D(input CD, D, SCLK, output Q); endmodule\\n// module IFS1S1I(input PD, D, SCLK, output Q); endmodule\\n// module IFS1S1J(input CD, D, SCLK, output Q); endmodule\\n\",\n            \"cells_io.vh\": \"// Diamond I/O buffers\\nmodule IB   ((* iopad_external_pin *) input I,     output O); (* PULLMODE=\\\"NONE\\\" *) TRELLIS_IO #(.DIR(\\\"INPUT\\\"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule\\nmodule IBPU ((* iopad_external_pin *) input I,     output O); (* PULLMODE=\\\"UP\\\"   *) TRELLIS_IO #(.DIR(\\\"INPUT\\\"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule\\nmodule IBPD ((* iopad_external_pin *) input I,     output O); (* PULLMODE=\\\"DOWN\\\" *) TRELLIS_IO #(.DIR(\\\"INPUT\\\"))  _TECHMAP_REPLACE_ (.B(I), .O(O)); endmodule\\nmodule OB   (input I,     (* iopad_external_pin *) output O); (* PULLMODE=\\\"NONE\\\" *) TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(O), .I(I)); endmodule\\nmodule OBZ  (input I, T,  (* iopad_external_pin *) output O); (* PULLMODE=\\\"NONE\\\" *) TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule\\nmodule OBZPU(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE=\\\"UP\\\"   *) TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule\\nmodule OBZPD(input I, T,  (* iopad_external_pin *) output O); (* PULLMODE=\\\"DOWN\\\" *) TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(O), .I(I), .T(T)); endmodule\\nmodule OBCO (input I,     output OT, OC); OLVDS olvds (.A(I), .Z(OT), .ZN(OC)); endmodule\\nmodule BB   (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE=\\\"NONE\\\" *) TRELLIS_IO #(.DIR(\\\"BIDIR\\\")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule\\nmodule BBPU (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE=\\\"UP\\\"   *) TRELLIS_IO #(.DIR(\\\"BIDIR\\\")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule\\nmodule BBPD (input I, T,  output O, (* iopad_external_pin *) inout B); (* PULLMODE=\\\"DOWN\\\" *) TRELLIS_IO #(.DIR(\\\"BIDIR\\\")) _TECHMAP_REPLACE_ (.B(B), .I(I), .O(O), .T(T)); endmodule\\nmodule ILVDS(input A, AN, (* iopad_external_pin *) output Z    ); TRELLIS_IO #(.DIR(\\\"INPUT\\\"))  _TECHMAP_REPLACE_ (.B(A), .O(Z)); endmodule\\nmodule OLVDS(input A,     (* iopad_external_pin *) output Z, output ZN); TRELLIS_IO #(.DIR(\\\"OUTPUT\\\")) _TECHMAP_REPLACE_ (.B(Z), .I(A)); endmodule\\n\",\n            \"cells_map.v\": \"module  \\\\$_DFF_N_ (input D, C, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFF_P_ (input D, C, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFFE_NN_ (input D, C, E, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFFE_PN_ (input D, C, E, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFFE_NP_ (input D, C, E, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFFE_PP_ (input D, C, E, output Q);\\n    parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n    generate if (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    else\\n        TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(1'b0), .DI(D), .Q(Q));\\n    endgenerate\\n    wire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\nendmodule\\n\\nmodule  \\\\$_DFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_SDFF_NP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFF_NP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFF_PP0_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFF_PP1_ (input D, C, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_DFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_DFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_DFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_SDFFE_NP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_NP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP0P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP1P_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule  \\\\$_SDFFE_NP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_NP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP0N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\nmodule  \\\\$_SDFFE_PP1N_ (input D, C, E, R, output Q); TRELLIS_FF #(.GSR(\\\"AUTO\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"SET\\\"), .SRMODE(\\\"LSR_OVER_CE\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(R), .DI(D), .Q(Q)); wire _TECHMAP_REMOVEINIT_Q_ = 1'b1; endmodule\\n\\nmodule \\\\$_ALDFF_NP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"INV\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\nmodule \\\\$_ALDFF_PP_ (input C, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"1\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\n\\nmodule \\\\$_ALDFFE_NPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"INV\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\nmodule \\\\$_ALDFFE_NPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"INV\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\nmodule \\\\$_ALDFFE_PPN_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"INV\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\nmodule \\\\$_ALDFFE_PPP_ (input C, E, L, AD, D, output Q); TRELLIS_FF #(.GSR(\\\"DISABLED\\\"), .CEMUX(\\\"CE\\\"), .CLKMUX(\\\"CLK\\\"), .LSRMODE(\\\"PRLD\\\"), .LSRMUX(\\\"LSR\\\"), .REGSET(\\\"RESET\\\"), .SRMODE(\\\"ASYNC\\\"))  _TECHMAP_REPLACE_ (.CLK(C), .CE(E), .LSR(L), .DI(D), .M(AD), .Q(Q)); endmodule\\n\\n`include \\\"cells_ff.vh\\\"\\n`include \\\"cells_io.vh\\\"\\n\\n`ifndef NO_LUT\\nmodule \\\\$lut (A, Y);\\n    parameter WIDTH = 0;\\n    parameter LUT = 0;\\n\\n    (* force_downto *)\\n    input [WIDTH-1:0] A;\\n    output Y;\\n\\n    generate\\n        if (WIDTH == 1) begin\\n            localparam [15:0] INIT = {{8{LUT[1]}}, {8{LUT[0]}}};\\n            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),\\n                .A(1'b0), .B(1'b0), .C(1'b0), .D(A[0]));\\n        end else\\n        if (WIDTH == 2) begin\\n            localparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};\\n            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),\\n                .A(1'b0), .B(1'b0), .C(A[0]), .D(A[1]));\\n        end else\\n        if (WIDTH == 3) begin\\n            localparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};\\n            LUT4 #(.INIT(INIT)) _TECHMAP_REPLACE_ (.Z(Y),\\n                .A(1'b0), .B(A[0]), .C(A[1]), .D(A[2]));\\n        end else\\n        if (WIDTH == 4) begin\\n            LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Z(Y),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n        `ifndef NO_PFUMUX\\n        end else\\n        if (WIDTH == 5) begin\\n            wire f0, f1;\\n            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            PFUMX mux5(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(Y));\\n        end else\\n        if (WIDTH == 6) begin\\n            wire f0, f1, f2, f3, g0, g1;\\n            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));\\n            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));\\n            L6MUX21 mux6 (.D0(g0), .D1(g1), .SD(A[5]), .Z(Y));\\n        end else\\n        if (WIDTH == 7) begin\\n            wire f0, f1, f2, f3, f4, f5, f6, f7, g0, g1, g2, g3, h0, h1;\\n            LUT4 #(.INIT(LUT[15: 0])) lut0 (.Z(f0),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[31:16])) lut1 (.Z(f1),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            LUT4 #(.INIT(LUT[47:32])) lut2 (.Z(f2),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[63:48])) lut3 (.Z(f3),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            LUT4 #(.INIT(LUT[79:64])) lut4 (.Z(f4),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[95:80])) lut5 (.Z(f5),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            LUT4 #(.INIT(LUT[111: 96])) lut6 (.Z(f6),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n            LUT4 #(.INIT(LUT[127:112])) lut7 (.Z(f7),\\n                .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\n            PFUMX mux50(.ALUT(f1), .BLUT(f0), .C0(A[4]), .Z(g0));\\n            PFUMX mux51(.ALUT(f3), .BLUT(f2), .C0(A[4]), .Z(g1));\\n            PFUMX mux52(.ALUT(f5), .BLUT(f4), .C0(A[4]), .Z(g2));\\n            PFUMX mux53(.ALUT(f7), .BLUT(f6), .C0(A[4]), .Z(g3));\\n            L6MUX21 mux60 (.D0(g0), .D1(g1), .SD(A[5]), .Z(h0));\\n            L6MUX21 mux61 (.D0(g2), .D1(g3), .SD(A[5]), .Z(h1));\\n            L6MUX21 mux7  (.D0(h0), .D1(h1), .SD(A[6]), .Z(Y));\\n        `endif\\n        end else begin\\n            wire _TECHMAP_FAIL_ = 1;\\n        end\\n    endgenerate\\nendmodule\\n`endif\\n\",\n            \"cells_sim_ecp5.v\": \"`include \\\"common_sim.vh\\\"\\n`include \\\"ccu2c_sim.vh\\\"\\n\\n`ifndef NO_INCLUDES\\n\\n`include \\\"cells_ff.vh\\\"\\n`include \\\"cells_io.vh\\\"\\n\\n`endif\\n\",\n            \"cells_sim_xo2.v\": \"`include \\\"common_sim.vh\\\"\\n`include \\\"ccu2d_sim.vh\\\"\\n\\n`ifndef NO_INCLUDES\\n\\n`include \\\"cells_ff.vh\\\"\\n`include \\\"cells_io.vh\\\"\\n\\n`endif\\n\",\n            \"cells_sim_xo3.v\": \"`include \\\"common_sim.vh\\\"\\n`include \\\"ccu2d_sim.vh\\\"\\n\\n`ifndef NO_INCLUDES\\n\\n`include \\\"cells_ff.vh\\\"\\n`include \\\"cells_io.vh\\\"\\n\\n`endif\\n\",\n            \"cells_sim_xo3d.v\": \"`include \\\"common_sim.vh\\\"\\n`include \\\"ccu2d_sim.vh\\\"\\n\\n`ifndef NO_INCLUDES\\n\\n`include \\\"cells_ff.vh\\\"\\n`include \\\"cells_io.vh\\\"\\n\\n`endif\\n\",\n            \"common_sim.vh\": \"// ---------------------------------------\\n\\n(* abc9_lut=1, lib_whitebox *)\\nmodule LUT4(input A, B, C, D, output Z);\\n    parameter [15:0] INIT = 16'h0000;\\n    wire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];\\n    wire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];\\n    wire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];\\n    assign Z =      A ?          s1[1] :         s1[0];\\n    specify\\n        (A => Z) = 141;\\n        (B => Z) = 275;\\n        (C => Z) = 379;\\n        (D => Z) = 379;\\n    endspecify\\nendmodule\\n\\n// This is a placeholder for ABC9 to extract the area/delay\\n//   cost of 5-input LUTs and is not intended to be instantiated\\n// LUT5 = 2x LUT4 + PFUMX\\n(* abc9_lut=2 *)\\nmodule \\\\$__ABC9_LUT5 (input M0, D, C, B, A, output Z);\\n    specify\\n        (M0 => Z) = 151;\\n        (D => Z) = 239;\\n        (C => Z) = 373;\\n        (B => Z) = 477;\\n        (A => Z) = 477;\\n    endspecify\\nendmodule\\n\\n// This is a placeholder for ABC9 to extract the area/delay\\n//   of 6-input LUTs and is not intended to be instantiated\\n// LUT6 = 2x LUT5 + MUX2\\n(* abc9_lut=4 *)\\nmodule \\\\$__ABC9_LUT6 (input M1, M0, D, C, B, A, output Z);\\n    specify\\n        (M1 => Z) = 148;\\n        (M0 => Z) = 292;\\n        (D => Z) = 380;\\n        (C => Z) = 514;\\n        (B => Z) = 618;\\n        (A => Z) = 618;\\n    endspecify\\nendmodule\\n\\n// This is a placeholder for ABC9 to extract the area/delay\\n//   of 7-input LUTs and is not intended to be instantiated\\n// LUT7 = 2x LUT6 + MUX2\\n(* abc9_lut=8 *)\\nmodule \\\\$__ABC9_LUT7 (input M2, M1, M0, D, C, B, A, output Z);\\n    specify\\n        (M2 => Z) = 148;\\n        (M1 => Z) = 289;\\n        (M0 => Z) = 433;\\n        (D => Z) = 521;\\n        (C => Z) = 655;\\n        (B => Z) = 759;\\n        (A => Z) = 759;\\n    endspecify\\nendmodule\\n\\n// ---------------------------------------\\n(* abc9_box, lib_whitebox *)\\nmodule L6MUX21 (input D0, D1, SD, output Z);\\n\\tassign Z = SD ? D1 : D0;\\n\\tspecify\\n\\t\\t(D0 => Z) = 140;\\n\\t\\t(D1 => Z) = 141;\\n\\t\\t(SD => Z) = 148;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n\\nmodule TRELLIS_RAM16X2 (\\n\\tinput DI0, DI1,\\n\\tinput WAD0, WAD1, WAD2, WAD3,\\n\\tinput WRE, WCK,\\n\\tinput RAD0, RAD1, RAD2, RAD3,\\n\\toutput DO0, DO1\\n);\\n\\tparameter WCKMUX = \\\"WCK\\\";\\n\\tparameter WREMUX = \\\"WRE\\\";\\n\\tparameter INITVAL_0 = 16'h0000;\\n\\tparameter INITVAL_1 = 16'h0000;\\n\\n\\treg [1:0] mem[15:0];\\n\\n\\tinteger i;\\n\\tinitial begin\\n\\t\\tfor (i = 0; i < 16; i = i + 1)\\n\\t\\t\\tmem[i] <= {INITVAL_1[i], INITVAL_0[i]};\\n\\tend\\n\\n\\twire muxwck = (WCKMUX == \\\"INV\\\") ? ~WCK : WCK;\\n\\n\\treg muxwre;\\n\\talways @(*)\\n\\t\\tcase (WREMUX)\\n\\t\\t\\t\\\"1\\\": muxwre = 1'b1;\\n\\t\\t\\t\\\"0\\\": muxwre = 1'b0;\\n\\t\\t\\t\\\"INV\\\": muxwre = ~WRE;\\n\\t\\t\\tdefault: muxwre = WRE;\\n\\t\\tendcase\\n\\n\\n\\talways @(posedge muxwck)\\n\\t\\tif (muxwre)\\n\\t\\t\\tmem[{WAD3, WAD2, WAD1, WAD0}] <= {DI1, DI0};\\n\\n\\tassign {DO1, DO0} = mem[{RAD3, RAD2, RAD1, RAD0}];\\nendmodule\\n\\n// ---------------------------------------\\n(* abc9_box, lib_whitebox *)\\nmodule PFUMX (input ALUT, BLUT, C0, output Z);\\n\\tassign Z = C0 ? ALUT : BLUT;\\n\\tspecify\\n\\t\\t(ALUT => Z) = 98;\\n\\t\\t(BLUT => Z) = 98;\\n\\t\\t(C0 => Z) = 151;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n(* abc9_box, lib_whitebox *)\\nmodule TRELLIS_DPR16X4 (\\n\\tinput  [3:0] DI,\\n\\tinput  [3:0] WAD,\\n\\tinput        WRE,\\n\\tinput        WCK,\\n\\tinput  [3:0] RAD,\\n\\toutput [3:0] DO\\n);\\n\\tparameter WCKMUX = \\\"WCK\\\";\\n\\tparameter WREMUX = \\\"WRE\\\";\\n\\tparameter [63:0] INITVAL = 64'h0000000000000000;\\n\\n\\treg [3:0] mem[15:0];\\n\\n\\tinteger i;\\n\\tinitial begin\\n\\t\\tfor (i = 0; i < 16; i = i + 1)\\n\\t\\t\\tmem[i] <= INITVAL[4*i +: 4];\\n\\tend\\n\\n\\twire muxwck = (WCKMUX == \\\"INV\\\") ? ~WCK : WCK;\\n\\n\\treg muxwre;\\n\\talways @(*)\\n\\t\\tcase (WREMUX)\\n\\t\\t\\t\\\"1\\\": muxwre = 1'b1;\\n\\t\\t\\t\\\"0\\\": muxwre = 1'b0;\\n\\t\\t\\t\\\"INV\\\": muxwre = ~WRE;\\n\\t\\t\\tdefault: muxwre = WRE;\\n\\t\\tendcase\\n\\n\\talways @(posedge muxwck)\\n\\t\\tif (muxwre)\\n\\t\\t\\tmem[WAD] <= DI;\\n\\n\\tassign DO = mem[RAD];\\n\\n\\tspecify\\n\\t\\t// TODO\\n\\t\\t(RAD *> DO) = 0;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n\\n(* abc9_box, lib_whitebox *)\\nmodule DPR16X4C (\\n\\t\\tinput [3:0] DI,\\n\\t\\tinput WCK, WRE,\\n\\t\\tinput [3:0] RAD,\\n\\t\\tinput [3:0] WAD,\\n\\t\\toutput [3:0] DO\\n);\\n\\t// For legacy Lattice compatibility, INITIVAL is a hex\\n\\t// string rather than a numeric parameter\\n\\tparameter INITVAL = \\\"0x0000000000000000\\\";\\n\\n\\tfunction [63:0] convert_initval;\\n\\t\\tinput [143:0] hex_initval;\\n\\t\\treg done;\\n\\t\\treg [63:0] temp;\\n\\t\\treg [7:0] char;\\n\\t\\tinteger i;\\n\\t\\tbegin\\n\\t\\t\\tdone = 1'b0;\\n\\t\\t\\ttemp = 0;\\n\\t\\t\\tfor (i = 0; i < 16; i = i + 1) begin\\n\\t\\t\\t\\tif (!done) begin\\n\\t\\t\\t\\t\\tchar = hex_initval[8*i +: 8];\\n\\t\\t\\t\\t\\tif (char == \\\"x\\\") begin\\n\\t\\t\\t\\t\\t\\tdone = 1'b1;\\n\\t\\t\\t\\t\\tend else begin\\n\\t\\t\\t\\t\\t\\tif (char >= \\\"0\\\" && char <= \\\"9\\\")\\n\\t\\t\\t\\t\\t\\t\\ttemp[4*i +: 4] = char - \\\"0\\\";\\n\\t\\t\\t\\t\\t\\telse if (char >= \\\"A\\\" && char <= \\\"F\\\")\\n\\t\\t\\t\\t\\t\\t\\ttemp[4*i +: 4] = 10 + char - \\\"A\\\";\\n\\t\\t\\t\\t\\t\\telse if (char >= \\\"a\\\" && char <= \\\"f\\\")\\n\\t\\t\\t\\t\\t\\t\\ttemp[4*i +: 4] = 10 + char - \\\"a\\\";\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tend\\n\\t\\t\\tend\\n\\t\\t\\tconvert_initval = temp;\\n\\t\\tend\\n\\tendfunction\\n\\n\\tlocalparam conv_initval = convert_initval(INITVAL);\\n\\n\\treg [3:0] ram[0:15];\\n\\tinteger i;\\n\\tinitial begin\\n\\t\\tfor (i = 0; i < 15; i = i + 1) begin\\n\\t\\t\\tram[i] <= conv_initval[4*i +: 4];\\n\\t\\tend\\n\\tend\\n\\n\\talways @(posedge WCK)\\n\\t\\tif (WRE)\\n\\t\\t\\tram[WAD] <= DI;\\n\\n\\tassign DO = ram[RAD];\\n\\n\\tspecify\\n\\t\\t// TODO\\n\\t\\t(RAD *> DO) = 0;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n\\n(* lib_whitebox *)\\nmodule LUT2(input A, B, output Z);\\n    parameter [3:0] INIT = 4'h0;\\n    wire [1:0] s1 = B ?     INIT[ 3:2] :     INIT[1:0];\\n    assign Z =      A ?          s1[1] :         s1[0];\\nendmodule\\n\\n// ---------------------------------------\\n\\n`ifdef YOSYS\\n(* abc9_flop=(SRMODE != \\\"ASYNC\\\"), abc9_box=(SRMODE == \\\"ASYNC\\\"), lib_whitebox *)\\n`endif\\nmodule TRELLIS_FF(input CLK, LSR, CE, DI, M, output reg Q);\\n\\tparameter GSR = \\\"ENABLED\\\";\\n\\tparameter [127:0] CEMUX = \\\"1\\\";\\n\\tparameter CLKMUX = \\\"CLK\\\";\\n\\tparameter LSRMUX = \\\"LSR\\\";\\n\\tparameter SRMODE = \\\"LSR_OVER_CE\\\";\\n\\tparameter REGSET = \\\"RESET\\\";\\n\\tparameter [127:0] LSRMODE = \\\"LSR\\\";\\n\\n\\twire muxce;\\n\\tgenerate\\n\\t\\tcase (CEMUX)\\n\\t\\t\\t\\\"1\\\": assign muxce = 1'b1;\\n\\t\\t\\t\\\"0\\\": assign muxce = 1'b0;\\n\\t\\t\\t\\\"INV\\\": assign muxce = ~CE;\\n\\t\\t\\tdefault: assign muxce = CE;\\n\\t\\tendcase\\n\\tendgenerate\\n\\n\\twire muxlsr = (LSRMUX == \\\"INV\\\") ? ~LSR : LSR;\\n\\twire muxclk = (CLKMUX == \\\"INV\\\") ? ~CLK : CLK;\\n\\twire srval;\\n\\tgenerate\\n\\t\\tif (LSRMODE == \\\"PRLD\\\")\\n\\t\\t\\tassign srval = M;\\n\\t\\telse\\n\\t\\t\\tassign srval = (REGSET == \\\"SET\\\") ? 1'b1 : 1'b0;\\n\\tendgenerate\\n\\n\\tinitial Q = srval;\\n\\n\\tgenerate\\n\\t\\tif (SRMODE == \\\"ASYNC\\\") begin\\n\\t\\t\\talways @(posedge muxclk, posedge muxlsr)\\n\\t\\t\\t\\tif (muxlsr)\\n\\t\\t\\t\\t\\tQ <= srval;\\n\\t\\t\\t\\telse if (muxce)\\n\\t\\t\\t\\t\\tQ <= DI;\\n\\t\\tend else begin\\n\\t\\t\\talways @(posedge muxclk)\\n\\t\\t\\t\\tif (muxlsr)\\n\\t\\t\\t\\t\\tQ <= srval;\\n\\t\\t\\t\\telse if (muxce)\\n\\t\\t\\t\\t\\tQ <= DI;\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tspecify\\n\\t\\t$setup(DI, negedge CLK &&& CLKMUX == \\\"INV\\\", 0);\\n\\t\\t$setup(CE, negedge CLK &&& CLKMUX == \\\"INV\\\", 0);\\n\\t\\t$setup(LSR, negedge CLK &&& CLKMUX == \\\"INV\\\", 0);\\n\\t\\t$setup(DI, posedge CLK &&& CLKMUX != \\\"INV\\\", 0);\\n\\t\\t$setup(CE, posedge CLK &&& CLKMUX != \\\"INV\\\", 0);\\n\\t\\t$setup(LSR, posedge CLK &&& CLKMUX != \\\"INV\\\", 0);\\n`ifndef YOSYS\\n\\t\\tif (SRMODE == \\\"ASYNC\\\" && muxlsr && CLKMUX == \\\"INV\\\") (negedge CLK => (Q : srval)) = 0;\\n\\t\\tif (SRMODE == \\\"ASYNC\\\" && muxlsr && CLKMUX != \\\"INV\\\") (posedge CLK => (Q : srval)) = 0;\\n`else\\n\\t\\tif (SRMODE == \\\"ASYNC\\\" && muxlsr) (LSR => Q) = 0; \\t// Technically, this should be an edge sensitive path\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// but for facilitating a bypass box, let's pretend it's\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// a simple path\\n`endif\\n\\t\\tif (!muxlsr && muxce && CLKMUX == \\\"INV\\\") (negedge CLK => (Q : DI)) = 0;\\n\\t\\tif (!muxlsr && muxce && CLKMUX != \\\"INV\\\") (posedge CLK => (Q : DI)) = 0;\\n\\tendspecify\\nendmodule\\n\\n// ---------------------------------------\\n(* keep *)\\nmodule TRELLIS_IO(\\n\\t(* iopad_external_pin *)\\n\\tinout B,\\n\\tinput I,\\n\\tinput T,\\n\\toutput O\\n);\\n\\tparameter DIR = \\\"INPUT\\\";\\n\\treg T_pd;\\n\\talways @(*) if (T === 1'bz) T_pd <= 1'b0; else T_pd <= T;\\n\\n\\tgenerate\\n\\t\\tif (DIR == \\\"INPUT\\\") begin\\n\\t\\t\\tassign B = 1'bz;\\n\\t\\t\\tassign O = B;\\n\\t\\tend else if (DIR == \\\"OUTPUT\\\") begin\\n\\t\\t\\tassign B = T_pd ? 1'bz : I;\\n\\t\\t\\tassign O = 1'bx;\\n\\t\\tend else if (DIR == \\\"BIDIR\\\") begin\\n\\t\\t\\tassign B = T_pd ? 1'bz : I;\\n\\t\\t\\tassign O = B;\\n\\t\\tend else begin\\n\\t\\t\\tERROR_UNKNOWN_IO_MODE error();\\n\\t\\tend\\n\\tendgenerate\\n\\nendmodule\\n\\n// ---------------------------------------\\n\\nmodule INV(input A, output Z);\\n\\tassign Z = !A;\\nendmodule\\n\\n// ---------------------------------------\\n\\nmodule TRELLIS_COMB(\\n\\tinput A, B, C, D, M,\\n\\tinput FCI, F1, FXA, FXB,\\n\\tinput WD,\\n\\tinput WAD0, WAD1, WAD2, WAD3,\\n\\tinput WRE, WCK,\\n\\toutput F, FCO, OFX\\n);\\n\\tparameter MODE = \\\"LOGIC\\\";\\n\\tparameter INITVAL = 16'h0;\\n\\tparameter CCU2_INJECT1 = \\\"NO\\\";\\n\\tparameter WREMUX = \\\"WRE\\\";\\n\\tparameter IS_Z1 = 1'b0;\\n\\n\\tgenerate\\n\\t\\tif (MODE == \\\"LOGIC\\\") begin: mode_logic\\n\\t\\t\\tLUT4 #(.INIT(INITVAL)) lut4 (.A(A), .B(B), .C(C), .D(D), .Z(F));\\n\\t\\tend else if (MODE == \\\"CCU2\\\") begin: mode_ccu2\\n\\t\\t\\twire l4o, l2o;\\n\\t\\t\\tLUT4 #(.INIT(INITVAL)) lut4_0(.A(A), .B(B), .C(C), .D(D), .Z(l4o));\\n\\t\\t\\tLUT2 #(.INIT(INITVAL[3:0])) lut2_0(.A(A), .B(B), .Z(l2o));\\n\\t\\t\\twire gated_cin_0 = (CCU2_INJECT1 == \\\"YES\\\") ? 1'b0 : FCI;\\n\\t\\t\\tassign F = l4o ^ gated_cin_0;\\n\\t\\t\\twire gated_lut2_0 = (CCU2_INJECT1 == \\\"YES\\\") ? 1'b0 : l2o;\\n\\t\\t\\twire FCO = (~l4o & gated_lut2_0) | (l4o & FCI);\\n\\t\\tend else if (MODE == \\\"DPRAM\\\") begin: mode_dpram\\n\\t\\t\\treg [15:0] ram = INITVAL;\\n\\t\\t\\talways @(posedge WCK)\\n\\t\\t\\t\\tif (WRE)\\n\\t\\t\\t\\t\\tram[{WAD3, WAD2, WAD1, WAD0}] <= WD;\\n\\t\\t\\tassign F = ram[{A, C, B, D}];\\n\\t\\tend else begin\\n\\t\\t\\t$error(\\\"unsupported COMB mode %s\\\", MODE);\\n\\t\\tend\\n\\n \\t\\tif (IS_Z1)\\n\\t\\t\\tL6MUX21 lutx_mux (.D0(FXA), .D1(FXB), .SD(M), .Z(OFX));\\n\\t\\telse\\n\\t\\t\\tPFUMX lut5_mux (.ALUT(F1), .BLUT(F), .C0(M), .Z(OFX));\\n\\tendgenerate\\n\\nendmodule\\n\\n// Constants\\nmodule VLO(output Z);\\n\\tassign Z = 1'b0;\\nendmodule\\n\\nmodule VHI(output Z);\\n\\tassign Z = 1'b1;\\nendmodule\\n\\n`ifndef NO_INCLUDES\\n\\n`include \\\"cells_ff.vh\\\"\\n`include \\\"cells_io.vh\\\"\\n\\n`endif\\n\",\n            \"dsp_map_18x18.v\": \"module \\\\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);\\n\\n\\tparameter A_WIDTH = 18;\\n\\tparameter B_WIDTH = 18;\\n\\tparameter Y_WIDTH = 36;\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\n\\tMULT18X18D _TECHMAP_REPLACE_ (\\n\\t\\t.A0(A[0]), .A1(A[1]), .A2(A[2]), .A3(A[3]), .A4(A[4]), .A5(A[5]), .A6(A[6]), .A7(A[7]), .A8(A[8]), .A9(A[9]), .A10(A[10]), .A11(A[11]), .A12(A[12]), .A13(A[13]), .A14(A[14]), .A15(A[15]), .A16(A[16]), .A17(A[17]),\\n\\t\\t.B0(B[0]), .B1(B[1]), .B2(B[2]), .B3(B[3]), .B4(B[4]), .B5(B[5]), .B6(B[6]), .B7(B[7]), .B8(B[8]), .B9(B[9]), .B10(B[10]), .B11(B[11]), .B12(B[12]), .B13(B[13]), .B14(B[14]), .B15(B[15]), .B16(B[16]), .B17(B[17]),\\n\\t\\t.C17(1'b0), .C16(1'b0), .C15(1'b0), .C14(1'b0), .C13(1'b0), .C12(1'b0), .C11(1'b0), .C10(1'b0), .C9(1'b0), .C8(1'b0), .C7(1'b0), .C6(1'b0), .C5(1'b0), .C4(1'b0), .C3(1'b0), .C2(1'b0), .C1(1'b0), .C0(1'b0),\\n\\t\\t.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0), .SIGNEDB(B_SIGNED ? 1'b1 : 1'b0), .SOURCEA(1'b0), .SOURCEB(1'b0),\\n\\n\\t\\t.P0(Y[0]), .P1(Y[1]), .P2(Y[2]), .P3(Y[3]), .P4(Y[4]), .P5(Y[5]), .P6(Y[6]), .P7(Y[7]), .P8(Y[8]), .P9(Y[9]), .P10(Y[10]), .P11(Y[11]), .P12(Y[12]), .P13(Y[13]), .P14(Y[14]), .P15(Y[15]), .P16(Y[16]), .P17(Y[17]), .P18(Y[18]), .P19(Y[19]), .P20(Y[20]), .P21(Y[21]), .P22(Y[22]), .P23(Y[23]), .P24(Y[24]), .P25(Y[25]), .P26(Y[26]), .P27(Y[27]), .P28(Y[28]), .P29(Y[29]), .P30(Y[30]), .P31(Y[31]), .P32(Y[32]), .P33(Y[33]), .P34(Y[34]), .P35(Y[35])\\n\\t);\\nendmodule\\n\",\n            \"latches_map.v\": \"module \\\\$_DLATCH_N_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = !E ? D : Q;\\nendmodule\\n\\nmodule \\\\$_DLATCH_P_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = E ? D : Q;\\nendmodule\\n\",\n            \"lutrams.txt\": \"ram distributed $__TRELLIS_DPR16X4_ {\\n\\tabits 4;\\n\\twidth 4;\\n\\tcost 4;\\n\\tinit any;\\n\\tprune_rom;\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock anyedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\",\n            \"lutrams_map.v\": \"module $__TRELLIS_DPR16X4_(...);\\n\\nparameter INIT = 64'bx;\\nparameter PORT_W_CLK_POL = 1;\\n\\ninput PORT_W_CLK;\\ninput [3:0] PORT_W_ADDR;\\ninput [3:0] PORT_W_WR_DATA;\\ninput PORT_W_WR_EN;\\n\\ninput [3:0] PORT_R_ADDR;\\noutput [3:0] PORT_R_RD_DATA;\\n\\nlocalparam WCKMUX = PORT_W_CLK_POL ? \\\"WCK\\\" : \\\"INV\\\";\\n\\nTRELLIS_DPR16X4 #(\\n\\t.INITVAL(INIT),\\n\\t.WCKMUX(WCKMUX),\\n\\t.WREMUX(\\\"WRE\\\")\\n) _TECHMAP_REPLACE_ (\\n\\t.RAD(PORT_R_ADDR),\\n\\t.DO(PORT_R_RD_DATA),\\n\\n\\t.WAD(PORT_W_ADDR),\\n\\t.DI(PORT_W_WR_DATA),\\n\\t.WCK(PORT_W_CLK),\\n\\t.WRE(PORT_W_WR_EN)\\n);\\n\\nendmodule\\n\",\n        },\n        \"mul2dsp.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *                2019  Eddie Hung    <eddie@fpgeh.com>\\n *                2019  gatecat <gatecat@ds0.me>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n *  ---\\n *\\n *  Tech-mapping rules for decomposing arbitrarily-sized $mul cells\\n *  into an equivalent collection of smaller `DSP_NAME cells (with the \\n *  same interface as $mul) no larger than `DSP_[AB]_MAXWIDTH, attached \\n *  to $shl and $add cells.\\n *\\n */\\n\\n`ifndef DSP_A_MAXWIDTH\\n$fatal(1, \\\"Macro DSP_A_MAXWIDTH must be defined\\\");\\n`endif\\n`ifndef DSP_B_MAXWIDTH\\n$fatal(1, \\\"Macro DSP_B_MAXWIDTH must be defined\\\");\\n`endif\\n`ifndef DSP_B_MAXWIDTH\\n$fatal(1, \\\"Macro DSP_B_MAXWIDTH must be defined\\\");\\n`endif\\n`ifndef DSP_A_MAXWIDTH_PARTIAL\\n`define DSP_A_MAXWIDTH_PARTIAL `DSP_A_MAXWIDTH\\n`endif\\n`ifndef DSP_B_MAXWIDTH_PARTIAL\\n`define DSP_B_MAXWIDTH_PARTIAL `DSP_B_MAXWIDTH\\n`endif\\n\\n`ifndef DSP_NAME\\n$fatal(1, \\\"Macro DSP_NAME must be defined\\\");\\n`endif\\n\\n`define MAX(a,b) (a > b ? a : b)\\n`define MIN(a,b) (a < b ? a : b)\\n\\n(* techmap_celltype = \\\"$mul $__mul\\\" *)\\nmodule _80_mul (A, B, Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\tparameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n\\n\\tgenerate\\n\\tif (0) begin end\\n`ifdef DSP_A_MINWIDTH\\n\\telse if (A_WIDTH < `DSP_A_MINWIDTH)\\n\\t\\twire _TECHMAP_FAIL_ = 1;\\n`endif\\n`ifdef DSP_B_MINWIDTH\\n\\telse if (B_WIDTH < `DSP_B_MINWIDTH)\\n\\t\\twire _TECHMAP_FAIL_ = 1;\\n`endif\\n`ifdef DSP_Y_MINWIDTH\\n\\telse if (Y_WIDTH < `DSP_Y_MINWIDTH)\\n\\t\\twire _TECHMAP_FAIL_ = 1;\\n`endif\\n`ifdef DSP_SIGNEDONLY\\n\\telse if (_TECHMAP_CELLTYPE_ == \\\"$mul\\\" && !A_SIGNED && !B_SIGNED)\\n\\t\\t\\\\$mul #(\\n\\t\\t\\t.A_SIGNED(1),\\n\\t\\t\\t.B_SIGNED(1),\\n\\t\\t\\t.A_WIDTH(A_WIDTH + 1),\\n\\t\\t\\t.B_WIDTH(B_WIDTH + 1),\\n\\t\\t\\t.Y_WIDTH(Y_WIDTH)\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t.A({1'b0, A}),\\n\\t\\t\\t.B({1'b0, B}),\\n\\t\\t\\t.Y(Y)\\n\\t\\t);\\n`endif\\n\\telse if (_TECHMAP_CELLTYPE_ == \\\"$mul\\\" && A_WIDTH < B_WIDTH)\\n\\t\\t\\\\$mul #(\\n\\t\\t\\t.A_SIGNED(B_SIGNED),\\n\\t\\t\\t.B_SIGNED(A_SIGNED),\\n\\t\\t\\t.A_WIDTH(B_WIDTH),\\n\\t\\t\\t.B_WIDTH(A_WIDTH),\\n\\t\\t\\t.Y_WIDTH(Y_WIDTH)\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t.A(B),\\n\\t\\t\\t.B(A),\\n\\t\\t\\t.Y(Y)\\n\\t\\t);\\n\\telse begin\\n\\t\\twire [1023:0] _TECHMAP_DO_ = \\\"proc; clean\\\";\\n\\n`ifdef DSP_SIGNEDONLY\\n\\t\\tlocalparam sign_headroom = 1;\\n`else\\n\\t\\tlocalparam sign_headroom = 0;\\n`endif\\n\\n\\t\\tgenvar i;\\n\\t\\tif (A_WIDTH > `DSP_A_MAXWIDTH) begin\\n\\t\\t\\tlocalparam n = (A_WIDTH-`DSP_A_MAXWIDTH+`DSP_A_MAXWIDTH_PARTIAL-sign_headroom-1) / (`DSP_A_MAXWIDTH_PARTIAL-sign_headroom);\\n\\t\\t\\tlocalparam partial_Y_WIDTH = `MIN(Y_WIDTH, B_WIDTH+`DSP_A_MAXWIDTH_PARTIAL);\\n\\t\\t\\tlocalparam last_A_WIDTH = A_WIDTH-n*(`DSP_A_MAXWIDTH_PARTIAL-sign_headroom);\\n\\t\\t\\tlocalparam last_Y_WIDTH = B_WIDTH+last_A_WIDTH;\\n\\t\\t\\tif (A_SIGNED && B_SIGNED) begin : blk\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire signed [partial_Y_WIDTH-1:0] partial [n-1:0];\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire signed [last_Y_WIDTH-1:0] last_partial;\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire signed [Y_WIDTH-1:0] partial_sum [n:0];\\n\\t\\t\\tend\\n\\t\\t\\telse begin : blk\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire [partial_Y_WIDTH-1:0] partial [n-1:0];\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire [last_Y_WIDTH-1:0] last_partial;\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire [Y_WIDTH-1:0] partial_sum [n:0];\\n\\t\\t\\tend\\n\\n\\t\\t\\tfor (i = 0; i < n; i=i+1) begin:sliceA\\n\\t\\t\\t\\t\\\\$__mul #(\\n\\t\\t\\t\\t\\t.A_SIGNED(sign_headroom),\\n\\t\\t\\t\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t\\t\\t\\t.A_WIDTH(`DSP_A_MAXWIDTH_PARTIAL),\\n\\t\\t\\t\\t\\t.B_WIDTH(B_WIDTH),\\n\\t\\t\\t\\t\\t.Y_WIDTH(partial_Y_WIDTH)\\n\\t\\t\\t\\t) mul (\\n\\t\\t\\t\\t\\t.A({{sign_headroom{1'b0}}, A[i*(`DSP_A_MAXWIDTH_PARTIAL-sign_headroom) +: `DSP_A_MAXWIDTH_PARTIAL-sign_headroom]}),\\n\\t\\t\\t\\t\\t.B(B),\\n\\t\\t\\t\\t\\t.Y(blk.partial[i])\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t// TODO: Currently a 'cascade' approach to summing the partial\\n\\t\\t\\t\\t//       products is taken here, but a more efficient 'binary\\n\\t\\t\\t\\t//       reduction' approach also exists...\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tassign blk.partial_sum[i] = blk.partial[i];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tassign blk.partial_sum[i] = (blk.partial[i] << (* mul2dsp *) i*(`DSP_A_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[i-1];\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\\$__mul #(\\n\\t\\t\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t\\t\\t.A_WIDTH(last_A_WIDTH),\\n\\t\\t\\t\\t.B_WIDTH(B_WIDTH),\\n\\t\\t\\t\\t.Y_WIDTH(last_Y_WIDTH)\\n\\t\\t\\t) sliceA.last (\\n\\t\\t\\t\\t.A(A[A_WIDTH-1 -: last_A_WIDTH]),\\n\\t\\t\\t\\t.B(B),\\n\\t\\t\\t\\t.Y(blk.last_partial)\\n\\t\\t\\t);\\n\\t\\t\\tassign blk.partial_sum[n] = (blk.last_partial << (* mul2dsp *) n*(`DSP_A_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[n-1];\\n\\t\\t\\tassign Y = blk.partial_sum[n];\\n\\t\\tend\\n\\t\\telse if (B_WIDTH > `DSP_B_MAXWIDTH) begin\\n\\t\\t\\tlocalparam n = (B_WIDTH-`DSP_B_MAXWIDTH+`DSP_B_MAXWIDTH_PARTIAL-sign_headroom-1) / (`DSP_B_MAXWIDTH_PARTIAL-sign_headroom);\\n\\t\\t\\tlocalparam partial_Y_WIDTH = `MIN(Y_WIDTH, A_WIDTH+`DSP_B_MAXWIDTH_PARTIAL);\\n\\t\\t\\tlocalparam last_B_WIDTH = B_WIDTH-n*(`DSP_B_MAXWIDTH_PARTIAL-sign_headroom);\\n\\t\\t\\tlocalparam last_Y_WIDTH = A_WIDTH+last_B_WIDTH;\\n\\t\\t\\tif (A_SIGNED && B_SIGNED) begin : blk\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire signed [partial_Y_WIDTH-1:0] partial [n-1:0];\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire signed [last_Y_WIDTH-1:0] last_partial;\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire signed [Y_WIDTH-1:0] partial_sum [n:0];\\n\\t\\t\\tend\\n\\t\\t\\telse begin : blk\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire [partial_Y_WIDTH-1:0] partial [n-1:0];\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire [last_Y_WIDTH-1:0] last_partial;\\n\\t\\t\\t\\t(* force_downto *)\\n\\t\\t\\t\\twire [Y_WIDTH-1:0] partial_sum [n:0];\\n\\t\\t\\tend\\n\\n\\t\\t\\tfor (i = 0; i < n; i=i+1) begin:sliceB\\n\\t\\t\\t\\t\\\\$__mul #(\\n\\t\\t\\t\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t\\t\\t\\t.B_SIGNED(sign_headroom),\\n\\t\\t\\t\\t\\t.A_WIDTH(A_WIDTH),\\n\\t\\t\\t\\t\\t.B_WIDTH(`DSP_B_MAXWIDTH_PARTIAL),\\n\\t\\t\\t\\t\\t.Y_WIDTH(partial_Y_WIDTH)\\n\\t\\t\\t\\t) mul (\\n\\t\\t\\t\\t\\t.A(A),\\n\\t\\t\\t\\t\\t.B({{sign_headroom{1'b0}}, B[i*(`DSP_B_MAXWIDTH_PARTIAL-sign_headroom) +: `DSP_B_MAXWIDTH_PARTIAL-sign_headroom]}),\\n\\t\\t\\t\\t\\t.Y(blk.partial[i])\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t// TODO: Currently a 'cascade' approach to summing the partial\\n\\t\\t\\t\\t//       products is taken here, but a more efficient 'binary\\n\\t\\t\\t\\t//       reduction' approach also exists...\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tassign blk.partial_sum[i] = blk.partial[i];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tassign blk.partial_sum[i] = (blk.partial[i] << (* mul2dsp *) i*(`DSP_B_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[i-1];\\n\\t\\t\\tend\\n\\n\\t\\t\\t\\\\$__mul #(\\n\\t\\t\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t\\t\\t.A_WIDTH(A_WIDTH),\\n\\t\\t\\t\\t.B_WIDTH(last_B_WIDTH),\\n\\t\\t\\t\\t.Y_WIDTH(last_Y_WIDTH)\\n\\t\\t\\t) mul_sliceB_last (\\n\\t\\t\\t\\t.A(A),\\n\\t\\t\\t\\t.B(B[B_WIDTH-1 -: last_B_WIDTH]),\\n\\t\\t\\t\\t.Y(blk.last_partial)\\n\\t\\t\\t);\\n\\t\\t\\tassign blk.partial_sum[n] = (blk.last_partial << (* mul2dsp *) n*(`DSP_B_MAXWIDTH_PARTIAL-sign_headroom)) + (* mul2dsp *) blk.partial_sum[n-1];\\n\\t\\t\\tassign Y = blk.partial_sum[n];\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\tif (A_SIGNED) begin : blkA\\n\\t\\t\\t\\twire signed [`DSP_A_MAXWIDTH-1:0] Aext = $signed(A);\\n\\t\\t\\tend\\n\\t\\t\\telse begin : blkA\\n\\t\\t\\t\\twire [`DSP_A_MAXWIDTH-1:0] Aext = A;\\n\\t\\t\\tend\\n\\t\\t\\tif (B_SIGNED) begin : blkB\\n\\t\\t\\t\\twire signed [`DSP_B_MAXWIDTH-1:0] Bext = $signed(B);\\n\\t\\t\\tend\\n\\t\\t\\telse begin : blkB\\n\\t\\t\\t\\twire [`DSP_B_MAXWIDTH-1:0] Bext = B;\\n\\t\\t\\tend\\n\\n\\t\\t\\t`DSP_NAME #(\\n\\t\\t\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t\\t\\t.A_WIDTH(`DSP_A_MAXWIDTH),\\n\\t\\t\\t\\t.B_WIDTH(`DSP_B_MAXWIDTH),\\n\\t\\t\\t\\t.Y_WIDTH(`MIN(Y_WIDTH,`DSP_A_MAXWIDTH+`DSP_B_MAXWIDTH)),\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t.A(blkA.Aext),\\n\\t\\t\\t\\t.B(blkB.Bext),\\n\\t\\t\\t\\t.Y(Y)\\n\\t\\t\\t);\\n\\t\\tend\\n\\tend\\n\\tendgenerate\\nendmodule\\n\\n(* techmap_celltype = \\\"$mul $__mul\\\" *)\\nmodule _90_soft_mul (A, B, Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\t// Indirection necessary since mapping\\n\\t//   back to $mul will cause recursion\\n\\tgenerate\\n\\tif (A_SIGNED && !B_SIGNED)\\n\\t\\t\\\\$__soft_mul #(\\n\\t\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t\\t.B_SIGNED(1),\\n\\t\\t\\t.A_WIDTH(A_WIDTH),\\n\\t\\t\\t.B_WIDTH(B_WIDTH+1),\\n\\t\\t\\t.Y_WIDTH(Y_WIDTH)\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t.A(A),\\n\\t\\t\\t.B({1'b0,B}),\\n\\t\\t\\t.Y(Y)\\n\\t\\t);\\n\\telse if (!A_SIGNED && B_SIGNED)\\n\\t\\t\\\\$__soft_mul #(\\n\\t\\t\\t.A_SIGNED(1),\\n\\t\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t\\t.A_WIDTH(A_WIDTH+1),\\n\\t\\t\\t.B_WIDTH(B_WIDTH),\\n\\t\\t\\t.Y_WIDTH(Y_WIDTH)\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t.A({1'b0,A}),\\n\\t\\t\\t.B(B),\\n\\t\\t\\t.Y(Y)\\n\\t\\t);\\n\\telse\\n\\t\\t\\\\$__soft_mul #(\\n\\t\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t\\t.A_WIDTH(A_WIDTH),\\n\\t\\t\\t.B_WIDTH(B_WIDTH),\\n\\t\\t\\t.Y_WIDTH(Y_WIDTH)\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t.A(A),\\n\\t\\t\\t.B(B),\\n\\t\\t\\t.Y(Y)\\n\\t\\t);\\n\\tendgenerate\\nendmodule\\n\",\n        \"nexus\": {\n            \"arith_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *  Copyright (C) 2018  gatecat <gatecat@ds0.me>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_nexus_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 4;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\tfunction integer round_up2;\\n\\t\\tinput integer N;\\n\\t\\tbegin\\n\\t\\t\\tround_up2 = ((N + 1) / 2) * 2;\\n\\t\\tend\\n\\tendfunction\\n\\n\\tlocalparam Y_WIDTH2 = round_up2(Y_WIDTH);\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] BB = BI ? ~B_buf : B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2-1:0] BX = B_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH2+1:0] FCO, Y1;\\n\\n\\tgenvar i;\\n\\n\\t// Carry feed-in\\n\\tCCU2 #(\\n\\t\\t.INIT0(\\\"0xFFFF\\\"),\\n\\t\\t.INIT1(\\\"0x00AA\\\"),\\n\\t\\t.INJECT(\\\"NO\\\")\\n\\t) ccu2c_i (\\n\\t\\t.A0(1'b1), .B0(1'b1), .C0(1'b1), .D0(1'b1),\\n\\t\\t.A1(CI), .B1(1'b1), .C1(1'b1), .D1(1'b1),\\n\\t\\t.COUT(FCO[0])\\n\\t);\\n\\n\\tgenerate for (i = 0; i < Y_WIDTH2; i = i + 2) begin:slice\\n\\t\\tCCU2 #(\\n\\t\\t\\t.INIT0(\\\"0x96AA\\\"),\\n\\t\\t\\t.INIT1(\\\"0x96AA\\\"),\\n\\t\\t\\t.INJECT(\\\"NO\\\")\\n\\t\\t) ccu2c_i (\\n\\t\\t\\t.CIN(FCO[i]),\\n\\t\\t\\t.A0(AA[i]), .B0(BX[i]), .C0(BI), .D0(1'b1),\\n\\t\\t\\t.A1(AA[i+1]), .B1(BX[i+1]), .C1(BI), .D1(1'b1),\\n\\t\\t\\t.S0(Y[i]), .S1(Y1[i]),\\n\\t\\t\\t.COUT(FCO[i+2])\\n\\t\\t);\\n\\n\\t\\tassign CO[i] = (AA[i] && BB[i]) || ((Y[i] ^ AA[i] ^ BB[i]) && (AA[i] || BB[i]));\\n\\t\\tif (i+1 < Y_WIDTH) begin\\n\\t\\t\\tassign CO[i + 1] = (AA[i + 1] && BB[i + 1]) || ((Y[i + 1] ^ AA[i + 1] ^ BB[i + 1]) && (AA[i + 1] || BB[i + 1]));\\n\\t\\t\\tassign Y[i+1] = Y1[i];\\n\\t\\tend\\n\\tend endgenerate\\n\\n\\tassign X = AA ^ BB;\\nendmodule\\n\",\n            \"brams.txt\": \"ram block $__NX_DP16K_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 per_port;\\n\\tbyte 9;\\n\\tcost 129;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t\\twrbe_separate;\\n\\t\\trdwr no_change;\\n\\t\\tportoption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero gated_clken;\\n\\t\\t}\\n\\t\\tportoption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n}\\n\\nram block $__NX_PDP16K_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 36 per_port;\\n\\tbyte 9;\\n\\toption \\\"SAME_CLOCK\\\" 1 cost 128;\\n\\toption \\\"SAME_CLOCK\\\" 0 cost 129;\\n\\tinit no_undef;\\n\\tport sr \\\"R\\\" {\\n\\t\\toption \\\"SAME_CLOCK\\\" 1 clock posedge \\\"C\\\";\\n\\t\\toption \\\"SAME_CLOCK\\\" 0 clock posedge;\\n\\t\\tclken;\\n\\t\\tportoption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero gated_clken;\\n\\t\\t}\\n\\t\\tportoption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t}\\n\\tport sw \\\"W\\\" {\\n\\t\\toption \\\"SAME_CLOCK\\\" 1 clock posedge \\\"C\\\";\\n\\t\\toption \\\"SAME_CLOCK\\\" 0 clock posedge;\\n\\t\\tclken;\\n\\t\\toption \\\"SAME_CLOCK\\\" 1 wrtrans all old;\\n\\t}\\n}\\n\",\n            \"brams_map.v\": \"module $__NX_DP16K_ (...);\\n\\nparameter INIT = 0;\\n\\nparameter PORT_A_OPTION_RESETMODE = \\\"SYNC\\\";\\nparameter PORT_A_WIDTH = 18;\\nparameter PORT_A_WR_BE_WIDTH = 2;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput PORT_A_WR_EN;\\ninput PORT_A_RD_SRST;\\ninput PORT_A_RD_ARST;\\ninput [13:0] PORT_A_ADDR;\\ninput [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\n\\nparameter PORT_B_OPTION_RESETMODE = \\\"SYNC\\\";\\nparameter PORT_B_WIDTH = 18;\\nparameter PORT_B_WR_BE_WIDTH = 2;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput PORT_B_WR_EN;\\ninput PORT_B_RD_SRST;\\ninput PORT_B_RD_ARST;\\ninput [13:0] PORT_B_ADDR;\\ninput [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\n\\nfunction [319:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tinit_slice = 0;\\n\\tfor (i = 0; i < 32; i = i + 1) begin\\n\\t\\tinit_slice[i*10+:9] = INIT[(idx * 32 + i) * 9+:9];\\n\\tend\\nendfunction\\n\\nwire [17:0] DOA;\\nwire [17:0] DOB;\\nwire [17:0] DIA = PORT_A_WR_DATA;\\nwire [17:0] DIB = PORT_B_WR_DATA;\\nwire [13:0] ADA;\\nwire [13:0] ADB;\\n\\ngenerate\\n\\ncase(PORT_A_WIDTH)\\n1: assign ADA = PORT_A_ADDR;\\n2: assign ADA = {PORT_A_ADDR[13:1], 1'b1};\\n4: assign ADA = {PORT_A_ADDR[13:2], 2'b11};\\n9: assign ADA = {PORT_A_ADDR[13:3], 3'b111};\\n18: assign ADA = {PORT_A_ADDR[13:4], 2'b11, PORT_A_WR_BE};\\nendcase\\n\\ncase(PORT_B_WIDTH)\\n1: assign ADB = PORT_B_ADDR;\\n2: assign ADB = {PORT_B_ADDR[13:1], 1'b1};\\n4: assign ADB = {PORT_B_ADDR[13:2], 2'b11};\\n9: assign ADB = {PORT_B_ADDR[13:3], 3'b111};\\n18: assign ADB = {PORT_B_ADDR[13:4], 2'b11, PORT_B_WR_BE};\\nendcase\\n\\nendgenerate\\n\\nassign PORT_A_RD_DATA = DOA;\\nassign PORT_B_RD_DATA = DOB;\\n\\nDP16K #(\\n\\t.INITVAL_00($sformatf(\\\"0x%080x\\\", init_slice('h00))),\\n\\t.INITVAL_01($sformatf(\\\"0x%080x\\\", init_slice('h01))),\\n\\t.INITVAL_02($sformatf(\\\"0x%080x\\\", init_slice('h02))),\\n\\t.INITVAL_03($sformatf(\\\"0x%080x\\\", init_slice('h03))),\\n\\t.INITVAL_04($sformatf(\\\"0x%080x\\\", init_slice('h04))),\\n\\t.INITVAL_05($sformatf(\\\"0x%080x\\\", init_slice('h05))),\\n\\t.INITVAL_06($sformatf(\\\"0x%080x\\\", init_slice('h06))),\\n\\t.INITVAL_07($sformatf(\\\"0x%080x\\\", init_slice('h07))),\\n\\t.INITVAL_08($sformatf(\\\"0x%080x\\\", init_slice('h08))),\\n\\t.INITVAL_09($sformatf(\\\"0x%080x\\\", init_slice('h09))),\\n\\t.INITVAL_0A($sformatf(\\\"0x%080x\\\", init_slice('h0a))),\\n\\t.INITVAL_0B($sformatf(\\\"0x%080x\\\", init_slice('h0b))),\\n\\t.INITVAL_0C($sformatf(\\\"0x%080x\\\", init_slice('h0c))),\\n\\t.INITVAL_0D($sformatf(\\\"0x%080x\\\", init_slice('h0d))),\\n\\t.INITVAL_0E($sformatf(\\\"0x%080x\\\", init_slice('h0e))),\\n\\t.INITVAL_0F($sformatf(\\\"0x%080x\\\", init_slice('h0f))),\\n\\t.INITVAL_10($sformatf(\\\"0x%080x\\\", init_slice('h10))),\\n\\t.INITVAL_11($sformatf(\\\"0x%080x\\\", init_slice('h11))),\\n\\t.INITVAL_12($sformatf(\\\"0x%080x\\\", init_slice('h12))),\\n\\t.INITVAL_13($sformatf(\\\"0x%080x\\\", init_slice('h13))),\\n\\t.INITVAL_14($sformatf(\\\"0x%080x\\\", init_slice('h14))),\\n\\t.INITVAL_15($sformatf(\\\"0x%080x\\\", init_slice('h15))),\\n\\t.INITVAL_16($sformatf(\\\"0x%080x\\\", init_slice('h16))),\\n\\t.INITVAL_17($sformatf(\\\"0x%080x\\\", init_slice('h17))),\\n\\t.INITVAL_18($sformatf(\\\"0x%080x\\\", init_slice('h18))),\\n\\t.INITVAL_19($sformatf(\\\"0x%080x\\\", init_slice('h19))),\\n\\t.INITVAL_1A($sformatf(\\\"0x%080x\\\", init_slice('h1a))),\\n\\t.INITVAL_1B($sformatf(\\\"0x%080x\\\", init_slice('h1b))),\\n\\t.INITVAL_1C($sformatf(\\\"0x%080x\\\", init_slice('h1c))),\\n\\t.INITVAL_1D($sformatf(\\\"0x%080x\\\", init_slice('h1d))),\\n\\t.INITVAL_1E($sformatf(\\\"0x%080x\\\", init_slice('h1e))),\\n\\t.INITVAL_1F($sformatf(\\\"0x%080x\\\", init_slice('h1f))),\\n\\t.INITVAL_20($sformatf(\\\"0x%080x\\\", init_slice('h20))),\\n\\t.INITVAL_21($sformatf(\\\"0x%080x\\\", init_slice('h21))),\\n\\t.INITVAL_22($sformatf(\\\"0x%080x\\\", init_slice('h22))),\\n\\t.INITVAL_23($sformatf(\\\"0x%080x\\\", init_slice('h23))),\\n\\t.INITVAL_24($sformatf(\\\"0x%080x\\\", init_slice('h24))),\\n\\t.INITVAL_25($sformatf(\\\"0x%080x\\\", init_slice('h25))),\\n\\t.INITVAL_26($sformatf(\\\"0x%080x\\\", init_slice('h26))),\\n\\t.INITVAL_27($sformatf(\\\"0x%080x\\\", init_slice('h27))),\\n\\t.INITVAL_28($sformatf(\\\"0x%080x\\\", init_slice('h28))),\\n\\t.INITVAL_29($sformatf(\\\"0x%080x\\\", init_slice('h29))),\\n\\t.INITVAL_2A($sformatf(\\\"0x%080x\\\", init_slice('h2a))),\\n\\t.INITVAL_2B($sformatf(\\\"0x%080x\\\", init_slice('h2b))),\\n\\t.INITVAL_2C($sformatf(\\\"0x%080x\\\", init_slice('h2c))),\\n\\t.INITVAL_2D($sformatf(\\\"0x%080x\\\", init_slice('h2d))),\\n\\t.INITVAL_2E($sformatf(\\\"0x%080x\\\", init_slice('h2e))),\\n\\t.INITVAL_2F($sformatf(\\\"0x%080x\\\", init_slice('h2f))),\\n\\t.INITVAL_30($sformatf(\\\"0x%080x\\\", init_slice('h30))),\\n\\t.INITVAL_31($sformatf(\\\"0x%080x\\\", init_slice('h31))),\\n\\t.INITVAL_32($sformatf(\\\"0x%080x\\\", init_slice('h32))),\\n\\t.INITVAL_33($sformatf(\\\"0x%080x\\\", init_slice('h33))),\\n\\t.INITVAL_34($sformatf(\\\"0x%080x\\\", init_slice('h34))),\\n\\t.INITVAL_35($sformatf(\\\"0x%080x\\\", init_slice('h35))),\\n\\t.INITVAL_36($sformatf(\\\"0x%080x\\\", init_slice('h36))),\\n\\t.INITVAL_37($sformatf(\\\"0x%080x\\\", init_slice('h37))),\\n\\t.INITVAL_38($sformatf(\\\"0x%080x\\\", init_slice('h38))),\\n\\t.INITVAL_39($sformatf(\\\"0x%080x\\\", init_slice('h39))),\\n\\t.INITVAL_3A($sformatf(\\\"0x%080x\\\", init_slice('h3a))),\\n\\t.INITVAL_3B($sformatf(\\\"0x%080x\\\", init_slice('h3b))),\\n\\t.INITVAL_3C($sformatf(\\\"0x%080x\\\", init_slice('h3c))),\\n\\t.INITVAL_3D($sformatf(\\\"0x%080x\\\", init_slice('h3d))),\\n\\t.INITVAL_3E($sformatf(\\\"0x%080x\\\", init_slice('h3e))),\\n\\t.INITVAL_3F($sformatf(\\\"0x%080x\\\", init_slice('h3f))),\\n\\t.DATA_WIDTH_A($sformatf(\\\"X%0d\\\", PORT_A_WIDTH)),\\n\\t.DATA_WIDTH_B($sformatf(\\\"X%0d\\\", PORT_B_WIDTH)),\\n\\t.OUTREG_A(\\\"BYPASSED\\\"),\\n\\t.OUTREG_B(\\\"BYPASSED\\\"),\\n\\t.RESETMODE_A(PORT_A_OPTION_RESETMODE),\\n\\t.RESETMODE_B(PORT_B_OPTION_RESETMODE),\\n\\t.ASYNC_RST_RELEASE_A(PORT_A_OPTION_RESETMODE),\\n\\t.ASYNC_RST_RELEASE_B(PORT_B_OPTION_RESETMODE),\\n\\t.CSDECODE_A(\\\"111\\\"),\\n\\t.CSDECODE_B(\\\"111\\\"),\\n\\t.GSR(\\\"DISABLED\\\"),\\n) _TECHMAP_REPLACE_ (\\n\\t.CLKA(PORT_A_CLK),\\n\\t.WEA(PORT_A_WIDTH == 18 ? PORT_A_WR_EN : (PORT_A_WR_EN | PORT_A_WR_BE[0])),\\n\\t.CEA(PORT_A_CLK_EN),\\n\\t.RSTA(PORT_A_OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST),\\n\\t.CSA(3'b111),\\n\\t.DIA(DIA),\\n\\t.DOA(DOA),\\n\\t.ADA(ADA),\\n\\n\\t.CLKB(PORT_B_CLK),\\n\\t.WEB(PORT_B_WIDTH == 18 ? PORT_B_WR_EN : (PORT_B_WR_EN | PORT_B_WR_BE[0])),\\n\\t.CEB(PORT_B_CLK_EN),\\n\\t.RSTB(PORT_B_OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_B_RD_SRST : PORT_B_RD_ARST),\\n\\t.CSB(3'b111),\\n\\t.ADB(ADB),\\n\\t.DIB(DIB),\\n\\t.DOB(DOB),\\n);\\n\\nendmodule\\n\\n\\nmodule $__NX_PDP16K_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_SAME_CLOCK = 1;\\n\\nparameter PORT_R_WIDTH = 36;\\nparameter PORT_R_OPTION_RESETMODE = \\\"SYNC\\\";\\n\\ninput CLK_C;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput PORT_R_RD_SRST;\\ninput PORT_R_RD_ARST;\\ninput [13:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\n\\nparameter PORT_W_WIDTH = 36;\\nparameter PORT_W_WR_EN_WIDTH = 4;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput [13:0] PORT_W_ADDR;\\ninput [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\n\\nfunction [319:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tinit_slice = 0;\\n\\tfor (i = 0; i < 32; i = i + 1) begin\\n\\t\\tinit_slice[i*10+:9] = INIT[(idx * 32 + i) * 9+:9];\\n\\tend\\nendfunction\\n\\nwire [35:0] DI = PORT_W_WR_DATA;\\nwire [35:0] DO;\\n\\nassign PORT_R_RD_DATA = DO;\\n\\nwire [13:0] ADW;\\nwire [13:0] ADR;\\n\\ngenerate\\n\\ncase (PORT_W_WIDTH)\\n1: assign ADW = PORT_W_ADDR;\\n2: assign ADW = {PORT_W_ADDR[13:1], 1'b1};\\n4: assign ADW = {PORT_W_ADDR[13:2], 2'b11};\\n9: assign ADW = {PORT_W_ADDR[13:3], 3'b111};\\n18: assign ADW = {PORT_W_ADDR[13:4], 2'b11, PORT_W_WR_EN};\\n36: assign ADW = {PORT_W_ADDR[13:5], 1'b1, PORT_W_WR_EN};\\nendcase\\n\\ncase (PORT_R_WIDTH)\\n1: assign ADR = PORT_R_ADDR;\\n2: assign ADR = {PORT_R_ADDR[13:1], 1'b1};\\n4: assign ADR = {PORT_R_ADDR[13:2], 2'b11};\\n9: assign ADR = {PORT_R_ADDR[13:3], 3'b111};\\n18: assign ADR = {PORT_R_ADDR[13:4], 4'b1111};\\n36: assign ADR = {PORT_R_ADDR[13:5], 5'b11111};\\nendcase\\n\\nif (OPTION_SAME_CLOCK) begin\\n\\nPDPSC16K #(\\n\\t.INITVAL_00($sformatf(\\\"0x%080x\\\", init_slice('h00))),\\n\\t.INITVAL_01($sformatf(\\\"0x%080x\\\", init_slice('h01))),\\n\\t.INITVAL_02($sformatf(\\\"0x%080x\\\", init_slice('h02))),\\n\\t.INITVAL_03($sformatf(\\\"0x%080x\\\", init_slice('h03))),\\n\\t.INITVAL_04($sformatf(\\\"0x%080x\\\", init_slice('h04))),\\n\\t.INITVAL_05($sformatf(\\\"0x%080x\\\", init_slice('h05))),\\n\\t.INITVAL_06($sformatf(\\\"0x%080x\\\", init_slice('h06))),\\n\\t.INITVAL_07($sformatf(\\\"0x%080x\\\", init_slice('h07))),\\n\\t.INITVAL_08($sformatf(\\\"0x%080x\\\", init_slice('h08))),\\n\\t.INITVAL_09($sformatf(\\\"0x%080x\\\", init_slice('h09))),\\n\\t.INITVAL_0A($sformatf(\\\"0x%080x\\\", init_slice('h0a))),\\n\\t.INITVAL_0B($sformatf(\\\"0x%080x\\\", init_slice('h0b))),\\n\\t.INITVAL_0C($sformatf(\\\"0x%080x\\\", init_slice('h0c))),\\n\\t.INITVAL_0D($sformatf(\\\"0x%080x\\\", init_slice('h0d))),\\n\\t.INITVAL_0E($sformatf(\\\"0x%080x\\\", init_slice('h0e))),\\n\\t.INITVAL_0F($sformatf(\\\"0x%080x\\\", init_slice('h0f))),\\n\\t.INITVAL_10($sformatf(\\\"0x%080x\\\", init_slice('h10))),\\n\\t.INITVAL_11($sformatf(\\\"0x%080x\\\", init_slice('h11))),\\n\\t.INITVAL_12($sformatf(\\\"0x%080x\\\", init_slice('h12))),\\n\\t.INITVAL_13($sformatf(\\\"0x%080x\\\", init_slice('h13))),\\n\\t.INITVAL_14($sformatf(\\\"0x%080x\\\", init_slice('h14))),\\n\\t.INITVAL_15($sformatf(\\\"0x%080x\\\", init_slice('h15))),\\n\\t.INITVAL_16($sformatf(\\\"0x%080x\\\", init_slice('h16))),\\n\\t.INITVAL_17($sformatf(\\\"0x%080x\\\", init_slice('h17))),\\n\\t.INITVAL_18($sformatf(\\\"0x%080x\\\", init_slice('h18))),\\n\\t.INITVAL_19($sformatf(\\\"0x%080x\\\", init_slice('h19))),\\n\\t.INITVAL_1A($sformatf(\\\"0x%080x\\\", init_slice('h1a))),\\n\\t.INITVAL_1B($sformatf(\\\"0x%080x\\\", init_slice('h1b))),\\n\\t.INITVAL_1C($sformatf(\\\"0x%080x\\\", init_slice('h1c))),\\n\\t.INITVAL_1D($sformatf(\\\"0x%080x\\\", init_slice('h1d))),\\n\\t.INITVAL_1E($sformatf(\\\"0x%080x\\\", init_slice('h1e))),\\n\\t.INITVAL_1F($sformatf(\\\"0x%080x\\\", init_slice('h1f))),\\n\\t.INITVAL_20($sformatf(\\\"0x%080x\\\", init_slice('h20))),\\n\\t.INITVAL_21($sformatf(\\\"0x%080x\\\", init_slice('h21))),\\n\\t.INITVAL_22($sformatf(\\\"0x%080x\\\", init_slice('h22))),\\n\\t.INITVAL_23($sformatf(\\\"0x%080x\\\", init_slice('h23))),\\n\\t.INITVAL_24($sformatf(\\\"0x%080x\\\", init_slice('h24))),\\n\\t.INITVAL_25($sformatf(\\\"0x%080x\\\", init_slice('h25))),\\n\\t.INITVAL_26($sformatf(\\\"0x%080x\\\", init_slice('h26))),\\n\\t.INITVAL_27($sformatf(\\\"0x%080x\\\", init_slice('h27))),\\n\\t.INITVAL_28($sformatf(\\\"0x%080x\\\", init_slice('h28))),\\n\\t.INITVAL_29($sformatf(\\\"0x%080x\\\", init_slice('h29))),\\n\\t.INITVAL_2A($sformatf(\\\"0x%080x\\\", init_slice('h2a))),\\n\\t.INITVAL_2B($sformatf(\\\"0x%080x\\\", init_slice('h2b))),\\n\\t.INITVAL_2C($sformatf(\\\"0x%080x\\\", init_slice('h2c))),\\n\\t.INITVAL_2D($sformatf(\\\"0x%080x\\\", init_slice('h2d))),\\n\\t.INITVAL_2E($sformatf(\\\"0x%080x\\\", init_slice('h2e))),\\n\\t.INITVAL_2F($sformatf(\\\"0x%080x\\\", init_slice('h2f))),\\n\\t.INITVAL_30($sformatf(\\\"0x%080x\\\", init_slice('h30))),\\n\\t.INITVAL_31($sformatf(\\\"0x%080x\\\", init_slice('h31))),\\n\\t.INITVAL_32($sformatf(\\\"0x%080x\\\", init_slice('h32))),\\n\\t.INITVAL_33($sformatf(\\\"0x%080x\\\", init_slice('h33))),\\n\\t.INITVAL_34($sformatf(\\\"0x%080x\\\", init_slice('h34))),\\n\\t.INITVAL_35($sformatf(\\\"0x%080x\\\", init_slice('h35))),\\n\\t.INITVAL_36($sformatf(\\\"0x%080x\\\", init_slice('h36))),\\n\\t.INITVAL_37($sformatf(\\\"0x%080x\\\", init_slice('h37))),\\n\\t.INITVAL_38($sformatf(\\\"0x%080x\\\", init_slice('h38))),\\n\\t.INITVAL_39($sformatf(\\\"0x%080x\\\", init_slice('h39))),\\n\\t.INITVAL_3A($sformatf(\\\"0x%080x\\\", init_slice('h3a))),\\n\\t.INITVAL_3B($sformatf(\\\"0x%080x\\\", init_slice('h3b))),\\n\\t.INITVAL_3C($sformatf(\\\"0x%080x\\\", init_slice('h3c))),\\n\\t.INITVAL_3D($sformatf(\\\"0x%080x\\\", init_slice('h3d))),\\n\\t.INITVAL_3E($sformatf(\\\"0x%080x\\\", init_slice('h3e))),\\n\\t.INITVAL_3F($sformatf(\\\"0x%080x\\\", init_slice('h3f))),\\n\\t.DATA_WIDTH_W($sformatf(\\\"X%0d\\\", PORT_W_WIDTH)),\\n\\t.DATA_WIDTH_R($sformatf(\\\"X%0d\\\", PORT_R_WIDTH)),\\n\\t.OUTREG(\\\"BYPASSED\\\"),\\n\\t.RESETMODE(PORT_R_OPTION_RESETMODE),\\n\\t.ASYNC_RST_RELEASE(PORT_R_OPTION_RESETMODE),\\n\\t.CSDECODE_W(\\\"111\\\"),\\n\\t.CSDECODE_R(\\\"111\\\"),\\n\\t.ECC(\\\"DISABLED\\\"),\\n\\t.GSR(\\\"DISABLED\\\"),\\n) _TECHMAP_REPLACE_ (\\n\\t.CLK(CLK_C),\\n\\n\\t.CEW(PORT_W_CLK_EN & (|PORT_W_WR_EN)),\\n\\t.CSW(3'b111),\\n\\t.ADW(ADW),\\n\\t.DI(DI),\\n\\n\\t.CER(PORT_R_CLK_EN),\\n\\t.RST(PORT_R_OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_R_RD_SRST : PORT_R_RD_ARST),\\n\\t.CSR(3'b111),\\n\\t.ADR(ADR),\\n\\t.DO(DO),\\n);\\n\\nend else begin\\n\\nPDP16K #(\\n\\t.INITVAL_00($sformatf(\\\"0x%080x\\\", init_slice('h00))),\\n\\t.INITVAL_01($sformatf(\\\"0x%080x\\\", init_slice('h01))),\\n\\t.INITVAL_02($sformatf(\\\"0x%080x\\\", init_slice('h02))),\\n\\t.INITVAL_03($sformatf(\\\"0x%080x\\\", init_slice('h03))),\\n\\t.INITVAL_04($sformatf(\\\"0x%080x\\\", init_slice('h04))),\\n\\t.INITVAL_05($sformatf(\\\"0x%080x\\\", init_slice('h05))),\\n\\t.INITVAL_06($sformatf(\\\"0x%080x\\\", init_slice('h06))),\\n\\t.INITVAL_07($sformatf(\\\"0x%080x\\\", init_slice('h07))),\\n\\t.INITVAL_08($sformatf(\\\"0x%080x\\\", init_slice('h08))),\\n\\t.INITVAL_09($sformatf(\\\"0x%080x\\\", init_slice('h09))),\\n\\t.INITVAL_0A($sformatf(\\\"0x%080x\\\", init_slice('h0a))),\\n\\t.INITVAL_0B($sformatf(\\\"0x%080x\\\", init_slice('h0b))),\\n\\t.INITVAL_0C($sformatf(\\\"0x%080x\\\", init_slice('h0c))),\\n\\t.INITVAL_0D($sformatf(\\\"0x%080x\\\", init_slice('h0d))),\\n\\t.INITVAL_0E($sformatf(\\\"0x%080x\\\", init_slice('h0e))),\\n\\t.INITVAL_0F($sformatf(\\\"0x%080x\\\", init_slice('h0f))),\\n\\t.INITVAL_10($sformatf(\\\"0x%080x\\\", init_slice('h10))),\\n\\t.INITVAL_11($sformatf(\\\"0x%080x\\\", init_slice('h11))),\\n\\t.INITVAL_12($sformatf(\\\"0x%080x\\\", init_slice('h12))),\\n\\t.INITVAL_13($sformatf(\\\"0x%080x\\\", init_slice('h13))),\\n\\t.INITVAL_14($sformatf(\\\"0x%080x\\\", init_slice('h14))),\\n\\t.INITVAL_15($sformatf(\\\"0x%080x\\\", init_slice('h15))),\\n\\t.INITVAL_16($sformatf(\\\"0x%080x\\\", init_slice('h16))),\\n\\t.INITVAL_17($sformatf(\\\"0x%080x\\\", init_slice('h17))),\\n\\t.INITVAL_18($sformatf(\\\"0x%080x\\\", init_slice('h18))),\\n\\t.INITVAL_19($sformatf(\\\"0x%080x\\\", init_slice('h19))),\\n\\t.INITVAL_1A($sformatf(\\\"0x%080x\\\", init_slice('h1a))),\\n\\t.INITVAL_1B($sformatf(\\\"0x%080x\\\", init_slice('h1b))),\\n\\t.INITVAL_1C($sformatf(\\\"0x%080x\\\", init_slice('h1c))),\\n\\t.INITVAL_1D($sformatf(\\\"0x%080x\\\", init_slice('h1d))),\\n\\t.INITVAL_1E($sformatf(\\\"0x%080x\\\", init_slice('h1e))),\\n\\t.INITVAL_1F($sformatf(\\\"0x%080x\\\", init_slice('h1f))),\\n\\t.INITVAL_20($sformatf(\\\"0x%080x\\\", init_slice('h20))),\\n\\t.INITVAL_21($sformatf(\\\"0x%080x\\\", init_slice('h21))),\\n\\t.INITVAL_22($sformatf(\\\"0x%080x\\\", init_slice('h22))),\\n\\t.INITVAL_23($sformatf(\\\"0x%080x\\\", init_slice('h23))),\\n\\t.INITVAL_24($sformatf(\\\"0x%080x\\\", init_slice('h24))),\\n\\t.INITVAL_25($sformatf(\\\"0x%080x\\\", init_slice('h25))),\\n\\t.INITVAL_26($sformatf(\\\"0x%080x\\\", init_slice('h26))),\\n\\t.INITVAL_27($sformatf(\\\"0x%080x\\\", init_slice('h27))),\\n\\t.INITVAL_28($sformatf(\\\"0x%080x\\\", init_slice('h28))),\\n\\t.INITVAL_29($sformatf(\\\"0x%080x\\\", init_slice('h29))),\\n\\t.INITVAL_2A($sformatf(\\\"0x%080x\\\", init_slice('h2a))),\\n\\t.INITVAL_2B($sformatf(\\\"0x%080x\\\", init_slice('h2b))),\\n\\t.INITVAL_2C($sformatf(\\\"0x%080x\\\", init_slice('h2c))),\\n\\t.INITVAL_2D($sformatf(\\\"0x%080x\\\", init_slice('h2d))),\\n\\t.INITVAL_2E($sformatf(\\\"0x%080x\\\", init_slice('h2e))),\\n\\t.INITVAL_2F($sformatf(\\\"0x%080x\\\", init_slice('h2f))),\\n\\t.INITVAL_30($sformatf(\\\"0x%080x\\\", init_slice('h30))),\\n\\t.INITVAL_31($sformatf(\\\"0x%080x\\\", init_slice('h31))),\\n\\t.INITVAL_32($sformatf(\\\"0x%080x\\\", init_slice('h32))),\\n\\t.INITVAL_33($sformatf(\\\"0x%080x\\\", init_slice('h33))),\\n\\t.INITVAL_34($sformatf(\\\"0x%080x\\\", init_slice('h34))),\\n\\t.INITVAL_35($sformatf(\\\"0x%080x\\\", init_slice('h35))),\\n\\t.INITVAL_36($sformatf(\\\"0x%080x\\\", init_slice('h36))),\\n\\t.INITVAL_37($sformatf(\\\"0x%080x\\\", init_slice('h37))),\\n\\t.INITVAL_38($sformatf(\\\"0x%080x\\\", init_slice('h38))),\\n\\t.INITVAL_39($sformatf(\\\"0x%080x\\\", init_slice('h39))),\\n\\t.INITVAL_3A($sformatf(\\\"0x%080x\\\", init_slice('h3a))),\\n\\t.INITVAL_3B($sformatf(\\\"0x%080x\\\", init_slice('h3b))),\\n\\t.INITVAL_3C($sformatf(\\\"0x%080x\\\", init_slice('h3c))),\\n\\t.INITVAL_3D($sformatf(\\\"0x%080x\\\", init_slice('h3d))),\\n\\t.INITVAL_3E($sformatf(\\\"0x%080x\\\", init_slice('h3e))),\\n\\t.INITVAL_3F($sformatf(\\\"0x%080x\\\", init_slice('h3f))),\\n\\t.DATA_WIDTH_W($sformatf(\\\"X%0d\\\", PORT_W_WIDTH)),\\n\\t.DATA_WIDTH_R($sformatf(\\\"X%0d\\\", PORT_R_WIDTH)),\\n\\t.OUTREG(\\\"BYPASSED\\\"),\\n\\t.RESETMODE(PORT_R_OPTION_RESETMODE),\\n\\t.ASYNC_RST_RELEASE(PORT_R_OPTION_RESETMODE),\\n\\t.CSDECODE_W(\\\"111\\\"),\\n\\t.CSDECODE_R(\\\"111\\\"),\\n\\t.ECC(\\\"DISABLED\\\"),\\n\\t.GSR(\\\"DISABLED\\\"),\\n) _TECHMAP_REPLACE_ (\\n\\t.CLKW(PORT_W_CLK),\\n\\t.CEW(PORT_W_CLK_EN & (|PORT_W_WR_EN)),\\n\\t.CSW(3'b111),\\n\\t.ADW(ADW),\\n\\t.DI(DI),\\n\\n\\t.CLKR(PORT_R_CLK),\\n\\t.CER(PORT_R_CLK_EN),\\n\\t.RST(PORT_R_OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_R_RD_SRST : PORT_R_RD_ARST),\\n\\t.CSR(3'b111),\\n\\t.ADR(ADR),\\n\\t.DO(DO),\\n);\\n\\nend\\n\\nendgenerate\\n\\nendmodule\\n\",\n            \"cells_map.v\": \"// Flipflop intermediate map level\\nmodule \\\\$__FF_NOLSR (input D, C, E, output Q);\\n\\tparameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\n\\tgenerate\\n\\t\\tif (_TECHMAP_WIREINIT_Q_ === 1'b1)\\n\\t\\t\\tFD1P3JX #(.GSR(\\\"DISABLED\\\")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .PD(1'b0), .Q(Q));\\n\\t\\telse\\n\\t\\t\\tFD1P3IX #(.GSR(\\\"DISABLED\\\")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .CD(1'b0), .Q(Q));\\n\\tendgenerate\\nendmodule\\n\\nmodule \\\\$__FF_SYNCLSR (input D, C, E, R, output Q);\\n\\tparameter SR_VAL = 1'b0;\\n\\tparameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n\\twire _TECHMAP_REMOVEINIT_Q_ = 1'b1;\\n\\twire Ci, Ei, Ri, Rg, Dd;\\n\\tgenerate\\n\\t\\tif (SR_VAL)\\n\\t\\t\\tFD1P3JX #(.GSR(\\\"DISABLED\\\")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .PD(R), .Q(Q));\\n\\t\\telse\\n\\t\\t\\tFD1P3IX #(.GSR(\\\"DISABLED\\\")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .CD(R), .Q(Q));\\n\\tendgenerate\\nendmodule\\n\\nmodule \\\\$__FF_ASYNCLSR (input D, C, E, R, output Q);\\n\\tparameter SR_VAL = 1'b0;\\n\\tparameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n\\twire _TECHMAP_REMOVEINIT_Q_ = (_TECHMAP_WIREINIT_Q_ === 1'bx || _TECHMAP_WIREINIT_Q_ === SR_VAL);\\n\\twire Ci, Ei, Ri, Rg, Dd;\\n\\tgenerate\\n\\t\\tif (SR_VAL)\\n\\t\\t\\tFD1P3BX #(.GSR(\\\"DISABLED\\\")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .PD(R), .Q(Q));\\n\\t\\telse\\n\\t\\t\\tFD1P3DX #(.GSR(\\\"DISABLED\\\")) _TECHMAP_REPLACE_ (.D(D), .CK(C), .SP(E), .CD(R), .Q(Q));\\n\\tendgenerate\\nendmodule\\n\\n\\nmodule  \\\\$_DFF_P_ (input D, C, output Q); \\\\$__FF_NOLSR _TECHMAP_REPLACE_ (.D(D), .C(C), .E(1'b1), .Q(Q)); endmodule\\n\\nmodule  \\\\$_DFFE_PP_ (input D, C, E, output Q); \\\\$__FF_NOLSR _TECHMAP_REPLACE_ (.D(D), .C(C), .E(E), .Q(Q)); endmodule\\n\\nmodule  \\\\$_DFF_PP0_ (input D, C, R, output Q); \\\\$__FF_ASYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule\\nmodule  \\\\$_DFF_PP1_ (input D, C, R, output Q); \\\\$__FF_ASYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule\\n\\nmodule  \\\\$_SDFF_PP0_ (input D, C, R, output Q); \\\\$__FF_SYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule\\nmodule  \\\\$_SDFF_PP1_ (input D, C, R, output Q); \\\\$__FF_SYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(1'b1), .Q(Q)); endmodule\\n\\nmodule  \\\\$_DFFE_PP0P_ (input D, C, E, R, output Q); \\\\$__FF_ASYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule\\nmodule  \\\\$_DFFE_PP1P_ (input D, C, E, R, output Q); \\\\$__FF_ASYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule\\n\\nmodule  \\\\$_SDFFE_PP0P_ (input D, C, E, R, output Q); \\\\$__FF_SYNCLSR #(0)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule\\nmodule  \\\\$_SDFFE_PP1P_ (input D, C, E, R, output Q); \\\\$__FF_SYNCLSR #(1)  _TECHMAP_REPLACE_ (.D(D), .C(C), .R(R), .E(E), .Q(Q)); endmodule\\n\\n`ifndef NO_LUT\\nmodule \\\\$lut (A, Y);\\n\\tparameter WIDTH = 0;\\n\\tparameter LUT = 0;\\n\\n\\tinput [WIDTH-1:0] A;\\n\\toutput Y;\\n\\n\\tgenerate\\n\\t\\tif (WIDTH == 1) begin\\n\\t\\t\\tif (LUT == 2'b01)\\n\\t\\t\\t\\tINV _TECHMAP_REPLACE_ (.A(A[0]), .Z(Y));\\n\\t\\t\\telse\\n\\t\\t\\t\\tLUT4 #(.INIT($sformatf(\\\"0x%04x\\\", {{8{LUT[1]}}, {8{LUT[0]}}}))) _TECHMAP_REPLACE_ (.Z(Y),\\n\\t\\t\\t\\t\\t.D(A[0]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 2) begin\\n\\t\\t\\tlocalparam [15:0] INIT = {{4{LUT[3]}}, {4{LUT[2]}}, {4{LUT[1]}}, {4{LUT[0]}}};\\n\\t\\t\\tLUT4 #(.INIT($sformatf(\\\"0x%04x\\\",  INIT))) _TECHMAP_REPLACE_ (.Z(Y),\\n\\t\\t\\t\\t.C(A[0]), .D(A[1]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 3) begin\\n\\t\\t\\tlocalparam [15:0] INIT = {{2{LUT[7]}}, {2{LUT[6]}}, {2{LUT[5]}}, {2{LUT[4]}}, {2{LUT[3]}}, {2{LUT[2]}}, {2{LUT[1]}}, {2{LUT[0]}}};\\n\\t\\t\\tLUT4 #(.INIT($sformatf(\\\"0x%04x\\\", INIT))) _TECHMAP_REPLACE_ (.Z(Y),\\n\\t\\t\\t\\t.B(A[0]), .C(A[1]), .D(A[2]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 4) begin\\n\\t\\t\\tLUT4 #(.INIT($sformatf(\\\"0x%04x\\\", LUT))) _TECHMAP_REPLACE_ (.Z(Y),\\n\\t\\t\\t\\t.A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n\\t\\tend else\\n\\t\\tif (WIDTH == 5) begin\\n\\t\\t\\tWIDEFN9 #(\\n\\t\\t\\t\\t.INIT0($sformatf(\\\"0x%04x\\\", LUT[15:0 ])),\\n\\t\\t\\t\\t.INIT1($sformatf(\\\"0x%04x\\\", LUT[31:16])),\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t.A0(A[0]), .B0(A[1]), .C0(A[2]), .D0(A[3]),\\n\\t\\t\\t\\t.A1(A[0]), .B1(A[1]), .C1(A[2]), .D1(A[3]),\\n\\t\\t\\t\\t.SEL(A[4]), .Z(Y)\\n\\t\\t\\t);\\n\\t\\tend\\n\\tendgenerate\\nendmodule\\n`endif\\n\",\n            \"cells_sim.v\": \"(* abc9_lut=1, lib_whitebox *)\\nmodule LUT4(input A, B, C, D, output Z);\\n\\tparameter INIT = \\\"0x0000\\\";\\n`include \\\"parse_init.vh\\\"\\n\\tlocalparam initp = parse_init(INIT);\\n\\twire [7:0] s3 = D ?     initp[15:8] :    initp[7:0];\\n\\twire [3:0] s2 = C ?       s3[ 7:4]  :       s3[3:0];\\n\\twire [1:0] s1 = B ?       s2[ 3:2]  :       s2[1:0];\\n\\tassign Z =      A ?          s1[1]  :         s1[0];\\n\\n\\t// Per-input delay differences are considered 'interconnect'\\n\\t// so not known yet\\n\\tspecify\\n\\t\\t(A => Z) = 233;\\n\\t\\t(B => Z) = 233;\\n\\t\\t(C => Z) = 233;\\n\\t\\t(D => Z) = 233;\\n\\tendspecify\\n\\nendmodule\\n\\n// This is a placeholder for ABC9 to extract the area/delay\\n//   cost of 5-input LUTs and is not intended to be instantiated\\n(* abc9_lut=2 *)\\nmodule \\\\$__ABC9_LUT5 (input SEL, D, C, B, A, output Z);\\n\\tspecify\\n\\t\\t(SEL => Z) = 171;\\n\\t\\t(D => Z) = 303;\\n\\t\\t(C => Z) = 311;\\n\\t\\t(B => Z) = 309;\\n\\t\\t(A => Z) = 306;\\n\\tendspecify\\nendmodule\\n\\n// Two LUT4s and MUX2\\nmodule WIDEFN9(input A0, B0, C0, D0, A1, B1, C1, D1, SEL, output Z);\\n\\tparameter INIT0 = \\\"0x0000\\\";\\n\\tparameter INIT1 = \\\"0x0000\\\";\\n\\twire z0, z1;\\n\\tLUT4 #(.INIT(INIT0)) lut4_0 (.A(A0), .B(B0), .C(C0), .D(D0), .Z(z0));\\n\\tLUT4 #(.INIT(INIT1)) lut4_1 (.A(A1), .B(B1), .C(C1), .D(D1), .Z(z1));\\n\\tassign Z = SEL ? z1 : z0;\\nendmodule\\n\\n(* abc9_box, lib_whitebox *)\\nmodule INV(input A, output Z);\\n\\tassign Z = !A;\\n\\n\\tspecify\\n\\t\\t(A => Z) = 10;\\n\\tendspecify\\nendmodule\\n\\n// Bidirectional IO buffer\\nmodule BB(input T, I, output O,\\n\\t(* iopad_external_pin *) inout B);\\n\\tassign B = T ? 1'bz : I;\\n\\tassign O = B;\\nendmodule\\n\\n// Input buffer\\nmodule IB(\\n\\t(* iopad_external_pin *) input I,\\n\\toutput O);\\n\\tassign O = I;\\nendmodule\\n\\n// Output buffer\\nmodule OB(input I,\\n\\t(* iopad_external_pin *) output O);\\n\\tassign O = I;\\nendmodule\\n\\n// Output buffer with tristate\\nmodule OBZ(input I, T,\\n\\t(* iopad_external_pin *) output O);\\n\\tassign O = T ? 1'bz : I;\\nendmodule\\n\\n// Constants\\nmodule VLO(output Z);\\n\\tassign Z = 1'b0;\\nendmodule\\n\\nmodule VHI(output Z);\\n\\tassign Z = 1'b1;\\nendmodule\\n\\n// Vendor flipflops\\n// (all have active high clock, enable and set/reset - use INV to invert)\\n\\n// Async preset\\n(* abc9_box, lib_whitebox *)\\nmodule FD1P3BX(input D, CK, SP, PD, output reg Q);\\n\\tparameter GSR = \\\"DISABLED\\\";\\n\\tinitial Q = 1'b1;\\n\\talways @(posedge CK or posedge PD)\\n\\t\\tif (PD)\\n\\t\\t\\tQ <= 1'b1;\\n\\t\\telse if (SP)\\n\\t\\t\\tQ <= D;\\n\\tspecify\\n\\t\\t$setup(D, posedge CK, 0);\\n\\t\\t$setup(SP, posedge CK, 212);\\n\\t\\t$setup(PD, posedge CK, 224);\\n`ifndef YOSYS\\n\\t\\tif (PD) (posedge CLK => (Q : 1)) = 0;\\n`else\\n\\t\\tif (PD) (PD => Q) = 0; \\t// Technically, this should be an edge sensitive path\\n\\t\\t\\t\\t\\t\\t\\t\\t// but for facilitating a bypass box, let's pretend it's\\n\\t\\t\\t\\t\\t\\t\\t\\t// a simple path\\n`endif\\n\\t\\tif (!PD && SP) (posedge CK => (Q : D)) = 336;\\n\\tendspecify\\nendmodule\\n\\n// Async clear\\n(* abc9_box, lib_whitebox *)\\nmodule FD1P3DX(input D, CK, SP, CD, output reg Q);\\n\\tparameter GSR = \\\"DISABLED\\\";\\n\\tinitial Q = 1'b0;\\n\\talways @(posedge CK or posedge CD)\\n\\t\\tif (CD)\\n\\t\\t\\tQ <= 1'b0;\\n\\t\\telse if (SP)\\n\\t\\t\\tQ <= D;\\n\\tspecify\\n\\t\\t$setup(D, posedge CK, 0);\\n\\t\\t$setup(SP, posedge CK, 212);\\n\\t\\t$setup(CD, posedge CK, 224);\\n`ifndef YOSYS\\n\\t\\tif (CD) (posedge CLK => (Q : 0)) = 0;\\n`else\\n\\t\\tif (CD) (CD => Q) = 0; \\t// Technically, this should be an edge sensitive path\\n\\t\\t\\t\\t\\t\\t\\t\\t// but for facilitating a bypass box, let's pretend it's\\n\\t\\t\\t\\t\\t\\t\\t\\t// a simple path\\n`endif\\n\\t\\tif (!CD && SP) (posedge CK => (Q : D)) = 336;\\n\\tendspecify\\nendmodule\\n\\n// Sync clear\\n(* abc9_flop, lib_whitebox *)\\nmodule FD1P3IX(input D, CK, SP, CD, output reg Q);\\n\\tparameter GSR = \\\"DISABLED\\\";\\n\\tinitial Q = 1'b0;\\n\\talways @(posedge CK)\\n\\t\\tif (CD)\\n\\t\\t\\tQ <= 1'b0;\\n\\t\\telse if (SP)\\n\\t\\t\\tQ <= D;\\n\\tspecify\\n\\t\\t$setup(D, posedge CK, 0);\\n\\t\\t$setup(SP, posedge CK, 212);\\n\\t\\t$setup(CD, posedge CK, 224);\\n\\t\\tif (!CD && SP) (posedge CK => (Q : D)) = 336;\\n\\tendspecify\\nendmodule\\n\\n// Sync preset\\n(* abc9_flop, lib_whitebox *)\\nmodule FD1P3JX(input D, CK, SP, PD, output reg Q);\\n\\tparameter GSR = \\\"DISABLED\\\";\\n\\tinitial Q = 1'b1;\\n\\talways @(posedge CK)\\n\\t\\tif (PD)\\n\\t\\t\\tQ <= 1'b1;\\n\\t\\telse if (SP)\\n\\t\\t\\tQ <= D;\\n\\tspecify\\n\\t\\t$setup(D, posedge CK, 0);\\n\\t\\t$setup(SP, posedge CK, 212);\\n\\t\\t$setup(PD, posedge CK, 224);\\n\\t\\tif (!PD && SP) (posedge CK => (Q : D)) = 336;\\n\\tendspecify\\nendmodule\\n\\n// LUT4 with LUT3 tap for CCU2 use only\\n(* lib_whitebox *)\\nmodule LUT4_3(input A, B, C, D, output Z, Z3);\\n\\tparameter INIT = \\\"0x0000\\\";\\n`include \\\"parse_init.vh\\\"\\n\\tlocalparam initp = parse_init(INIT);\\n\\twire [7:0] s3 = D ?     initp[15:8] :     initp[7:0];\\n\\twire [3:0] s2 = C ?        s3[ 7:4] :        s3[3:0];\\n\\twire [1:0] s1 = B ?        s2[ 3:2] :        s2[1:0];\\n\\tassign Z =      A ?           s1[1] :          s1[0];\\n\\n\\twire [3:0] s2_3 = C ?   initp[ 7:4] :     initp[3:0];\\n\\twire [1:0] s1_3 = B ?    s2_3[ 3:2] :      s2_3[1:0];\\n\\tassign Z3 =       A ?       s1_3[1] :        s1_3[0];\\n\\nendmodule\\n\\n// Carry primitive (incoporating two LUTs)\\n(* abc9_box, lib_whitebox *)\\nmodule CCU2(\\n\\t(* abc9_carry *) input CIN,\\n\\tinput A1, B1, C1, D1, A0, B0, C0, D0,\\n\\toutput S1, S0,\\n\\t(* abc9_carry *) output COUT);\\n\\tparameter INJECT = \\\"YES\\\";\\n\\tparameter INIT0 = \\\"0x0000\\\";\\n\\tparameter INIT1 = \\\"0x1111\\\";\\n\\n\\tlocalparam inject_p = (INJECT == \\\"YES\\\") ? 1'b1 : 1'b0;\\n\\n\\twire LUT3_0, LUT4_0, LUT3_1, LUT4_1, carry_0;\\n\\tLUT4_3 #(.INIT(INIT0)) lut0 (.A(A0), .B(B0), .C(C0), .D(D0), .Z(LUT4_0), .Z3(LUT3_0));\\n\\tLUT4_3 #(.INIT(INIT1)) lut1 (.A(A1), .B(B1), .C(C1), .D(D1), .Z(LUT4_1), .Z3(LUT3_1));\\n\\n\\tassign S0 = LUT4_0 ^ (CIN & ~inject_p);\\n\\tassign carry_0 = LUT4_0 ? CIN : (LUT3_0 & ~inject_p);\\n\\tassign S1 = LUT4_1 ^ (carry_0 & ~inject_p);\\n\\tassign COUT = LUT4_1 ? carry_0 : (LUT3_1 & ~inject_p);\\n\\n\\tspecify\\n\\t\\t(A0 => S0) = 233;\\n\\t\\t(B0 => S0) = 233;\\n\\t\\t(C0 => S0) = 233;\\n\\t\\t(D0 => S0) = 233;\\n\\t\\t(CIN => S0) = 228;\\n\\t\\t(A0 => S1) = 481;\\n\\t\\t(B0 => S1) = 481;\\n\\t\\t(C0 => S1) = 481;\\n\\t\\t(D0 => S1) = 481;\\n\\t\\t(A1 => S1) = 233;\\n\\t\\t(B1 => S1) = 233;\\n\\t\\t(C1 => S1) = 233;\\n\\t\\t(D1 => S1) = 233;\\n\\t\\t(CIN => S1) = 307;\\n\\t\\t(A0 => COUT) = 347;\\n\\t\\t(B0 => COUT) = 347;\\n\\t\\t(C0 => COUT) = 347;\\n\\t\\t(D0 => COUT) = 347;\\n\\t\\t(A1 => COUT) = 347;\\n\\t\\t(B1 => COUT) = 347;\\n\\t\\t(C1 => COUT) = 347;\\n\\t\\t(D1 => COUT) = 347;\\n\\t\\t(CIN => COUT) = 59;\\n\\tendspecify\\n\\nendmodule\\n\\n// Packed flipflop\\nmodule OXIDE_FF(input CLK, LSR, CE, DI, M, output reg Q);\\n\\tparameter GSR = \\\"ENABLED\\\";\\n\\tparameter [127:0] CEMUX = \\\"1\\\";\\n\\tparameter CLKMUX = \\\"CLK\\\";\\n\\tparameter LSRMUX = \\\"LSR\\\";\\n\\tparameter REGDDR = \\\"DISABLED\\\";\\n\\tparameter SRMODE = \\\"LSR_OVER_CE\\\";\\n\\tparameter REGSET = \\\"RESET\\\";\\n\\tparameter [127:0] LSRMODE = \\\"LSR\\\";\\n\\n\\twire muxce;\\n\\tgenerate\\n\\t\\tcase (CEMUX)\\n\\t\\t\\t\\\"1\\\": assign muxce = 1'b1;\\n\\t\\t\\t\\\"0\\\": assign muxce = 1'b0;\\n\\t\\t\\t\\\"INV\\\": assign muxce = ~CE;\\n\\t\\t\\tdefault: assign muxce = CE;\\n\\t\\tendcase\\n\\tendgenerate\\n\\n\\twire muxlsr = (LSRMUX == \\\"INV\\\") ? ~LSR : LSR;\\n\\twire muxclk = (CLKMUX == \\\"INV\\\") ? ~CLK : CLK;\\n\\twire srval;\\n\\tgenerate\\n\\t\\tif (LSRMODE == \\\"PRLD\\\")\\n\\t\\t\\tassign srval = M;\\n\\t\\telse\\n\\t\\t\\tassign srval = (REGSET == \\\"SET\\\") ? 1'b1 : 1'b0;\\n\\tendgenerate\\n\\n\\tinitial Q = srval;\\n\\n\\tgenerate\\n\\t\\tif (REGDDR == \\\"ENABLED\\\") begin\\n\\t\\t\\tif (SRMODE == \\\"ASYNC\\\") begin\\n\\t\\t\\t\\talways @(posedge muxclk, negedge muxclk, posedge muxlsr)\\n\\t\\t\\t\\t\\tif (muxlsr)\\n\\t\\t\\t\\t\\t\\tQ <= srval;\\n\\t\\t\\t\\t\\telse if (muxce)\\n\\t\\t\\t\\t\\t\\tQ <= DI;\\n\\t\\t\\tend else begin\\n\\t\\t\\t\\talways @(posedge muxclk, negedge muxclk)\\n\\t\\t\\t\\t\\tif (muxlsr)\\n\\t\\t\\t\\t\\t\\tQ <= srval;\\n\\t\\t\\t\\t\\telse if (muxce)\\n\\t\\t\\t\\t\\t\\tQ <= DI;\\n\\t\\t\\tend\\n\\t\\tend else begin\\n\\t\\t\\tif (SRMODE == \\\"ASYNC\\\") begin\\n\\t\\t\\t\\talways @(posedge muxclk, posedge muxlsr)\\n\\t\\t\\t\\t\\tif (muxlsr)\\n\\t\\t\\t\\t\\t\\tQ <= srval;\\n\\t\\t\\t\\t\\telse if (muxce)\\n\\t\\t\\t\\t\\t\\tQ <= DI;\\n\\t\\t\\tend else begin\\n\\t\\t\\t\\talways @(posedge muxclk)\\n\\t\\t\\t\\t\\tif (muxlsr)\\n\\t\\t\\t\\t\\t\\tQ <= srval;\\n\\t\\t\\t\\t\\telse if (muxce)\\n\\t\\t\\t\\t\\t\\tQ <= DI;\\n\\t\\t\\tend\\n\\t\\tend\\n\\tendgenerate\\nendmodule\\n\\n// Packed combinational logic (for post-pnr sim)\\nmodule OXIDE_COMB(\\n\\tinput A, B, C, D, // LUT inputs\\n\\tinput SEL, // mux select input\\n\\tinput F1, // output from LUT 1 for mux\\n\\tinput FCI, // carry input\\n\\tinput WAD0, WAD1, WAD2, WAD3, // LUTRAM write address inputs\\n\\tinput WD, // LUTRAM write data input\\n\\tinput WCK, WRE, // LUTRAM write clock and enable\\n\\toutput F, // LUT/carry output\\n\\toutput OFX // mux output\\n);\\n\\tparameter MODE = \\\"LOGIC\\\"; // LOGIC, CCU2, DPRAM\\n\\tparameter [15:0] INIT = 16'h0000;\\n\\tparameter INJECT = \\\"YES\\\";\\n\\n\\tlocalparam inject_p = (INJECT == \\\"YES\\\") ? 1'b1 : 1'b0;\\n\\n\\treg [15:0] lut = INIT;\\n\\n\\twire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];\\n\\twire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];\\n\\twire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];\\n\\twire Z =        A ?          s1[1] :         s1[0];\\n\\n\\twire [3:0] s2_3 = C ?   INIT[ 7:4] :     INIT[3:0];\\n\\twire [1:0] s1_3 = B ?   s2_3[ 3:2] :     s2_3[1:0];\\n\\twire Z3 =         A ?      s1_3[1] :       s1_3[0];\\n\\n\\tgenerate\\n\\t\\tif (MODE == \\\"DPRAM\\\") begin\\n\\t\\t\\talways @(posedge WCK)\\n\\t\\t\\t\\tif (WRE)\\n\\t\\t\\t\\t\\tlut[{WAD3, WAD2, WAD1, WAD0}] <= WD;\\n\\t\\tend\\n\\t\\tif (MODE == \\\"CCU2\\\") begin\\n\\t\\t\\tassign F = Z ^ (FCI & ~inject_p);\\n\\t\\t\\tassign FCO = Z ? FCI : (Z3 & ~inject_p);\\n\\t\\tend else begin\\n\\t\\t\\tassign F = Z;\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tassign OFX = SEL ? F1 : F;\\n\\nendmodule\\n\\n// LUTRAM\\nmodule DPR16X4(\\n\\tinput [3:0] RAD, DI, WAD,\\n\\tinput WRE, WCK,\\n\\toutput [3:0] DO\\n);\\n\\tparameter INITVAL = \\\"0x0000000000000000\\\";\\n`include \\\"parse_init.vh\\\"\\n\\tlocalparam [63:0] parsed_init = parse_init_64(INITVAL);\\n\\n\\treg [3:0] mem[0:15];\\n\\tinteger i;\\n\\tinitial begin\\n\\t\\tfor (i = 0; i < 15; i++)\\n\\t\\t\\tmem[i] = parsed_init[i * 4 +: 4];\\n\\tend\\n\\n\\talways @(posedge WCK)\\n\\t\\tif (WRE)\\n\\t\\t\\tmem[WAD] <= DI;\\n\\tassign DO = mem[RAD];\\nendmodule\\n\\n// Used for all the DSP models to reduce duplication\\nmodule OXIDE_DSP_REG #(\\n\\tparameter W = 18,\\n\\tparameter USED = \\\"REGISTER\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput CLK, CE, RST,\\n\\tinput [W-1:0] D,\\n\\toutput reg [W-1:0] Q\\n);\\n\\tgenerate\\n\\t\\tif (USED == \\\"BYPASS\\\")\\n\\t\\t\\talways @* Q = D;\\n\\t\\telse if (USED == \\\"REGISTER\\\") begin\\n\\t\\t\\tinitial Q = 0;\\n\\t\\t\\tif (RESETMODE == \\\"ASYNC\\\")\\n\\t\\t\\t\\talways @(posedge CLK, posedge RST) begin\\n\\t\\t\\t\\t\\tif (RST)\\n\\t\\t\\t\\t\\t\\tQ <= 0;\\n\\t\\t\\t\\t\\telse if (CE)\\n\\t\\t\\t\\t\\t\\tQ <= D;\\n\\t\\t\\t\\tend\\n\\t\\t\\telse if (RESETMODE == \\\"SYNC\\\")\\n\\t\\t\\t\\talways @(posedge CLK) begin\\n\\t\\t\\t\\t\\tif (RST)\\n\\t\\t\\t\\t\\t\\tQ <= 0;\\n\\t\\t\\t\\t\\telse if (CE)\\n\\t\\t\\t\\t\\t\\tQ <= D;\\n\\t\\t\\t\\tend\\n\\t\\tend\\n\\tendgenerate\\nendmodule\\n\\nmodule OXIDE_DSP_SIM #(\\n\\t// User facing parameters\\n\\tparameter REGINPUTA = \\\"BYPASS\\\",\\n\\tparameter REGINPUTB = \\\"BYPASS\\\",\\n\\tparameter REGINPUTC = \\\"BYPASS\\\",\\n\\tparameter REGADDSUB = \\\"BYPASS\\\",\\n\\tparameter REGLOADC = \\\"BYPASS\\\",\\n\\tparameter REGLOADC2 = \\\"BYPASS\\\",\\n\\tparameter REGCIN = \\\"BYPASS\\\",\\n\\tparameter REGPIPELINE = \\\"BYPASS\\\",\\n\\tparameter REGOUTPUT = \\\"BYPASS\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\",\\n\\t// Internally used parameters\\n\\tparameter A_WIDTH = 36,\\n\\tparameter B_WIDTH = 36,\\n\\tparameter C_WIDTH = 36,\\n\\tparameter Z_WIDTH = 72,\\n\\tparameter PREADD_USED = 0,\\n\\tparameter ADDSUB_USED = 0\\n) (\\n\\tinput [A_WIDTH-1:0] A,\\n\\tinput [B_WIDTH-1:0] B,\\n\\tinput [C_WIDTH-1:0] C,\\n\\tinput SIGNEDA,\\n\\tinput SIGNEDB,\\n\\tinput SIGNEDC,\\n\\tinput CIN,\\n\\tinput LOADC,\\n\\tinput ADDSUB,\\n\\tinput CLK,\\n\\tinput CEA, CEB, CEC, CEPIPE, CECTRL, CECIN, CEOUT,\\n\\tinput RSTA, RSTB, RSTC, RSTPIPE, RSTCTRL, RSTCIN, RSTOUT,\\n\\toutput wire [Z_WIDTH-1:0] Z\\n);\\n\\t\\n\\tlocalparam M_WIDTH = (A_WIDTH+B_WIDTH);\\n\\n\\t/******** REGISTERS ********/\\n\\n\\twire [M_WIDTH-1:0] pipe_d, pipe_q;\\n\\twire [Z_WIDTH-1:0] z_d;\\n\\n\\twire [A_WIDTH-1:0] a_r;\\n\\twire [B_WIDTH-1:0] b_r;\\n\\twire [C_WIDTH-1:0] c_r, c_r2;\\n\\twire asgd_r, bsgd_r, csgd_r, csgd_r2;\\n\\n\\twire addsub_r, addsub_r2, cin_r, cin_r2, sgd_r, sgd_r2;\\n\\twire loadc_r, loadc_r2;\\n\\n\\tOXIDE_DSP_REG #(A_WIDTH+1, REGINPUTA, RESETMODE) a_reg(CLK, CEA, RSTA, {SIGNEDA, A}, {asgd_r, a_r});\\n\\tOXIDE_DSP_REG #(B_WIDTH+1, REGINPUTB, RESETMODE) b_reg(CLK, CEB, RSTB, {SIGNEDB, B}, {bsgd_r, b_r});\\n\\tOXIDE_DSP_REG #(C_WIDTH+1, REGINPUTC, RESETMODE) c_reg(CLK, CEC, RSTC, {SIGNEDC, C}, {csgd_r, c_r});\\n\\n\\tOXIDE_DSP_REG #(M_WIDTH, REGPIPELINE, RESETMODE) pipe_reg(CLK, CEPIPE, RSTPIPE, pipe_d, pipe_q);\\n\\n\\tOXIDE_DSP_REG #(2, REGADDSUB, RESETMODE) addsub_reg(CLK, CECTRL, RSTCTRL, {SIGNEDA, ADDSUB}, {sgd_r, addsub_r});\\n\\tOXIDE_DSP_REG #(1, REGLOADC, RESETMODE) loadc_reg(CLK, CECTRL, RSTCTRL, LOADC, loadc_r);\\n\\tOXIDE_DSP_REG #(2, REGPIPELINE, RESETMODE) addsub2_reg(CLK, CECTRL, RSTCTRL, {sgd_r, addsub_r}, {sgd_r2, addsub_r2});\\n\\tOXIDE_DSP_REG #(1, REGLOADC2, RESETMODE) loadc2_reg(CLK, CECTRL, RSTCTRL, loadc_r, loadc_r2);\\n\\n\\tOXIDE_DSP_REG #(1, REGCIN, RESETMODE) cin_reg(CLK, CECIN, RSTCIN, CIN, cin_r);\\n\\tOXIDE_DSP_REG #(1, REGPIPELINE, RESETMODE) cin2_reg(CLK, CECIN, RSTCIN, cin_r, cin_r2);\\n\\n\\tOXIDE_DSP_REG #(C_WIDTH+1, REGPIPELINE, RESETMODE) c2_reg(CLK, CEC, RSTC, {csgd_r, c_r}, {csgd_r2, c_r2});\\n\\n\\tOXIDE_DSP_REG #(Z_WIDTH, REGOUTPUT, RESETMODE) z_reg(CLK, CEOUT, RSTOUT, z_d, Z);\\n\\n\\t/******** PREADDER ********/\\n\\n\\twire [B_WIDTH-1:0] mult_b;\\n\\twire mult_b_sgd;\\n\\n\\tgenerate\\n\\t\\tif (PREADD_USED) begin\\n\\t\\t\\tassign mult_b = (b_r + c_r);\\n\\t\\t\\tassign mult_b_sgd = (bsgd_r | csgd_r);\\n\\t\\tend else begin\\n\\t\\t\\tassign mult_b = b_r;\\n\\t\\t\\tassign mult_b_sgd = bsgd_r;\\n\\t\\tend\\n\\tendgenerate\\n\\n\\t/******** MULTIPLIER ********/\\n\\n\\t// sign extend operands if needed\\n\\twire [M_WIDTH-1:0] mult_a_ext = {{(M_WIDTH-A_WIDTH){asgd_r ? a_r[A_WIDTH-1] : 1'b0}}, a_r};\\n\\twire [M_WIDTH-1:0] mult_b_ext = {{(M_WIDTH-B_WIDTH){mult_b_sgd ? mult_b[B_WIDTH-1] : 1'b0}}, mult_b};\\n\\n\\twire [M_WIDTH-1:0] mult_m = mult_a_ext * mult_b_ext;\\n\\n\\t/******** ACCUMULATOR ********/\\n\\n\\twire [Z_WIDTH-1:0] m_ext;\\n\\n\\tgenerate\\n\\t\\tif (ADDSUB_USED) begin\\n\\t\\t\\tassign pipe_d = mult_m;\\n\\t\\t\\tassign m_ext = {{(Z_WIDTH-M_WIDTH){sgd_r2 ? pipe_q[M_WIDTH-1] : 1'b0}}, pipe_q};\\n\\t\\t\\tassign z_d = (loadc_r2 ? c_r2 : Z) + cin_r2 + (addsub_r2 ? -m_ext : m_ext);  \\n\\t\\tend else begin\\n\\t\\t\\tassign z_d = mult_m;\\n\\t\\tend\\n\\tendgenerate\\n\\n\\nendmodule\\n\\nmodule MULT9X9 #(\\n\\tparameter REGINPUTA = \\\"REGISTER\\\",\\n\\tparameter REGINPUTB = \\\"REGISTER\\\",\\n\\tparameter REGOUTPUT = \\\"REGISTER\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput [8:0] A,\\n\\tinput [8:0] B,\\n\\tinput CLK,\\n\\tinput CEA,\\n\\tinput RSTA,\\n\\tinput CEB,\\n\\tinput RSTB,\\n\\tinput SIGNEDA,\\n\\tinput SIGNEDB,\\n\\tinput RSTOUT,\\n\\tinput CEOUT,\\n\\toutput [17:0] Z\\n);\\n\\tOXIDE_DSP_SIM #(\\n\\t\\t.REGINPUTA(REGINPUTA),\\n\\t\\t.REGINPUTB(REGINPUTB),\\n\\t\\t.REGOUTPUT(REGOUTPUT),\\n\\t\\t.GSR(GSR),\\n\\t\\t.RESETMODE(RESETMODE),\\n\\n\\t\\t.A_WIDTH(9),\\n\\t\\t.B_WIDTH(9),\\n\\t\\t.Z_WIDTH(18),\\n\\t\\t.PREADD_USED(0),\\n\\t\\t.ADDSUB_USED(0)\\n\\t) dsp_i (\\n\\t\\t.A(A), .B(B),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA), .RSTA(RSTA),\\n\\t\\t.CEB(CEB), .RSTB(RSTB),\\n\\t\\t.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),\\n\\t\\t.RSTOUT(RSTOUT), .CEOUT(CEOUT),\\n\\t\\t.Z(Z)\\n\\t);\\nendmodule\\n\\nmodule MULT18X18 #(\\n\\tparameter REGINPUTA = \\\"REGISTER\\\",\\n\\tparameter REGINPUTB = \\\"REGISTER\\\",\\n\\tparameter REGOUTPUT = \\\"REGISTER\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput [17:0] A,\\n\\tinput [17:0] B,\\n\\tinput CLK,\\n\\tinput CEA,\\n\\tinput RSTA,\\n\\tinput CEB,\\n\\tinput RSTB,\\n\\tinput SIGNEDA,\\n\\tinput SIGNEDB,\\n\\tinput RSTOUT,\\n\\tinput CEOUT,\\n\\toutput [35:0] Z\\n);\\n\\tOXIDE_DSP_SIM #(\\n\\t\\t.REGINPUTA(REGINPUTA),\\n\\t\\t.REGINPUTB(REGINPUTB),\\n\\t\\t.REGOUTPUT(REGOUTPUT),\\n\\t\\t.GSR(GSR),\\n\\t\\t.RESETMODE(RESETMODE),\\n\\n\\t\\t.A_WIDTH(18),\\n\\t\\t.B_WIDTH(18),\\n\\t\\t.Z_WIDTH(36),\\n\\t\\t.PREADD_USED(0),\\n\\t\\t.ADDSUB_USED(0)\\n\\t) dsp_i (\\n\\t\\t.A(A), .B(B),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA), .RSTA(RSTA),\\n\\t\\t.CEB(CEB), .RSTB(RSTB),\\n\\t\\t.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),\\n\\t\\t.RSTOUT(RSTOUT), .CEOUT(CEOUT),\\n\\t\\t.Z(Z)\\n\\t);\\nendmodule\\n\\nmodule MULT18X36 #(\\n\\tparameter REGINPUTA = \\\"REGISTER\\\",\\n\\tparameter REGINPUTB = \\\"REGISTER\\\",\\n\\tparameter REGOUTPUT = \\\"REGISTER\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput [17:0] A,\\n\\tinput [35:0] B,\\n\\tinput CLK,\\n\\tinput CEA,\\n\\tinput RSTA,\\n\\tinput CEB,\\n\\tinput RSTB,\\n\\tinput SIGNEDA,\\n\\tinput SIGNEDB,\\n\\tinput RSTOUT,\\n\\tinput CEOUT,\\n\\toutput [53:0] Z\\n);\\n\\tOXIDE_DSP_SIM #(\\n\\t\\t.REGINPUTA(REGINPUTA),\\n\\t\\t.REGINPUTB(REGINPUTB),\\n\\t\\t.REGOUTPUT(REGOUTPUT),\\n\\t\\t.GSR(GSR),\\n\\t\\t.RESETMODE(RESETMODE),\\n\\n\\t\\t.A_WIDTH(18),\\n\\t\\t.B_WIDTH(36),\\n\\t\\t.Z_WIDTH(54),\\n\\t\\t.PREADD_USED(0),\\n\\t\\t.ADDSUB_USED(0)\\n\\t) dsp_i (\\n\\t\\t.A(A), .B(B),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA), .RSTA(RSTA),\\n\\t\\t.CEB(CEB), .RSTB(RSTB),\\n\\t\\t.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),\\n\\t\\t.RSTOUT(RSTOUT), .CEOUT(CEOUT),\\n\\t\\t.Z(Z)\\n\\t);\\nendmodule\\n\\nmodule MULT36X36 #(\\n\\tparameter REGINPUTA = \\\"REGISTER\\\",\\n\\tparameter REGINPUTB = \\\"REGISTER\\\",\\n\\tparameter REGOUTPUT = \\\"REGISTER\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput [35:0] A,\\n\\tinput [35:0] B,\\n\\tinput CLK,\\n\\tinput CEA,\\n\\tinput RSTA,\\n\\tinput CEB,\\n\\tinput RSTB,\\n\\tinput SIGNEDA,\\n\\tinput SIGNEDB,\\n\\tinput RSTOUT,\\n\\tinput CEOUT,\\n\\toutput [71:0] Z\\n);\\n\\tOXIDE_DSP_SIM #(\\n\\t\\t.REGINPUTA(REGINPUTA),\\n\\t\\t.REGINPUTB(REGINPUTB),\\n\\t\\t.REGOUTPUT(REGOUTPUT),\\n\\t\\t.GSR(GSR),\\n\\t\\t.RESETMODE(RESETMODE),\\n\\n\\t\\t.A_WIDTH(36),\\n\\t\\t.B_WIDTH(36),\\n\\t\\t.Z_WIDTH(72),\\n\\t\\t.PREADD_USED(0),\\n\\t\\t.ADDSUB_USED(0)\\n\\t) dsp_i (\\n\\t\\t.A(A), .B(B),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA), .RSTA(RSTA),\\n\\t\\t.CEB(CEB), .RSTB(RSTB),\\n\\t\\t.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB),\\n\\t\\t.RSTOUT(RSTOUT), .CEOUT(CEOUT),\\n\\t\\t.Z(Z)\\n\\t);\\nendmodule\\n\\n\\nmodule MULTPREADD9X9 #(\\n\\tparameter REGINPUTA = \\\"REGISTER\\\",\\n\\tparameter REGINPUTB = \\\"REGISTER\\\",\\n\\tparameter REGINPUTC = \\\"REGISTER\\\",\\n\\tparameter REGOUTPUT = \\\"REGISTER\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput [8:0] A,\\n\\tinput [8:0] B,\\n\\tinput [8:0] C,\\n\\tinput CLK,\\n\\tinput CEA,\\n\\tinput RSTA,\\n\\tinput CEB,\\n\\tinput RSTB,\\n\\tinput CEC,\\n\\tinput RSTC,\\n\\tinput SIGNEDA,\\n\\tinput SIGNEDB,\\n\\tinput SIGNEDC,\\n\\tinput RSTOUT,\\n\\tinput CEOUT,\\n\\toutput [17:0] Z\\n);\\n\\tOXIDE_DSP_SIM #(\\n\\t\\t.REGINPUTA(REGINPUTA),\\n\\t\\t.REGINPUTB(REGINPUTB),\\n\\t\\t.REGINPUTC(REGINPUTC),\\n\\t\\t.REGOUTPUT(REGOUTPUT),\\n\\t\\t.GSR(GSR),\\n\\t\\t.RESETMODE(RESETMODE),\\n\\n\\t\\t.A_WIDTH(9),\\n\\t\\t.B_WIDTH(9),\\n\\t\\t.C_WIDTH(9),\\n\\t\\t.Z_WIDTH(18),\\n\\t\\t.PREADD_USED(1),\\n\\t\\t.ADDSUB_USED(0)\\n\\t) dsp_i (\\n\\t\\t.A(A), .B(B), .C(C),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA), .RSTA(RSTA),\\n\\t\\t.CEB(CEB), .RSTB(RSTB),\\n\\t\\t.CEC(CEC), .RSTC(RSTC),\\n\\t\\t.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB), .SIGNEDC(SIGNEDC),\\n\\t\\t.RSTOUT(RSTOUT), .CEOUT(CEOUT),\\n\\t\\t.Z(Z)\\n\\t);\\nendmodule\\n\\n\\nmodule MULTPREADD18X18 #(\\n\\tparameter REGINPUTA = \\\"REGISTER\\\",\\n\\tparameter REGINPUTB = \\\"REGISTER\\\",\\n\\tparameter REGINPUTC = \\\"REGISTER\\\",\\n\\tparameter REGOUTPUT = \\\"REGISTER\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput [17:0] A,\\n\\tinput [17:0] B,\\n\\tinput [17:0] C,\\n\\tinput CLK,\\n\\tinput CEA,\\n\\tinput RSTA,\\n\\tinput CEB,\\n\\tinput RSTB,\\n\\tinput CEC,\\n\\tinput RSTC,\\n\\tinput SIGNEDA,\\n\\tinput SIGNEDB,\\n\\tinput SIGNEDC,\\n\\tinput RSTOUT,\\n\\tinput CEOUT,\\n\\toutput [35:0] Z\\n);\\n\\tOXIDE_DSP_SIM #(\\n\\t\\t.REGINPUTA(REGINPUTA),\\n\\t\\t.REGINPUTB(REGINPUTB),\\n\\t\\t.REGINPUTC(REGINPUTC),\\n\\t\\t.REGOUTPUT(REGOUTPUT),\\n\\t\\t.GSR(GSR),\\n\\t\\t.RESETMODE(RESETMODE),\\n\\n\\t\\t.A_WIDTH(18),\\n\\t\\t.B_WIDTH(18),\\n\\t\\t.C_WIDTH(18),\\n\\t\\t.Z_WIDTH(36),\\n\\t\\t.PREADD_USED(1),\\n\\t\\t.ADDSUB_USED(0)\\n\\t) dsp_i (\\n\\t\\t.A(A), .B(B), .C(C),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA), .RSTA(RSTA),\\n\\t\\t.CEB(CEB), .RSTB(RSTB),\\n\\t\\t.CEC(CEC), .RSTC(RSTC),\\n\\t\\t.SIGNEDA(SIGNEDA), .SIGNEDB(SIGNEDB), .SIGNEDC(SIGNEDC),\\n\\t\\t.RSTOUT(RSTOUT), .CEOUT(CEOUT),\\n\\t\\t.Z(Z)\\n\\t);\\nendmodule\\n\\n\\nmodule MULTADDSUB18X18 #(\\n\\tparameter REGINPUTA = \\\"REGISTER\\\",\\n\\tparameter REGINPUTB = \\\"REGISTER\\\",\\n\\tparameter REGINPUTC = \\\"REGISTER\\\",\\n\\tparameter REGADDSUB = \\\"REGISTER\\\",\\n\\tparameter REGLOADC = \\\"REGISTER\\\",\\n\\tparameter REGLOADC2 = \\\"REGISTER\\\",\\n\\tparameter REGCIN = \\\"REGISTER\\\",\\n\\tparameter REGPIPELINE = \\\"REGISTER\\\",\\n\\tparameter REGOUTPUT = \\\"REGISTER\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput [17:0] A,\\n\\tinput [17:0] B,\\n\\tinput [53:0] C,\\n    input CLK,\\n    input CEA,\\n    input RSTA,\\n    input CEB,\\n    input RSTB,\\n    input CEC,\\n    input RSTC,\\n    input SIGNED,\\n    input RSTPIPE,\\n    input CEPIPE,\\n    input RSTCTRL,\\n    input CECTRL,\\n    input RSTCIN,\\n    input CECIN,\\n    input LOADC,\\n    input ADDSUB,\\n    output [53:0] Z,\\n    input RSTOUT,\\n    input CEOUT,\\n    input CIN\\n);\\n\\tOXIDE_DSP_SIM #(\\n\\t\\t.REGINPUTA(REGINPUTA),\\n\\t\\t.REGINPUTB(REGINPUTB),\\n\\t\\t.REGINPUTC(REGINPUTC),\\n\\t\\t.REGADDSUB(REGADDSUB),\\n\\t\\t.REGLOADC(REGLOADC),\\n\\t\\t.REGLOADC2(REGLOADC2),\\n\\t\\t.REGCIN(REGCIN),\\n\\t\\t.REGPIPELINE(REGPIPELINE),\\n\\t\\t.REGOUTPUT(REGOUTPUT),\\n\\t\\t.GSR(GSR),\\n\\t\\t.RESETMODE(RESETMODE),\\n\\n\\t\\t.A_WIDTH(18),\\n\\t\\t.B_WIDTH(18),\\n\\t\\t.C_WIDTH(54),\\n\\t\\t.Z_WIDTH(54),\\n\\t\\t.PREADD_USED(0),\\n\\t\\t.ADDSUB_USED(1)\\n\\t) dsp_i (\\n\\t\\t.A(A), .B(B), .C(C),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA), .RSTA(RSTA),\\n\\t\\t.CEB(CEB), .RSTB(RSTB),\\n\\t\\t.CEC(CEC), .RSTC(RSTC),\\n\\t\\t.CEPIPE(CEPIPE), .RSTPIPE(RSTPIPE),\\n\\t\\t.CECTRL(CECTRL), .RSTCTRL(RSTCTRL),\\n\\t\\t.CECIN(CECIN), .RSTCIN(RSTCIN),\\n\\t\\t.CIN(CIN), .LOADC(LOADC), .ADDSUB(ADDSUB),\\n\\t\\t.SIGNEDA(SIGNED), .SIGNEDB(SIGNED), .SIGNEDC(SIGNED),\\n\\t\\t.RSTOUT(RSTOUT), .CEOUT(CEOUT),\\n\\t\\t.Z(Z)\\n\\t);\\nendmodule\\n\\n\\nmodule MULTADDSUB36X36 #(\\n\\tparameter REGINPUTA = \\\"REGISTER\\\",\\n\\tparameter REGINPUTB = \\\"REGISTER\\\",\\n\\tparameter REGINPUTC = \\\"REGISTER\\\",\\n\\tparameter REGADDSUB = \\\"REGISTER\\\",\\n\\tparameter REGLOADC = \\\"REGISTER\\\",\\n\\tparameter REGLOADC2 = \\\"REGISTER\\\",\\n\\tparameter REGCIN = \\\"REGISTER\\\",\\n\\tparameter REGPIPELINE = \\\"REGISTER\\\",\\n\\tparameter REGOUTPUT = \\\"REGISTER\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput [35:0] A,\\n\\tinput [35:0] B,\\n\\tinput [107:0] C,\\n    input CLK,\\n    input CEA,\\n    input RSTA,\\n    input CEB,\\n    input RSTB,\\n    input CEC,\\n    input RSTC,\\n    input SIGNED,\\n    input RSTPIPE,\\n    input CEPIPE,\\n    input RSTCTRL,\\n    input CECTRL,\\n    input RSTCIN,\\n    input CECIN,\\n    input LOADC,\\n    input ADDSUB,\\n    output [107:0] Z,\\n    input RSTOUT,\\n    input CEOUT,\\n    input CIN\\n);\\n\\tOXIDE_DSP_SIM #(\\n\\t\\t.REGINPUTA(REGINPUTA),\\n\\t\\t.REGINPUTB(REGINPUTB),\\n\\t\\t.REGINPUTC(REGINPUTC),\\n\\t\\t.REGADDSUB(REGADDSUB),\\n\\t\\t.REGLOADC(REGLOADC),\\n\\t\\t.REGLOADC2(REGLOADC2),\\n\\t\\t.REGCIN(REGCIN),\\n\\t\\t.REGPIPELINE(REGPIPELINE),\\n\\t\\t.REGOUTPUT(REGOUTPUT),\\n\\t\\t.GSR(GSR),\\n\\t\\t.RESETMODE(RESETMODE),\\n\\n\\t\\t.A_WIDTH(36),\\n\\t\\t.B_WIDTH(36),\\n\\t\\t.C_WIDTH(108),\\n\\t\\t.Z_WIDTH(108),\\n\\t\\t.PREADD_USED(0),\\n\\t\\t.ADDSUB_USED(1)\\n\\t) dsp_i (\\n\\t\\t.A(A), .B(B), .C(C),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA), .RSTA(RSTA),\\n\\t\\t.CEB(CEB), .RSTB(RSTB),\\n\\t\\t.CEC(CEC), .RSTC(RSTC),\\n\\t\\t.CEPIPE(CEPIPE), .RSTPIPE(RSTPIPE),\\n\\t\\t.CECTRL(CECTRL), .RSTCTRL(RSTCTRL),\\n\\t\\t.CECIN(CECIN), .RSTCIN(RSTCIN),\\n\\t\\t.CIN(CIN), .LOADC(LOADC), .ADDSUB(ADDSUB),\\n\\t\\t.SIGNEDA(SIGNED), .SIGNEDB(SIGNED), .SIGNEDC(SIGNED),\\n\\t\\t.RSTOUT(RSTOUT), .CEOUT(CEOUT),\\n\\t\\t.Z(Z)\\n\\t);\\nendmodule\\n\\nmodule MULTADDSUB9X9WIDE #(\\n\\tparameter REGINPUTAB0 = \\\"REGISTER\\\",\\n\\tparameter REGINPUTAB1 = \\\"REGISTER\\\",\\n\\tparameter REGINPUTAB2 = \\\"REGISTER\\\",\\n\\tparameter REGINPUTAB3 = \\\"REGISTER\\\",\\n\\tparameter REGINPUTC = \\\"REGISTER\\\",\\n\\tparameter REGADDSUB = \\\"REGISTER\\\",\\n\\tparameter REGLOADC = \\\"REGISTER\\\",\\n\\tparameter REGLOADC2 = \\\"REGISTER\\\",\\n\\tparameter REGPIPELINE = \\\"REGISTER\\\",\\n\\tparameter REGOUTPUT = \\\"REGISTER\\\",\\n\\tparameter GSR = \\\"ENABLED\\\",\\n\\tparameter RESETMODE = \\\"SYNC\\\"\\n) (\\n\\tinput [8:0] A0, B0, A1, B1, A2, B2, A3, B3,\\n\\tinput [53:0] C,\\n\\tinput CLK,\\n\\tinput CEA0A1, CEA2A3,\\n\\tinput RSTA0A1, RSTA2A3,\\n\\tinput CEB0B1, CEB2B3,\\n\\tinput RSTB0B1, RSTB2B3,\\n\\tinput CEC, RSTC,\\n\\tinput CECTRL, RSTCTRL,\\n\\tinput SIGNED,\\n\\tinput RSTPIPE, CEPIPE,\\n\\tinput RSTOUT, CEOUT,\\n\\tinput LOADC,\\n\\tinput [3:0] ADDSUB,\\n\\toutput [53:0] Z\\n);\\n\\twire [17:0] m0, m1, m2, m3;\\n\\n\\tlocalparam M_WIDTH = 18;\\n\\tlocalparam Z_WIDTH = 54;\\n\\n\\tMULT9X9 #(\\n\\t\\t.REGINPUTA(REGINPUTAB0), .REGINPUTB(REGINPUTAB0), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)\\n\\t) m9_0 (\\n\\t\\t.A(A0), .B(B0), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA0A1), .RSTA(RSTA0A1),\\n\\t\\t.CEB(CEB0B1), .RSTB(RSTB0B1),\\n\\t\\t.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),\\n\\t\\t.Z(m0)\\n\\t);\\n\\tMULT9X9 #(\\n\\t\\t.REGINPUTA(REGINPUTAB1), .REGINPUTB(REGINPUTAB1), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)\\n\\t) m9_1 (\\n\\t\\t.A(A1), .B(B1), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA0A1), .RSTA(RSTA0A1),\\n\\t\\t.CEB(CEB0B1), .RSTB(RSTB0B1),\\n\\t\\t.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),\\n\\t\\t.Z(m1)\\n\\t);\\n\\tMULT9X9 #(\\n\\t\\t.REGINPUTA(REGINPUTAB2), .REGINPUTB(REGINPUTAB2), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)\\n\\t) m9_2 (\\n\\t\\t.A(A2), .B(B2), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA2A3), .RSTA(RSTA2A3),\\n\\t\\t.CEB(CEB2B3), .RSTB(RSTB2B3),\\n\\t\\t.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),\\n\\t\\t.Z(m2)\\n\\t);\\n\\tMULT9X9 #(\\n\\t\\t.REGINPUTA(REGINPUTAB3), .REGINPUTB(REGINPUTAB3), .REGOUTPUT(REGPIPELINE), .GSR(GSR), .RESETMODE(RESETMODE)\\n\\t) m9_3 (\\n\\t\\t.A(A3), .B(B3), .SIGNEDA(SIGNED), .SIGNEDB(SIGNED),\\n\\t\\t.CLK(CLK),\\n\\t\\t.CEA(CEA2A3), .RSTA(RSTA2A3),\\n\\t\\t.CEB(CEB2B3), .RSTB(RSTB2B3),\\n\\t\\t.CEOUT(CEPIPE), .RSTOUT(RSTPIPE),\\n\\t\\t.Z(m3)\\n\\t);\\n\\n\\twire [53:0] c_r, c_r2;\\n\\twire [3:0] addsub_r, addsub_r2;\\n\\twire sgd_r, sgd_r2, csgd_r, csgd_r2;\\n\\twire loadc_r, loadc_r2;\\n\\n\\tOXIDE_DSP_REG #(5, REGADDSUB, RESETMODE) addsub_reg(CLK, CECTRL, RSTCTRL, {SIGNED, ADDSUB}, {sgd_r, addsub_r});\\n\\tOXIDE_DSP_REG #(5, REGADDSUB, RESETMODE) addsub2_reg(CLK, CECTRL, RSTCTRL, {sgd_r, addsub_r}, {sgd_r2, addsub_r2});\\n\\n\\tOXIDE_DSP_REG #(1, REGLOADC, RESETMODE) loadc_reg(CLK, CECTRL, RSTCTRL, LOADC, loadc_r);\\n\\tOXIDE_DSP_REG #(1, REGLOADC2, RESETMODE) loadc2_reg(CLK, CECTRL, RSTCTRL, loadc_r, loadc_r2);\\n\\n\\tOXIDE_DSP_REG #(55, REGINPUTC, RESETMODE) c_reg(CLK, CEC, RSTC, {SIGNED, C}, {csgd_r, c_r});\\n\\tOXIDE_DSP_REG #(55, REGPIPELINE, RESETMODE) c2_reg(CLK, CEC, RSTC, {csgd_r, c_r}, {csgd_r2, c_r2});\\n\\n\\n\\twire [18:0] m0_ext, m1_ext, m2_ext, m3_ext;\\n\\n\\tassign m0_ext = {sgd_r2 ? m0[M_WIDTH-1] : 1'b0, m0};\\n\\tassign m1_ext = {sgd_r2 ? m1[M_WIDTH-1] : 1'b0, m1};\\n\\tassign m2_ext = {sgd_r2 ? m2[M_WIDTH-1] : 1'b0, m2};\\n\\tassign m3_ext = {sgd_r2 ? m3[M_WIDTH-1] : 1'b0, m3};\\n\\n\\twire [18:0] s0 = addsub_r2[2] ? (m0_ext - m1_ext) : (m0_ext + m1_ext);\\n\\twire [18:0] s1 = addsub_r2[3] ? (m2_ext - m3_ext) : (m2_ext + m3_ext);\\n\\n\\twire [53:0] s0_ext = {{(54-19){sgd_r2 ? s0[18] : 1'b0}}, s0};\\n\\twire [53:0] s1_ext = {{(54-19){sgd_r2 ? s1[18] : 1'b0}}, s1};\\n\\n\\twire [53:0] c_op = loadc_r2 ? c_r2 : Z;\\n\\n\\t// The diagram in the docs is wrong! It is not two cascaded 2-input add/subs as shown,\\n\\t// but a three-input unit with negation controls on two inputs (i.e. addsub_r2[0]\\n\\t// negates s1 not (s1 +/- s0))\\n\\twire [53:0] z_d =  c_op + (addsub_r2[0] ? -s1_ext : s1_ext) + (addsub_r2[1] ? -s0_ext : s0_ext);\\n\\n\\tOXIDE_DSP_REG #(Z_WIDTH, REGOUTPUT, RESETMODE) z_reg(CLK, CEOUT, RSTOUT, z_d, Z);\\n\\nendmodule\\n\",\n            \"cells_xtra.v\": new URL(/* asset import */ __webpack_require__(/*! ./share/nexus/cells_xtra.v */ \"./node_modules/@yowasp/yosys/gen/share/nexus/cells_xtra.v\"), __webpack_require__.b),\n            \"dsp_map.v\": \"module \\\\$__NX_MUL36X36 (input [35:0] A, input [35:0] B, output [71:0] Y);\\n\\n\\tparameter A_WIDTH = 36;\\n\\tparameter B_WIDTH = 36;\\n\\tparameter Y_WIDTH = 72;\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\n\\tMULT36X36 #(\\n\\t\\t.REGINPUTA(\\\"BYPASS\\\"),\\n\\t\\t.REGINPUTB(\\\"BYPASS\\\"),\\n\\t\\t.REGOUTPUT(\\\"BYPASS\\\")\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.A(A), .B(B),\\n\\t\\t.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0),\\n\\t\\t.SIGNEDB(B_SIGNED ? 1'b1 : 1'b0),\\n\\t\\t.Z(Y)\\n\\t);\\nendmodule\\n\\nmodule \\\\$__NX_MUL36X18 (input [35:0] A, input [17:0] B, output [53:0] Y);\\n\\n\\tparameter A_WIDTH = 36;\\n\\tparameter B_WIDTH = 18;\\n\\tparameter Y_WIDTH = 54;\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\n\\tMULT18X36 #(\\n\\t\\t.REGINPUTA(\\\"BYPASS\\\"),\\n\\t\\t.REGINPUTB(\\\"BYPASS\\\"),\\n\\t\\t.REGOUTPUT(\\\"BYPASS\\\")\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.A(B), .B(A),\\n\\t\\t.SIGNEDA(B_SIGNED ? 1'b1 : 1'b0),\\n\\t\\t.SIGNEDB(A_SIGNED ? 1'b1 : 1'b0),\\n\\t\\t.Z(Y)\\n\\t);\\nendmodule\\n\\nmodule \\\\$__NX_MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);\\n\\n\\tparameter A_WIDTH = 18;\\n\\tparameter B_WIDTH = 18;\\n\\tparameter Y_WIDTH = 36;\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\n\\tMULT18X18 #(\\n\\t\\t.REGINPUTA(\\\"BYPASS\\\"),\\n\\t\\t.REGINPUTB(\\\"BYPASS\\\"),\\n\\t\\t.REGOUTPUT(\\\"BYPASS\\\")\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.A(A), .B(B),\\n\\t\\t.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0),\\n\\t\\t.SIGNEDB(B_SIGNED ? 1'b1 : 1'b0),\\n\\t\\t.Z(Y)\\n\\t);\\nendmodule\\n\\nmodule \\\\$__NX_MUL9X9 (input [8:0] A, input [8:0] B, output [17:0] Y);\\n\\n\\tparameter A_WIDTH = 9;\\n\\tparameter B_WIDTH = 9;\\n\\tparameter Y_WIDTH = 18;\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\n\\tMULT9X9 #(\\n\\t\\t.REGINPUTA(\\\"BYPASS\\\"),\\n\\t\\t.REGINPUTB(\\\"BYPASS\\\"),\\n\\t\\t.REGOUTPUT(\\\"BYPASS\\\")\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.A(A), .B(B),\\n\\t\\t.SIGNEDA(A_SIGNED ? 1'b1 : 1'b0),\\n\\t\\t.SIGNEDB(B_SIGNED ? 1'b1 : 1'b0),\\n\\t\\t.Z(Y)\\n\\t);\\nendmodule\\n\",\n            \"latches_map.v\": \"module \\\\$_DLATCH_N_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = !E ? D : Q;\\nendmodule\\n\\nmodule \\\\$_DLATCH_P_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = E ? D : Q;\\nendmodule\\n\",\n            \"lrams.txt\": \"ram huge $__NX_DPSC512K_ {\\n\\tabits 14;\\n\\twidth 32;\\n\\tbyte 8;\\n\\tcost 2048;\\n\\tinit no_undef;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock posedge \\\"C\\\";\\n\\t\\tclken;\\n\\t\\twrbe_separate;\\n\\t\\trdwr no_change;\\n\\t\\toption \\\"RESETMODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero gated_clken;\\n\\t\\t}\\n\\t\\toption \\\"RESETMODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\trdinit zero;\\n\\t\\twrtrans all old;\\n\\t}\\n}\\n\",\n            \"lrams_map.v\": \"module $__NX_DPSC512K_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RESETMODE = \\\"SYNC\\\";\\n\\ninput CLK_C;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput PORT_A_WR_EN;\\ninput PORT_A_RD_SRST;\\ninput PORT_A_RD_ARST;\\ninput [13:0] PORT_A_ADDR;\\ninput [3:0] PORT_A_WR_BE;\\ninput [31:0] PORT_A_WR_DATA;\\noutput [31:0] PORT_A_RD_DATA;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput PORT_B_WR_EN;\\ninput PORT_B_RD_SRST;\\ninput PORT_B_RD_ARST;\\ninput [13:0] PORT_B_ADDR;\\ninput [3:0] PORT_B_WR_BE;\\ninput [31:0] PORT_B_WR_DATA;\\noutput [31:0] PORT_B_RD_DATA;\\n\\nfunction [5119:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i, j;\\n\\tinit_slice = 0;\\n\\tfor (i = 0; i < 128; i = i + 1) begin\\n\\t\\tinit_slice[i*40+:32] = INIT[(idx * 128 + i) * 32+:32];\\n\\tend\\nendfunction\\n\\nDPSC512K #(\\n\\t.INITVAL_00($sformatf(\\\"0x%01280x\\\", init_slice('h00))),\\n\\t.INITVAL_01($sformatf(\\\"0x%01280x\\\", init_slice('h01))),\\n\\t.INITVAL_02($sformatf(\\\"0x%01280x\\\", init_slice('h02))),\\n\\t.INITVAL_03($sformatf(\\\"0x%01280x\\\", init_slice('h03))),\\n\\t.INITVAL_04($sformatf(\\\"0x%01280x\\\", init_slice('h04))),\\n\\t.INITVAL_05($sformatf(\\\"0x%01280x\\\", init_slice('h05))),\\n\\t.INITVAL_06($sformatf(\\\"0x%01280x\\\", init_slice('h06))),\\n\\t.INITVAL_07($sformatf(\\\"0x%01280x\\\", init_slice('h07))),\\n\\t.INITVAL_08($sformatf(\\\"0x%01280x\\\", init_slice('h08))),\\n\\t.INITVAL_09($sformatf(\\\"0x%01280x\\\", init_slice('h09))),\\n\\t.INITVAL_0A($sformatf(\\\"0x%01280x\\\", init_slice('h0a))),\\n\\t.INITVAL_0B($sformatf(\\\"0x%01280x\\\", init_slice('h0b))),\\n\\t.INITVAL_0C($sformatf(\\\"0x%01280x\\\", init_slice('h0c))),\\n\\t.INITVAL_0D($sformatf(\\\"0x%01280x\\\", init_slice('h0d))),\\n\\t.INITVAL_0E($sformatf(\\\"0x%01280x\\\", init_slice('h0e))),\\n\\t.INITVAL_0F($sformatf(\\\"0x%01280x\\\", init_slice('h0f))),\\n\\t.INITVAL_10($sformatf(\\\"0x%01280x\\\", init_slice('h10))),\\n\\t.INITVAL_11($sformatf(\\\"0x%01280x\\\", init_slice('h11))),\\n\\t.INITVAL_12($sformatf(\\\"0x%01280x\\\", init_slice('h12))),\\n\\t.INITVAL_13($sformatf(\\\"0x%01280x\\\", init_slice('h13))),\\n\\t.INITVAL_14($sformatf(\\\"0x%01280x\\\", init_slice('h14))),\\n\\t.INITVAL_15($sformatf(\\\"0x%01280x\\\", init_slice('h15))),\\n\\t.INITVAL_16($sformatf(\\\"0x%01280x\\\", init_slice('h16))),\\n\\t.INITVAL_17($sformatf(\\\"0x%01280x\\\", init_slice('h17))),\\n\\t.INITVAL_18($sformatf(\\\"0x%01280x\\\", init_slice('h18))),\\n\\t.INITVAL_19($sformatf(\\\"0x%01280x\\\", init_slice('h19))),\\n\\t.INITVAL_1A($sformatf(\\\"0x%01280x\\\", init_slice('h1a))),\\n\\t.INITVAL_1B($sformatf(\\\"0x%01280x\\\", init_slice('h1b))),\\n\\t.INITVAL_1C($sformatf(\\\"0x%01280x\\\", init_slice('h1c))),\\n\\t.INITVAL_1D($sformatf(\\\"0x%01280x\\\", init_slice('h1d))),\\n\\t.INITVAL_1E($sformatf(\\\"0x%01280x\\\", init_slice('h1e))),\\n\\t.INITVAL_1F($sformatf(\\\"0x%01280x\\\", init_slice('h1f))),\\n\\t.INITVAL_20($sformatf(\\\"0x%01280x\\\", init_slice('h20))),\\n\\t.INITVAL_21($sformatf(\\\"0x%01280x\\\", init_slice('h21))),\\n\\t.INITVAL_22($sformatf(\\\"0x%01280x\\\", init_slice('h22))),\\n\\t.INITVAL_23($sformatf(\\\"0x%01280x\\\", init_slice('h23))),\\n\\t.INITVAL_24($sformatf(\\\"0x%01280x\\\", init_slice('h24))),\\n\\t.INITVAL_25($sformatf(\\\"0x%01280x\\\", init_slice('h25))),\\n\\t.INITVAL_26($sformatf(\\\"0x%01280x\\\", init_slice('h26))),\\n\\t.INITVAL_27($sformatf(\\\"0x%01280x\\\", init_slice('h27))),\\n\\t.INITVAL_28($sformatf(\\\"0x%01280x\\\", init_slice('h28))),\\n\\t.INITVAL_29($sformatf(\\\"0x%01280x\\\", init_slice('h29))),\\n\\t.INITVAL_2A($sformatf(\\\"0x%01280x\\\", init_slice('h2a))),\\n\\t.INITVAL_2B($sformatf(\\\"0x%01280x\\\", init_slice('h2b))),\\n\\t.INITVAL_2C($sformatf(\\\"0x%01280x\\\", init_slice('h2c))),\\n\\t.INITVAL_2D($sformatf(\\\"0x%01280x\\\", init_slice('h2d))),\\n\\t.INITVAL_2E($sformatf(\\\"0x%01280x\\\", init_slice('h2e))),\\n\\t.INITVAL_2F($sformatf(\\\"0x%01280x\\\", init_slice('h2f))),\\n\\t.INITVAL_30($sformatf(\\\"0x%01280x\\\", init_slice('h30))),\\n\\t.INITVAL_31($sformatf(\\\"0x%01280x\\\", init_slice('h31))),\\n\\t.INITVAL_32($sformatf(\\\"0x%01280x\\\", init_slice('h32))),\\n\\t.INITVAL_33($sformatf(\\\"0x%01280x\\\", init_slice('h33))),\\n\\t.INITVAL_34($sformatf(\\\"0x%01280x\\\", init_slice('h34))),\\n\\t.INITVAL_35($sformatf(\\\"0x%01280x\\\", init_slice('h35))),\\n\\t.INITVAL_36($sformatf(\\\"0x%01280x\\\", init_slice('h36))),\\n\\t.INITVAL_37($sformatf(\\\"0x%01280x\\\", init_slice('h37))),\\n\\t.INITVAL_38($sformatf(\\\"0x%01280x\\\", init_slice('h38))),\\n\\t.INITVAL_39($sformatf(\\\"0x%01280x\\\", init_slice('h39))),\\n\\t.INITVAL_3A($sformatf(\\\"0x%01280x\\\", init_slice('h3a))),\\n\\t.INITVAL_3B($sformatf(\\\"0x%01280x\\\", init_slice('h3b))),\\n\\t.INITVAL_3C($sformatf(\\\"0x%01280x\\\", init_slice('h3c))),\\n\\t.INITVAL_3D($sformatf(\\\"0x%01280x\\\", init_slice('h3d))),\\n\\t.INITVAL_3E($sformatf(\\\"0x%01280x\\\", init_slice('h3e))),\\n\\t.INITVAL_3F($sformatf(\\\"0x%01280x\\\", init_slice('h3f))),\\n\\t.INITVAL_40($sformatf(\\\"0x%01280x\\\", init_slice('h40))),\\n\\t.INITVAL_41($sformatf(\\\"0x%01280x\\\", init_slice('h41))),\\n\\t.INITVAL_42($sformatf(\\\"0x%01280x\\\", init_slice('h42))),\\n\\t.INITVAL_43($sformatf(\\\"0x%01280x\\\", init_slice('h43))),\\n\\t.INITVAL_44($sformatf(\\\"0x%01280x\\\", init_slice('h44))),\\n\\t.INITVAL_45($sformatf(\\\"0x%01280x\\\", init_slice('h45))),\\n\\t.INITVAL_46($sformatf(\\\"0x%01280x\\\", init_slice('h46))),\\n\\t.INITVAL_47($sformatf(\\\"0x%01280x\\\", init_slice('h47))),\\n\\t.INITVAL_48($sformatf(\\\"0x%01280x\\\", init_slice('h48))),\\n\\t.INITVAL_49($sformatf(\\\"0x%01280x\\\", init_slice('h49))),\\n\\t.INITVAL_4A($sformatf(\\\"0x%01280x\\\", init_slice('h4a))),\\n\\t.INITVAL_4B($sformatf(\\\"0x%01280x\\\", init_slice('h4b))),\\n\\t.INITVAL_4C($sformatf(\\\"0x%01280x\\\", init_slice('h4c))),\\n\\t.INITVAL_4D($sformatf(\\\"0x%01280x\\\", init_slice('h4d))),\\n\\t.INITVAL_4E($sformatf(\\\"0x%01280x\\\", init_slice('h4e))),\\n\\t.INITVAL_4F($sformatf(\\\"0x%01280x\\\", init_slice('h4f))),\\n\\t.INITVAL_50($sformatf(\\\"0x%01280x\\\", init_slice('h50))),\\n\\t.INITVAL_51($sformatf(\\\"0x%01280x\\\", init_slice('h51))),\\n\\t.INITVAL_52($sformatf(\\\"0x%01280x\\\", init_slice('h52))),\\n\\t.INITVAL_53($sformatf(\\\"0x%01280x\\\", init_slice('h53))),\\n\\t.INITVAL_54($sformatf(\\\"0x%01280x\\\", init_slice('h54))),\\n\\t.INITVAL_55($sformatf(\\\"0x%01280x\\\", init_slice('h55))),\\n\\t.INITVAL_56($sformatf(\\\"0x%01280x\\\", init_slice('h56))),\\n\\t.INITVAL_57($sformatf(\\\"0x%01280x\\\", init_slice('h57))),\\n\\t.INITVAL_58($sformatf(\\\"0x%01280x\\\", init_slice('h58))),\\n\\t.INITVAL_59($sformatf(\\\"0x%01280x\\\", init_slice('h59))),\\n\\t.INITVAL_5A($sformatf(\\\"0x%01280x\\\", init_slice('h5a))),\\n\\t.INITVAL_5B($sformatf(\\\"0x%01280x\\\", init_slice('h5b))),\\n\\t.INITVAL_5C($sformatf(\\\"0x%01280x\\\", init_slice('h5c))),\\n\\t.INITVAL_5D($sformatf(\\\"0x%01280x\\\", init_slice('h5d))),\\n\\t.INITVAL_5E($sformatf(\\\"0x%01280x\\\", init_slice('h5e))),\\n\\t.INITVAL_5F($sformatf(\\\"0x%01280x\\\", init_slice('h5f))),\\n\\t.INITVAL_60($sformatf(\\\"0x%01280x\\\", init_slice('h60))),\\n\\t.INITVAL_61($sformatf(\\\"0x%01280x\\\", init_slice('h61))),\\n\\t.INITVAL_62($sformatf(\\\"0x%01280x\\\", init_slice('h62))),\\n\\t.INITVAL_63($sformatf(\\\"0x%01280x\\\", init_slice('h63))),\\n\\t.INITVAL_64($sformatf(\\\"0x%01280x\\\", init_slice('h64))),\\n\\t.INITVAL_65($sformatf(\\\"0x%01280x\\\", init_slice('h65))),\\n\\t.INITVAL_66($sformatf(\\\"0x%01280x\\\", init_slice('h66))),\\n\\t.INITVAL_67($sformatf(\\\"0x%01280x\\\", init_slice('h67))),\\n\\t.INITVAL_68($sformatf(\\\"0x%01280x\\\", init_slice('h68))),\\n\\t.INITVAL_69($sformatf(\\\"0x%01280x\\\", init_slice('h69))),\\n\\t.INITVAL_6A($sformatf(\\\"0x%01280x\\\", init_slice('h6a))),\\n\\t.INITVAL_6B($sformatf(\\\"0x%01280x\\\", init_slice('h6b))),\\n\\t.INITVAL_6C($sformatf(\\\"0x%01280x\\\", init_slice('h6c))),\\n\\t.INITVAL_6D($sformatf(\\\"0x%01280x\\\", init_slice('h6d))),\\n\\t.INITVAL_6E($sformatf(\\\"0x%01280x\\\", init_slice('h6e))),\\n\\t.INITVAL_6F($sformatf(\\\"0x%01280x\\\", init_slice('h6f))),\\n\\t.INITVAL_70($sformatf(\\\"0x%01280x\\\", init_slice('h70))),\\n\\t.INITVAL_71($sformatf(\\\"0x%01280x\\\", init_slice('h71))),\\n\\t.INITVAL_72($sformatf(\\\"0x%01280x\\\", init_slice('h72))),\\n\\t.INITVAL_73($sformatf(\\\"0x%01280x\\\", init_slice('h73))),\\n\\t.INITVAL_74($sformatf(\\\"0x%01280x\\\", init_slice('h74))),\\n\\t.INITVAL_75($sformatf(\\\"0x%01280x\\\", init_slice('h75))),\\n\\t.INITVAL_76($sformatf(\\\"0x%01280x\\\", init_slice('h76))),\\n\\t.INITVAL_77($sformatf(\\\"0x%01280x\\\", init_slice('h77))),\\n\\t.INITVAL_78($sformatf(\\\"0x%01280x\\\", init_slice('h78))),\\n\\t.INITVAL_79($sformatf(\\\"0x%01280x\\\", init_slice('h79))),\\n\\t.INITVAL_7A($sformatf(\\\"0x%01280x\\\", init_slice('h7a))),\\n\\t.INITVAL_7B($sformatf(\\\"0x%01280x\\\", init_slice('h7b))),\\n\\t.INITVAL_7C($sformatf(\\\"0x%01280x\\\", init_slice('h7c))),\\n\\t.INITVAL_7D($sformatf(\\\"0x%01280x\\\", init_slice('h7d))),\\n\\t.INITVAL_7E($sformatf(\\\"0x%01280x\\\", init_slice('h7e))),\\n\\t.INITVAL_7F($sformatf(\\\"0x%01280x\\\", init_slice('h7f))),\\n\\t.OUTREG_A(\\\"NO_REG\\\"),\\n\\t.OUTREG_B(\\\"NO_REG\\\"),\\n\\t.ECC_BYTE_SEL(\\\"BYTE_EN\\\"),\\n\\t.GSR(\\\"DISABLED\\\"),\\n\\t.RESETMODE(OPTION_RESETMODE),\\n\\t.ASYNC_RESET_RELEASE(OPTION_RESETMODE),\\n) _TECHMAP_REPLACE_ (\\n\\t.CLK(CLK_C),\\n\\n\\t.WEA(PORT_A_WR_EN),\\n\\t.CEA(PORT_A_CLK_EN),\\n\\t.RSTA(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST),\\n\\t.CSA(1'b1),\\n\\t.ADA(PORT_A_ADDR),\\n\\t.BENA_N(~PORT_A_WR_BE),\\n\\t.DIA(PORT_A_WR_DATA),\\n\\t.DOA(PORT_A_RD_DATA),\\n\\n\\t.WEB(PORT_B_WR_EN),\\n\\t.CEB(PORT_B_CLK_EN),\\n\\t.RSTB(OPTION_RESETMODE == \\\"SYNC\\\" ? PORT_B_RD_SRST : PORT_B_RD_ARST),\\n\\t.CSB(1'b1),\\n\\t.BENB_N(~PORT_B_WR_BE),\\n\\t.ADB(PORT_B_ADDR),\\n\\t.DIB(PORT_B_WR_DATA),\\n\\t.DOB(PORT_B_RD_DATA),\\n);\\n\\nendmodule\\n\",\n            \"lutrams.txt\": \"ram distributed $__NEXUS_DPR16X4_ {\\n\\tabits 4;\\n\\twidth 4;\\n\\tcost 4;\\n\\tinit no_undef;\\n\\tprune_rom;\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\",\n            \"lutrams_map.v\": \"module $__NEXUS_DPR16X4_ (...);\\n\\tparameter INIT = 64'b0;\\n\\n\\tinput PORT_W_CLK;\\n\\tinput [3:0] PORT_W_ADDR;\\n\\tinput [3:0] PORT_W_WR_DATA;\\n\\tinput PORT_W_WR_EN;\\n\\n\\tinput [3:0] PORT_R_ADDR;\\n\\toutput [3:0] PORT_R_RD_DATA;\\n\\n\\tDPR16X4 #(\\n\\t\\t.INITVAL($sformatf(\\\"0x%08x\\\", INIT))\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.RAD(PORT_R_ADDR),\\n\\t\\t.DO(PORT_R_RD_DATA),\\n\\n\\t\\t.WAD(PORT_W_ADDR),\\n\\t\\t.DI(PORT_W_WR_DATA),\\n\\t\\t.WCK(PORT_W_CLK),\\n\\t\\t.WRE(PORT_W_WR_EN)\\n\\t);\\nendmodule\\n\",\n            \"parse_init.vh\": \"function [15:0] parse_init;\\n\\tinput [((2+(16/4))*8)-1:0] init;\\n\\treg [7:0] c;\\n\\tinteger i;\\n\\tbegin\\n\\t\\tfor (i = 0; i < (16/4); i = i + 1) begin\\n\\t\\t\\tc = init[(i * 8) +: 8];\\n\\t\\t\\tif (c >= \\\"0\\\" && c <= \\\"9\\\")\\n\\t\\t\\t\\tparse_init[(i * 4) +: 4] = (c - \\\"0\\\");\\n\\t\\t\\telse if (c >= \\\"A\\\" && c <= \\\"F\\\")\\n\\t\\t\\t\\tparse_init[(i * 4) +: 4] = (c - \\\"A\\\") + 10;\\n\\t\\t\\telse if (c >= \\\"a\\\" && c <= \\\"f\\\")\\n\\t\\t\\t\\tparse_init[(i * 4) +: 4] = (c - \\\"a\\\") + 10;\\n\\t\\tend\\n\\tend\\nendfunction\\n\\nfunction [63:0] parse_init_64;\\n\\tinput [((2+(64/4))*8)-1:0] init;\\n\\treg [7:0] c;\\n\\tinteger i;\\n\\tbegin\\n\\t\\tfor (i = 0; i < (64/4); i = i + 1) begin\\n\\t\\t\\tc = init[(i * 8) +: 8];\\n\\t\\t\\tif (c >= \\\"0\\\" && c <= \\\"9\\\")\\n\\t\\t\\t\\tparse_init_64[(i * 4) +: 4] = (c - \\\"0\\\");\\n\\t\\t\\telse if (c >= \\\"A\\\" && c <= \\\"F\\\")\\n\\t\\t\\t\\tparse_init_64[(i * 4) +: 4] = (c - \\\"A\\\") + 10;\\n\\t\\t\\telse if (c >= \\\"a\\\" && c <= \\\"f\\\")\\n\\t\\t\\t\\tparse_init_64[(i * 4) +: 4] = (c - \\\"a\\\") + 10;\\n\\t\\tend\\n\\tend\\nendfunction\\n\",\n        },\n        \"pmux2mux.v\": \"module \\\\$pmux (A, B, S, Y);\\n\\nwire [1023:0] _TECHMAP_DO_ = \\\"proc; clean\\\";\\n\\nparameter WIDTH = 1;\\nparameter S_WIDTH = 1;\\n\\ninput [WIDTH-1:0] A;\\ninput [WIDTH*S_WIDTH-1:0] B;\\ninput [S_WIDTH-1:0] S;\\noutput reg [WIDTH-1:0] Y;\\n\\ninteger i;\\n\\nalways @* begin\\n\\tY <= A;\\n\\tfor (i = 0; i < S_WIDTH; i=i+1)\\n\\t\\tif (S[i]) Y <= B[WIDTH*i +: WIDTH];\\nend\\n\\nendmodule\\n\",\n        \"python3\": {\n            \"smtio.py\": \"#\\n# yosys -- Yosys Open SYnthesis Suite\\n#\\n# Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n#\\n# Permission to use, copy, modify, and/or distribute this software for any\\n# purpose with or without fee is hereby granted, provided that the above\\n# copyright notice and this permission notice appear in all copies.\\n#\\n# THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n#\\n\\nimport sys, re, os, signal, json\\nimport subprocess\\nif os.name == \\\"posix\\\":\\n    import resource\\nfrom copy import copy\\nfrom select import select\\nfrom time import time\\nfrom queue import Queue, Empty\\nfrom threading import Thread\\n\\n\\n# This is needed so that the recursive SMT2 S-expression parser\\n# does not run out of stack frames when parsing large expressions\\nif os.name == \\\"posix\\\":\\n    smtio_reclimit = 64 * 1024\\n    if sys.getrecursionlimit() < smtio_reclimit:\\n        sys.setrecursionlimit(smtio_reclimit)\\n\\n    current_rlimit_stack = resource.getrlimit(resource.RLIMIT_STACK)\\n    if current_rlimit_stack[0] != resource.RLIM_INFINITY:\\n        smtio_stacksize = 128 * 1024 * 1024\\n        if os.uname().sysname == \\\"Darwin\\\":\\n            # MacOS has rather conservative stack limits\\n            smtio_stacksize = 8 * 1024 * 1024\\n        if current_rlimit_stack[1] != resource.RLIM_INFINITY:\\n            smtio_stacksize = min(smtio_stacksize, current_rlimit_stack[1])\\n        if current_rlimit_stack[0] < smtio_stacksize:\\n            try:\\n                resource.setrlimit(resource.RLIMIT_STACK, (smtio_stacksize, current_rlimit_stack[1]))\\n            except ValueError:\\n                # couldn't get more stack, just run with what we have\\n                pass\\n\\n\\n# currently running solvers (so we can kill them)\\nrunning_solvers = dict()\\nforced_shutdown = False\\nsolvers_index = 0\\n\\ndef force_shutdown(signum, frame):\\n    global forced_shutdown\\n    if not forced_shutdown:\\n        forced_shutdown = True\\n        if signum is not None:\\n            print(\\\"<%s>\\\" % signal.Signals(signum).name)\\n        for p in running_solvers.values():\\n            # os.killpg(os.getpgid(p.pid), signal.SIGTERM)\\n            os.kill(p.pid, signal.SIGTERM)\\n    sys.exit(1)\\n\\nif os.name == \\\"posix\\\":\\n    signal.signal(signal.SIGHUP, force_shutdown)\\nsignal.signal(signal.SIGINT, force_shutdown)\\nsignal.signal(signal.SIGTERM, force_shutdown)\\n\\ndef except_hook(exctype, value, traceback):\\n    if not forced_shutdown:\\n        sys.__excepthook__(exctype, value, traceback)\\n    force_shutdown(None, None)\\n\\nsys.excepthook = except_hook\\n\\n\\ndef recursion_helper(iteration, *request):\\n    stack = [iteration(*request)]\\n\\n    while stack:\\n        top = stack.pop()\\n        try:\\n            request = next(top)\\n        except StopIteration:\\n            continue\\n\\n        stack.append(top)\\n        stack.append(iteration(*request))\\n\\n\\nhex_dict = {\\n    \\\"0\\\": \\\"0000\\\", \\\"1\\\": \\\"0001\\\", \\\"2\\\": \\\"0010\\\", \\\"3\\\": \\\"0011\\\",\\n    \\\"4\\\": \\\"0100\\\", \\\"5\\\": \\\"0101\\\", \\\"6\\\": \\\"0110\\\", \\\"7\\\": \\\"0111\\\",\\n    \\\"8\\\": \\\"1000\\\", \\\"9\\\": \\\"1001\\\", \\\"A\\\": \\\"1010\\\", \\\"B\\\": \\\"1011\\\",\\n    \\\"C\\\": \\\"1100\\\", \\\"D\\\": \\\"1101\\\", \\\"E\\\": \\\"1110\\\", \\\"F\\\": \\\"1111\\\",\\n    \\\"a\\\": \\\"1010\\\", \\\"b\\\": \\\"1011\\\", \\\"c\\\": \\\"1100\\\", \\\"d\\\": \\\"1101\\\",\\n    \\\"e\\\": \\\"1110\\\", \\\"f\\\": \\\"1111\\\"\\n}\\n\\n\\nclass SmtModInfo:\\n    def __init__(self):\\n        self.inputs = set()\\n        self.outputs = set()\\n        self.registers = set()\\n        self.memories = dict()\\n        self.wires = set()\\n        self.wsize = dict()\\n        self.clocks = dict()\\n        self.cells = dict()\\n        self.asserts = dict()\\n        self.assumes = dict()\\n        self.covers = dict()\\n        self.maximize = set()\\n        self.minimize = set()\\n        self.anyconsts = dict()\\n        self.anyseqs = dict()\\n        self.allconsts = dict()\\n        self.allseqs = dict()\\n        self.asize = dict()\\n        self.witness = []\\n\\n\\nclass SmtIo:\\n    def __init__(self, opts=None):\\n        global solvers_index\\n\\n        self.logic = None\\n        self.logic_qf = True\\n        self.logic_ax = True\\n        self.logic_uf = True\\n        self.logic_bv = True\\n        self.logic_dt = False\\n        self.forall = False\\n        self.timeout = 0\\n        self.produce_models = True\\n        self.recheck = False\\n        self.smt2cache = [list()]\\n        self.smt2_options = dict()\\n        self.smt2_assumptions = dict()\\n        self.p = None\\n        self.p_index = solvers_index\\n        solvers_index += 1\\n\\n        if opts is not None:\\n            self.logic = opts.logic\\n            self.solver = opts.solver\\n            self.solver_opts = opts.solver_opts\\n            self.debug_print = opts.debug_print\\n            self.debug_file = opts.debug_file\\n            self.dummy_file = opts.dummy_file\\n            self.timeinfo = opts.timeinfo\\n            self.timeout = opts.timeout\\n            self.unroll = opts.unroll\\n            self.noincr = opts.noincr\\n            self.info_stmts = opts.info_stmts\\n            self.nocomments = opts.nocomments\\n\\n        else:\\n            self.solver = \\\"yices\\\"\\n            self.solver_opts = list()\\n            self.debug_print = False\\n            self.debug_file = None\\n            self.dummy_file = None\\n            self.timeinfo = os.name != \\\"nt\\\"\\n            self.timeout = 0\\n            self.unroll = False\\n            self.noincr = False\\n            self.info_stmts = list()\\n            self.nocomments = False\\n\\n        self.start_time = time()\\n\\n        self.modinfo = dict()\\n        self.curmod = None\\n        self.topmod = None\\n        self.setup_done = False\\n\\n    def __del__(self):\\n        if self.p is not None and not forced_shutdown:\\n            os.killpg(os.getpgid(self.p.pid), signal.SIGTERM)\\n            if running_solvers is not None:\\n                del running_solvers[self.p_index]\\n\\n    def setup(self):\\n        assert not self.setup_done\\n\\n        if self.forall:\\n            self.unroll = False\\n\\n        if self.solver == \\\"yices\\\":\\n            if self.forall:\\n                self.noincr = True\\n\\n            if self.noincr:\\n                self.popen_vargs = ['yices-smt2'] + self.solver_opts\\n            else:\\n                self.popen_vargs = ['yices-smt2', '--incremental'] + self.solver_opts\\n            if self.timeout != 0:\\n                self.popen_vargs.append('-t')\\n                self.popen_vargs.append('%d' % self.timeout);\\n\\n        if self.solver == \\\"z3\\\":\\n            self.popen_vargs = ['z3', '-smt2', '-in'] + self.solver_opts\\n            if self.timeout != 0:\\n                self.popen_vargs.append('-T:%d' % self.timeout);\\n\\n        if self.solver in [\\\"cvc4\\\", \\\"cvc5\\\"]:\\n            self.recheck = True\\n            if self.noincr:\\n                self.popen_vargs = [self.solver, '--lang', 'smt2.6' if self.logic_dt else 'smt2'] + self.solver_opts\\n            else:\\n                self.popen_vargs = [self.solver, '--incremental', '--lang', 'smt2.6' if self.logic_dt else 'smt2'] + self.solver_opts\\n            if self.timeout != 0:\\n                self.popen_vargs.append('--tlimit=%d000' % self.timeout);\\n\\n        if self.solver == \\\"mathsat\\\":\\n            self.popen_vargs = ['mathsat'] + self.solver_opts\\n            if self.timeout != 0:\\n                print('timeout option is not supported for mathsat.')\\n                sys.exit(1)\\n\\n        if self.solver in [\\\"boolector\\\", \\\"bitwuzla\\\"]:\\n            if self.noincr:\\n                self.popen_vargs = [self.solver, '--smt2'] + self.solver_opts\\n            else:\\n                self.popen_vargs = [self.solver, '--smt2', '-i'] + self.solver_opts\\n            self.unroll = True\\n            if self.timeout != 0:\\n                print('timeout option is not supported for %s.' % self.solver)\\n                sys.exit(1)\\n\\n        if self.solver == \\\"abc\\\":\\n            if len(self.solver_opts) > 0:\\n                self.popen_vargs = ['yosys-abc', '-S', '; '.join(self.solver_opts)]\\n            else:\\n                self.popen_vargs = ['yosys-abc', '-S', '%blast; &sweep -C 5000; &syn4; &cec -s -m -C 2000']\\n            self.logic_ax = False\\n            self.unroll = True\\n            self.noincr = True\\n            if self.timeout != 0:\\n                print('timeout option is not supported for abc.')\\n                sys.exit(1)\\n\\n        if self.solver == \\\"dummy\\\":\\n            assert self.dummy_file is not None\\n            self.dummy_fd = open(self.dummy_file, \\\"r\\\")\\n        else:\\n            if self.dummy_file is not None:\\n                self.dummy_fd = open(self.dummy_file, \\\"w\\\")\\n            if not self.noincr:\\n                self.p_open()\\n\\n        if self.unroll:\\n            assert not self.forall\\n            self.logic_uf = False\\n            self.unroll_idcnt = 0\\n            self.unroll_buffer = \\\"\\\"\\n            self.unroll_level = 0\\n            self.unroll_sorts = set()\\n            self.unroll_objs = set()\\n            self.unroll_decls = dict()\\n            self.unroll_cache = dict()\\n            self.unroll_stack = list()\\n\\n        if self.logic is None:\\n            self.logic = \\\"\\\"\\n            if self.logic_qf: self.logic += \\\"QF_\\\"\\n            if self.logic_ax: self.logic += \\\"A\\\"\\n            if self.logic_uf: self.logic += \\\"UF\\\"\\n            if self.logic_bv: self.logic += \\\"BV\\\"\\n            if self.logic_dt: self.logic = \\\"ALL\\\"\\n            if self.solver == \\\"yices\\\" and self.forall: self.logic = \\\"BV\\\"\\n\\n        self.setup_done = True\\n\\n        for stmt in self.info_stmts:\\n            self.write(stmt)\\n\\n        if self.produce_models:\\n            self.write(\\\"(set-option :produce-models true)\\\")\\n\\n        #See the SMT-LIB Standard, Section 4.1.7\\n        modestart_options = [\\\":global-declarations\\\", \\\":interactive-mode\\\", \\\":produce-assertions\\\", \\\":produce-assignments\\\", \\\":produce-models\\\", \\\":produce-proofs\\\", \\\":produce-unsat-assumptions\\\", \\\":produce-unsat-cores\\\", \\\":random-seed\\\"]\\n        for key, val in self.smt2_options.items():\\n            if key in modestart_options:\\n                self.write(\\\"(set-option {} {})\\\".format(key, val))\\n\\n        self.write(\\\"(set-logic %s)\\\" % self.logic)\\n\\n        if self.forall and self.solver == \\\"yices\\\":\\n            self.write(\\\"(set-option :yices-ef-max-iters 1000000000)\\\")\\n\\n        for key, val in self.smt2_options.items():\\n            if key not in modestart_options:\\n                self.write(\\\"(set-option {} {})\\\".format(key, val))\\n\\n    def timestamp(self):\\n        secs = int(time() - self.start_time)\\n        return \\\"## %3d:%02d:%02d \\\" % (secs // (60*60), (secs // 60) % 60, secs % 60)\\n\\n    def replace_in_stmt(self, stmt, pat, repl):\\n        if stmt == pat:\\n            return repl\\n\\n        if isinstance(stmt, list):\\n            return [self.replace_in_stmt(s, pat, repl) for s in stmt]\\n\\n        return stmt\\n\\n    def unroll_stmt(self, stmt):\\n        result = []\\n        recursion_helper(self._unroll_stmt_into, stmt, result)\\n        return result.pop()\\n\\n    def _unroll_stmt_into(self, stmt, output, depth=128):\\n        if not isinstance(stmt, list):\\n            output.append(stmt)\\n            return\\n\\n        new_stmt = []\\n        for s in stmt:\\n            if depth:\\n                yield from self._unroll_stmt_into(s, new_stmt, depth - 1)\\n            else:\\n                yield s, new_stmt\\n        stmt = new_stmt\\n\\n        if len(stmt) >= 2 and not isinstance(stmt[0], list) and stmt[0] in self.unroll_decls:\\n            assert stmt[1] in self.unroll_objs\\n\\n            key = tuple(stmt)\\n            if key not in self.unroll_cache:\\n                decl = copy(self.unroll_decls[key[0]])\\n\\n                self.unroll_cache[key] = \\\"|UNROLL#%d|\\\" % self.unroll_idcnt\\n                decl[1] = self.unroll_cache[key]\\n                self.unroll_idcnt += 1\\n\\n                if decl[0] == \\\"declare-fun\\\":\\n                    if isinstance(decl[3], list) or decl[3] not in self.unroll_sorts:\\n                        self.unroll_objs.add(decl[1])\\n                        decl[2] = list()\\n                    else:\\n                        self.unroll_objs.add(decl[1])\\n                        decl = list()\\n\\n                elif decl[0] == \\\"define-fun\\\":\\n                    arg_index = 1\\n                    for arg_name, arg_sort in decl[2]:\\n                        decl[4] = self.replace_in_stmt(decl[4], arg_name, key[arg_index])\\n                        arg_index += 1\\n                    decl[2] = list()\\n\\n                if len(decl) > 0:\\n                    tmp = []\\n                    if depth:\\n                        yield from self._unroll_stmt_into(decl, tmp, depth - 1)\\n                    else:\\n                        yield decl, tmp\\n\\n                    decl = tmp.pop()\\n                    self.write(self.unparse(decl), unroll=False)\\n\\n            output.append(self.unroll_cache[key])\\n            return\\n\\n        output.append(stmt)\\n\\n    def p_thread_main(self):\\n        while True:\\n            data = self.p.stdout.readline().decode(\\\"utf-8\\\")\\n            if data == \\\"\\\": break\\n            self.p_queue.put(data)\\n        self.p_queue.put(\\\"\\\")\\n        self.p_running = False\\n\\n    def p_open(self):\\n        assert self.p is None\\n        try:\\n            self.p = subprocess.Popen(self.popen_vargs, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\\n        except FileNotFoundError:\\n            print(\\\"%s SMT Solver '%s' not found in path.\\\" % (self.timestamp(), self.popen_vargs[0]), flush=True)\\n            sys.exit(1)\\n        running_solvers[self.p_index] = self.p\\n        self.p_running = True\\n        self.p_next = None\\n        self.p_queue = Queue()\\n        self.p_thread = Thread(target=self.p_thread_main)\\n        self.p_thread.start()\\n\\n    def p_write(self, data, flush):\\n        assert self.p is not None\\n        self.p.stdin.write(bytes(data, \\\"utf-8\\\"))\\n        if flush: self.p.stdin.flush()\\n\\n    def p_read(self):\\n        assert self.p is not None\\n        if self.p_next is not None:\\n            data = self.p_next\\n            self.p_next = None\\n            return data\\n        if not self.p_running:\\n            return \\\"\\\"\\n        return self.p_queue.get()\\n\\n    def p_poll(self, timeout=0.1):\\n        assert self.p is not None\\n        assert self.p_running\\n        if self.p_next is not None:\\n            return False\\n        try:\\n            self.p_next = self.p_queue.get(True, timeout)\\n            return False\\n        except Empty:\\n            return True\\n\\n    def p_close(self):\\n        assert self.p is not None\\n        self.p.stdin.close()\\n        self.p_thread.join()\\n        assert not self.p_running\\n        del running_solvers[self.p_index]\\n        self.p = None\\n        self.p_next = None\\n        self.p_queue = None\\n        self.p_thread = None\\n\\n    def write(self, stmt, unroll=True):\\n        if stmt.startswith(\\\";\\\"):\\n            self.info(stmt)\\n            if not self.setup_done:\\n                self.info_stmts.append(stmt)\\n                return\\n        elif not self.setup_done:\\n            self.setup()\\n\\n        stmt = stmt.strip()\\n\\n        if self.nocomments or self.unroll:\\n            stmt = re.sub(r\\\" *;.*\\\", \\\"\\\", stmt)\\n            if stmt == \\\"\\\": return\\n\\n        recheck = None\\n\\n        if self.solver != \\\"dummy\\\":\\n            if self.noincr:\\n                # Don't close the solver yet, if we're just unrolling definitions\\n                # required for a (get-...) statement\\n                if self.p is not None and not stmt.startswith(\\\"(get-\\\") and unroll:\\n                    self.p_close()\\n\\n        if unroll and self.unroll:\\n            s = re.sub(r\\\"\\\\|[^|]*\\\\|\\\", \\\"\\\", stmt)\\n            self.unroll_level += s.count(\\\"(\\\") - s.count(\\\")\\\")\\n            if self.unroll_level > 0:\\n                self.unroll_buffer += stmt\\n                self.unroll_buffer += \\\" \\\"\\n                return\\n            else:\\n                stmt = self.unroll_buffer + stmt\\n                self.unroll_buffer = \\\"\\\"\\n\\n            s = self.parse(stmt)\\n\\n            if self.recheck and s and s[0].startswith(\\\"get-\\\"):\\n                recheck = self.unroll_idcnt\\n\\n            if self.debug_print:\\n                print(\\\"-> %s\\\" % s)\\n\\n            if len(s) == 3 and s[0] == \\\"declare-sort\\\" and s[2] == \\\"0\\\":\\n                self.unroll_sorts.add(s[1])\\n                return\\n\\n            elif len(s) == 4 and s[0] == \\\"declare-fun\\\" and s[2] == [] and s[3] in self.unroll_sorts:\\n                self.unroll_objs.add(s[1])\\n                return\\n\\n            elif len(s) >= 4 and s[0] == \\\"declare-fun\\\":\\n                for arg_sort in s[2]:\\n                    if arg_sort in self.unroll_sorts:\\n                        self.unroll_decls[s[1]] = s\\n                        return\\n\\n            elif len(s) >= 4 and s[0] == \\\"define-fun\\\":\\n                for arg_name, arg_sort in s[2]:\\n                    if arg_sort in self.unroll_sorts:\\n                        self.unroll_decls[s[1]] = s\\n                        return\\n\\n            stmt = self.unparse(self.unroll_stmt(s))\\n\\n            if recheck is not None and recheck != self.unroll_idcnt:\\n                self.check_sat([\\\"sat\\\"])\\n\\n            if stmt == \\\"(push 1)\\\":\\n                self.unroll_stack.append((\\n                    copy(self.unroll_sorts),\\n                    copy(self.unroll_objs),\\n                    copy(self.unroll_decls),\\n                    copy(self.unroll_cache),\\n                ))\\n\\n            if stmt == \\\"(pop 1)\\\":\\n                self.unroll_sorts, self.unroll_objs, self.unroll_decls, self.unroll_cache = self.unroll_stack.pop()\\n\\n        if self.debug_print:\\n            print(\\\"> %s\\\" % stmt)\\n\\n        if self.debug_file:\\n            print(stmt, file=self.debug_file)\\n            self.debug_file.flush()\\n\\n        if self.solver != \\\"dummy\\\":\\n            if self.noincr:\\n                if stmt == \\\"(push 1)\\\":\\n                    self.smt2cache.append(list())\\n                elif stmt == \\\"(pop 1)\\\":\\n                    self.smt2cache.pop()\\n                else:\\n                    if self.p is not None:\\n                        self.p_write(stmt + \\\"\\\\n\\\", True)\\n                    self.smt2cache[-1].append(stmt)\\n            else:\\n                self.p_write(stmt + \\\"\\\\n\\\", True)\\n\\n    def info(self, stmt):\\n        if not stmt.startswith(\\\"; yosys-smt2-\\\"):\\n            return\\n\\n        fields = stmt.split()\\n\\n        if fields[1] == \\\"yosys-smt2-solver-option\\\":\\n            self.smt2_options[fields[2]] = fields[3]\\n\\n        if fields[1] == \\\"yosys-smt2-nomem\\\":\\n            if self.logic is None:\\n                self.logic_ax = False\\n\\n        if fields[1] == \\\"yosys-smt2-nobv\\\":\\n            if self.logic is None:\\n                self.logic_bv = False\\n\\n        if fields[1] == \\\"yosys-smt2-stdt\\\":\\n            if self.logic is None:\\n                self.logic_dt = True\\n\\n        if fields[1] == \\\"yosys-smt2-forall\\\":\\n            if self.logic is None:\\n                self.logic_qf = False\\n            self.forall = True\\n\\n        if fields[1] == \\\"yosys-smt2-module\\\":\\n            self.curmod = fields[2]\\n            self.modinfo[self.curmod] = SmtModInfo()\\n\\n        if fields[1] == \\\"yosys-smt2-cell\\\":\\n            self.modinfo[self.curmod].cells[fields[3]] = fields[2]\\n\\n        if fields[1] == \\\"yosys-smt2-topmod\\\":\\n            self.topmod = fields[2]\\n\\n        if fields[1] == \\\"yosys-smt2-input\\\":\\n            self.modinfo[self.curmod].inputs.add(fields[2])\\n            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])\\n\\n        if fields[1] == \\\"yosys-smt2-output\\\":\\n            self.modinfo[self.curmod].outputs.add(fields[2])\\n            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])\\n\\n        if fields[1] == \\\"yosys-smt2-register\\\":\\n            self.modinfo[self.curmod].registers.add(fields[2])\\n            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])\\n\\n        if fields[1] == \\\"yosys-smt2-memory\\\":\\n            self.modinfo[self.curmod].memories[fields[2]] = (int(fields[3]), int(fields[4]), int(fields[5]), int(fields[6]), fields[7] == \\\"async\\\")\\n\\n        if fields[1] == \\\"yosys-smt2-wire\\\":\\n            self.modinfo[self.curmod].wires.add(fields[2])\\n            self.modinfo[self.curmod].wsize[fields[2]] = int(fields[3])\\n\\n        if fields[1] == \\\"yosys-smt2-clock\\\":\\n            for edge in fields[3:]:\\n                if fields[2] not in self.modinfo[self.curmod].clocks:\\n                    self.modinfo[self.curmod].clocks[fields[2]] = edge\\n                elif self.modinfo[self.curmod].clocks[fields[2]] != edge:\\n                    self.modinfo[self.curmod].clocks[fields[2]] = \\\"event\\\"\\n\\n        if fields[1] == \\\"yosys-smt2-assert\\\":\\n            if len(fields) > 4:\\n                self.modinfo[self.curmod].asserts[\\\"%s_a %s\\\" % (self.curmod, fields[2])] = f'{fields[4]} ({fields[3]})'\\n            else:\\n                self.modinfo[self.curmod].asserts[\\\"%s_a %s\\\" % (self.curmod, fields[2])] = fields[3]\\n\\n        if fields[1] == \\\"yosys-smt2-cover\\\":\\n            if len(fields) > 4:\\n                self.modinfo[self.curmod].covers[\\\"%s_c %s\\\" % (self.curmod, fields[2])] = f'{fields[4]} ({fields[3]})'\\n            else:\\n                self.modinfo[self.curmod].covers[\\\"%s_c %s\\\" % (self.curmod, fields[2])] = fields[3]\\n\\n        if fields[1] == \\\"yosys-smt2-assume\\\":\\n            if len(fields) > 4:\\n                self.modinfo[self.curmod].assumes[\\\"%s_u %s\\\" % (self.curmod, fields[2])] = f'{fields[4]} ({fields[3]})'\\n            else:\\n                self.modinfo[self.curmod].assumes[\\\"%s_u %s\\\" % (self.curmod, fields[2])] = fields[3]\\n\\n        if fields[1] == \\\"yosys-smt2-maximize\\\":\\n            self.modinfo[self.curmod].maximize.add(fields[2])\\n\\n        if fields[1] == \\\"yosys-smt2-minimize\\\":\\n            self.modinfo[self.curmod].minimize.add(fields[2])\\n\\n        if fields[1] == \\\"yosys-smt2-anyconst\\\":\\n            self.modinfo[self.curmod].anyconsts[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])\\n            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])\\n\\n        if fields[1] == \\\"yosys-smt2-anyseq\\\":\\n            self.modinfo[self.curmod].anyseqs[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])\\n            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])\\n\\n        if fields[1] == \\\"yosys-smt2-allconst\\\":\\n            self.modinfo[self.curmod].allconsts[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])\\n            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])\\n\\n        if fields[1] == \\\"yosys-smt2-allseq\\\":\\n            self.modinfo[self.curmod].allseqs[fields[2]] = (fields[4], None if len(fields) <= 5 else fields[5])\\n            self.modinfo[self.curmod].asize[fields[2]] = int(fields[3])\\n\\n        if fields[1] == \\\"yosys-smt2-witness\\\":\\n            data = json.loads(stmt.split(None, 2)[2])\\n            if data.get(\\\"type\\\") in [\\\"cell\\\", \\\"mem\\\", \\\"posedge\\\", \\\"negedge\\\", \\\"input\\\", \\\"reg\\\", \\\"init\\\", \\\"seq\\\", \\\"blackbox\\\"]:\\n                self.modinfo[self.curmod].witness.append(data)\\n\\n    def hiernets(self, top, regs_only=False):\\n        def hiernets_worker(nets, mod, cursor):\\n            for netname in sorted(self.modinfo[mod].wsize.keys()):\\n                if not regs_only or netname in self.modinfo[mod].registers:\\n                    nets.append(cursor + [netname])\\n            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):\\n                hiernets_worker(nets, celltype, cursor + [cellname])\\n\\n        nets = list()\\n        hiernets_worker(nets, top, [])\\n        return nets\\n\\n    def hieranyconsts(self, top):\\n        def worker(results, mod, cursor):\\n            for name, value in sorted(self.modinfo[mod].anyconsts.items()):\\n                width = self.modinfo[mod].asize[name]\\n                results.append((cursor, name, value[0], value[1], width))\\n            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):\\n                worker(results, celltype, cursor + [cellname])\\n\\n        results = list()\\n        worker(results, top, [])\\n        return results\\n\\n    def hieranyseqs(self, top):\\n        def worker(results, mod, cursor):\\n            for name, value in sorted(self.modinfo[mod].anyseqs.items()):\\n                width = self.modinfo[mod].asize[name]\\n                results.append((cursor, name, value[0], value[1], width))\\n            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):\\n                worker(results, celltype, cursor + [cellname])\\n\\n        results = list()\\n        worker(results, top, [])\\n        return results\\n\\n    def hierallconsts(self, top):\\n        def worker(results, mod, cursor):\\n            for name, value in sorted(self.modinfo[mod].allconsts.items()):\\n                width = self.modinfo[mod].asize[name]\\n                results.append((cursor, name, value[0], value[1], width))\\n            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):\\n                worker(results, celltype, cursor + [cellname])\\n\\n        results = list()\\n        worker(results, top, [])\\n        return results\\n\\n    def hierallseqs(self, top):\\n        def worker(results, mod, cursor):\\n            for name, value in sorted(self.modinfo[mod].allseqs.items()):\\n                width = self.modinfo[mod].asize[name]\\n                results.append((cursor, name, value[0], value[1], width))\\n            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):\\n                worker(results, celltype, cursor + [cellname])\\n\\n        results = list()\\n        worker(results, top, [])\\n        return results\\n\\n    def hiermems(self, top):\\n        def hiermems_worker(mems, mod, cursor):\\n            for memname in sorted(self.modinfo[mod].memories.keys()):\\n                mems.append(cursor + [memname])\\n            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):\\n                hiermems_worker(mems, celltype, cursor + [cellname])\\n\\n        mems = list()\\n        hiermems_worker(mems, top, [])\\n        return mems\\n\\n    def hierwitness(self, top, allregs=False, blackbox=True):\\n        init_witnesses = []\\n        seq_witnesses = []\\n        clk_witnesses = []\\n        mem_witnesses = []\\n\\n        def absolute(path, cursor, witness):\\n            return {\\n                **witness,\\n                \\\"path\\\": path + tuple(witness[\\\"path\\\"]),\\n                \\\"smtpath\\\": cursor + [witness[\\\"smtname\\\"]],\\n            }\\n\\n        for witness in self.modinfo[top].witness:\\n            if witness[\\\"type\\\"] == \\\"input\\\":\\n                seq_witnesses.append(absolute((), [], witness))\\n            if witness[\\\"type\\\"] in (\\\"posedge\\\", \\\"negedge\\\"):\\n                clk_witnesses.append(absolute((), [], witness))\\n\\n        init_types = [\\\"init\\\"]\\n        if allregs:\\n            init_types.append(\\\"reg\\\")\\n\\n        seq_types = [\\\"seq\\\"]\\n        if blackbox:\\n            seq_types.append(\\\"blackbox\\\")\\n\\n        def worker(mod, path, cursor):\\n            cell_paths = {}\\n            for witness in self.modinfo[mod].witness:\\n                if witness[\\\"type\\\"] in init_types:\\n                    init_witnesses.append(absolute(path, cursor, witness))\\n                if witness[\\\"type\\\"] in seq_types:\\n                    seq_witnesses.append(absolute(path, cursor, witness))\\n                if witness[\\\"type\\\"] == \\\"mem\\\":\\n                    if allregs and not witness[\\\"rom\\\"]:\\n                        width, size = witness[\\\"width\\\"], witness[\\\"size\\\"]\\n                        witness = {**witness, \\\"uninitialized\\\": [{\\\"width\\\": width * size, \\\"offset\\\": 0}]}\\n                    if not witness[\\\"uninitialized\\\"]:\\n                        continue\\n\\n                    mem_witnesses.append(absolute(path, cursor, witness))\\n                if witness[\\\"type\\\"] == \\\"cell\\\":\\n                    cell_paths[witness[\\\"smtname\\\"]] = tuple(witness[\\\"path\\\"])\\n\\n            for cellname, celltype in sorted(self.modinfo[mod].cells.items()):\\n                worker(celltype, path + cell_paths.get(cellname, (\\\"?\\\" + cellname,)), cursor + [cellname])\\n\\n        worker(top, (), [])\\n        return init_witnesses, seq_witnesses, clk_witnesses, mem_witnesses\\n\\n    def read(self):\\n        stmt = []\\n        count_brackets = 0\\n\\n        while True:\\n            if self.solver == \\\"dummy\\\":\\n                line = self.dummy_fd.readline().strip()\\n            else:\\n                line = self.p_read().strip()\\n                if self.dummy_file is not None:\\n                    self.dummy_fd.write(line + \\\"\\\\n\\\")\\n\\n            count_brackets += line.count(\\\"(\\\")\\n            count_brackets -= line.count(\\\")\\\")\\n            stmt.append(line)\\n\\n            if self.debug_print:\\n                print(\\\"< %s\\\" % line)\\n            if count_brackets == 0:\\n                break\\n            if self.solver != \\\"dummy\\\" and self.p.poll():\\n                print(\\\"%s Solver terminated unexpectedly: %s\\\" % (self.timestamp(), \\\"\\\".join(stmt)), flush=True)\\n                sys.exit(1)\\n\\n        stmt = \\\"\\\".join(stmt)\\n        if stmt.startswith(\\\"(error\\\"):\\n            print(\\\"%s Solver Error: %s\\\" % (self.timestamp(), stmt), flush=True)\\n            if self.solver != \\\"dummy\\\":\\n                self.p_close()\\n            sys.exit(1)\\n\\n        return stmt\\n\\n    def check_sat(self, expected=[\\\"sat\\\", \\\"unsat\\\", \\\"unknown\\\", \\\"timeout\\\", \\\"interrupted\\\"]):\\n        if self.smt2_assumptions:\\n            assume_exprs = \\\" \\\".join(self.smt2_assumptions.values())\\n            check_stmt = f\\\"(check-sat-assuming ({assume_exprs}))\\\"\\n        else:\\n            check_stmt = \\\"(check-sat)\\\"\\n        if self.debug_print:\\n            print(f\\\"> {check_stmt}\\\")\\n        if self.debug_file and not self.nocomments:\\n            print(\\\"; running check-sat..\\\", file=self.debug_file)\\n            self.debug_file.flush()\\n\\n        if self.solver != \\\"dummy\\\":\\n            if self.noincr:\\n                if self.p is not None:\\n                    self.p_close()\\n                self.p_open()\\n                for cache_ctx in self.smt2cache:\\n                    for cache_stmt in cache_ctx:\\n                        self.p_write(cache_stmt + \\\"\\\\n\\\", False)\\n\\n            self.p_write(f\\\"{check_stmt}\\\\n\\\", True)\\n\\n            if self.timeinfo:\\n                i = 0\\n                s = r\\\"/-\\\\|\\\"\\n\\n                count = 0\\n                num_bs = 0\\n                while self.p_poll():\\n                    count += 1\\n\\n                    if count < 25:\\n                        continue\\n\\n                    if count % 10 == 0 or count == 25:\\n                        secs = count // 10\\n\\n                        if secs < 60:\\n                            m = \\\"(%d seconds)\\\" % secs\\n                        elif secs < 60*60:\\n                            m = \\\"(%d seconds -- %d:%02d)\\\" % (secs, secs // 60, secs % 60)\\n                        else:\\n                            m = \\\"(%d seconds -- %d:%02d:%02d)\\\" % (secs, secs // (60*60), (secs // 60) % 60, secs % 60)\\n\\n                        print(\\\"%s %s %c\\\" % (\\\"\\\\b \\\\b\\\" * num_bs, m, s[i]), end=\\\"\\\", file=sys.stderr)\\n                        num_bs = len(m) + 3\\n\\n                    else:\\n                        print(\\\"\\\\b\\\" + s[i], end=\\\"\\\", file=sys.stderr)\\n\\n                    sys.stderr.flush()\\n                    i = (i + 1) % len(s)\\n\\n                if num_bs != 0:\\n                    print(\\\"\\\\b \\\\b\\\" * num_bs, end=\\\"\\\", file=sys.stderr)\\n                    sys.stderr.flush()\\n\\n            else:\\n                count = 0\\n                while self.p_poll(60):\\n                    count += 1\\n                    msg = None\\n\\n                    if count == 1:\\n                        msg = \\\"1 minute\\\"\\n\\n                    elif count in [5, 10, 15, 30]:\\n                        msg = \\\"%d minutes\\\" % count\\n\\n                    elif count == 60:\\n                        msg = \\\"1 hour\\\"\\n\\n                    elif count % 60 == 0:\\n                        msg = \\\"%d hours\\\" % (count // 60)\\n\\n                    if msg is not None:\\n                        print(\\\"%s waiting for solver (%s)\\\" % (self.timestamp(), msg), flush=True)\\n\\n        if self.forall:\\n            result = self.read()\\n            while result not in [\\\"sat\\\", \\\"unsat\\\", \\\"unknown\\\", \\\"timeout\\\", \\\"interrupted\\\", \\\"\\\"]:\\n                print(\\\"%s %s: %s\\\" % (self.timestamp(), self.solver, result))\\n                result = self.read()\\n        else:\\n            result = self.read()\\n\\n        if self.debug_file:\\n            print(\\\"(set-info :status %s)\\\" % result, file=self.debug_file)\\n            print(check_stmt, file=self.debug_file)\\n            self.debug_file.flush()\\n\\n        if result not in expected:\\n            if result == \\\"\\\":\\n                print(\\\"%s Unexpected EOF response from solver.\\\" % (self.timestamp()), flush=True)\\n            else:\\n                print(\\\"%s Unexpected response from solver: %s\\\" % (self.timestamp(), result), flush=True)\\n            if self.solver != \\\"dummy\\\":\\n                self.p_close()\\n            sys.exit(1)\\n\\n        return result\\n\\n    def parse(self, stmt):\\n        def worker(stmt, cursor=0):\\n            while stmt[cursor] in [\\\" \\\", \\\"\\\\t\\\", \\\"\\\\r\\\", \\\"\\\\n\\\"]:\\n                cursor += 1\\n\\n            if stmt[cursor] == '(':\\n                expr = []\\n                cursor += 1\\n                while stmt[cursor] != ')':\\n                    el, cursor = worker(stmt, cursor)\\n                    expr.append(el)\\n                return expr, cursor+1\\n\\n            if stmt[cursor] == '|':\\n                expr = \\\"|\\\"\\n                cursor += 1\\n                while stmt[cursor] != '|':\\n                    expr += stmt[cursor]\\n                    cursor += 1\\n                expr += \\\"|\\\"\\n                return expr, cursor+1\\n\\n            expr = \\\"\\\"\\n            while stmt[cursor] not in [\\\"(\\\", \\\")\\\", \\\"|\\\", \\\" \\\", \\\"\\\\t\\\", \\\"\\\\r\\\", \\\"\\\\n\\\"]:\\n                expr += stmt[cursor]\\n                cursor += 1\\n            return expr, cursor\\n        return worker(stmt)[0]\\n\\n    def unparse(self, stmt):\\n        if isinstance(stmt, list):\\n            return \\\"(\\\" + \\\" \\\".join([self.unparse(s) for s in stmt]) + \\\")\\\"\\n        return stmt\\n\\n    def bv2hex(self, v):\\n        h = \\\"\\\"\\n        v = self.bv2bin(v)\\n        while len(v) > 0:\\n            d = 0\\n            if len(v) > 0 and v[-1] == \\\"1\\\": d += 1\\n            if len(v) > 1 and v[-2] == \\\"1\\\": d += 2\\n            if len(v) > 2 and v[-3] == \\\"1\\\": d += 4\\n            if len(v) > 3 and v[-4] == \\\"1\\\": d += 8\\n            h = hex(d)[2:] + h\\n            if len(v) < 4: break\\n            v = v[:-4]\\n        return h\\n\\n    def bv2bin(self, v):\\n        if type(v) is list and len(v) == 3 and v[0] == \\\"_\\\" and v[1].startswith(\\\"bv\\\"):\\n            x, n = int(v[1][2:]), int(v[2])\\n            return \\\"\\\".join(\\\"1\\\" if (x & (1 << i)) else \\\"0\\\" for i in range(n-1, -1, -1))\\n        if v == \\\"true\\\": return \\\"1\\\"\\n        if v == \\\"false\\\": return \\\"0\\\"\\n        if v.startswith(\\\"#b\\\"):\\n            return v[2:]\\n        if v.startswith(\\\"#x\\\"):\\n            return \\\"\\\".join(hex_dict.get(x) for x in v[2:])\\n        assert False\\n\\n    def bv2int(self, v):\\n        return int(self.bv2bin(v), 2)\\n\\n    def get_raw_unsat_assumptions(self):\\n        self.write(\\\"(get-unsat-assumptions)\\\")\\n        exprs = set(self.unparse(part) for part in self.parse(self.read()))\\n        unsat_assumptions = []\\n        for key, value in self.smt2_assumptions.items():\\n            # normalize expression\\n            value = self.unparse(self.parse(value))\\n            if value in exprs:\\n                exprs.remove(value)\\n                unsat_assumptions.append(key)\\n        return unsat_assumptions\\n\\n    def get_unsat_assumptions(self, minimize=False):\\n        if not minimize:\\n            return self.get_raw_unsat_assumptions()\\n        required_assumptions = {}\\n\\n        while True:\\n            candidate_assumptions = {}\\n            for key in self.get_raw_unsat_assumptions():\\n                if key not in required_assumptions:\\n                    candidate_assumptions[key] = self.smt2_assumptions[key]\\n\\n            while candidate_assumptions:\\n\\n                candidate_key, candidate_assume = candidate_assumptions.popitem()\\n\\n                self.smt2_assumptions = {}\\n                for key, assume in candidate_assumptions.items():\\n                    self.smt2_assumptions[key] = assume\\n                for key, assume in required_assumptions.items():\\n                    self.smt2_assumptions[key] = assume\\n                result = self.check_sat()\\n\\n                if result == 'unsat':\\n                    candidate_assumptions = None\\n                else:\\n                    required_assumptions[candidate_key] = candidate_assume\\n\\n            if candidate_assumptions is not None:\\n                return list(required_assumptions)\\n\\n    def get(self, expr):\\n        self.write(\\\"(get-value (%s))\\\" % (expr))\\n        return self.parse(self.read())[0][1]\\n\\n    def get_list(self, expr_list):\\n        if len(expr_list) == 0:\\n            return []\\n        self.write(\\\"(get-value (%s))\\\" % \\\" \\\".join(expr_list))\\n        return [n[1] for n in self.parse(self.read()) if n]\\n\\n    def get_path(self, mod, path):\\n        assert mod in self.modinfo\\n        path = path.replace(\\\"\\\\\\\\\\\", \\\"/\\\").split(\\\".\\\")\\n\\n        for i in range(len(path)-1):\\n            first = \\\".\\\".join(path[0:i+1])\\n            second = \\\".\\\".join(path[i+1:])\\n\\n            if first in self.modinfo[mod].cells:\\n                nextmod = self.modinfo[mod].cells[first]\\n                return [first] + self.get_path(nextmod, second)\\n\\n        return [\\\".\\\".join(path)]\\n\\n    def net_expr(self, mod, base, path):\\n        if len(path) == 0:\\n            return base\\n\\n        if len(path) == 1:\\n            assert mod in self.modinfo\\n            if path[0] == \\\"\\\":\\n                return base\\n            if isinstance(path[0], int):\\n                return \\\"(|%s#%d| %s)\\\" % (mod, path[0], base)\\n            if path[0] in self.modinfo[mod].cells:\\n                return \\\"(|%s_h %s| %s)\\\" % (mod, path[0], base)\\n            if path[0] in self.modinfo[mod].wsize:\\n                return \\\"(|%s_n %s| %s)\\\" % (mod, path[0], base)\\n            if path[0] in self.modinfo[mod].memories:\\n                return \\\"(|%s_m %s| %s)\\\" % (mod, path[0], base)\\n            assert 0\\n\\n        assert mod in self.modinfo\\n        assert path[0] in self.modinfo[mod].cells\\n\\n        nextmod = self.modinfo[mod].cells[path[0]]\\n        nextbase = \\\"(|%s_h %s| %s)\\\" % (mod, path[0], base)\\n        return self.net_expr(nextmod, nextbase, path[1:])\\n\\n    def witness_net_expr(self, mod, base, witness):\\n        net = self.net_expr(mod, base, witness[\\\"smtpath\\\"])\\n        is_bool = self.net_width(mod, witness[\\\"smtpath\\\"]) == 1\\n        if is_bool:\\n            assert witness[\\\"width\\\"] == 1\\n            assert witness[\\\"smtoffset\\\"] == 0\\n            return net\\n        return \\\"((_ extract %d %d) %s)\\\" % (witness[\\\"smtoffset\\\"] + witness[\\\"width\\\"] - 1, witness[\\\"smtoffset\\\"], net)\\n\\n    def net_width(self, mod, net_path):\\n        for i in range(len(net_path)-1):\\n            assert mod in self.modinfo\\n            assert net_path[i] in self.modinfo[mod].cells\\n            mod = self.modinfo[mod].cells[net_path[i]]\\n\\n        assert mod in self.modinfo\\n        if isinstance(net_path[-1], int):\\n            return None\\n        assert net_path[-1] in self.modinfo[mod].wsize\\n        return self.modinfo[mod].wsize[net_path[-1]]\\n\\n    def net_clock(self, mod, net_path):\\n        for i in range(len(net_path)-1):\\n            assert mod in self.modinfo\\n            assert net_path[i] in self.modinfo[mod].cells\\n            mod = self.modinfo[mod].cells[net_path[i]]\\n\\n        assert mod in self.modinfo\\n        if net_path[-1] not in self.modinfo[mod].clocks:\\n            return None\\n        return self.modinfo[mod].clocks[net_path[-1]]\\n\\n    def net_exists(self, mod, net_path):\\n        for i in range(len(net_path)-1):\\n            if mod not in self.modinfo: return False\\n            if net_path[i] not in self.modinfo[mod].cells: return False\\n            mod = self.modinfo[mod].cells[net_path[i]]\\n\\n        if mod not in self.modinfo: return False\\n        if net_path[-1] not in self.modinfo[mod].wsize: return False\\n        return True\\n\\n    def mem_exists(self, mod, mem_path):\\n        for i in range(len(mem_path)-1):\\n            if mod not in self.modinfo: return False\\n            if mem_path[i] not in self.modinfo[mod].cells: return False\\n            mod = self.modinfo[mod].cells[mem_path[i]]\\n\\n        if mod not in self.modinfo: return False\\n        if mem_path[-1] not in self.modinfo[mod].memories: return False\\n        return True\\n\\n    def mem_expr(self, mod, base, path, port=None, infomode=False):\\n        if len(path) == 1:\\n            assert mod in self.modinfo\\n            assert path[0] in self.modinfo[mod].memories\\n            if infomode:\\n                return self.modinfo[mod].memories[path[0]]\\n            return \\\"(|%s_m%s %s| %s)\\\" % (mod, \\\"\\\" if port is None else \\\":%s\\\" % port, path[0], base)\\n\\n        assert mod in self.modinfo\\n        assert path[0] in self.modinfo[mod].cells\\n\\n        nextmod = self.modinfo[mod].cells[path[0]]\\n        nextbase = \\\"(|%s_h %s| %s)\\\" % (mod, path[0], base)\\n        return self.mem_expr(nextmod, nextbase, path[1:], port=port, infomode=infomode)\\n\\n    def mem_info(self, mod, path):\\n        return self.mem_expr(mod, \\\"\\\", path, infomode=True)\\n\\n    def get_net(self, mod_name, net_path, state_name):\\n        return self.get(self.net_expr(mod_name, state_name, net_path))\\n\\n    def get_net_list(self, mod_name, net_path_list, state_name):\\n        return self.get_list([self.net_expr(mod_name, state_name, n) for n in net_path_list])\\n\\n    def get_net_hex(self, mod_name, net_path, state_name):\\n        return self.bv2hex(self.get_net(mod_name, net_path, state_name))\\n\\n    def get_net_hex_list(self, mod_name, net_path_list, state_name):\\n        return [self.bv2hex(v) for v in self.get_net_list(mod_name, net_path_list, state_name)]\\n\\n    def get_net_bin(self, mod_name, net_path, state_name):\\n        return self.bv2bin(self.get_net(mod_name, net_path, state_name))\\n\\n    def get_net_bin_list(self, mod_name, net_path_list, state_name):\\n        return [self.bv2bin(v) for v in self.get_net_list(mod_name, net_path_list, state_name)]\\n\\n    def wait(self):\\n        if self.p is not None:\\n            self.p.wait()\\n            self.p_close()\\n\\n\\nclass SmtOpts:\\n    def __init__(self):\\n        self.shortopts = \\\"s:S:v\\\"\\n        self.longopts = [\\\"unroll\\\", \\\"noincr\\\", \\\"noprogress\\\", \\\"timeout=\\\", \\\"dump-smt2=\\\", \\\"logic=\\\", \\\"dummy=\\\", \\\"info=\\\", \\\"nocomments\\\"]\\n        self.solver = \\\"yices\\\"\\n        self.solver_opts = list()\\n        self.debug_print = False\\n        self.debug_file = None\\n        self.dummy_file = None\\n        self.unroll = False\\n        self.noincr = False\\n        self.timeinfo = os.name != \\\"nt\\\"\\n        self.timeout = 0\\n        self.logic = None\\n        self.info_stmts = list()\\n        self.nocomments = False\\n\\n    def handle(self, o, a):\\n        if o == \\\"-s\\\":\\n            self.solver = a\\n        elif o == \\\"-S\\\":\\n            self.solver_opts.append(a)\\n        elif o == \\\"--timeout\\\":\\n            self.timeout = int(a)\\n        elif o == \\\"-v\\\":\\n            self.debug_print = True\\n        elif o == \\\"--unroll\\\":\\n            self.unroll = True\\n        elif o == \\\"--noincr\\\":\\n            self.noincr = True\\n        elif o == \\\"--noprogress\\\":\\n            self.timeinfo = False\\n        elif o == \\\"--dump-smt2\\\":\\n            self.debug_file = open(a, \\\"w\\\")\\n        elif o == \\\"--logic\\\":\\n            self.logic = a\\n        elif o == \\\"--dummy\\\":\\n            self.dummy_file = a\\n        elif o == \\\"--info\\\":\\n            self.info_stmts.append(a)\\n        elif o == \\\"--nocomments\\\":\\n            self.nocomments = True\\n        else:\\n            return False\\n        return True\\n\\n    def helpmsg(self):\\n        return \\\"\\\"\\\"\\n    -s <solver>\\n        set SMT solver: z3, yices, boolector, bitwuzla, cvc4, mathsat, dummy\\n        default: yices\\n\\n    -S <opt>\\n        pass <opt> as command line argument to the solver\\n\\n    --timeout <value>\\n        set the solver timeout to the specified value (in seconds).\\n\\n    --logic <smt2_logic>\\n        use the specified SMT2 logic (e.g. QF_AUFBV)\\n\\n    --dummy <filename>\\n        if solver is \\\"dummy\\\", read solver output from that file\\n        otherwise: write solver output to that file\\n\\n    -v\\n        enable debug output\\n\\n    --unroll\\n        unroll uninterpreted functions\\n\\n    --noincr\\n        don't use incremental solving, instead restart solver for\\n        each (check-sat). This also avoids (push) and (pop).\\n\\n    --noprogress\\n        disable timer display during solving\\n        (this option is set implicitly on Windows)\\n\\n    --dump-smt2 <filename>\\n        write smt2 statements to file\\n\\n    --info <smt2-info-stmt>\\n        include the specified smt2 info statement in the smt2 output\\n\\n    --nocomments\\n        strip all comments from the generated smt2 code\\n\\\"\\\"\\\"\\n\\n\\nclass MkVcd:\\n    def __init__(self, f):\\n        self.f = f\\n        self.t = -1\\n        self.nets = dict()\\n        self.clocks = dict()\\n\\n    def add_net(self, path, width):\\n        path = tuple(path)\\n        assert self.t == -1\\n        key = \\\"n%d\\\" % len(self.nets)\\n        self.nets[path] = (key, width)\\n\\n    def add_clock(self, path, edge):\\n        path = tuple(path)\\n        assert self.t == -1\\n        key = \\\"n%d\\\" % len(self.nets)\\n        self.nets[path] = (key, 1)\\n        self.clocks[path] = (key, edge)\\n\\n    def set_net(self, path, bits):\\n        path = tuple(path)\\n        assert self.t >= 0\\n        assert path in self.nets\\n        if path not in self.clocks:\\n            print(\\\"b%s %s\\\" % (bits, self.nets[path][0]), file=self.f)\\n\\n    def escape_name(self, name):\\n        name = re.sub(r\\\"\\\\[([0-9a-zA-Z_]*[a-zA-Z_][0-9a-zA-Z_]*)\\\\]\\\", r\\\"<\\\\1>\\\", name)\\n        if re.match(r\\\"[\\\\[\\\\]]\\\", name) and name[0] != \\\"\\\\\\\\\\\":\\n            name = \\\"\\\\\\\\\\\" + name\\n        return name\\n\\n    def set_time(self, t):\\n        assert t >= self.t\\n        if t != self.t:\\n            if self.t == -1:\\n                print(\\\"$version Generated by Yosys-SMTBMC $end\\\", file=self.f)\\n                print(\\\"$timescale 1ns $end\\\", file=self.f)\\n                print(\\\"$var integer 32 t smt_step $end\\\", file=self.f)\\n                print(\\\"$var event 1 ! smt_clock $end\\\", file=self.f)\\n\\n                def vcdescape(n):\\n                    if n.startswith(\\\"$\\\") or \\\":\\\" in n:\\n                        return \\\"\\\\\\\\\\\" + n\\n                    return n\\n\\n                scope = []\\n                for path in sorted(self.nets):\\n                    key, width = self.nets[path]\\n\\n                    uipath = list(path)\\n                    if \\\".\\\" in uipath[-1] and not uipath[-1].startswith(\\\"$\\\"):\\n                        uipath = uipath[0:-1] + uipath[-1].split(\\\".\\\")\\n                    for i in range(len(uipath)):\\n                        uipath[i] = re.sub(r\\\"\\\\[([^\\\\]]*)\\\\]\\\", r\\\"<\\\\1>\\\", uipath[i])\\n\\n                    while uipath[:len(scope)] != scope:\\n                        print(\\\"$upscope $end\\\", file=self.f)\\n                        scope = scope[:-1]\\n\\n                    while uipath[:-1] != scope:\\n                        scopename = uipath[len(scope)]\\n                        print(\\\"$scope module %s $end\\\" % vcdescape(scopename), file=self.f)\\n                        scope.append(uipath[len(scope)])\\n\\n                    if path in self.clocks and self.clocks[path][1] == \\\"event\\\":\\n                        print(\\\"$var event 1 %s %s $end\\\" % (key, vcdescape(uipath[-1])), file=self.f)\\n                    else:\\n                        print(\\\"$var wire %d %s %s $end\\\" % (width, key, vcdescape(uipath[-1])), file=self.f)\\n\\n                for i in range(len(scope)):\\n                    print(\\\"$upscope $end\\\", file=self.f)\\n\\n                print(\\\"$enddefinitions $end\\\", file=self.f)\\n\\n            self.t = t\\n            assert self.t >= 0\\n\\n            if self.t > 0:\\n                print(\\\"#%d\\\" % (10 * self.t - 5), file=self.f)\\n                for path in sorted(self.clocks.keys()):\\n                    if self.clocks[path][1] == \\\"posedge\\\":\\n                        print(\\\"b0 %s\\\" % self.nets[path][0], file=self.f)\\n                    elif self.clocks[path][1] == \\\"negedge\\\":\\n                        print(\\\"b1 %s\\\" % self.nets[path][0], file=self.f)\\n\\n            print(\\\"#%d\\\" % (10 * self.t), file=self.f)\\n            print(\\\"1!\\\", file=self.f)\\n            print(\\\"b%s t\\\" % format(self.t, \\\"032b\\\"), file=self.f)\\n\\n            for path in sorted(self.clocks.keys()):\\n                if self.clocks[path][1] == \\\"negedge\\\":\\n                    print(\\\"b0 %s\\\" % self.nets[path][0], file=self.f)\\n                else:\\n                    print(\\\"b1 %s\\\" % self.nets[path][0], file=self.f)\\n\",\n            \"ywio.py\": \"#\\n# yosys -- Yosys Open SYnthesis Suite\\n#\\n# Copyright (C) 2022  Jannis Harder <jix@yosyshq.com> <me@jix.one>\\n#\\n# Permission to use, copy, modify, and/or distribute this software for any\\n# purpose with or without fee is hereby granted, provided that the above\\n# copyright notice and this permission notice appear in all copies.\\n#\\n# THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n#\\n\\nimport json, re\\n\\nfrom functools import total_ordering\\n\\n\\nclass PrettyJson:\\n    def __init__(self, f):\\n        self.f = f\\n        self.indent = 0\\n        self.state = [\\\"value\\\"]\\n\\n    def line(self):\\n        indent = len(self.state) - bool(self.state and self.state[-1] == \\\"value\\\")\\n        print(\\\"\\\\n\\\", end=\\\" \\\" * (2 * indent), file=self.f)\\n\\n    def raw(self, str):\\n        print(end=str, file=self.f)\\n\\n    def begin_object(self):\\n        self.begin_value()\\n        self.raw(\\\"{\\\")\\n        self.state.append(\\\"object_first\\\")\\n\\n    def begin_array(self):\\n        self.begin_value()\\n        self.raw(\\\"[\\\")\\n        self.state.append(\\\"array_first\\\")\\n\\n    def end_object(self):\\n        state = self.state.pop()\\n        if state == \\\"object\\\":\\n            self.line()\\n        else:\\n            assert state == \\\"object_first\\\"\\n        self.raw(\\\"}\\\")\\n        self.end_value()\\n\\n    def end_array(self):\\n        state = self.state.pop()\\n        if state == \\\"array\\\":\\n            self.line()\\n        else:\\n            assert state == \\\"array_first\\\"\\n        self.raw(\\\"]\\\")\\n        self.end_value()\\n\\n    def name(self, name):\\n        if self.state[-1] == \\\"object_first\\\":\\n            self.state[-1] = \\\"object\\\"\\n        else:\\n            self.raw(\\\",\\\")\\n        self.line()\\n        json.dump(str(name), self.f)\\n        self.raw(\\\": \\\")\\n        self.state.append(\\\"value\\\")\\n\\n    def begin_value(self):\\n        if self.state[-1] == \\\"array_first\\\":\\n            self.line()\\n            self.state[-1] = \\\"array\\\"\\n        elif self.state[-1] == \\\"array\\\":\\n            self.raw(\\\",\\\")\\n            self.line()\\n        else:\\n            assert self.state.pop() == \\\"value\\\"\\n\\n    def end_value(self):\\n        if not self.state:\\n            print(file=self.f, flush=True)\\n\\n    def value(self, value):\\n        self.begin_value()\\n        json.dump(value, self.f)\\n        self.end_value()\\n\\n    def entry(self, name, value):\\n        self.name(name)\\n        self.value(value)\\n\\n    def object(self, entries=None):\\n        if isinstance(entries, dict):\\n            entries = dict.items()\\n        self.begin_object()\\n        for name, value in entries:\\n            self.entry(name, value)\\n        self.end_object()\\n\\n    def array(self, values=None):\\n        self.begin_array()\\n        for value in values:\\n            self.value(value)\\n        self.end_array()\\n\\n\\naddr_re = re.compile(r'\\\\\\\\\\\\[[0-9]+\\\\]$')\\npublic_name_re = re.compile(r\\\"\\\\\\\\([a-zA-Z_][a-zA-Z0-9_]*(\\\\[[0-9]+\\\\])?|\\\\[[0-9]+\\\\])$\\\")\\n\\ndef pretty_name(id):\\n    if public_name_re.match(id):\\n        return id.lstrip(\\\"\\\\\\\\\\\")\\n    else:\\n        return id\\n\\ndef pretty_path(path):\\n    out = \\\"\\\"\\n    for name in path:\\n        name = pretty_name(name)\\n        if name.startswith(\\\"[\\\"):\\n            out += name\\n            continue\\n        if out:\\n            out += \\\".\\\"\\n        if name.startswith(\\\"\\\\\\\\\\\") or name.startswith(\\\"$\\\"):\\n            out += name + \\\" \\\"\\n        else:\\n            out += name\\n\\n    return out\\n\\n@total_ordering\\nclass WitnessSig:\\n    def __init__(self, path, offset, width=1, init_only=False):\\n        path = tuple(path)\\n        self.path, self.width, self.offset, self.init_only = path, width, offset, init_only\\n\\n        self.memory_path = None\\n        self.memory_addr = None\\n\\n        sort_path = path\\n        sort_id = -1\\n        if path and addr_re.match(path[-1]):\\n            self.memory_path = sort_path = path[:-1]\\n            self.memory_addr = sort_id = int(path[-1][2:-1])\\n\\n        self.sort_key = (init_only, sort_path, sort_id, offset, width)\\n\\n    def bits(self):\\n        return ((self.path, i) for i in range(self.offset, self.offset + self.width))\\n\\n    def rev_bits(self):\\n        return ((self.path, i) for i in reversed(range(self.offset, self.offset + self.width)))\\n\\n    def pretty(self):\\n        if self.width > 1:\\n            last_offset = self.offset + self.width - 1\\n            return f\\\"{pretty_path(self.path)}[{last_offset}:{self.offset}]\\\"\\n        else:\\n            return f\\\"{pretty_path(self.path)}[{self.offset}]\\\"\\n\\n    def __eq__(self, other):\\n        return self.sort_key == other.sort_key\\n\\n    def __hash__(self):\\n        return hash(self.sort_key)\\n\\n    def __lt__(self, other):\\n        return self.sort_key < other.sort_key\\n\\n\\ndef coalesce_signals(signals, bits=None):\\n    if bits is None:\\n        bits = {}\\n    for sig in signals:\\n        for bit in sig.bits():\\n            if sig.init_only:\\n                bits.setdefault(bit, False)\\n            else:\\n                bits[bit] = True\\n\\n    active = None\\n\\n    out = []\\n\\n    for bit, not_init in sorted(bits.items()):\\n        if active:\\n            if active[0] == bit[0] and active[2] == bit[1] and active[3] == not_init:\\n                active[2] += 1\\n            else:\\n                out.append(WitnessSig(active[0], active[1], active[2] - active[1], not active[3]))\\n                active = None\\n\\n        if active is None:\\n            active = [bit[0], bit[1], bit[1] + 1, not_init]\\n\\n    if active:\\n        out.append(WitnessSig(active[0], active[1], active[2] - active[1], not active[3]))\\n\\n    return sorted(out)\\n\\n\\nclass WitnessSigMap:\\n    def __init__(self, signals=[]):\\n        self.signals = []\\n\\n        self.id_to_bit = []\\n        self.bit_to_id = {}\\n        self.bit_to_sig = {}\\n\\n        for sig in signals:\\n            self.add_signal(sig)\\n\\n    def add_signal(self, sig):\\n        self.signals.append(sig)\\n        for bit in sig.bits():\\n            self.add_bit(bit)\\n            self.bit_to_sig[bit] = sig\\n\\n    def add_bit(self, bit, id=None):\\n        if id is None:\\n            id = len(self.id_to_bit)\\n            self.id_to_bit.append(bit)\\n        else:\\n            if len(self.id_to_bit) <= id:\\n                self.id_to_bit += [None] * (id - len(self.id_to_bit) + 1)\\n            self.id_to_bit[id] = bit\\n        self.bit_to_id[bit] = id\\n\\n\\nclass WitnessValues:\\n    def __init__(self):\\n        self.values = {}\\n\\n    def __setitem__(self, key, value):\\n        if isinstance(key, tuple) and len(key) == 2:\\n            if value != \\\"?\\\":\\n                assert isinstance(value, str)\\n                assert len(value) == 1\\n                self.values[key] = value\\n        else:\\n            assert isinstance(key, WitnessSig)\\n            assert key.width == len(value)\\n            if isinstance(value, str):\\n                value = reversed(value)\\n            for bit, bit_value in zip(key.bits(), value):\\n                if bit_value != \\\"?\\\":\\n                    self.values[bit] = bit_value\\n\\n    def __getitem__(self, key):\\n        if isinstance(key, tuple) and len(key) == 2:\\n            return self.values.get(key, \\\"?\\\")\\n        else:\\n            assert isinstance(key, WitnessSig)\\n            return \\\"\\\".join([self.values.get(bit, \\\"?\\\") for bit in key.rev_bits()])\\n\\n    def pack_present(self, sigmap):\\n        missing = []\\n\\n        max_id = max((sigmap.bit_to_id.get(bit, -1) for bit in self.values), default=-1)\\n\\n        vector = [\\\"?\\\"] * (max_id + 1)\\n        for bit, bit_value in self.values.items():\\n            id = sigmap.bit_to_id.get(bit, - 1)\\n            if id < 0:\\n                missing.append(bit)\\n            else:\\n                vector[max_id - sigmap.bit_to_id[bit]] = bit_value\\n\\n        return \\\"\\\".join(vector), missing\\n\\n    def pack(self, sigmap):\\n        packed, missing = self.pack_present(sigmap)\\n        if missing:\\n            raise RuntimeError(f\\\"Cannot pack bits {missing!r}\\\")\\n        return packed\\n\\n    def unpack(self, sigmap, bits):\\n        for i, bit_value in enumerate(reversed(bits)):\\n            if bit_value != \\\"?\\\":\\n                self.values[sigmap.id_to_bit[i]] = bit_value\\n\\n    def present_signals(self, sigmap):\\n        signals = set(sigmap.bit_to_sig.get(bit) for bit in self.values)\\n        missing_signals = None in signals\\n        if missing_signals:\\n            signals.discard(None)\\n\\n        return sorted(signals), missing_signals\\n\\n    def __add__(self, other: \\\"WitnessValues\\\"):\\n        new = WitnessValues()\\n        new += self\\n        new += other\\n        return new\\n\\n    def __iadd__(self, other: \\\"WitnessValues\\\"):\\n        for key, value in other.values.items():\\n            self.values.setdefault(key, value)\\n        return self\\n\\nclass WriteWitness:\\n    def __init__(self, f, generator):\\n        self.out = PrettyJson(f)\\n        self.t = 0\\n        self.header_written = False\\n        self.clocks = []\\n        self.signals = []\\n\\n        self.out.begin_object()\\n        self.out.entry(\\\"format\\\", \\\"Yosys Witness Trace\\\")\\n        self.out.entry(\\\"generator\\\", generator)\\n\\n    def add_clock(self, path, offset, edge):\\n        assert not self.header_written\\n        self.clocks.append({\\n            \\\"path\\\": path,\\n            \\\"edge\\\": edge,\\n            \\\"offset\\\": offset,\\n        })\\n\\n    def add_sig(self, path, offset, width=1, init_only=False):\\n        assert not self.header_written\\n        sig = WitnessSig(path, offset, width, init_only)\\n        self.signals.append(sig)\\n        return sig\\n\\n    def write_header(self):\\n        assert not self.header_written\\n        self.header_written = True\\n        self.out.name(\\\"clocks\\\")\\n        self.out.array(self.clocks)\\n\\n        self.signals = coalesce_signals(self.signals)\\n        self.sigmap = WitnessSigMap(self.signals)\\n\\n        self.out.name(\\\"signals\\\")\\n        self.out.array({\\n            \\\"path\\\": sig.path,\\n            \\\"width\\\": sig.width,\\n            \\\"offset\\\": sig.offset,\\n            \\\"init_only\\\": sig.init_only,\\n        } for sig in self.signals)\\n\\n        self.out.name(\\\"steps\\\")\\n        self.out.begin_array()\\n\\n    def step(self, values, skip_x=False):\\n        if not self.header_written:\\n            self.write_header()\\n\\n        packed = values.pack(self.sigmap)\\n        if skip_x:\\n            packed = packed.replace('x', '?')\\n        self.out.value({\\\"bits\\\": packed})\\n\\n        self.t += 1\\n\\n    def end_trace(self):\\n        if not self.header_written:\\n            self.write_header()\\n        self.out.end_array()\\n        self.out.end_object()\\n\\n\\nclass ReadWitness:\\n    def __init__(self, f):\\n        data = json.load(f)\\n        if not isinstance(data, dict):\\n            data = {}\\n\\n        data_format = data.get(\\\"format\\\", \\\"Unknown Format\\\")\\n\\n        if data_format != \\\"Yosys Witness Trace\\\":\\n            raise ValueError(f\\\"unsupported format {data_format!r}\\\")\\n\\n        self.clocks = data[\\\"clocks\\\"]\\n        for clock in self.clocks:\\n            clock[\\\"path\\\"] = tuple(clock[\\\"path\\\"])\\n\\n        self.signals = [\\n            WitnessSig(sig[\\\"path\\\"], sig[\\\"offset\\\"], sig[\\\"width\\\"], sig[\\\"init_only\\\"])\\n            for sig in data[\\\"signals\\\"]\\n        ]\\n\\n        self.sigmap = WitnessSigMap(self.signals)\\n\\n        self.bits = [step[\\\"bits\\\"] for step in data[\\\"steps\\\"]]\\n\\n    def skip_x(self):\\n        self.bits = [step.replace('x', '?') for step in self.bits]\\n\\n    def init_step(self):\\n        return self.step(0)\\n    \\n    def non_init_bits(self):\\n        if len(self) > 1:\\n            return len(self.bits[1])\\n        else:\\n            return sum([sig.width for sig in self.signals if not sig.init_only])\\n    \\n    def first_step(self):\\n        values = WitnessValues()\\n        # may have issues when non_init_bits is 0\\n        values.unpack(WitnessSigMap([sig for sig in self.signals if not sig.init_only]), self.bits[0][-self.non_init_bits():])\\n        return values\\n\\n    def step(self, t):\\n        values = WitnessValues()\\n        values.unpack(self.sigmap, self.bits[t])\\n        return values\\n\\n    def steps(self, start=0):\\n        for i in range(start, len(self.bits)):\\n            yield i, self.step(i)\\n\\n    def append_steps(self, t):\\n        if not t:\\n            pass\\n        elif t < 0:\\n            self.bits = self.bits[:t]\\n        else:\\n            self.bits.extend([\\\"0\\\"*self.non_init_bits()]*t)\\n\\n    def __len__(self):\\n        return len(self.bits)\\n\",\n        },\n        \"quicklogic\": {\n            \"common\": {\n                \"cells_sim.v\": \"module inv (\\n  output Q,\\n  input A\\n);\\n  assign Q = A ? 0 : 1;\\nendmodule\\n\\nmodule buff (\\n  output Q,\\n  input A\\n);\\n  assign Q = A;\\nendmodule\\n\\nmodule logic_0 (\\n  output A\\n);\\n  assign A = 0;\\nendmodule\\n\\nmodule logic_1 (\\n  output A\\n);\\n  assign A = 1;\\nendmodule\\n\\nmodule gclkbuff (\\n  input A,\\n  output Z\\n);\\n  specify\\n    (A => Z) = 0;\\n  endspecify\\n\\n  assign Z = A;\\nendmodule\\n\",\n            },\n            \"pp3\": {\n                \"abc9_map.v\": \"// This file exists to map purely-synchronous flops to ABC9 flops, while \\n// mapping flops with asynchronous-set/clear as boxes, this is because ABC9 \\n// doesn't support asynchronous-set/clear flops in sequential synthesis.\\n\\nmodule dffepc (\\n  output Q,\\n  input D,\\n  input CLK,\\n  input EN,\\n  input CLR,\\n  input PRE\\n);\\n\\nparameter INIT = 1'b0;\\n\\nparameter _TECHMAP_CONSTMSK_CLR_ = 1'b0;\\nparameter _TECHMAP_CONSTMSK_PRE_ = 1'b0;\\nparameter _TECHMAP_CONSTVAL_CLR_ = 1'b0;\\nparameter _TECHMAP_CONSTVAL_PRE_ = 1'b0;\\n\\nif (_TECHMAP_CONSTMSK_CLR_ != 1'b0 && _TECHMAP_CONSTMSK_PRE_ != 1'b0 && _TECHMAP_CONSTVAL_CLR_ == 1'b0 && _TECHMAP_CONSTVAL_PRE_ == 1'b0)\\n    $__PP3_DFFEPC_SYNCONLY _TECHMAP_REPLACE_ (.Q(Q), .D(D), .CLK(CLK), .EN(EN));\\nelse\\n    wire _TECHMAP_FAIL_ = 1;\\n\\nendmodule\\n\",\n                \"abc9_model.v\": \"(* abc9_flop, lib_whitebox *)\\nmodule $__PP3_DFFEPC_SYNCONLY (\\n  output Q,\\n  input D,\\n  input CLK,\\n  input EN,\\n);\\n\\n  dffepc ff (.Q(Q), .D(D), .CLK(CLK), .EN(EN), .PRE(1'b0), .CLR(1'b0));\\n\\nendmodule\\n\",\n                \"abc9_unmap.v\": \"module $__PP3_DFFEPC_SYNCONLY (\\n  output Q,\\n  input D,\\n  input CLK,\\n  input EN,\\n);\\n\\n// For some reason ABC9 adds init attributes to wires even though they were removed before mapping.\\n// As a workaround, remove any init attributes that get reintroduced.\\nwire _TECHMAP_REMOVEINIT_Q_ = 1;\\n\\ndffepc _TECHMAP_REPLACE_ (.Q(Q), .D(D), .CLK(CLK), .EN(EN), .PRE(1'b0), .CLR(1'b0));\\n\\nendmodule\\n\",\n                \"cells_map.v\": \"module \\\\$_MUX8_ (\\n  A, B, C, D, E, F, G, H, S, T, U, Y\\n);\\n  input A, B, C, D, E, F, G, H, S, T, U;\\n  output Y;\\n  mux8x0 _TECHMAP_REPLACE_ (\\n    .A(A),\\n    .B(B),\\n    .C(C),\\n    .D(D),\\n    .E(E),\\n    .F(F),\\n    .G(G),\\n    .H(H),\\n    .S0(S),\\n    .S1(T),\\n    .S2(U),\\n    .Q(Y)\\n  );\\nendmodule\\n\\nmodule \\\\$_MUX4_ (\\n  A, B, C, D, S, T, U, Y\\n);\\n  input A, B, C, D, S, T, U;\\n  output Y;\\n  mux4x0 _TECHMAP_REPLACE_ (\\n    .A(A),\\n    .B(B),\\n    .C(C),\\n    .D(D),\\n    .S0(S),\\n    .S1(T),\\n    .Q(Y)\\n  );\\nendmodule\\n\",\n                \"cells_sim.v\": \"module inpad (\\n  output Q,\\n  (* iopad_external_pin *)\\n  input P\\n);\\n  specify\\n    (P => Q) = 0;\\n  endspecify\\n  assign Q = P;\\nendmodule\\n\\nmodule outpad (\\n  (* iopad_external_pin *)\\n  output P,\\n  input A\\n);\\n  specify\\n    (A => P) = 0;\\n  endspecify\\n  assign P = A;\\nendmodule\\n\\nmodule ckpad (\\n  output Q,\\n  (* iopad_external_pin *)\\n  input P\\n);\\n  specify\\n    (P => Q) = 0;\\n  endspecify\\n  assign Q = P;\\nendmodule\\n\\nmodule bipad (\\n  input A,\\n  input EN,\\n  output Q,\\n  (* iopad_external_pin *)\\n  inout P\\n);\\n  assign Q = P;\\n  assign P = EN ? A : 1'bz;\\nendmodule\\n\\nmodule dff (\\n  output reg Q,\\n  input D,\\n  (* clkbuf_sink *)\\n  input CLK\\n);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n  always @(posedge CLK) Q <= D;\\nendmodule\\n\\nmodule dffc (\\n  output reg Q,\\n  input D,\\n  (* clkbuf_sink *)\\n  input CLK,\\n  (* clkbuf_sink *)\\n  input CLR\\n);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n  always @(posedge CLK or posedge CLR)\\n    if (CLR) Q <= 1'b0;\\n    else Q <= D;\\nendmodule\\n\\nmodule dffp (\\n  output reg Q,\\n  input D,\\n  (* clkbuf_sink *)\\n  input CLK,\\n  (* clkbuf_sink *)\\n  input PRE\\n);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n  always @(posedge CLK or posedge PRE)\\n    if (PRE) Q <= 1'b1;\\n    else Q <= D;\\nendmodule\\n\\nmodule dffpc (\\n  output reg Q,\\n  input D,\\n  (* clkbuf_sink *)\\n  input CLK,\\n  (* clkbuf_sink *)\\n  input CLR,\\n  (* clkbuf_sink *)\\n  input PRE\\n);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n  always @(posedge CLK or posedge CLR or posedge PRE)\\n    if (CLR) Q <= 1'b0;\\n    else if (PRE) Q <= 1'b1;\\n    else Q <= D;\\nendmodule\\n\\nmodule dffe (\\n  output reg Q,\\n  input D,\\n  (* clkbuf_sink *)\\n  input CLK,\\n  input EN\\n);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n  always @(posedge CLK) if (EN) Q <= D;\\nendmodule\\n\\nmodule dffec (\\n  output reg Q,\\n  input D,\\n  (* clkbuf_sink *)\\n  input CLK,\\n  input EN,\\n  (* clkbuf_sink *)\\n  input CLR\\n);\\n  parameter [0:0] INIT = 1'b0;\\n  initial Q = INIT;\\n\\n  always @(posedge CLK or posedge CLR)\\n    if (CLR) Q <= 1'b0;\\n    else if (EN) Q <= D;\\nendmodule\\n\\n(* lib_whitebox *)\\nmodule dffepc (\\n  output reg Q,\\n  input D,\\n  (* clkbuf_sink *)\\n  input CLK,\\n  input EN,\\n  (* clkbuf_sink *)\\n  input CLR,\\n  (* clkbuf_sink *)\\n  input PRE\\n);\\n  parameter [0:0] INIT = 1'b0;\\n\\n  specify\\n    if (EN) (posedge CLK => (Q : D)) = 1701; // QCK -> QZ\\n    if (CLR) (CLR => Q) = 967; // QRT -> QZ\\n    if (PRE) (PRE => Q) = 1252; // QST -> QZ\\n    $setup(D, posedge CLK, 216); // QCK -> QDS\\n    $setup(EN, posedge CLK, 590); // QCK -> QEN\\n  endspecify\\n\\n  initial Q = INIT;\\n  always @(posedge CLK or posedge CLR or posedge PRE)\\n    if (CLR) Q <= 1'b0;\\n    else if (PRE) Q <= 1'b1;\\n    else if (EN) Q <= D;\\nendmodule\\n\\n//                  FZ       FS F2 (F1 TO 0)\\n(* abc9_box, lib_whitebox *)\\nmodule AND2I0 (\\n  output Q,\\n  input A, B\\n);\\n  specify\\n    (A => Q) = 698; // FS -> FZ\\n    (B => Q) = 639; // F2 -> FZ\\n  endspecify\\n\\n  assign Q = A ? B : 0;\\nendmodule\\n\\n(* abc9_box, lib_whitebox *)\\nmodule mux2x0 (\\n  output Q,\\n  input S, A, B\\n);\\n  specify\\n    (S => Q) = 698; // FS -> FZ\\n    (A => Q) = 639; // F1 -> FZ\\n    (B => Q) = 639; // F2 -> FZ\\n  endspecify\\n\\n  assign Q = S ? B : A;\\nendmodule\\n\\n(* abc9_box, lib_whitebox *)\\nmodule mux2x1 (\\n  output Q,\\n  input S, A, B\\n);\\n  specify\\n    (S => Q) = 698; // FS -> FZ\\n    (A => Q) = 639; // F1 -> FZ\\n    (B => Q) = 639; // F2 -> FZ\\n  endspecify\\n\\n  assign Q = S ? B : A;\\nendmodule\\n\\n(* abc9_box, lib_whitebox *)\\nmodule mux4x0 (\\n  output Q,\\n  input S0, S1, A, B, C, D\\n);\\n  specify\\n    (S0 => Q) = 1251; // TAB -> TZ\\n    (S1 => Q) = 1406; // TSL -> TZ\\n    (A => Q) = 1699;  // TA1 -> TZ\\n    (B => Q) = 1687;  // TA2 -> TZ\\n    (C => Q) = 1669;  // TB1 -> TZ\\n    (D => Q) = 1679;  // TB2 -> TZ\\n  endspecify\\n\\n  assign Q = S1 ? (S0 ? D : C) : (S0 ? B : A);\\nendmodule\\n\\n// S0 BSL TSL\\n// S1 BAB TAB\\n// S2 TBS\\n// A TA1\\n// B TA2\\n// C TB1\\n// D TB2\\n// E BA1\\n// F BA2\\n// G BB1\\n// H BB2\\n// Q CZ\\n(* abc9_box, lib_whitebox *)\\nmodule mux8x0 (\\n  output Q,\\n  input S0, S1, S2, A, B, C, D, E, F, G, H\\n);\\n  specify\\n    (S0 => Q) = 1593; // ('TSL', 'BSL') -> CZ\\n    (S1 => Q) = 1437; // ('TAB', 'BAB') -> CZ\\n    (S2 => Q) = 995; // TBS -> CZ\\n    (A => Q) = 1887; // TA1 -> CZ\\n    (B => Q) = 1873; // TA2 -> CZ\\n    (C => Q) = 1856; // TB1 -> CZ\\n    (D => Q) = 1860; // TB2 -> CZ\\n    (E => Q) = 1714; // BA1 -> CZ\\n    (F => Q) = 1773; // BA2 -> CZ\\n    (G => Q) = 1749; // BB1 -> CZ\\n    (H => Q) = 1723; // BB2 -> CZ\\n  endspecify\\n\\n  assign Q = S2 ? (S1 ? (S0 ? H : G) : (S0 ? F : E)) : (S1 ? (S0 ? D : C) : (S0 ? B : A));\\nendmodule\\n\\n(* blackbox *)\\n(* keep *)\\nmodule qlal4s3b_cell_macro (\\n  input WB_CLK,\\n  input WBs_ACK,\\n  input [31:0] WBs_RD_DAT,\\n  output [3:0] WBs_BYTE_STB,\\n  output WBs_CYC,\\n  output WBs_WE,\\n  output WBs_RD,\\n  output WBs_STB,\\n  output [16:0] WBs_ADR,\\n  input [3:0] SDMA_Req,\\n  input [3:0] SDMA_Sreq,\\n  output [3:0] SDMA_Done,\\n  output [3:0] SDMA_Active,\\n  input [3:0] FB_msg_out,\\n  input [7:0] FB_Int_Clr,\\n  output FB_Start,\\n  input FB_Busy,\\n  output WB_RST,\\n  output Sys_PKfb_Rst,\\n  output Clk16,\\n  output Clk16_Rst,\\n  output Clk21,\\n  output Clk21_Rst,\\n  output Sys_Pclk,\\n  output Sys_Pclk_Rst,\\n  input Sys_PKfb_Clk,\\n  input [31:0] FB_PKfbData,\\n  output [31:0] WBs_WR_DAT,\\n  input [3:0] FB_PKfbPush,\\n  input FB_PKfbSOF,\\n  input FB_PKfbEOF,\\n  output [7:0] Sensor_Int,\\n  output FB_PKfbOverflow,\\n  output [23:0] TimeStamp,\\n  input Sys_PSel,\\n  input [15:0] SPIm_Paddr,\\n  input SPIm_PEnable,\\n  input SPIm_PWrite,\\n  input [31:0] SPIm_PWdata,\\n  output SPIm_PReady,\\n  output SPIm_PSlvErr,\\n  output [31:0] SPIm_Prdata,\\n  input [15:0] Device_ID,\\n  input [13:0] FBIO_In_En,\\n  input [13:0] FBIO_Out,\\n  input [13:0] FBIO_Out_En,\\n  output [13:0] FBIO_In,\\n  inout [13:0] SFBIO,\\n  input Device_ID_6S,\\n  input Device_ID_4S,\\n  input SPIm_PWdata_26S,\\n  input SPIm_PWdata_24S,\\n  input SPIm_PWdata_14S,\\n  input SPIm_PWdata_11S,\\n  input SPIm_PWdata_0S,\\n  input SPIm_Paddr_8S,\\n  input SPIm_Paddr_6S,\\n  input FB_PKfbPush_1S,\\n  input FB_PKfbData_31S,\\n  input FB_PKfbData_21S,\\n  input FB_PKfbData_19S,\\n  input FB_PKfbData_9S,\\n  input FB_PKfbData_6S,\\n  input Sys_PKfb_ClkS,\\n  input FB_BusyS,\\n  input WB_CLKS\\n);\\n\\nendmodule\\n\\n(* abc9_lut=1, lib_whitebox *)\\nmodule LUT1 (\\n  output O,\\n  input I0\\n);\\n  parameter [1:0] INIT = 0;\\n  parameter EQN = \\\"(I0)\\\";\\n\\n  // These timings are for PolarPro 3E; other families will need updating.\\n  specify\\n    (I0 => O) = 698; // FS -> FZ\\n  endspecify\\n\\n  assign O = I0 ? INIT[1] : INIT[0];\\nendmodule\\n\\n//               TZ        TSL TAB\\n(* abc9_lut=2, lib_whitebox *)\\nmodule LUT2 (\\n  output O,\\n  input I0, I1\\n);\\n  parameter [3:0] INIT = 4'h0;\\n  parameter EQN = \\\"(I0)\\\";\\n\\n  // These timings are for PolarPro 3E; other families will need updating.\\n  specify\\n    (I0 => O) = 1251; // TAB -> TZ\\n    (I1 => O) = 1406; // TSL -> TZ\\n  endspecify\\n\\n  wire [1:0] s1 = I1 ? INIT[3:2] : INIT[1:0];\\n  assign O = I0 ? s1[1] : s1[0];\\nendmodule\\n\\n(* abc9_lut=2, lib_whitebox *)\\nmodule LUT3 (\\n  output O,\\n  input I0, I1, I2\\n);\\n  parameter [7:0] INIT = 8'h0;\\n  parameter EQN = \\\"(I0)\\\";\\n\\n  // These timings are for PolarPro 3E; other families will need updating.\\n  specify\\n    (I0 => O) = 1251; // TAB -> TZ\\n    (I1 => O) = 1406; // TSL -> TZ\\n    (I2 => O) = 1699; // ('TA1', 'TA2', 'TB1', 'TB2') -> TZ\\n  endspecify\\n\\n  wire [3:0] s2 = I2 ? INIT[7:4] : INIT[3:0];\\n  wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];\\n  assign O = I0 ? s1[1] : s1[0];\\nendmodule\\n\\n(* abc9_lut=4, lib_whitebox *)\\nmodule LUT4 (\\n  output O,\\n  input I0, I1, I2, I3\\n);\\n  parameter [15:0] INIT = 16'h0;\\n  parameter EQN = \\\"(I0)\\\";\\n\\n  // These timings are for PolarPro 3E; other families will need updating.\\n  specify\\n    (I0 => O) = 995;  // TBS -> CZ\\n    (I1 => O) = 1437; // ('TAB', 'BAB') -> CZ\\n    (I2 => O) = 1593; // ('TSL', 'BSL') -> CZ\\n    (I3 => O) = 1887; // ('TA1', 'TA2', 'TB1', 'TB2', 'BA1', 'BA2', 'BB1', 'BB2') -> CZ\\n  endspecify\\n\\n  wire [7:0] s3 = I3 ? INIT[15:8] : INIT[7:0];\\n  wire [3:0] s2 = I2 ? s3[7:4] : s3[3:0];\\n  wire [1:0] s1 = I1 ? s2[3:2] : s2[1:0];\\n  assign O = I0 ? s1[1] : s1[0];\\nendmodule\\n\",\n                \"ffs_map.v\": \"module \\\\$_DFFSRE_PPPP_ (input C, S, R, E, D, output Q);\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\n  dffepc #(.INIT(1'b0)) _TECHMAP_REPLACE_ (.CLK(C), .PRE(S), .CLR(R), .EN(E), .D(D), .Q(Q));\\nendmodule\\n\",\n                \"latches_map.v\": \"module \\\\$_DLATCH_P_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = E ? D : Q;\\nendmodule\\n\\nmodule \\\\$_DLATCH_N_ (E, D, Q);\\n  wire [1023:0] _TECHMAP_DO_ = \\\"simplemap; opt\\\";\\n  input E, D;\\n  output Q = !E ? D : Q;\\nendmodule\\n\",\n                \"lut_map.v\": \"module \\\\$lut (\\n  A, Y\\n);\\n  parameter WIDTH = 0;\\n  parameter LUT = 0;\\n\\n  input [WIDTH-1:0] A;\\n  output Y;\\n\\n  generate\\n    if (WIDTH == 1) begin\\n      LUT1 #(\\n        .EQN(\\\"\\\"),\\n        .INIT(LUT)\\n      ) _TECHMAP_REPLACE_ (\\n        .O(Y),\\n        .I0(A[0])\\n      );\\n    end else if (WIDTH == 2) begin\\n      LUT2 #(\\n        .EQN(\\\"\\\"),\\n        .INIT(LUT)\\n      ) _TECHMAP_REPLACE_ (\\n        .O(Y),\\n        .I0(A[0]),\\n        .I1(A[1])\\n      );\\n    end else if (WIDTH == 3) begin\\n      LUT3 #(\\n        .EQN(\\\"\\\"),\\n        .INIT(LUT)\\n      ) _TECHMAP_REPLACE_ (\\n        .O(Y),\\n        .I0(A[0]),\\n        .I1(A[1]),\\n        .I2(A[2])\\n      );\\n    end else if (WIDTH == 4) begin\\n      LUT4 #(\\n        .EQN(\\\"\\\"),\\n        .INIT(LUT)\\n      ) _TECHMAP_REPLACE_ (\\n        .O(Y),\\n        .I0(A[0]),\\n        .I1(A[1]),\\n        .I2(A[2]),\\n        .I3(A[3])\\n      );\\n    end else begin\\n      wire _TECHMAP_FAIL_ = 1;\\n    end\\n  endgenerate\\nendmodule\\n\",\n            },\n            \"qlf_k6n10f\": {\n                \"TDP18K_FIFO.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\n`default_nettype wire\\nmodule TDP18K_FIFO (\\n\\tRMODE_A_i,\\n\\tRMODE_B_i,\\n\\tWMODE_A_i,\\n\\tWMODE_B_i,\\n\\tWEN_A_i,\\n\\tWEN_B_i,\\n\\tREN_A_i,\\n\\tREN_B_i,\\n\\tCLK_A_i,\\n\\tCLK_B_i,\\n\\tBE_A_i,\\n\\tBE_B_i,\\n\\tADDR_A_i,\\n\\tADDR_B_i,\\n\\tWDATA_A_i,\\n\\tWDATA_B_i,\\n\\tRDATA_A_o,\\n\\tRDATA_B_o,\\n\\tEMPTY_o,\\n\\tEPO_o,\\n\\tEWM_o,\\n\\tUNDERRUN_o,\\n\\tFULL_o,\\n\\tFMO_o,\\n\\tFWM_o,\\n\\tOVERRUN_o,\\n\\tFLUSH_ni,\\n\\tFMODE_i,\\n);\\n\\tparameter SYNC_FIFO_i = 1'b0;\\n\\tparameter POWERDN_i = 1'b0;\\n\\tparameter SLEEP_i = 1'b0;\\n\\tparameter PROTECT_i = 1'b0;\\n\\tparameter UPAF_i = 11'b0;\\n\\tparameter UPAE_i = 11'b0;\\n\\tparameter [18*1024-1:0] INIT_i = 18431'bx;\\n\\n\\tinput wire [2:0] RMODE_A_i;\\n\\tinput wire [2:0] RMODE_B_i;\\n\\tinput wire [2:0] WMODE_A_i;\\n\\tinput wire [2:0] WMODE_B_i;\\n\\tinput wire WEN_A_i;\\n\\tinput wire WEN_B_i;\\n\\tinput wire REN_A_i;\\n\\tinput wire REN_B_i;\\n\\t(* clkbuf_sink *)\\n\\tinput wire CLK_A_i;\\n\\t(* clkbuf_sink *)\\n\\tinput wire CLK_B_i;\\n\\tinput wire [1:0] BE_A_i;\\n\\tinput wire [1:0] BE_B_i;\\n\\tinput wire [13:0] ADDR_A_i;\\n\\tinput wire [13:0] ADDR_B_i;\\n\\tinput wire [17:0] WDATA_A_i;\\n\\tinput wire [17:0] WDATA_B_i;\\n\\toutput reg [17:0] RDATA_A_o;\\n\\toutput reg [17:0] RDATA_B_o;\\n\\toutput wire EMPTY_o;\\n\\toutput wire EPO_o;\\n\\toutput wire EWM_o;\\n\\toutput wire UNDERRUN_o;\\n\\toutput wire FULL_o;\\n\\toutput wire FMO_o;\\n\\toutput wire FWM_o;\\n\\toutput wire OVERRUN_o;\\n\\tinput wire FLUSH_ni;\\n\\tinput wire FMODE_i;\\n\\treg [17:0] wmsk_a;\\n\\treg [17:0] wmsk_b;\\n\\twire [8:0] addr_a;\\n\\twire [8:0] addr_b;\\n\\treg [4:0] addr_a_d;\\n\\treg [4:0] addr_b_d;\\n\\twire [17:0] ram_rdata_a;\\n\\twire [17:0] ram_rdata_b;\\n\\treg [17:0] aligned_wdata_a;\\n\\treg [17:0] aligned_wdata_b;\\n\\twire ren_o;\\n\\twire [10:0] ff_raddr;\\n\\twire [10:0] ff_waddr;\\n\\twire [13:0] ram_addr_a;\\n\\twire [13:0] ram_addr_b;\\n\\twire [3:0] ram_waddr_a;\\n\\twire [3:0] ram_waddr_b;\\n\\twire initn;\\n\\twire smux_rclk;\\n\\twire smux_wclk;\\n\\twire real_fmode;\\n\\twire [3:0] raw_fflags;\\n\\treg [1:0] fifo_rmode;\\n\\treg [1:0] fifo_wmode;\\n\\twire smux_clk_a;\\n\\twire smux_clk_b;\\n\\twire ram_ren_a;\\n\\twire ram_ren_b;\\n\\twire ram_wen_a;\\n\\twire ram_wen_b;\\n\\twire cen_a;\\n\\twire cen_b;\\n\\twire cen_a_n;\\n\\twire cen_b_n;\\n\\twire ram_wen_a_n;\\n\\twire ram_wen_b_n;\\n\\tlocalparam MODE_9 = 3'b001;\\n\\talways @(*) begin\\n\\t\\tfifo_rmode = (RMODE_B_i == MODE_9 ? 2'b10 : 2'b01);\\n\\t\\tfifo_wmode = (WMODE_A_i == MODE_9 ? 2'b10 : 2'b01);\\n\\tend\\n\\tassign smux_clk_a = CLK_A_i;\\n\\tassign smux_clk_b = CLK_B_i;\\n\\tassign real_fmode = FMODE_i;\\n\\tassign ram_ren_b = real_fmode ? ren_o : REN_B_i;\\n\\tassign ram_wen_a = FMODE_i ? ~FULL_o & WEN_A_i : WEN_A_i;\\n\\tassign ram_ren_a = FMODE_i ? 0 : REN_A_i;\\n\\tassign ram_wen_b = FMODE_i ? 1'b0 : WEN_B_i;\\n\\tassign cen_b = ram_ren_b | ram_wen_b;\\n\\tassign cen_a = ram_ren_a | ram_wen_a;\\n\\tassign ram_waddr_b = real_fmode ? {ff_raddr[0], 3'b000} : ADDR_B_i[3:0];\\n\\tassign ram_waddr_a = real_fmode ? {ff_waddr[0], 3'b000} : ADDR_A_i[3:0];\\n\\tassign ram_addr_b = real_fmode ? {ff_raddr[10:0], 3'h0} : {ADDR_B_i[13:4], addr_b_d[3:0]};\\n\\tassign ram_addr_a = real_fmode ? {ff_waddr[10:0], 3'h0} : {ADDR_A_i[13:4], addr_a_d[3:0]};\\n\\talways @(posedge CLK_A_i) addr_a_d[3:0] <= ADDR_A_i[3:0];\\n\\talways @(posedge CLK_B_i) addr_b_d[3:0] <= ADDR_B_i[3:0];\\n\\tassign cen_a_n = ~cen_a;\\n\\tassign ram_wen_a_n = ~ram_wen_a;\\n\\tassign cen_b_n = ~cen_b;\\n\\tassign ram_wen_b_n = ~ram_wen_b;\\n\\n\\tsram1024x18 #(\\n\\t\\t.init(INIT_i)\\n\\t) uram(\\n\\t\\t.clk_a(smux_clk_a),\\n\\t\\t.cen_a(cen_a_n),\\n\\t\\t.wen_a(ram_wen_a_n),\\n\\t\\t.addr_a(ram_addr_a[13:4]),\\n\\t\\t.wmsk_a(wmsk_a),\\n\\t\\t.wdata_a(aligned_wdata_a),\\n\\t\\t.rdata_a(ram_rdata_a),\\n\\t\\t.clk_b(smux_clk_b),\\n\\t\\t.cen_b(cen_b_n),\\n\\t\\t.wen_b(ram_wen_b_n),\\n\\t\\t.addr_b(ram_addr_b[13:4]),\\n\\t\\t.wmsk_b(wmsk_b),\\n\\t\\t.wdata_b(aligned_wdata_b),\\n\\t\\t.rdata_b(ram_rdata_b)\\n\\t);\\n\\tfifo_ctl #(\\n\\t\\t.ADDR_WIDTH(11),\\n\\t\\t.FIFO_WIDTH(2),\\n\\t\\t.DEPTH(6)\\n\\t) fifo_ctl(\\n\\t\\t.rclk(smux_clk_b),\\n\\t\\t.rst_R_n(FLUSH_ni),\\n\\t\\t.wclk(smux_clk_a),\\n\\t\\t.rst_W_n(FLUSH_ni),\\n\\t\\t.ren(REN_B_i),\\n\\t\\t.wen(ram_wen_a),\\n\\t\\t.sync(SYNC_FIFO_i),\\n\\t\\t.rmode(fifo_rmode),\\n\\t\\t.wmode(fifo_wmode),\\n\\t\\t.ren_o(ren_o),\\n\\t\\t.fflags({FULL_o, FMO_o, FWM_o, OVERRUN_o, EMPTY_o, EPO_o, EWM_o, UNDERRUN_o}),\\n\\t\\t.raddr(ff_raddr),\\n\\t\\t.waddr(ff_waddr),\\n\\t\\t.upaf(UPAF_i),\\n\\t\\t.upae(UPAE_i)\\n\\t);\\n\\tlocalparam MODE_1 = 3'b101;\\n\\tlocalparam MODE_18 = 3'b010;\\n\\tlocalparam MODE_2 = 3'b110;\\n\\tlocalparam MODE_4 = 3'b100;\\n\\talways @(*) begin : WDATA_MODE_SEL\\n\\t\\tif (ram_wen_a == 1) begin\\n\\t\\t\\tcase (WMODE_A_i)\\n\\t\\t\\t\\tMODE_18: begin\\n\\t\\t\\t\\t\\taligned_wdata_a = WDATA_A_i;\\n\\t\\t\\t\\t\\t{wmsk_a[17], wmsk_a[15:8]} = (FMODE_i ? 9'h000 : (BE_A_i[1] ? 9'h000 : 9'h1ff));\\n\\t\\t\\t\\t\\t{wmsk_a[16], wmsk_a[7:0]} = (FMODE_i ? 9'h000 : (BE_A_i[0] ? 9'h000 : 9'h1ff));\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tMODE_9: begin\\n\\t\\t\\t\\t\\taligned_wdata_a = {{2 {WDATA_A_i[16]}}, {2 {WDATA_A_i[7:0]}}};\\n\\t\\t\\t\\t\\t{wmsk_a[17], wmsk_a[15:8]} = (ram_waddr_a[3] ? 9'h000 : 9'h1ff);\\n\\t\\t\\t\\t\\t{wmsk_a[16], wmsk_a[7:0]} = (ram_waddr_a[3] ? 9'h1ff : 9'h000);\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tMODE_4: begin\\n\\t\\t\\t\\t\\taligned_wdata_a = {2'b00, {4 {WDATA_A_i[3:0]}}};\\n\\t\\t\\t\\t\\twmsk_a[17:16] = 2'b00;\\n\\t\\t\\t\\t\\twmsk_a[15:12] = (ram_waddr_a[3:2] == 2'b11 ? 4'h0 : 4'hf);\\n\\t\\t\\t\\t\\twmsk_a[11:8] = (ram_waddr_a[3:2] == 2'b10 ? 4'h0 : 4'hf);\\n\\t\\t\\t\\t\\twmsk_a[7:4] = (ram_waddr_a[3:2] == 2'b01 ? 4'h0 : 4'hf);\\n\\t\\t\\t\\t\\twmsk_a[3:0] = (ram_waddr_a[3:2] == 2'b00 ? 4'h0 : 4'hf);\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tMODE_2: begin\\n\\t\\t\\t\\t\\taligned_wdata_a = {2'b00, {8 {WDATA_A_i[1:0]}}};\\n\\t\\t\\t\\t\\twmsk_a[17:16] = 2'b00;\\n\\t\\t\\t\\t\\twmsk_a[15:14] = (ram_waddr_a[3:1] == 3'b111 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_a[13:12] = (ram_waddr_a[3:1] == 3'b110 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_a[11:10] = (ram_waddr_a[3:1] == 3'b101 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_a[9:8] = (ram_waddr_a[3:1] == 3'b100 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_a[7:6] = (ram_waddr_a[3:1] == 3'b011 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_a[5:4] = (ram_waddr_a[3:1] == 3'b010 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_a[3:2] = (ram_waddr_a[3:1] == 3'b001 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_a[1:0] = (ram_waddr_a[3:1] == 3'b000 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tMODE_1: begin\\n\\t\\t\\t\\t\\taligned_wdata_a = {2'b00, {16 {WDATA_A_i[0]}}};\\n\\t\\t\\t\\t\\twmsk_a = 18'h0ffff;\\n\\t\\t\\t\\t\\twmsk_a[{1'b0, ram_waddr_a[3:0]}] = 0;\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tdefault: wmsk_a = 18'h3ffff;\\n\\t\\t\\tendcase\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\taligned_wdata_a = 18'h00000;\\n\\t\\t\\twmsk_a = 18'h3ffff;\\n\\t\\tend\\n\\t\\tif (ram_wen_b == 1)\\n\\t\\t\\tcase (WMODE_B_i)\\n\\t\\t\\t\\tMODE_18: begin\\n\\t\\t\\t\\t\\taligned_wdata_b = WDATA_B_i;\\n\\t\\t\\t\\t\\t{wmsk_b[17], wmsk_b[15:8]} = (BE_B_i[1] ? 9'h000 : 9'h1ff);\\n\\t\\t\\t\\t\\t{wmsk_b[16], wmsk_b[7:0]} = (BE_B_i[0] ? 9'h000 : 9'h1ff);\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tMODE_9: begin\\n\\t\\t\\t\\t\\taligned_wdata_b = {{2 {WDATA_B_i[16]}}, {2 {WDATA_B_i[7:0]}}};\\n\\t\\t\\t\\t\\t{wmsk_b[17], wmsk_b[15:8]} = (ram_waddr_b[3] ? 9'h000 : 9'h1ff);\\n\\t\\t\\t\\t\\t{wmsk_b[16], wmsk_b[7:0]} = (ram_waddr_b[3] ? 9'h1ff : 9'h000);\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tMODE_4: begin\\n\\t\\t\\t\\t\\taligned_wdata_b = {2'b00, {4 {WDATA_B_i[3:0]}}};\\n\\t\\t\\t\\t\\twmsk_b[17:16] = 2'b00;\\n\\t\\t\\t\\t\\twmsk_b[15:12] = (ram_waddr_b[3:2] == 2'b11 ? 4'h0 : 4'hf);\\n\\t\\t\\t\\t\\twmsk_b[11:8] = (ram_waddr_b[3:2] == 2'b10 ? 4'h0 : 4'hf);\\n\\t\\t\\t\\t\\twmsk_b[7:4] = (ram_waddr_b[3:2] == 2'b01 ? 4'h0 : 4'hf);\\n\\t\\t\\t\\t\\twmsk_b[3:0] = (ram_waddr_b[3:2] == 2'b00 ? 4'h0 : 4'hf);\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tMODE_2: begin\\n\\t\\t\\t\\t\\taligned_wdata_b = {2'b00, {8 {WDATA_B_i[1:0]}}};\\n\\t\\t\\t\\t\\twmsk_b[17:16] = 2'b00;\\n\\t\\t\\t\\t\\twmsk_b[15:14] = (ram_waddr_b[3:1] == 3'b111 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_b[13:12] = (ram_waddr_b[3:1] == 3'b110 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_b[11:10] = (ram_waddr_b[3:1] == 3'b101 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_b[9:8] = (ram_waddr_b[3:1] == 3'b100 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_b[7:6] = (ram_waddr_b[3:1] == 3'b011 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_b[5:4] = (ram_waddr_b[3:1] == 3'b010 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_b[3:2] = (ram_waddr_b[3:1] == 3'b001 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\t\\twmsk_b[1:0] = (ram_waddr_b[3:1] == 3'b000 ? 2'h0 : 2'h3);\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tMODE_1: begin\\n\\t\\t\\t\\t\\taligned_wdata_b = {2'b00, {16 {WDATA_B_i[0]}}};\\n\\t\\t\\t\\t\\twmsk_b = 18'h0ffff;\\n\\t\\t\\t\\t\\twmsk_b[{1'b0, ram_waddr_b[3:0]}] = 0;\\n\\t\\t\\t\\tend\\n\\t\\t\\t\\tdefault: wmsk_b = 18'h3ffff;\\n\\t\\t\\tendcase\\n\\t\\telse begin\\n\\t\\t\\taligned_wdata_b = 18'b000000000000000000;\\n\\t\\t\\twmsk_b = 18'h3ffff;\\n\\t\\tend\\n\\tend\\n\\talways @(*) begin : RDATA_A_MODE_SEL\\n\\t\\tcase (RMODE_A_i)\\n\\t\\t\\tdefault: RDATA_A_o = 18'h00000;\\n\\t\\t\\tMODE_18: RDATA_A_o = ram_rdata_a;\\n\\t\\t\\tMODE_9: begin\\n\\t\\t\\t\\t{RDATA_A_o[17], RDATA_A_o[15:8]} = 9'h000;\\n\\t\\t\\t\\t{RDATA_A_o[16], RDATA_A_o[7:0]} = (ram_addr_a[3] ? {ram_rdata_a[17], ram_rdata_a[15:8]} : {ram_rdata_a[16], ram_rdata_a[7:0]});\\n\\t\\t\\tend\\n\\t\\t\\tMODE_4: begin\\n\\t\\t\\t\\tRDATA_A_o[17:4] = 14'h0000;\\n\\t\\t\\t\\tcase (ram_addr_a[3:2])\\n\\t\\t\\t\\t\\t3: RDATA_A_o[3:0] = ram_rdata_a[15:12];\\n\\t\\t\\t\\t\\t2: RDATA_A_o[3:0] = ram_rdata_a[11:8];\\n\\t\\t\\t\\t\\t1: RDATA_A_o[3:0] = ram_rdata_a[7:4];\\n\\t\\t\\t\\t\\t0: RDATA_A_o[3:0] = ram_rdata_a[3:0];\\n\\t\\t\\t\\tendcase\\n\\t\\t\\tend\\n\\t\\t\\tMODE_2: begin\\n\\t\\t\\t\\tRDATA_A_o[17:2] = 16'h0000;\\n\\t\\t\\t\\tcase (ram_addr_a[3:1])\\n\\t\\t\\t\\t\\t7: RDATA_A_o[1:0] = ram_rdata_a[15:14];\\n\\t\\t\\t\\t\\t6: RDATA_A_o[1:0] = ram_rdata_a[13:12];\\n\\t\\t\\t\\t\\t5: RDATA_A_o[1:0] = ram_rdata_a[11:10];\\n\\t\\t\\t\\t\\t4: RDATA_A_o[1:0] = ram_rdata_a[9:8];\\n\\t\\t\\t\\t\\t3: RDATA_A_o[1:0] = ram_rdata_a[7:6];\\n\\t\\t\\t\\t\\t2: RDATA_A_o[1:0] = ram_rdata_a[5:4];\\n\\t\\t\\t\\t\\t1: RDATA_A_o[1:0] = ram_rdata_a[3:2];\\n\\t\\t\\t\\t\\t0: RDATA_A_o[1:0] = ram_rdata_a[1:0];\\n\\t\\t\\t\\tendcase\\n\\t\\t\\tend\\n\\t\\t\\tMODE_1: begin\\n\\t\\t\\t\\tRDATA_A_o[17:1] = 17'h00000;\\n\\t\\t\\t\\tRDATA_A_o[0] = ram_rdata_a[ram_addr_a[3:0]];\\n\\t\\t\\tend\\n\\t\\tendcase\\n\\tend\\n\\talways @(*)\\n\\t\\tcase (RMODE_B_i)\\n\\t\\t\\tdefault: RDATA_B_o = 18'h15566;\\n\\t\\t\\tMODE_18: RDATA_B_o = ram_rdata_b;\\n\\t\\t\\tMODE_9: begin\\n\\t\\t\\t\\t{RDATA_B_o[17], RDATA_B_o[15:8]} = 9'b000000000;\\n\\t\\t\\t\\t{RDATA_B_o[16], RDATA_B_o[7:0]} = (ram_addr_b[3] ? {ram_rdata_b[17], ram_rdata_b[15:8]} : {ram_rdata_b[16], ram_rdata_b[7:0]});\\n\\t\\t\\tend\\n\\t\\t\\tMODE_4:\\n\\t\\t\\t\\tcase (ram_addr_b[3:2])\\n\\t\\t\\t\\t\\t3: RDATA_B_o[3:0] = ram_rdata_b[15:12];\\n\\t\\t\\t\\t\\t2: RDATA_B_o[3:0] = ram_rdata_b[11:8];\\n\\t\\t\\t\\t\\t1: RDATA_B_o[3:0] = ram_rdata_b[7:4];\\n\\t\\t\\t\\t\\t0: RDATA_B_o[3:0] = ram_rdata_b[3:0];\\n\\t\\t\\t\\tendcase\\n\\t\\t\\tMODE_2:\\n\\t\\t\\t\\tcase (ram_addr_b[3:1])\\n\\t\\t\\t\\t\\t7: RDATA_B_o[1:0] = ram_rdata_b[15:14];\\n\\t\\t\\t\\t\\t6: RDATA_B_o[1:0] = ram_rdata_b[13:12];\\n\\t\\t\\t\\t\\t5: RDATA_B_o[1:0] = ram_rdata_b[11:10];\\n\\t\\t\\t\\t\\t4: RDATA_B_o[1:0] = ram_rdata_b[9:8];\\n\\t\\t\\t\\t\\t3: RDATA_B_o[1:0] = ram_rdata_b[7:6];\\n\\t\\t\\t\\t\\t2: RDATA_B_o[1:0] = ram_rdata_b[5:4];\\n\\t\\t\\t\\t\\t1: RDATA_B_o[1:0] = ram_rdata_b[3:2];\\n\\t\\t\\t\\t\\t0: RDATA_B_o[1:0] = ram_rdata_b[1:0];\\n\\t\\t\\t\\tendcase\\n\\t\\t\\tMODE_1: RDATA_B_o[0] = ram_rdata_b[{1'b0, ram_addr_b[3:0]}];\\n\\t\\tendcase\\nendmodule\\n`default_nettype none\\n\",\n                \"arith_map.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_quicklogic_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 2;\\n\\tparameter B_WIDTH = 2;\\n\\tparameter Y_WIDTH = 2;\\n\\tparameter _TECHMAP_CONSTVAL_CI_ = 0;\\n\\tparameter _TECHMAP_CONSTMSK_CI_ = 0;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 2;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\\n\\n\\tgenvar i;\\n\\twire co;\\n\\n\\t(* force_downto *)\\n\\t//wire [Y_WIDTH-1:0] C = {CO, CI};\\n\\twire [Y_WIDTH:0] C;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] S  = {AA ^ BB};\\n\\tassign CO[Y_WIDTH-1:0] = C[Y_WIDTH:1];\\n\\t\\t//assign CO[Y_WIDTH-1] = co;\\n\\n\\tgenerate\\n\\t\\tadder_carry intermediate_adder (\\n\\t\\t\\t.cin     ( ),\\n\\t\\t\\t.cout    (C[0]),\\n\\t\\t\\t.p       (1'b0),\\n\\t\\t\\t.g       (CI),\\n\\t\\t\\t.sumout  ()\\n\\t\\t);\\n\\tendgenerate\\n\\tgenvar i;\\n\\tgenerate if (Y_WIDTH > 2) begin\\n\\t  for (i = 0; i < Y_WIDTH-2; i = i + 1) begin:slice\\n\\t\\tadder_carry  my_adder (\\n\\t\\t\\t.cin     (C[i]),\\n\\t\\t\\t.g       (AA[i]),\\n\\t\\t\\t.p       (S[i]),\\n\\t\\t\\t.cout    (C[i+1]),\\n\\t\\t\\t.sumout  (Y[i])\\n\\t\\t);\\n\\t\\t  end\\n\\tend endgenerate\\n\\tgenerate\\n\\t\\tadder_carry final_adder (\\n\\t\\t\\t.cin     (C[Y_WIDTH-2]),\\n\\t\\t\\t.cout    (),\\n\\t\\t\\t.p       (1'b0),\\n\\t\\t\\t.g       (1'b0),\\n\\t\\t\\t.sumout  (co)\\n\\t\\t);\\n\\tendgenerate\\n\\n\\tassign Y[Y_WIDTH-2] = S[Y_WIDTH-2] ^ co;\\n\\tassign C[Y_WIDTH-1] = S[Y_WIDTH-2] ? co : AA[Y_WIDTH-2];\\n\\tassign Y[Y_WIDTH-1] = S[Y_WIDTH-1] ^ C[Y_WIDTH-1];\\n\\tassign C[Y_WIDTH] = S[Y_WIDTH-1] ? C[Y_WIDTH-1] : AA[Y_WIDTH-1];\\n\\n\\tassign X = S;\\nendmodule\\n\\n\",\n                \"bram_types_sim.v\": new URL(/* asset import */ __webpack_require__(/*! ./share/quicklogic/qlf_k6n10f/bram_types_sim.v */ \"./node_modules/@yowasp/yosys/gen/share/quicklogic/qlf_k6n10f/bram_types_sim.v\"), __webpack_require__.b),\n                \"brams_map.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\nmodule RAM_36K_BLK (\\n\\t\\tWEN_i,\\n\\t\\tREN_i,\\n\\t\\tWR_CLK_i,\\n\\t\\tRD_CLK_i,\\n\\t\\tWR_BE_i,\\n\\t\\tWR_ADDR_i,\\n\\t\\tRD_ADDR_i,\\n\\t\\tWDATA_i,\\n\\t\\tRDATA_o\\n);\\n\\nparameter WR_ADDR_WIDTH = 10;\\nparameter RD_ADDR_WIDTH = 10;\\nparameter WR_DATA_WIDTH = 36;\\nparameter RD_DATA_WIDTH = 36;\\nparameter BE_WIDTH = 4;\\n\\nparameter INIT = 0;\\n\\ninput wire WEN_i;\\ninput wire REN_i;\\ninput wire WR_CLK_i;\\ninput wire RD_CLK_i;\\ninput wire [BE_WIDTH-1:0] WR_BE_i;\\ninput wire [WR_ADDR_WIDTH-1 :0] WR_ADDR_i;\\ninput wire [RD_ADDR_WIDTH-1 :0] RD_ADDR_i;\\ninput wire [WR_DATA_WIDTH-1 :0] WDATA_i;\\noutput wire [RD_DATA_WIDTH-1 :0] RDATA_o;\\n\\n// Fixed mode settings\\nlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\nlocalparam [ 0:0] FMODE1_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\nlocalparam [11:0] UPAE1_i       = 12'd10;\\nlocalparam [11:0] UPAF1_i       = 12'd10;\\n\\nlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\nlocalparam [ 0:0] FMODE2_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\nlocalparam [10:0] UPAE2_i       = 11'd10;\\nlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n// Width mode function\\nfunction [2:0] mode;\\ninput integer width;\\ncase (width)\\n1: mode = 3'b101;\\n2: mode = 3'b110;\\n4: mode = 3'b100;\\n8,9: mode = 3'b001;\\n16, 18: mode = 3'b010;\\n32, 36: mode = 3'b011;\\ndefault: mode = 3'b000;\\nendcase\\nendfunction\\n\\nfunction integer rwmode;\\ninput integer rwwidth;\\ncase (rwwidth)\\n1: rwmode = 1;\\n2: rwmode = 2;\\n4: rwmode = 4;\\n8,9: rwmode = 9;\\n16, 18: rwmode = 18;\\n32, 36: rwmode = 36;\\ndefault: rwmode = 36;\\nendcase\\nendfunction\\n\\nwire REN_A1_i;\\nwire REN_A2_i;\\n\\nwire REN_B1_i;\\nwire REN_B2_i;\\n\\nwire WEN_A1_i;\\nwire WEN_A2_i;\\n\\nwire WEN_B1_i;\\nwire WEN_B2_i;\\n\\nwire [1:0] BE_A1_i;\\nwire [1:0] BE_A2_i;\\n\\nwire [1:0] BE_B1_i;\\nwire [1:0] BE_B2_i;\\n\\nwire [14:0] ADDR_A1_i;\\nwire [13:0] ADDR_A2_i;\\n\\nwire [14:0] ADDR_B1_i;\\nwire [13:0] ADDR_B2_i;\\n\\nwire [17:0] WDATA_A1_i;\\nwire [17:0] WDATA_A2_i;\\n\\nwire [17:0] WDATA_B1_i;\\nwire [17:0] WDATA_B2_i;\\n\\nwire [17:0] RDATA_A1_o;\\nwire [17:0] RDATA_A2_o;\\n\\nwire [17:0] RDATA_B1_o;\\nwire [17:0] RDATA_B2_o;\\n\\nwire [3:0] WR_BE;\\n\\nwire [35:0] PORT_B_RDATA;\\nwire [35:0] PORT_A_WDATA;\\n\\nwire [14:0] WR_ADDR_INT;\\nwire [14:0] RD_ADDR_INT;\\n\\nwire [14:0] PORT_A_ADDR;\\nwire [14:0] PORT_B_ADDR;\\n\\nwire PORT_A_CLK;\\nwire PORT_B_CLK;\\n\\n// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)\\nlocalparam [ 2:0] RMODE_A1_i    = mode(WR_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_A1_i    = mode(WR_DATA_WIDTH);\\nlocalparam [ 2:0] RMODE_A2_i    = mode(WR_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_A2_i    = mode(WR_DATA_WIDTH);\\n\\nlocalparam [ 2:0] RMODE_B1_i    = mode(RD_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_B1_i    = mode(RD_DATA_WIDTH);\\nlocalparam [ 2:0] RMODE_B2_i    = mode(RD_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_B2_i    = mode(RD_DATA_WIDTH);\\n\\nlocalparam PORT_A_WRWIDTH = rwmode(WR_DATA_WIDTH);\\nlocalparam PORT_B_WRWIDTH = rwmode(RD_DATA_WIDTH);\\n\\nassign PORT_A_CLK = WR_CLK_i;\\nassign PORT_B_CLK = RD_CLK_i;\\n\\ngenerate\\n\\tif (WR_ADDR_WIDTH == 15) begin\\n\\t\\tassign WR_ADDR_INT = WR_ADDR_i;\\n\\tend else begin\\n\\t\\tassign WR_ADDR_INT[14:WR_ADDR_WIDTH] = 0;\\n\\t\\tassign WR_ADDR_INT[WR_ADDR_WIDTH-1:0] = WR_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (WR_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A_ADDR = WR_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A_ADDR = WR_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A_ADDR = WR_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A_ADDR = WR_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A_ADDR = WR_ADDR_INT << 4;\\n\\tend\\n\\t32, 36: begin\\n\\t\\tassign PORT_A_ADDR = WR_ADDR_INT << 5;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A_ADDR = WR_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (RD_ADDR_WIDTH == 15) begin\\n\\t\\tassign RD_ADDR_INT = RD_ADDR_i;\\n\\tend else begin\\n\\t\\tassign RD_ADDR_INT[14:RD_ADDR_WIDTH] = 0;\\n\\t\\tassign RD_ADDR_INT[RD_ADDR_WIDTH-1:0] = RD_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (RD_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B_ADDR = RD_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B_ADDR = RD_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B_ADDR = RD_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B_ADDR = RD_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B_ADDR = RD_ADDR_INT << 4;\\n\\tend\\n\\t32, 36: begin\\n\\t\\tassign PORT_B_ADDR = RD_ADDR_INT << 5;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B_ADDR = RD_ADDR_INT;\\n\\tend\\nendcase\\n\\ncase (BE_WIDTH)\\n\\t4: begin\\n\\t\\tassign WR_BE = WR_BE_i[BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign WR_BE[3:BE_WIDTH] = 0;\\n\\t\\tassign WR_BE[BE_WIDTH-1 :0] = WR_BE_i[BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\nassign REN_A1_i = 1'b0;\\nassign WEN_A1_i = WEN_i;\\nassign {BE_A2_i, BE_A1_i} = WR_BE;\\n\\nassign REN_B1_i = REN_i;\\nassign WEN_B1_i = 1'b0;\\nassign {BE_B2_i, BE_B1_i} = 4'h0;\\n\\ngenerate\\n\\tif (WR_DATA_WIDTH == 36) begin\\n\\t\\tassign PORT_A_WDATA[WR_DATA_WIDTH-1:0] = WDATA_i[WR_DATA_WIDTH-1:0];\\n\\tend else if (WR_DATA_WIDTH > 18 && WR_DATA_WIDTH < 36) begin\\n\\t\\tassign PORT_A_WDATA[WR_DATA_WIDTH+1:18]  = WDATA_i[WR_DATA_WIDTH-1:16];\\n\\t\\tassign PORT_A_WDATA[17:0] = {2'b00,WDATA_i[15:0]};\\n\\tend else if (WR_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_A_WDATA = {19'h0, WDATA_i[8], 8'h0, WDATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A_WDATA[35:WR_DATA_WIDTH] = 0;\\n\\t\\tassign PORT_A_WDATA[WR_DATA_WIDTH-1:0] = WDATA_i[WR_DATA_WIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A1_i = PORT_A_WDATA[17:0];\\nassign WDATA_A2_i = PORT_A_WDATA[35:18];\\n\\nassign WDATA_B1_i = 18'h0;\\nassign WDATA_B2_i = 18'h0;\\n\\ngenerate\\n\\tif (RD_DATA_WIDTH == 36) begin\\n\\t\\tassign PORT_B_RDATA = {RDATA_B2_o, RDATA_B1_o};\\n\\tend else if (RD_DATA_WIDTH > 18 && RD_DATA_WIDTH < 36) begin\\n\\t\\tassign PORT_B_RDATA  = {2'b00,RDATA_B2_o[17:0],RDATA_B1_o[15:0]};\\n\\tend else if (RD_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_B_RDATA = { 27'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B_RDATA = {18'h0, RDATA_B1_o};\\n\\tend\\nendgenerate\\n\\nassign RDATA_o = PORT_B_RDATA[RD_DATA_WIDTH-1:0];\\n\\ndefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n};\\n\\n\\n(* is_inferred = 0 *)\\n(* is_split = 0 *)\\n(* is_fifo = 0 *)\\n(* port_a_dwidth = PORT_A_WRWIDTH *)\\n(* port_b_dwidth = PORT_B_WRWIDTH *)\\nTDP36K _TECHMAP_REPLACE_ (\\n\\t.RESET_ni(1'b1),\\n\\n\\t.CLK_A1_i(PORT_A_CLK),\\n\\t.ADDR_A1_i(PORT_A_ADDR),\\n\\t.WEN_A1_i(WEN_A1_i),\\n\\t.BE_A1_i(BE_A1_i),\\n\\t.WDATA_A1_i(WDATA_A1_i),\\n\\t.REN_A1_i(REN_A1_i),\\n\\t.RDATA_A1_o(RDATA_A1_o),\\n\\n\\t.CLK_A2_i(PORT_A_CLK),\\n\\t.ADDR_A2_i(PORT_A_ADDR[13:0]),\\n\\t.WEN_A2_i(WEN_A1_i),\\n\\t.BE_A2_i(BE_A2_i),\\n\\t.WDATA_A2_i(WDATA_A2_i),\\n\\t.REN_A2_i(REN_A1_i),\\n\\t.RDATA_A2_o(RDATA_A2_o),\\n\\n\\t.CLK_B1_i(PORT_B_CLK),\\n\\t.ADDR_B1_i(PORT_B_ADDR),\\n\\t.WEN_B1_i(WEN_B1_i),\\n\\t.BE_B1_i(BE_B1_i),\\n\\t.WDATA_B1_i(WDATA_B1_i),\\n\\t.REN_B1_i(REN_B1_i),\\n\\t.RDATA_B1_o(RDATA_B1_o),\\n\\n\\t.CLK_B2_i(PORT_B_CLK),\\n\\t.ADDR_B2_i(PORT_B_ADDR[13:0]),\\n\\t.WEN_B2_i(WEN_B1_i),\\n\\t.BE_B2_i(BE_B2_i),\\n\\t.WDATA_B2_i(WDATA_B2_i),\\n\\t.REN_B2_i(REN_B1_i),\\n\\t.RDATA_B2_o(RDATA_B2_o),\\n\\n\\t.FLUSH1_i(1'b0),\\n\\t.FLUSH2_i(1'b0)\\n);\\n\\nendmodule\\n\\nmodule RAM_18K_BLK (\\n\\t\\tWEN_i,\\n\\t\\tREN_i,\\n\\t\\tWR_CLK_i,\\n\\t\\tRD_CLK_i,\\n\\t\\tWR_BE_i,\\n\\t\\tWR_ADDR_i,\\n\\t\\tRD_ADDR_i,\\n\\t\\tWDATA_i,\\n\\t\\tRDATA_o\\n);\\n\\nparameter WR_ADDR_WIDTH = 10;\\nparameter RD_ADDR_WIDTH = 10;\\nparameter WR_DATA_WIDTH = 18;\\nparameter RD_DATA_WIDTH = 18;\\nparameter BE_WIDTH = 2;\\n\\ninput wire WEN_i;\\ninput wire REN_i;\\ninput wire WR_CLK_i;\\ninput wire RD_CLK_i;\\ninput wire [BE_WIDTH-1:0] WR_BE_i;\\ninput wire [WR_ADDR_WIDTH-1 :0] WR_ADDR_i;\\ninput wire [RD_ADDR_WIDTH-1 :0] RD_ADDR_i;\\ninput wire [WR_DATA_WIDTH-1 :0] WDATA_i;\\noutput wire [RD_DATA_WIDTH-1 :0] RDATA_o;\\n\\n\\t(* is_inferred = 0 *)\\n\\t(* is_split = 0 *)\\n\\t(* is_fifo = 0 *)\\n\\tBRAM2x18_SP  #(\\n\\t\\t\\t.WR1_ADDR_WIDTH(WR_ADDR_WIDTH),\\n\\t\\t\\t.RD1_ADDR_WIDTH(RD_ADDR_WIDTH),\\n\\t\\t\\t.WR1_DATA_WIDTH(WR_DATA_WIDTH),\\n\\t\\t\\t.RD1_DATA_WIDTH(RD_DATA_WIDTH),\\n\\t\\t\\t.BE1_WIDTH(BE_WIDTH),\\n\\t\\t\\t.WR2_ADDR_WIDTH(),\\n\\t\\t\\t.RD2_ADDR_WIDTH(),\\n\\t\\t\\t.WR2_DATA_WIDTH(),\\n\\t\\t\\t.RD2_DATA_WIDTH(),\\n\\t\\t\\t.BE2_WIDTH()\\n\\t\\t\\t ) U1\\n\\t\\t\\t(\\n\\t\\t\\t.RESET_ni(1'b1),\\n\\n\\t\\t\\t.WEN1_i(WEN_i),\\n\\t\\t\\t.REN1_i(REN_i),\\n\\t\\t\\t.WR1_CLK_i(WR_CLK_i),\\n\\t\\t\\t.RD1_CLK_i(RD_CLK_i),\\n\\t\\t\\t.WR1_BE_i(WR_BE_i),\\n\\t\\t\\t.WR1_ADDR_i(WR_ADDR_i),\\n\\t\\t\\t.RD1_ADDR_i(RD_ADDR_i),\\n\\t\\t\\t.WDATA1_i(WDATA_i),\\n\\t\\t\\t.RDATA1_o(RDATA_o),\\n\\n\\t\\t\\t.WEN2_i(1'b0),\\n\\t\\t\\t.REN2_i(1'b0),\\n\\t\\t\\t.WR2_CLK_i(1'b0),\\n\\t\\t\\t.RD2_CLK_i(1'b0),\\n\\t\\t\\t.WR2_BE_i(2'b00),\\n\\t\\t\\t.WR2_ADDR_i(14'h0),\\n\\t\\t\\t.RD2_ADDR_i(14'h0),\\n\\t\\t\\t.WDATA2_i(18'h0),\\n\\t\\t\\t.RDATA2_o()\\n\\t\\t\\t);\\n\\nendmodule\\n\\nmodule RAM_18K_X2_BLK (\\n\\t\\tRESET_ni,\\n\\n\\t\\tWEN1_i,\\n\\t\\tREN1_i,\\n\\t\\tWR1_CLK_i,\\n\\t\\tRD1_CLK_i,\\n\\t\\tWR1_BE_i,\\n\\t\\tWR1_ADDR_i,\\n\\t\\tRD1_ADDR_i,\\n\\t\\tWDATA1_i,\\n\\t\\tRDATA1_o,\\n\\n\\t\\tWEN2_i,\\n\\t\\tREN2_i,\\n\\t\\tWR2_CLK_i,\\n\\t\\tRD2_CLK_i,\\n\\t\\tWR2_BE_i,\\n\\t\\tWR2_ADDR_i,\\n\\t\\tRD2_ADDR_i,\\n\\t\\tWDATA2_i,\\n\\t\\tRDATA2_o\\n);\\n\\nparameter WR1_ADDR_WIDTH = 10;\\nparameter RD1_ADDR_WIDTH = 10;\\nparameter WR1_DATA_WIDTH = 18;\\nparameter RD1_DATA_WIDTH = 18;\\nparameter BE1_WIDTH = 2;\\n\\nparameter WR2_ADDR_WIDTH = 10;\\nparameter RD2_ADDR_WIDTH = 10;\\nparameter WR2_DATA_WIDTH = 18;\\nparameter RD2_DATA_WIDTH = 18;\\nparameter BE2_WIDTH = 2;\\n\\ninput wire RESET_ni;\\n\\ninput wire WEN1_i;\\ninput wire REN1_i;\\ninput wire WR1_CLK_i;\\ninput wire RD1_CLK_i;\\ninput wire [BE1_WIDTH-1:0] WR1_BE_i;\\ninput wire [WR1_ADDR_WIDTH-1 :0] WR1_ADDR_i;\\ninput wire [RD1_ADDR_WIDTH-1 :0] RD1_ADDR_i;\\ninput wire [WR1_DATA_WIDTH-1 :0] WDATA1_i;\\noutput wire [RD1_DATA_WIDTH-1 :0] RDATA1_o;\\n\\ninput wire WEN2_i;\\ninput wire REN2_i;\\ninput wire WR2_CLK_i;\\ninput wire RD2_CLK_i;\\ninput wire [BE2_WIDTH-1:0] WR2_BE_i;\\ninput wire [WR2_ADDR_WIDTH-1 :0] WR2_ADDR_i;\\ninput wire [RD2_ADDR_WIDTH-1 :0] RD2_ADDR_i;\\ninput wire [WR2_DATA_WIDTH-1 :0] WDATA2_i;\\noutput wire [RD2_DATA_WIDTH-1 :0] RDATA2_o;\\n\\n// Fixed mode settings\\nlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\nlocalparam [ 0:0] FMODE1_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\nlocalparam [11:0] UPAE1_i       = 12'd10;\\nlocalparam [11:0] UPAF1_i       = 12'd10;\\n\\nlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\nlocalparam [ 0:0] FMODE2_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\nlocalparam [10:0] UPAE2_i       = 11'd10;\\nlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n// Width mode function\\nfunction [2:0] mode;\\ninput integer width;\\ncase (width)\\n1: mode = 3'b101;\\n2: mode = 3'b110;\\n4: mode = 3'b100;\\n8,9: mode = 3'b001;\\n16, 18: mode = 3'b010;\\n32, 36: mode = 3'b011;\\ndefault: mode = 3'b000;\\nendcase\\nendfunction\\n\\nfunction integer rwmode;\\ninput integer rwwidth;\\ncase (rwwidth)\\n1: rwmode = 1;\\n2: rwmode = 2;\\n4: rwmode = 4;\\n8,9: rwmode = 9;\\n16, 18: rwmode = 18;\\ndefault: rwmode = 18;\\nendcase\\nendfunction\\n\\nwire REN_A1_i;\\nwire REN_A2_i;\\n\\nwire REN_B1_i;\\nwire REN_B2_i;\\n\\nwire WEN_A1_i;\\nwire WEN_A2_i;\\n\\nwire WEN_B1_i;\\nwire WEN_B2_i;\\n\\nwire [1:0] BE_A1_i;\\nwire [1:0] BE_A2_i;\\n\\nwire [1:0] BE_B1_i;\\nwire [1:0] BE_B2_i;\\n\\nwire [14:0] ADDR_A1_i;\\nwire [13:0] ADDR_A2_i;\\n\\nwire [14:0] ADDR_B1_i;\\nwire [13:0] ADDR_B2_i;\\n\\nwire [17:0] WDATA_A1_i;\\nwire [17:0] WDATA_A2_i;\\n\\nwire [17:0] WDATA_B1_i;\\nwire [17:0] WDATA_B2_i;\\n\\nwire [17:0] RDATA_A1_o;\\nwire [17:0] RDATA_A2_o;\\n\\nwire [17:0] RDATA_B1_o;\\nwire [17:0] RDATA_B2_o;\\n\\nwire [1:0] WR1_BE;\\nwire [1:0] WR2_BE;\\n\\nwire [17:0] PORT_B1_RDATA;\\nwire [17:0] PORT_A1_WDATA;\\n\\nwire [17:0] PORT_B2_RDATA;\\nwire [17:0] PORT_A2_WDATA;\\n\\nwire [13:0] WR1_ADDR_INT;\\nwire [13:0] RD1_ADDR_INT;\\n\\nwire [13:0] WR2_ADDR_INT;\\nwire [13:0] RD2_ADDR_INT;\\n\\nwire [13:0] PORT_A1_ADDR;\\nwire [13:0] PORT_B1_ADDR;\\n\\nwire [13:0] PORT_A2_ADDR;\\nwire [13:0] PORT_B2_ADDR;\\n\\n\\n// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)\\nlocalparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);\\nlocalparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\nlocalparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);\\nlocalparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\nlocalparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);\\nlocalparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);\\nlocalparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);\\nlocalparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);\\n\\ngenerate\\n\\tif (WR1_ADDR_WIDTH == 14) begin\\n\\t\\tassign WR1_ADDR_INT = WR1_ADDR_i;\\n\\tend else begin\\n\\t\\tassign WR1_ADDR_INT[13:WR1_ADDR_WIDTH] = 0;\\n\\t\\tassign WR1_ADDR_INT[WR1_ADDR_WIDTH-1:0] = WR1_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (WR1_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (RD1_ADDR_WIDTH == 14) begin\\n\\t\\tassign RD1_ADDR_INT = RD1_ADDR_i;\\n\\tend else begin\\n\\t\\tassign RD1_ADDR_INT[13:RD1_ADDR_WIDTH] = 0;\\n\\t\\tassign RD1_ADDR_INT[RD1_ADDR_WIDTH-1:0] = RD1_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (RD1_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (WR2_ADDR_WIDTH == 14) begin\\n\\t\\tassign WR2_ADDR_INT = WR2_ADDR_i;\\n\\tend else begin\\n\\t\\tassign WR2_ADDR_INT[13:WR2_ADDR_WIDTH] = 0;\\n\\t\\tassign WR2_ADDR_INT[WR2_ADDR_WIDTH-1:0] = WR2_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (WR2_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (RD2_ADDR_WIDTH == 14) begin\\n\\t\\tassign RD2_ADDR_INT = RD2_ADDR_i;\\n\\tend else begin\\n\\t\\tassign RD2_ADDR_INT[13:RD2_ADDR_WIDTH] = 0;\\n\\t\\tassign RD2_ADDR_INT[RD2_ADDR_WIDTH-1:0] = RD2_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (RD2_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT;\\n\\tend\\nendcase\\n\\ncase (BE1_WIDTH)\\n\\t2: begin\\n\\t\\tassign WR1_BE = WR1_BE_i[BE1_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign WR1_BE[1:BE1_WIDTH] = 0;\\n\\t\\tassign WR1_BE[BE1_WIDTH-1 :0] = WR1_BE_i[BE1_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\ncase (BE2_WIDTH)\\n\\t2: begin\\n\\t\\tassign WR2_BE = WR2_BE_i[BE2_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign WR2_BE[1:BE2_WIDTH] = 0;\\n\\t\\tassign WR2_BE[BE2_WIDTH-1 :0] = WR2_BE_i[BE2_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\nassign REN_A1_i = 1'b0;\\nassign WEN_A1_i = WEN1_i;\\nassign BE_A1_i = WR1_BE;\\nassign REN_A2_i = 1'b0;\\nassign WEN_A2_i = WEN2_i;\\nassign BE_A2_i = WR2_BE;\\n\\nassign REN_B1_i = REN1_i;\\nassign WEN_B1_i = 1'b0;\\nassign BE_B1_i = 4'h0;\\nassign REN_B2_i = REN2_i;\\nassign WEN_B2_i = 1'b0;\\nassign BE_B2_i = 4'h0;\\n\\ngenerate\\n\\tif (WR1_DATA_WIDTH == 18) begin\\n\\t\\tassign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];\\n\\tend else if (WR1_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_A1_WDATA = {1'b0, WDATA1_i[8], 8'h0, WDATA1_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A1_WDATA[17:WR1_DATA_WIDTH] = 0;\\n\\t\\tassign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A1_i = PORT_A1_WDATA[17:0];\\nassign WDATA_B1_i = 18'h0;\\n\\ngenerate\\n\\tif (RD1_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B1_RDATA = RDATA_B1_o;\\n\\tend\\nendgenerate\\n\\nassign RDATA1_o = PORT_B1_RDATA[RD1_DATA_WIDTH-1:0];\\n\\ngenerate\\n\\tif (WR2_DATA_WIDTH == 18) begin\\n\\t\\tassign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];\\n\\tend else if (WR2_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_A2_WDATA = {1'b0, WDATA2_i[8], 8'h0, WDATA2_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A2_WDATA[17:WR2_DATA_WIDTH] = 0;\\n\\t\\tassign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A2_i = PORT_A2_WDATA[17:0];\\nassign WDATA_B2_i = 18'h0;\\n\\ngenerate\\n\\tif (RD2_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B2_RDATA = RDATA_B2_o;\\n\\tend\\nendgenerate\\n\\nassign RDATA2_o = PORT_B2_RDATA[RD2_DATA_WIDTH-1:0];\\n\\ndefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n};\\n\\n(* is_inferred = 0 *)\\n(* is_split = 1 *)\\n(* is_fifo = 0 *)\\n(* port_a1_dwidth = PORT_A1_WRWIDTH *)\\n(* port_a2_dwidth = PORT_A2_WRWIDTH *)\\n(* port_b1_dwidth = PORT_B1_WRWIDTH *)\\n(* port_b2_dwidth = PORT_B2_WRWIDTH *)\\nTDP36K _TECHMAP_REPLACE_ (\\n\\t.RESET_ni(1'b1),\\n\\n\\t.CLK_A1_i(WR1_CLK_i),\\n\\t.ADDR_A1_i({1'b0,PORT_A1_ADDR}),\\n\\t.WEN_A1_i(WEN_A1_i),\\n\\t.BE_A1_i(BE_A1_i),\\n\\t.WDATA_A1_i(WDATA_A1_i),\\n\\t.REN_A1_i(REN_A1_i),\\n\\t.RDATA_A1_o(RDATA_A1_o),\\n\\n\\t.CLK_A2_i(WR2_CLK_i),\\n\\t.ADDR_A2_i(PORT_A2_ADDR),\\n\\t.WEN_A2_i(WEN_A2_i),\\n\\t.BE_A2_i(BE_A2_i),\\n\\t.WDATA_A2_i(WDATA_A2_i),\\n\\t.REN_A2_i(REN_A2_i),\\n\\t.RDATA_A2_o(RDATA_A2_o),\\n\\n\\t.CLK_B1_i(RD1_CLK_i),\\n\\t.ADDR_B1_i({1'b0,PORT_B1_ADDR}),\\n\\t.WEN_B1_i(WEN_B1_i),\\n\\t.BE_B1_i(BE_B1_i),\\n\\t.WDATA_B1_i(WDATA_B1_i),\\n\\t.REN_B1_i(REN_B1_i),\\n\\t.RDATA_B1_o(RDATA_B1_o),\\n\\n\\t.CLK_B2_i(RD2_CLK_i),\\n\\t.ADDR_B2_i(PORT_B2_ADDR),\\n\\t.WEN_B2_i(WEN_B2_i),\\n\\t.BE_B2_i(BE_B2_i),\\n\\t.WDATA_B2_i(WDATA_B2_i),\\n\\t.REN_B2_i(REN_B2_i),\\n\\t.RDATA_B2_o(RDATA_B2_o),\\n\\n\\t.FLUSH1_i(1'b0),\\n\\t.FLUSH2_i(1'b0)\\n);\\n\\nendmodule\\n\\nmodule DPRAM_36K_BLK (\\n\\t\\tPORT_A_CLK_i,\\n\\t\\tPORT_A_WEN_i,\\n\\t\\tPORT_A_WR_BE_i,\\n\\t\\tPORT_A_REN_i,\\n\\t\\tPORT_A_ADDR_i,\\n\\t\\tPORT_A_WR_DATA_i,\\n\\t\\tPORT_A_RD_DATA_o,\\n\\n\\t\\tPORT_B_CLK_i,\\n\\t\\tPORT_B_WEN_i,\\n\\t\\tPORT_B_WR_BE_i,\\n\\t\\tPORT_B_REN_i,\\n\\t\\tPORT_B_ADDR_i,\\n\\t\\tPORT_B_WR_DATA_i,\\n\\t\\tPORT_B_RD_DATA_o\\n);\\n\\nparameter PORT_A_AWIDTH = 10;\\nparameter PORT_A_DWIDTH = 36;\\nparameter PORT_A_WR_BE_WIDTH = 4;\\n\\nparameter PORT_B_AWIDTH = 10;\\nparameter PORT_B_DWIDTH = 36;\\nparameter PORT_B_WR_BE_WIDTH = 4;\\n\\ninput PORT_A_CLK_i;\\ninput [PORT_A_AWIDTH-1:0] PORT_A_ADDR_i;\\ninput [PORT_A_DWIDTH-1:0] PORT_A_WR_DATA_i;\\ninput PORT_A_WEN_i;\\ninput [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE_i;\\ninput PORT_A_REN_i;\\noutput [PORT_A_DWIDTH-1:0] PORT_A_RD_DATA_o;\\n\\ninput PORT_B_CLK_i;\\ninput [PORT_B_AWIDTH-1:0] PORT_B_ADDR_i;\\ninput [PORT_B_DWIDTH-1:0] PORT_B_WR_DATA_i;\\ninput PORT_B_WEN_i;\\ninput [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE_i;\\ninput PORT_B_REN_i;\\noutput [PORT_B_DWIDTH-1:0] PORT_B_RD_DATA_o;\\n\\n\\n// Fixed mode settings\\nlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\nlocalparam [ 0:0] FMODE1_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\nlocalparam [11:0] UPAE1_i       = 12'd10;\\nlocalparam [11:0] UPAF1_i       = 12'd10;\\n\\nlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\nlocalparam [ 0:0] FMODE2_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\nlocalparam [10:0] UPAE2_i       = 11'd10;\\nlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n// Width mode function\\nfunction [2:0] mode;\\ninput integer width;\\ncase (width)\\n1: mode = 3'b101;\\n2: mode = 3'b110;\\n4: mode = 3'b100;\\n8,9: mode = 3'b001;\\n16, 18: mode = 3'b010;\\n32, 36: mode = 3'b011;\\ndefault: mode = 3'b000;\\nendcase\\nendfunction\\n\\nfunction integer rwmode;\\ninput integer rwwidth;\\ncase (rwwidth)\\n1: rwmode = 1;\\n2: rwmode = 2;\\n4: rwmode = 4;\\n8,9: rwmode = 9;\\n16, 18: rwmode = 18;\\n32, 36: rwmode = 36;\\ndefault: rwmode = 36;\\nendcase\\nendfunction\\n\\nwire REN_A1_i;\\nwire REN_A2_i;\\n\\nwire REN_B1_i;\\nwire REN_B2_i;\\n\\nwire WEN_A1_i;\\nwire WEN_A2_i;\\n\\nwire WEN_B1_i;\\nwire WEN_B2_i;\\n\\nwire [1:0] BE_A1_i;\\nwire [1:0] BE_A2_i;\\n\\nwire [1:0] BE_B1_i;\\nwire [1:0] BE_B2_i;\\n\\nwire [14:0] ADDR_A1_i;\\nwire [13:0] ADDR_A2_i;\\n\\nwire [14:0] ADDR_B1_i;\\nwire [13:0] ADDR_B2_i;\\n\\nwire [17:0] WDATA_A1_i;\\nwire [17:0] WDATA_A2_i;\\n\\nwire [17:0] WDATA_B1_i;\\nwire [17:0] WDATA_B2_i;\\n\\nwire [17:0] RDATA_A1_o;\\nwire [17:0] RDATA_A2_o;\\n\\nwire [17:0] RDATA_B1_o;\\nwire [17:0] RDATA_B2_o;\\n\\nwire [3:0] PORT_A_WR_BE;\\nwire [3:0] PORT_B_WR_BE;\\n\\nwire [35:0] PORT_B_WDATA;\\nwire [35:0] PORT_B_RDATA;\\nwire [35:0] PORT_A_WDATA;\\nwire [35:0] PORT_A_RDATA;\\n\\nwire [14:0] PORT_A_ADDR_INT;\\nwire [14:0] PORT_B_ADDR_INT;\\n\\nwire [14:0] PORT_A_ADDR;\\nwire [14:0] PORT_B_ADDR;\\n\\nwire PORT_A_CLK;\\nwire PORT_B_CLK;\\n\\n// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)\\nlocalparam [ 2:0] RMODE_A1_i    = mode(PORT_A_DWIDTH);\\nlocalparam [ 2:0] WMODE_A1_i    = mode(PORT_A_DWIDTH);\\nlocalparam [ 2:0] RMODE_A2_i    = mode(PORT_A_DWIDTH);\\nlocalparam [ 2:0] WMODE_A2_i    = mode(PORT_A_DWIDTH);\\n\\nlocalparam [ 2:0] RMODE_B1_i    = mode(PORT_B_DWIDTH);\\nlocalparam [ 2:0] WMODE_B1_i    = mode(PORT_B_DWIDTH);\\nlocalparam [ 2:0] RMODE_B2_i    = mode(PORT_B_DWIDTH);\\nlocalparam [ 2:0] WMODE_B2_i    = mode(PORT_B_DWIDTH);\\n\\nlocalparam PORT_A_WRWIDTH = rwmode(PORT_A_DWIDTH);\\nlocalparam PORT_B_WRWIDTH = rwmode(PORT_B_DWIDTH);\\n\\nassign PORT_A_CLK = PORT_A_CLK_i;\\nassign PORT_B_CLK = PORT_B_CLK_i;\\n\\ngenerate\\n\\tif (PORT_A_AWIDTH == 15) begin\\n\\t\\tassign PORT_A_ADDR_INT = PORT_A_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_A_ADDR_INT[14:PORT_A_AWIDTH] = 0;\\n\\t\\tassign PORT_A_ADDR_INT[PORT_A_AWIDTH-1:0] = PORT_A_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_A_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A_ADDR = PORT_A_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A_ADDR = PORT_A_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A_ADDR = PORT_A_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A_ADDR = PORT_A_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A_ADDR = PORT_A_ADDR_INT << 4;\\n\\tend\\n\\t32, 36: begin\\n\\t\\tassign PORT_A_ADDR = PORT_A_ADDR_INT << 5;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A_ADDR = PORT_A_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (PORT_B_AWIDTH == 15) begin\\n\\t\\tassign PORT_B_ADDR_INT = PORT_B_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_B_ADDR_INT[14:PORT_B_AWIDTH] = 0;\\n\\t\\tassign PORT_B_ADDR_INT[PORT_B_AWIDTH-1:0] = PORT_B_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_B_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B_ADDR = PORT_B_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B_ADDR = PORT_B_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B_ADDR = PORT_B_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B_ADDR = PORT_B_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B_ADDR = PORT_B_ADDR_INT << 4;\\n\\tend\\n\\t32, 36: begin\\n\\t\\tassign PORT_B_ADDR = PORT_B_ADDR_INT << 5;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B_ADDR = PORT_B_ADDR_INT;\\n\\tend\\nendcase\\n\\ncase (PORT_A_WR_BE_WIDTH)\\n\\t4: begin\\n\\t\\tassign PORT_A_WR_BE = PORT_A_WR_BE_i[PORT_A_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A_WR_BE[3:PORT_A_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_A_WR_BE[PORT_A_WR_BE_WIDTH-1 :0] = PORT_A_WR_BE_i[PORT_A_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\ncase (PORT_B_WR_BE_WIDTH)\\n\\t4: begin\\n\\t\\tassign PORT_B_WR_BE = PORT_B_WR_BE_i[PORT_B_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B_WR_BE[3:PORT_B_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_B_WR_BE[PORT_B_WR_BE_WIDTH-1 :0] = PORT_B_WR_BE_i[PORT_B_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\nassign REN_A1_i = PORT_A_REN_i;\\nassign WEN_A1_i = PORT_A_WEN_i;\\nassign {BE_A2_i, BE_A1_i} = PORT_A_WR_BE;\\n\\nassign REN_B1_i = PORT_B_REN_i;\\nassign WEN_B1_i = PORT_B_WEN_i;\\nassign {BE_B2_i, BE_B1_i} = PORT_B_WR_BE;\\n\\ngenerate\\n\\tif (PORT_A_DWIDTH == 36) begin\\n\\t\\tassign PORT_A_WDATA[PORT_A_DWIDTH-1:0] = PORT_A_WR_DATA_i[PORT_A_DWIDTH-1:0];\\n\\tend else if (PORT_A_DWIDTH > 18 && PORT_A_DWIDTH < 36) begin\\n\\t\\tassign PORT_A_WDATA[PORT_A_DWIDTH+1:18]  = PORT_A_WR_DATA_i[PORT_A_DWIDTH-1:16];\\n\\t\\tassign PORT_A_WDATA[17:0] = {2'b00,PORT_A_WR_DATA_i[15:0]};\\n\\tend else if (PORT_A_DWIDTH == 9) begin\\n\\t\\tassign PORT_A_WDATA = {19'h0, PORT_A_WR_DATA_i[8], 8'h0, PORT_A_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A_WDATA[35:PORT_A_DWIDTH] = 0;\\n\\t\\tassign PORT_A_WDATA[PORT_A_DWIDTH-1:0] = PORT_A_WR_DATA_i[PORT_A_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A1_i = PORT_A_WDATA[17:0];\\nassign WDATA_A2_i = PORT_A_WDATA[35:18];\\n\\ngenerate\\n\\tif (PORT_A_DWIDTH == 36) begin\\n\\t\\tassign PORT_A_RDATA = {RDATA_A2_o, RDATA_A1_o};\\n\\tend else if (PORT_A_DWIDTH > 18 && PORT_A_DWIDTH < 36) begin\\n\\t\\tassign PORT_A_RDATA  = {2'b00,RDATA_A2_o[17:0],RDATA_A1_o[15:0]};\\n\\tend else if (PORT_A_DWIDTH == 9) begin\\n\\t\\tassign PORT_A_RDATA = { 27'h0, RDATA_A1_o[16], RDATA_A1_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A_RDATA = {18'h0, RDATA_A1_o};\\n\\tend\\nendgenerate\\n\\nassign PORT_A_RD_DATA_o = PORT_A_RDATA[PORT_A_DWIDTH-1:0];\\n\\ngenerate\\n\\tif (PORT_B_DWIDTH == 36) begin\\n\\t\\tassign PORT_B_WDATA[PORT_B_DWIDTH-1:0] = PORT_B_WR_DATA_i[PORT_B_DWIDTH-1:0];\\n\\tend else if (PORT_B_DWIDTH > 18 && PORT_B_DWIDTH < 36) begin\\n\\t\\tassign PORT_B_WDATA[PORT_B_DWIDTH+1:18]  = PORT_B_WR_DATA_i[PORT_B_DWIDTH-1:16];\\n\\t\\tassign PORT_B_WDATA[17:0] = {2'b00,PORT_B_WR_DATA_i[15:0]};\\n\\tend else if (PORT_B_DWIDTH == 9) begin\\n\\t\\tassign PORT_B_WDATA = {19'h0, PORT_B_WR_DATA_i[8], 8'h0, PORT_B_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B_WDATA[35:PORT_B_DWIDTH] = 0;\\n\\t\\tassign PORT_B_WDATA[PORT_B_DWIDTH-1:0] = PORT_B_WR_DATA_i[PORT_B_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_B1_i = PORT_B_WDATA[17:0];\\nassign WDATA_B2_i = PORT_B_WDATA[35:18];\\n\\ngenerate\\n\\tif (PORT_B_DWIDTH == 36) begin\\n\\t\\tassign PORT_B_RDATA = {RDATA_B2_o, RDATA_B1_o};\\n\\tend else if (PORT_B_DWIDTH > 18 && PORT_B_DWIDTH < 36) begin\\n\\t\\tassign PORT_B_RDATA  = {2'b00,RDATA_B2_o[17:0],RDATA_B1_o[15:0]};\\n\\tend else if (PORT_B_DWIDTH == 9) begin\\n\\t\\tassign PORT_B_RDATA = { 27'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B_RDATA = {18'h0, RDATA_B1_o};\\n\\tend\\nendgenerate\\n\\nassign PORT_B_RD_DATA_o = PORT_B_RDATA[PORT_B_DWIDTH-1:0];\\n\\ndefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n};\\n\\n(* is_inferred = 0 *)\\n(* is_split = 0 *)\\n(* is_fifo = 0 *)\\n(* port_a_dwidth = PORT_A_WRWIDTH *)\\n(* port_b_dwidth = PORT_B_WRWIDTH *)\\nTDP36K _TECHMAP_REPLACE_ (\\n\\t.RESET_ni(1'b1),\\n\\n\\t.CLK_A1_i(PORT_A_CLK),\\n\\t.ADDR_A1_i(PORT_A_ADDR),\\n\\t.WEN_A1_i(WEN_A1_i),\\n\\t.BE_A1_i(BE_A1_i),\\n\\t.WDATA_A1_i(WDATA_A1_i),\\n\\t.REN_A1_i(REN_A1_i),\\n\\t.RDATA_A1_o(RDATA_A1_o),\\n\\n\\t.CLK_A2_i(PORT_A_CLK),\\n\\t.ADDR_A2_i(PORT_A_ADDR[13:0]),\\n\\t.WEN_A2_i(WEN_A1_i),\\n\\t.BE_A2_i(BE_A2_i),\\n\\t.WDATA_A2_i(WDATA_A2_i),\\n\\t.REN_A2_i(REN_A1_i),\\n\\t.RDATA_A2_o(RDATA_A2_o),\\n\\n\\t.CLK_B1_i(PORT_B_CLK),\\n\\t.ADDR_B1_i(PORT_B_ADDR),\\n\\t.WEN_B1_i(WEN_B1_i),\\n\\t.BE_B1_i(BE_B1_i),\\n\\t.WDATA_B1_i(WDATA_B1_i),\\n\\t.REN_B1_i(REN_B1_i),\\n\\t.RDATA_B1_o(RDATA_B1_o),\\n\\n\\t.CLK_B2_i(PORT_B_CLK),\\n\\t.ADDR_B2_i(PORT_B_ADDR[13:0]),\\n\\t.WEN_B2_i(WEN_B1_i),\\n\\t.BE_B2_i(BE_B2_i),\\n\\t.WDATA_B2_i(WDATA_B2_i),\\n\\t.REN_B2_i(REN_B1_i),\\n\\t.RDATA_B2_o(RDATA_B2_o),\\n\\n\\t.FLUSH1_i(1'b0),\\n\\t.FLUSH2_i(1'b0)\\n);\\n\\nendmodule\\n\\nmodule DPRAM_18K_BLK (\\n\\t\\tPORT_A_CLK_i,\\n\\t\\tPORT_A_WEN_i,\\n\\t\\tPORT_A_WR_BE_i,\\n\\t\\tPORT_A_REN_i,\\n\\t\\tPORT_A_ADDR_i,\\n\\t\\tPORT_A_WR_DATA_i,\\n\\t\\tPORT_A_RD_DATA_o,\\n\\n\\t\\tPORT_B_CLK_i,\\n\\t\\tPORT_B_WEN_i,\\n\\t\\tPORT_B_WR_BE_i,\\n\\t\\tPORT_B_REN_i,\\n\\t\\tPORT_B_ADDR_i,\\n\\t\\tPORT_B_WR_DATA_i,\\n\\t\\tPORT_B_RD_DATA_o\\n);\\n\\nparameter PORT_A_AWIDTH = 10;\\nparameter PORT_A_DWIDTH = 36;\\nparameter PORT_A_WR_BE_WIDTH = 4;\\n\\nparameter PORT_B_AWIDTH = 10;\\nparameter PORT_B_DWIDTH = 36;\\nparameter PORT_B_WR_BE_WIDTH = 4;\\n\\ninput PORT_A_CLK_i;\\ninput [PORT_A_AWIDTH-1:0] PORT_A_ADDR_i;\\ninput [PORT_A_DWIDTH-1:0] PORT_A_WR_DATA_i;\\ninput PORT_A_WEN_i;\\ninput [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE_i;\\ninput PORT_A_REN_i;\\noutput [PORT_A_DWIDTH-1:0] PORT_A_RD_DATA_o;\\n\\ninput PORT_B_CLK_i;\\ninput [PORT_B_AWIDTH-1:0] PORT_B_ADDR_i;\\ninput [PORT_B_DWIDTH-1:0] PORT_B_WR_DATA_i;\\ninput PORT_B_WEN_i;\\ninput [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE_i;\\ninput PORT_B_REN_i;\\noutput [PORT_B_DWIDTH-1:0] PORT_B_RD_DATA_o;\\n\\n\\n(* is_inferred = 0 *)\\n(* is_split = 0 *)\\n(* is_fifo = 0 *)\\nBRAM2x18_dP #(\\n\\t.PORT_A1_AWIDTH(PORT_A_AWIDTH),\\n\\t.PORT_A1_DWIDTH(PORT_A_DWIDTH),\\n\\t.PORT_A1_WR_BE_WIDTH(PORT_A_WR_BE_WIDTH),\\n\\t.PORT_B1_AWIDTH(PORT_B_AWIDTH),\\n\\t.PORT_B1_DWIDTH(PORT_B_DWIDTH),\\n\\t.PORT_B1_WR_BE_WIDTH(PORT_B_WR_BE_WIDTH),\\n\\t.PORT_A2_AWIDTH(),\\n\\t.PORT_A2_DWIDTH(),\\n\\t.PORT_A2_WR_BE_WIDTH(),\\n\\t.PORT_B2_AWIDTH(),\\n\\t.PORT_B2_DWIDTH(),\\n\\t.PORT_B2_WR_BE_WIDTH()\\n) U1 (\\n\\t\\t.PORT_A1_CLK_i(PORT_A_CLK_i),\\n\\t\\t.PORT_A1_WEN_i(PORT_A_WEN_i),\\n\\t\\t.PORT_A1_WR_BE_i(PORT_A_WR_BE_i),\\n\\t\\t.PORT_A1_REN_i(PORT_A_REN_i),\\n\\t\\t.PORT_A1_ADDR_i(PORT_A_ADDR_i),\\n\\t\\t.PORT_A1_WR_DATA_i(PORT_A_WR_DATA_i),\\n\\t\\t.PORT_A1_RD_DATA_o(PORT_A_RD_DATA_o),\\n\\n\\t\\t.PORT_B1_CLK_i(PORT_B_CLK_i),\\n\\t\\t.PORT_B1_WEN_i(PORT_B_WEN_i),\\n\\t\\t.PORT_B1_WR_BE_i(PORT_B_WR_BE_i),\\n\\t\\t.PORT_B1_REN_i(PORT_B_REN_i),\\n\\t\\t.PORT_B1_ADDR_i(PORT_B_ADDR_i),\\n\\t\\t.PORT_B1_WR_DATA_i(PORT_B_WR_DATA_i),\\n\\t\\t.PORT_B1_RD_DATA_o(PORT_B_RD_DATA_o),\\n\\n\\t\\t.PORT_A2_CLK_i(1'b0),\\n\\t\\t.PORT_A2_WEN_i(1'b0),\\n\\t\\t.PORT_A2_WR_BE_i(2'b00),\\n\\t\\t.PORT_A2_REN_i(1'b0),\\n\\t\\t.PORT_A2_ADDR_i(14'h0),\\n\\t\\t.PORT_A2_WR_DATA_i(18'h0),\\n\\t\\t.PORT_A2_RD_DATA_o(),\\n\\n\\t\\t.PORT_B2_CLK_i(1'b0),\\n\\t\\t.PORT_B2_WEN_i(1'b0),\\n\\t\\t.PORT_B2_WR_BE_i(2'b00),\\n\\t\\t.PORT_B2_REN_i(1'b0),\\n\\t\\t.PORT_B2_ADDR_i(14'h0),\\n\\t\\t.PORT_B2_WR_DATA_i(18'h0),\\n\\t\\t.PORT_B2_RD_DATA_o()\\n);\\n\\nendmodule\\n\\n\\nmodule DPRAM_18K_X2_BLK (\\n\\t\\tPORT_A1_CLK_i,\\n\\t\\tPORT_A1_WEN_i,\\n\\t\\tPORT_A1_WR_BE_i,\\n\\t\\tPORT_A1_REN_i,\\n\\t\\tPORT_A1_ADDR_i,\\n\\t\\tPORT_A1_WR_DATA_i,\\n\\t\\tPORT_A1_RD_DATA_o,\\n\\n\\t\\tPORT_B1_CLK_i,\\n\\t\\tPORT_B1_WEN_i,\\n\\t\\tPORT_B1_WR_BE_i,\\n\\t\\tPORT_B1_REN_i,\\n\\t\\tPORT_B1_ADDR_i,\\n\\t\\tPORT_B1_WR_DATA_i,\\n\\t\\tPORT_B1_RD_DATA_o,\\n\\n\\t\\tPORT_A2_CLK_i,\\n\\t\\tPORT_A2_WEN_i,\\n\\t\\tPORT_A2_WR_BE_i,\\n\\t\\tPORT_A2_REN_i,\\n\\t\\tPORT_A2_ADDR_i,\\n\\t\\tPORT_A2_WR_DATA_i,\\n\\t\\tPORT_A2_RD_DATA_o,\\n\\n\\t\\tPORT_B2_CLK_i,\\n\\t\\tPORT_B2_WEN_i,\\n\\t\\tPORT_B2_WR_BE_i,\\n\\t\\tPORT_B2_REN_i,\\n\\t\\tPORT_B2_ADDR_i,\\n\\t\\tPORT_B2_WR_DATA_i,\\n\\t\\tPORT_B2_RD_DATA_o\\n);\\n\\nparameter PORT_A1_AWIDTH = 10;\\nparameter PORT_A1_DWIDTH = 18;\\nparameter PORT_A1_WR_BE_WIDTH = 2;\\n\\nparameter PORT_B1_AWIDTH = 10;\\nparameter PORT_B1_DWIDTH = 18;\\nparameter PORT_B1_WR_BE_WIDTH = 2;\\n\\nparameter PORT_A2_AWIDTH = 10;\\nparameter PORT_A2_DWIDTH = 18;\\nparameter PORT_A2_WR_BE_WIDTH = 2;\\n\\nparameter PORT_B2_AWIDTH = 10;\\nparameter PORT_B2_DWIDTH = 18;\\nparameter PORT_B2_WR_BE_WIDTH = 2;\\n\\n\\ninput PORT_A1_CLK_i;\\ninput [PORT_A1_AWIDTH-1:0] PORT_A1_ADDR_i;\\ninput [PORT_A1_DWIDTH-1:0] PORT_A1_WR_DATA_i;\\ninput PORT_A1_WEN_i;\\ninput [PORT_A1_WR_BE_WIDTH-1:0] PORT_A1_WR_BE_i;\\ninput PORT_A1_REN_i;\\noutput [PORT_A1_DWIDTH-1:0] PORT_A1_RD_DATA_o;\\n\\ninput PORT_B1_CLK_i;\\ninput [PORT_B1_AWIDTH-1:0] PORT_B1_ADDR_i;\\ninput [PORT_B1_DWIDTH-1:0] PORT_B1_WR_DATA_i;\\ninput PORT_B1_WEN_i;\\ninput [PORT_B1_WR_BE_WIDTH-1:0] PORT_B1_WR_BE_i;\\ninput PORT_B1_REN_i;\\noutput [PORT_B1_DWIDTH-1:0] PORT_B1_RD_DATA_o;\\n\\ninput PORT_A2_CLK_i;\\ninput [PORT_A2_AWIDTH-1:0] PORT_A2_ADDR_i;\\ninput [PORT_A2_DWIDTH-1:0] PORT_A2_WR_DATA_i;\\ninput PORT_A2_WEN_i;\\ninput [PORT_A2_WR_BE_WIDTH-1:0] PORT_A2_WR_BE_i;\\ninput PORT_A2_REN_i;\\noutput [PORT_A2_DWIDTH-1:0] PORT_A2_RD_DATA_o;\\n\\ninput PORT_B2_CLK_i;\\ninput [PORT_B2_AWIDTH-1:0] PORT_B2_ADDR_i;\\ninput [PORT_B2_DWIDTH-1:0] PORT_B2_WR_DATA_i;\\ninput PORT_B2_WEN_i;\\ninput [PORT_B2_WR_BE_WIDTH-1:0] PORT_B2_WR_BE_i;\\ninput PORT_B2_REN_i;\\noutput [PORT_B2_DWIDTH-1:0] PORT_B2_RD_DATA_o;\\n\\n\\n// Fixed mode settings\\nlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\nlocalparam [ 0:0] FMODE1_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\nlocalparam [11:0] UPAE1_i       = 12'd10;\\nlocalparam [11:0] UPAF1_i       = 12'd10;\\n\\nlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\nlocalparam [ 0:0] FMODE2_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\nlocalparam [10:0] UPAE2_i       = 11'd10;\\nlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n// Width mode function\\nfunction [2:0] mode;\\ninput integer width;\\ncase (width)\\n1: mode = 3'b101;\\n2: mode = 3'b110;\\n4: mode = 3'b100;\\n8,9: mode = 3'b001;\\n16, 18: mode = 3'b010;\\n32, 36: mode = 3'b011;\\ndefault: mode = 3'b000;\\nendcase\\nendfunction\\n\\nfunction integer rwmode;\\ninput integer rwwidth;\\ncase (rwwidth)\\n1: rwmode = 1;\\n2: rwmode = 2;\\n4: rwmode = 4;\\n8,9: rwmode = 9;\\n16, 18: rwmode = 18;\\ndefault: rwmode = 18;\\nendcase\\nendfunction\\n\\nwire REN_A1_i;\\nwire REN_A2_i;\\n\\nwire REN_B1_i;\\nwire REN_B2_i;\\n\\nwire WEN_A1_i;\\nwire WEN_A2_i;\\n\\nwire WEN_B1_i;\\nwire WEN_B2_i;\\n\\nwire [1:0] BE_A1_i;\\nwire [1:0] BE_A2_i;\\n\\nwire [1:0] BE_B1_i;\\nwire [1:0] BE_B2_i;\\n\\nwire [14:0] ADDR_A1_i;\\nwire [13:0] ADDR_A2_i;\\n\\nwire [14:0] ADDR_B1_i;\\nwire [13:0] ADDR_B2_i;\\n\\nwire [17:0] WDATA_A1_i;\\nwire [17:0] WDATA_A2_i;\\n\\nwire [17:0] WDATA_B1_i;\\nwire [17:0] WDATA_B2_i;\\n\\nwire [17:0] RDATA_A1_o;\\nwire [17:0] RDATA_A2_o;\\n\\nwire [17:0] RDATA_B1_o;\\nwire [17:0] RDATA_B2_o;\\n\\nwire [1:0] PORT_A1_WR_BE;\\nwire [1:0] PORT_B1_WR_BE;\\n\\nwire [1:0] PORT_A2_WR_BE;\\nwire [1:0] PORT_B2_WR_BE;\\n\\nwire [17:0] PORT_B1_WDATA;\\nwire [17:0] PORT_B1_RDATA;\\nwire [17:0] PORT_A1_WDATA;\\nwire [17:0] PORT_A1_RDATA;\\n\\nwire [17:0] PORT_B2_WDATA;\\nwire [17:0] PORT_B2_RDATA;\\nwire [17:0] PORT_A2_WDATA;\\nwire [17:0] PORT_A2_RDATA;\\n\\nwire [13:0] PORT_A1_ADDR_INT;\\nwire [13:0] PORT_B1_ADDR_INT;\\n\\nwire [13:0] PORT_A2_ADDR_INT;\\nwire [13:0] PORT_B2_ADDR_INT;\\n\\nwire [13:0] PORT_A1_ADDR;\\nwire [13:0] PORT_B1_ADDR;\\n\\nwire [13:0] PORT_A2_ADDR;\\nwire [13:0] PORT_B2_ADDR;\\n\\nwire PORT_A1_CLK;\\nwire PORT_B1_CLK;\\n\\nwire PORT_A2_CLK;\\nwire PORT_B2_CLK;\\n\\n// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)\\nlocalparam [ 2:0] RMODE_A1_i    = mode(PORT_A1_DWIDTH);\\nlocalparam [ 2:0] WMODE_A1_i    = mode(PORT_A1_DWIDTH);\\nlocalparam [ 2:0] RMODE_A2_i    = mode(PORT_A2_DWIDTH);\\nlocalparam [ 2:0] WMODE_A2_i    = mode(PORT_A2_DWIDTH);\\n\\nlocalparam [ 2:0] RMODE_B1_i    = mode(PORT_B1_DWIDTH);\\nlocalparam [ 2:0] WMODE_B1_i    = mode(PORT_B1_DWIDTH);\\nlocalparam [ 2:0] RMODE_B2_i    = mode(PORT_B2_DWIDTH);\\nlocalparam [ 2:0] WMODE_B2_i    = mode(PORT_B2_DWIDTH);\\n\\nlocalparam PORT_A1_WRWIDTH = rwmode(PORT_A1_DWIDTH);\\nlocalparam PORT_B1_WRWIDTH = rwmode(PORT_B1_DWIDTH);\\nlocalparam PORT_A2_WRWIDTH = rwmode(PORT_A2_DWIDTH);\\nlocalparam PORT_B2_WRWIDTH = rwmode(PORT_B2_DWIDTH);\\n\\nassign PORT_A1_CLK = PORT_A1_CLK_i;\\nassign PORT_B1_CLK = PORT_B1_CLK_i;\\n\\nassign PORT_A2_CLK = PORT_A2_CLK_i;\\nassign PORT_B2_CLK = PORT_B2_CLK_i;\\n\\ngenerate\\n\\tif (PORT_A1_AWIDTH == 14) begin\\n\\t\\tassign PORT_A1_ADDR_INT = PORT_A1_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_A1_ADDR_INT[13:PORT_A1_AWIDTH] = 0;\\n\\t\\tassign PORT_A1_ADDR_INT[PORT_A1_AWIDTH-1:0] = PORT_A1_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_A1_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (PORT_B1_AWIDTH == 14) begin\\n\\t\\tassign PORT_B1_ADDR_INT = PORT_B1_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_B1_ADDR_INT[13:PORT_B1_AWIDTH] = 0;\\n\\t\\tassign PORT_B1_ADDR_INT[PORT_B1_AWIDTH-1:0] = PORT_B1_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_B1_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (PORT_A2_AWIDTH == 14) begin\\n\\t\\tassign PORT_A2_ADDR_INT = PORT_A2_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_A2_ADDR_INT[13:PORT_A2_AWIDTH] = 0;\\n\\t\\tassign PORT_A2_ADDR_INT[PORT_A2_AWIDTH-1:0] = PORT_A2_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_A2_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (PORT_B2_AWIDTH == 14) begin\\n\\t\\tassign PORT_B2_ADDR_INT = PORT_B2_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_B2_ADDR_INT[13:PORT_B2_AWIDTH] = 0;\\n\\t\\tassign PORT_B2_ADDR_INT[PORT_B2_AWIDTH-1:0] = PORT_B2_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_B2_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT;\\n\\tend\\nendcase\\n\\ncase (PORT_A1_WR_BE_WIDTH)\\n\\t2: begin\\n\\t\\tassign PORT_A1_WR_BE = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A1_WR_BE[1:PORT_A1_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_A1_WR_BE[PORT_A1_WR_BE_WIDTH-1 :0] = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\ncase (PORT_B1_WR_BE_WIDTH)\\n\\t2: begin\\n\\t\\tassign PORT_B1_WR_BE = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B1_WR_BE[1:PORT_B1_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_B1_WR_BE[PORT_B1_WR_BE_WIDTH-1 :0] = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\ncase (PORT_A2_WR_BE_WIDTH)\\n\\t2: begin\\n\\t\\tassign PORT_A2_WR_BE = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A2_WR_BE[1:PORT_A2_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_A2_WR_BE[PORT_A2_WR_BE_WIDTH-1 :0] = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\ncase (PORT_B2_WR_BE_WIDTH)\\n\\t2: begin\\n\\t\\tassign PORT_B2_WR_BE = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B2_WR_BE[1:PORT_B2_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_B2_WR_BE[PORT_B2_WR_BE_WIDTH-1 :0] = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\nassign REN_A1_i = PORT_A1_REN_i;\\nassign WEN_A1_i = PORT_A1_WEN_i;\\nassign BE_A1_i  = PORT_A1_WR_BE;\\n\\nassign REN_A2_i = PORT_A2_REN_i;\\nassign WEN_A2_i = PORT_A2_WEN_i;\\nassign BE_A2_i  = PORT_A2_WR_BE;\\n\\nassign REN_B1_i = PORT_B1_REN_i;\\nassign WEN_B1_i = PORT_B1_WEN_i;\\nassign BE_B1_i  = PORT_B1_WR_BE;\\n\\nassign REN_B2_i = PORT_B2_REN_i;\\nassign WEN_B2_i = PORT_B2_WEN_i;\\nassign BE_B2_i  = PORT_B2_WR_BE;\\n\\ngenerate\\n\\tif (PORT_A1_DWIDTH == 18) begin\\n\\t\\tassign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];\\n\\tend else if (PORT_A1_DWIDTH == 9) begin\\n\\t\\tassign PORT_A1_WDATA = {1'b0, PORT_A1_WR_DATA_i[8], 8'h0, PORT_A1_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A1_WDATA[17:PORT_A1_DWIDTH] = 0;\\n\\t\\tassign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A1_i = PORT_A1_WDATA;\\n\\ngenerate\\n\\tif (PORT_A2_DWIDTH == 18) begin\\n\\t\\tassign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];\\n\\tend else if (PORT_A2_DWIDTH == 9) begin\\n\\t\\tassign PORT_A2_WDATA = {1'b0, PORT_A2_WR_DATA_i[8], 8'h0, PORT_A2_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A2_WDATA[17:PORT_A2_DWIDTH] = 0;\\n\\t\\tassign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A2_i = PORT_A2_WDATA;\\n\\ngenerate\\n\\tif (PORT_A1_DWIDTH == 9) begin\\n\\t\\tassign PORT_A1_RDATA = { 9'h0, RDATA_A1_o[16], RDATA_A1_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A1_RDATA = RDATA_A1_o;\\n\\tend\\nendgenerate\\n\\nassign PORT_A1_RD_DATA_o = PORT_A1_RDATA[PORT_A1_DWIDTH-1:0];\\n\\ngenerate\\n\\tif (PORT_A2_DWIDTH == 9) begin\\n\\t\\tassign PORT_A2_RDATA = { 9'h0, RDATA_A2_o[16], RDATA_A2_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A2_RDATA = RDATA_A2_o;\\n\\tend\\nendgenerate\\n\\nassign PORT_A2_RD_DATA_o = PORT_A2_RDATA[PORT_A2_DWIDTH-1:0];\\n\\ngenerate\\n\\tif (PORT_B1_DWIDTH == 18) begin\\n\\t\\tassign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];\\n\\tend else if (PORT_B1_DWIDTH == 9) begin\\n\\t\\tassign PORT_B1_WDATA = {1'b0, PORT_B1_WR_DATA_i[8], 8'h0, PORT_B1_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B1_WDATA[17:PORT_B1_DWIDTH] = 0;\\n\\t\\tassign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_B1_i = PORT_B1_WDATA;\\n\\ngenerate\\n\\tif (PORT_B2_DWIDTH == 18) begin\\n\\t\\tassign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];\\n\\tend else if (PORT_B2_DWIDTH == 9) begin\\n\\t\\tassign PORT_B2_WDATA = {1'b0, PORT_B2_WR_DATA_i[8], 8'h0, PORT_B2_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B2_WDATA[17:PORT_B2_DWIDTH] = 0;\\n\\t\\tassign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_B2_i = PORT_B2_WDATA;\\n\\ngenerate\\n\\tif (PORT_B1_DWIDTH == 9) begin\\n\\t\\tassign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B1_RDATA = RDATA_B1_o;\\n\\tend\\nendgenerate\\n\\nassign PORT_B1_RD_DATA_o = PORT_B1_RDATA[PORT_B1_DWIDTH-1:0];\\n\\ngenerate\\n\\tif (PORT_B2_DWIDTH == 9) begin\\n\\t\\tassign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B2_RDATA = RDATA_B2_o;\\n\\tend\\nendgenerate\\n\\nassign PORT_B2_RD_DATA_o = PORT_B2_RDATA[PORT_B2_DWIDTH-1:0];\\n\\ndefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n};\\n\\n(* is_inferred = 0 *)\\n(* is_split = 1 *)\\n(* is_fifo = 0 *)\\n(* port_a1_dwidth = PORT_A1_WRWIDTH *)\\n(* port_a2_dwidth = PORT_A2_WRWIDTH *)\\n(* port_b1_dwidth = PORT_B1_WRWIDTH *)\\n(* port_b2_dwidth = PORT_B2_WRWIDTH *)\\nTDP36K _TECHMAP_REPLACE_ (\\n\\t.RESET_ni(1'b1),\\n\\n\\t.CLK_A1_i(PORT_A1_CLK),\\n\\t.ADDR_A1_i({1'b0,PORT_A1_ADDR}),\\n\\t.WEN_A1_i(WEN_A1_i),\\n\\t.BE_A1_i(BE_A1_i),\\n\\t.WDATA_A1_i(WDATA_A1_i),\\n\\t.REN_A1_i(REN_A1_i),\\n\\t.RDATA_A1_o(RDATA_A1_o),\\n\\n\\t.CLK_A2_i(PORT_A2_CLK),\\n\\t.ADDR_A2_i(PORT_A2_ADDR),\\n\\t.WEN_A2_i(WEN_A2_i),\\n\\t.BE_A2_i(BE_A2_i),\\n\\t.WDATA_A2_i(WDATA_A2_i),\\n\\t.REN_A2_i(REN_A2_i),\\n\\t.RDATA_A2_o(RDATA_A2_o),\\n\\n\\t.CLK_B1_i(PORT_B1_CLK),\\n\\t.ADDR_B1_i({1'b0,PORT_B1_ADDR}),\\n\\t.WEN_B1_i(WEN_B1_i),\\n\\t.BE_B1_i(BE_B1_i),\\n\\t.WDATA_B1_i(WDATA_B1_i),\\n\\t.REN_B1_i(REN_B1_i),\\n\\t.RDATA_B1_o(RDATA_B1_o),\\n\\n\\t.CLK_B2_i(PORT_B2_CLK),\\n\\t.ADDR_B2_i(PORT_B2_ADDR),\\n\\t.WEN_B2_i(WEN_B2_i),\\n\\t.BE_B2_i(BE_B2_i),\\n\\t.WDATA_B2_i(WDATA_B2_i),\\n\\t.REN_B2_i(REN_B2_i),\\n\\t.RDATA_B2_o(RDATA_B2_o),\\n\\n\\t.FLUSH1_i(1'b0),\\n\\t.FLUSH2_i(1'b0)\\n);\\n\\nendmodule\\n\\nmodule SFIFO_36K_BLK (\\n\\t\\tDIN,\\n\\t\\tPUSH,\\n\\t\\tPOP,\\n\\t\\tCLK,\\n\\t\\tAsync_Flush,\\n\\t\\tOverrun_Error,\\n\\t\\tFull_Watermark,\\n\\t\\tAlmost_Full,\\n\\t\\tFull,\\n\\t\\tUnderrun_Error,\\n\\t\\tEmpty_Watermark,\\n\\t\\tAlmost_Empty,\\n\\t\\tEmpty,\\n\\t\\tDOUT\\n);\\n\\n\\tparameter WR_DATA_WIDTH = 36;\\n\\tparameter RD_DATA_WIDTH = 36;\\n\\tparameter UPAE_DBITS = 12'd10;\\n\\tparameter UPAF_DBITS = 12'd10;\\n\\n\\tinput wire CLK;\\n\\tinput wire PUSH, POP;\\n\\tinput wire [WR_DATA_WIDTH-1:0] DIN;\\n\\tinput wire Async_Flush;\\n\\toutput wire [RD_DATA_WIDTH-1:0] DOUT;\\n\\toutput wire Almost_Full, Almost_Empty;\\n\\toutput wire Full, Empty;\\n\\toutput wire Full_Watermark, Empty_Watermark;\\n\\toutput wire Overrun_Error, Underrun_Error;\\n\\n\\t// Fixed mode settings\\n\\tlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd1;\\n\\tlocalparam [ 0:0] FMODE1_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\n\\tlocalparam [11:0] UPAE1_i       = UPAE_DBITS;\\n\\tlocalparam [11:0] UPAF1_i       = UPAF_DBITS;\\n\\n\\tlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\n\\tlocalparam [ 0:0] FMODE2_i      = 1'd0;\\n\\tlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\n\\tlocalparam [10:0] UPAE2_i       = 11'd10;\\n\\tlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n\\t// Width mode function\\n\\tfunction [2:0] mode;\\n\\tinput integer width;\\n\\tcase (width)\\n\\t1: mode = 3'b101;\\n\\t2: mode = 3'b110;\\n\\t4: mode = 3'b100;\\n\\t8,9: mode = 3'b001;\\n\\t16, 18: mode = 3'b010;\\n\\t32, 36: mode = 3'b011;\\n\\tdefault: mode = 3'b000;\\n\\tendcase\\n\\tendfunction\\n\\n\\tfunction integer rwmode;\\n\\tinput integer rwwidth;\\n\\tcase (rwwidth)\\n\\t1: rwmode = 1;\\n\\t2: rwmode = 2;\\n\\t4: rwmode = 4;\\n\\t8,9: rwmode = 9;\\n\\t16, 18: rwmode = 18;\\n\\t32, 36: rwmode = 36;\\n\\tdefault: rwmode = 36;\\n\\tendcase\\n\\tendfunction\\n\\n\\twire [35:0] in_reg;\\n\\twire [35:0] out_reg;\\n\\twire [17:0] fifo_flags;\\n\\n\\twire [35:0] RD_DATA_INT;\\n\\n\\twire Push_Clk, Pop_Clk;\\n\\n\\tassign Push_Clk = CLK;\\n\\tassign Pop_Clk = CLK;\\n\\n\\tassign Overrun_Error = fifo_flags[0];\\n\\tassign Full_Watermark = fifo_flags[1];\\n\\tassign Almost_Full = fifo_flags[2];\\n\\tassign Full = fifo_flags[3];\\n\\tassign Underrun_Error = fifo_flags[4];\\n\\tassign Empty_Watermark = fifo_flags[5];\\n\\tassign Almost_Empty = fifo_flags[6];\\n\\tassign Empty = fifo_flags[7];\\n\\n\\tlocalparam [ 2:0] RMODE_A1_i    = mode(WR_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A1_i    = mode(WR_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_A2_i    = mode(WR_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A2_i    = mode(WR_DATA_WIDTH);\\n\\n\\tlocalparam [ 2:0] RMODE_B1_i    = mode(RD_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B1_i    = mode(RD_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_B2_i    = mode(RD_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B2_i    = mode(RD_DATA_WIDTH);\\n\\n\\tlocalparam PORT_A_WRWIDTH = rwmode(WR_DATA_WIDTH);\\n\\tlocalparam PORT_B_WRWIDTH = rwmode(RD_DATA_WIDTH);\\n\\n\\tgenerate\\n\\t\\tif (WR_DATA_WIDTH == 36) begin\\n\\t\\t\\tassign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];\\n\\t\\tend else if (WR_DATA_WIDTH > 18 && WR_DATA_WIDTH < 36) begin\\n\\t\\t\\tassign in_reg[WR_DATA_WIDTH+1:18] = DIN[WR_DATA_WIDTH-1:16];\\n\\t\\t\\tassign in_reg[17:0] = {2'b00,DIN[15:0]};\\n\\t\\tend else if (WR_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg[35:0] = {19'h0, DIN[8], 8'h0, DIN[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg[35:WR_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD_DATA_WIDTH == 36) begin\\n\\t\\t\\tassign RD_DATA_INT = out_reg;\\n\\t\\tend else if (RD_DATA_WIDTH > 18 && RD_DATA_WIDTH < 36) begin\\n\\t\\t\\tassign RD_DATA_INT  = {2'b00,out_reg[35:18],out_reg[15:0]};\\n\\t\\tend else if (RD_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign RD_DATA_INT = { 27'h0, out_reg[16], out_reg[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign RD_DATA_INT = {18'h0, out_reg[17:0]};\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tassign DOUT[RD_DATA_WIDTH-1 : 0] = RD_DATA_INT[RD_DATA_WIDTH-1 : 0];\\n\\n\\tdefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n\\t};\\n\\n\\t(* is_fifo = 1 *)\\n\\t(* sync_fifo = 1 *)\\n\\t(* is_inferred = 0 *)\\n\\t(* is_split = 0 *)\\n\\t(* port_a_dwidth = PORT_A_WRWIDTH *)\\n\\t(* port_b_dwidth = PORT_B_WRWIDTH *)\\n\\t TDP36K _TECHMAP_REPLACE_ (\\n\\t\\t.RESET_ni(1'b1),\\n\\t\\t.WDATA_A1_i(in_reg[17:0]),\\n\\t\\t.WDATA_A2_i(in_reg[35:18]),\\n\\t\\t.RDATA_A1_o(fifo_flags),\\n\\t\\t.RDATA_A2_o(),\\n\\t\\t.ADDR_A1_i(14'h0),\\n\\t\\t.ADDR_A2_i(14'h0),\\n\\t\\t.CLK_A1_i(Push_Clk),\\n\\t\\t.CLK_A2_i(1'b0),\\n\\t\\t.REN_A1_i(1'b1),\\n\\t\\t.REN_A2_i(1'b0),\\n\\t\\t.WEN_A1_i(PUSH),\\n\\t\\t.WEN_A2_i(1'b0),\\n\\t\\t.BE_A1_i(2'b11),\\n\\t\\t.BE_A2_i(2'b11),\\n\\n\\t\\t.WDATA_B1_i(18'h0),\\n\\t\\t.WDATA_B2_i(18'h0),\\n\\t\\t.RDATA_B1_o(out_reg[17:0]),\\n\\t\\t.RDATA_B2_o(out_reg[35:18]),\\n\\t\\t.ADDR_B1_i(14'h0),\\n\\t\\t.ADDR_B2_i(14'h0),\\n\\t\\t.CLK_B1_i(Pop_Clk),\\n\\t\\t.CLK_B2_i(1'b0),\\n\\t\\t.REN_B1_i(POP),\\n\\t\\t.REN_B2_i(1'b0),\\n\\t\\t.WEN_B1_i(1'b0),\\n\\t\\t.WEN_B2_i(1'b0),\\n\\t\\t.BE_B1_i(2'b11),\\n\\t\\t.BE_B2_i(2'b11),\\n\\n\\t\\t.FLUSH1_i(Async_Flush),\\n\\t\\t.FLUSH2_i(1'b0)\\n\\t);\\n\\n\\n\\nendmodule\\n\\nmodule AFIFO_36K_BLK (\\n\\t\\tDIN,\\n\\t\\tPUSH,\\n\\t\\tPOP,\\n\\t\\tPush_Clk,\\n\\t\\tPop_Clk,\\n\\t\\tAsync_Flush,\\n\\t\\tOverrun_Error,\\n\\t\\tFull_Watermark,\\n\\t\\tAlmost_Full,\\n\\t\\tFull,\\n\\t\\tUnderrun_Error,\\n\\t\\tEmpty_Watermark,\\n\\t\\tAlmost_Empty,\\n\\t\\tEmpty,\\n\\t\\tDOUT\\n);\\n\\n\\tparameter WR_DATA_WIDTH = 36;\\n\\tparameter RD_DATA_WIDTH = 36;\\n\\tparameter UPAE_DBITS = 12'd10;\\n\\tparameter UPAF_DBITS = 12'd10;\\n\\n\\tinput wire Push_Clk, Pop_Clk;\\n\\tinput wire PUSH, POP;\\n\\tinput wire [WR_DATA_WIDTH-1:0] DIN;\\n\\tinput wire Async_Flush;\\n\\toutput wire [RD_DATA_WIDTH-1:0] DOUT;\\n\\toutput wire Almost_Full, Almost_Empty;\\n\\toutput wire Full, Empty;\\n\\toutput wire Full_Watermark, Empty_Watermark;\\n\\toutput wire Overrun_Error, Underrun_Error;\\n\\n\\t// Fixed mode settings\\n\\tlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\n\\tlocalparam [ 0:0] FMODE1_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\n\\tlocalparam [11:0] UPAE1_i       = UPAE_DBITS;\\n\\tlocalparam [11:0] UPAF1_i       = UPAF_DBITS;\\n\\n\\tlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\n\\tlocalparam [ 0:0] FMODE2_i      = 1'd0;\\n\\tlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\n\\tlocalparam [10:0] UPAE2_i       = 11'd10;\\n\\tlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n\\t// Width mode function\\n\\tfunction [2:0] mode;\\n\\tinput integer width;\\n\\tcase (width)\\n\\t1: mode = 3'b101;\\n\\t2: mode = 3'b110;\\n\\t4: mode = 3'b100;\\n\\t8,9: mode = 3'b001;\\n\\t16, 18: mode = 3'b010;\\n\\t32, 36: mode = 3'b011;\\n\\tdefault: mode = 3'b000;\\n\\tendcase\\n\\tendfunction\\n\\n\\tfunction integer rwmode;\\n\\tinput integer rwwidth;\\n\\tcase (rwwidth)\\n\\t1: rwmode = 1;\\n\\t2: rwmode = 2;\\n\\t4: rwmode = 4;\\n\\t8,9: rwmode = 9;\\n\\t16, 18: rwmode = 18;\\n\\t32, 36: rwmode = 36;\\n\\tdefault: rwmode = 36;\\n\\tendcase\\n\\tendfunction\\n\\n\\twire [35:0] in_reg;\\n\\twire [35:0] out_reg;\\n\\twire [17:0] fifo_flags;\\n\\n\\twire [35:0] RD_DATA_INT;\\n\\twire [35:WR_DATA_WIDTH] WR_DATA_CMPL;\\n\\n\\tassign Overrun_Error = fifo_flags[0];\\n\\tassign Full_Watermark = fifo_flags[1];\\n\\tassign Almost_Full = fifo_flags[2];\\n\\tassign Full = fifo_flags[3];\\n\\tassign Underrun_Error = fifo_flags[4];\\n\\tassign Empty_Watermark = fifo_flags[5];\\n\\tassign Almost_Empty = fifo_flags[6];\\n\\tassign Empty = fifo_flags[7];\\n\\n\\tlocalparam [ 2:0] RMODE_A1_i    = mode(WR_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A1_i    = mode(WR_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_A2_i    = mode(WR_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A2_i    = mode(WR_DATA_WIDTH);\\n\\n\\tlocalparam [ 2:0] RMODE_B1_i    = mode(RD_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B1_i    = mode(RD_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_B2_i    = mode(RD_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B2_i    = mode(RD_DATA_WIDTH);\\n\\n\\tlocalparam PORT_A_WRWIDTH = rwmode(WR_DATA_WIDTH);\\n\\tlocalparam PORT_B_WRWIDTH = rwmode(RD_DATA_WIDTH);\\n\\n\\tgenerate\\n\\t\\tif (WR_DATA_WIDTH == 36) begin\\n\\t\\t\\tassign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];\\n\\t\\tend else if (WR_DATA_WIDTH > 18 && WR_DATA_WIDTH < 36) begin\\n\\t\\t\\tassign in_reg[WR_DATA_WIDTH+1:18] = DIN[WR_DATA_WIDTH-1:16];\\n\\t\\t\\tassign in_reg[17:0] = {2'b00,DIN[15:0]};\\n\\t\\tend else if (WR_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg[35:0] = {19'h0, DIN[8], 8'h0, DIN[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg[35:WR_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg[WR_DATA_WIDTH-1:0] = DIN[WR_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD_DATA_WIDTH == 36) begin\\n\\t\\t\\tassign RD_DATA_INT = out_reg;\\n\\t\\tend else if (RD_DATA_WIDTH > 18 && RD_DATA_WIDTH < 36) begin\\n\\t\\t\\tassign RD_DATA_INT  = {2'b00,out_reg[35:18],out_reg[15:0]};\\n\\t\\tend else if (RD_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign RD_DATA_INT = { 27'h0, out_reg[16], out_reg[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign RD_DATA_INT = {18'h0, out_reg[17:0]};\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tassign DOUT[RD_DATA_WIDTH-1 : 0] = RD_DATA_INT[RD_DATA_WIDTH-1 : 0];\\n\\n\\tdefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n\\t};\\n\\n\\t(* is_fifo = 1 *)\\n\\t(* sync_fifo = 0 *)\\n\\t(* is_inferred = 0 *)\\n\\t(* is_split = 0 *)\\n\\t(* port_a_dwidth = PORT_A_WRWIDTH *)\\n\\t(* port_b_dwidth = PORT_B_WRWIDTH *)\\n \\tTDP36K _TECHMAP_REPLACE_ (\\n\\t\\t.RESET_ni(1'b1),\\n\\t\\t.WDATA_A1_i(in_reg[17:0]),\\n\\t\\t.WDATA_A2_i(in_reg[35:18]),\\n\\t\\t.RDATA_A1_o(fifo_flags),\\n\\t\\t.RDATA_A2_o(),\\n\\t\\t.ADDR_A1_i(14'h0),\\n\\t\\t.ADDR_A2_i(14'h0),\\n\\t\\t.CLK_A1_i(Push_Clk),\\n\\t\\t.CLK_A2_i(1'b0),\\n\\t\\t.REN_A1_i(1'b1),\\n\\t\\t.REN_A2_i(1'b0),\\n\\t\\t.WEN_A1_i(PUSH),\\n\\t\\t.WEN_A2_i(1'b0),\\n\\t\\t.BE_A1_i(2'b11),\\n\\t\\t.BE_A2_i(2'b11),\\n\\n\\t\\t.WDATA_B1_i(18'h0),\\n\\t\\t.WDATA_B2_i(18'h0),\\n\\t\\t.RDATA_B1_o(out_reg[17:0]),\\n\\t\\t.RDATA_B2_o(out_reg[35:18]),\\n\\t\\t.ADDR_B1_i(14'h0),\\n\\t\\t.ADDR_B2_i(14'h0),\\n\\t\\t.CLK_B1_i(Pop_Clk),\\n\\t\\t.CLK_B2_i(1'b0),\\n\\t\\t.REN_B1_i(POP),\\n\\t\\t.REN_B2_i(1'b0),\\n\\t\\t.WEN_B1_i(1'b0),\\n\\t\\t.WEN_B2_i(1'b0),\\n\\t\\t.BE_B1_i(2'b11),\\n\\t\\t.BE_B2_i(2'b11),\\n\\n\\t\\t.FLUSH1_i(Async_Flush),\\n\\t\\t.FLUSH2_i(1'b0)\\n\\t);\\n\\n\\n\\nendmodule\\n\\nmodule SFIFO_18K_BLK (\\n\\t\\tDIN,\\n\\t\\tPUSH,\\n\\t\\tPOP,\\n\\t\\tCLK,\\n\\t\\tAsync_Flush,\\n\\t\\tOverrun_Error,\\n\\t\\tFull_Watermark,\\n\\t\\tAlmost_Full,\\n\\t\\tFull,\\n\\t\\tUnderrun_Error,\\n\\t\\tEmpty_Watermark,\\n\\t\\tAlmost_Empty,\\n\\t\\tEmpty,\\n\\t\\tDOUT\\n);\\n\\n\\tparameter WR_DATA_WIDTH = 18;\\n\\tparameter RD_DATA_WIDTH = 18;\\n\\tparameter UPAE_DBITS = 11'd10;\\n\\tparameter UPAF_DBITS = 11'd10;\\n\\n\\tinput wire CLK;\\n\\tinput wire PUSH, POP;\\n\\tinput wire [WR_DATA_WIDTH-1:0] DIN;\\n\\tinput wire Async_Flush;\\n\\toutput wire [RD_DATA_WIDTH-1:0] DOUT;\\n\\toutput wire Almost_Full, Almost_Empty;\\n\\toutput wire Full, Empty;\\n\\toutput wire Full_Watermark, Empty_Watermark;\\n\\toutput wire Overrun_Error, Underrun_Error;\\n\\n \\tBRAM2x18_SFIFO  #(\\n\\t\\t\\t.WR1_DATA_WIDTH(WR_DATA_WIDTH),\\n\\t\\t\\t.RD1_DATA_WIDTH(RD_DATA_WIDTH),\\n\\t\\t\\t.UPAE_DBITS1(UPAE_DBITS),\\n\\t\\t\\t.UPAF_DBITS1(UPAF_DBITS),\\n\\t\\t\\t.WR2_DATA_WIDTH(),\\n\\t\\t\\t.RD2_DATA_WIDTH(),\\n\\t\\t\\t.UPAE_DBITS2(),\\n\\t\\t\\t.UPAF_DBITS2()\\n\\t\\t\\t ) U1\\n\\t\\t\\t(\\n\\t\\t\\t.DIN1(DIN),\\n\\t\\t\\t.PUSH1(PUSH),\\n\\t\\t\\t.POP1(POP),\\n\\t\\t\\t.CLK1(CLK),\\n\\t\\t\\t.Async_Flush1(Async_Flush),\\n\\t\\t\\t.Overrun_Error1(Overrun_Error),\\n\\t\\t\\t.Full_Watermark1(Full_Watermark),\\n\\t\\t\\t.Almost_Full1(Almost_Full),\\n\\t\\t\\t.Full1(Full),\\n\\t\\t\\t.Underrun_Error1(Underrun_Error),\\n\\t\\t\\t.Empty_Watermark1(Empty_Watermark),\\n\\t\\t\\t.Almost_Empty1(Almost_Empty),\\n\\t\\t\\t.Empty1(Empty),\\n\\t\\t\\t.DOUT1(DOUT),\\n\\n\\t\\t\\t.DIN2(18'h0),\\n\\t\\t\\t.PUSH2(1'b0),\\n\\t\\t\\t.POP2(1'b0),\\n\\t\\t\\t.CLK2(1'b0),\\n\\t\\t\\t.Async_Flush2(1'b0),\\n\\t\\t\\t.Overrun_Error2(),\\n\\t\\t\\t.Full_Watermark2(),\\n\\t\\t\\t.Almost_Full2(),\\n\\t\\t\\t.Full2(),\\n\\t\\t\\t.Underrun_Error2(),\\n\\t\\t\\t.Empty_Watermark2(),\\n\\t\\t\\t.Almost_Empty2(),\\n\\t\\t\\t.Empty2(),\\n\\t\\t\\t.DOUT2()\\n\\t);\\n\\nendmodule\\n\\nmodule SFIFO_18K_X2_BLK (\\n\\t\\tDIN1,\\n\\t\\tPUSH1,\\n\\t\\tPOP1,\\n\\t\\tCLK1,\\n\\t\\tAsync_Flush1,\\n\\t\\tOverrun_Error1,\\n\\t\\tFull_Watermark1,\\n\\t\\tAlmost_Full1,\\n\\t\\tFull1,\\n\\t\\tUnderrun_Error1,\\n\\t\\tEmpty_Watermark1,\\n\\t\\tAlmost_Empty1,\\n\\t\\tEmpty1,\\n\\t\\tDOUT1,\\n\\n\\t\\tDIN2,\\n\\t\\tPUSH2,\\n\\t\\tPOP2,\\n\\t\\tCLK2,\\n\\t\\tAsync_Flush2,\\n\\t\\tOverrun_Error2,\\n\\t\\tFull_Watermark2,\\n\\t\\tAlmost_Full2,\\n\\t\\tFull2,\\n\\t\\tUnderrun_Error2,\\n\\t\\tEmpty_Watermark2,\\n\\t\\tAlmost_Empty2,\\n\\t\\tEmpty2,\\n\\t\\tDOUT2\\n);\\n\\n\\tparameter WR1_DATA_WIDTH = 18;\\n\\tparameter RD1_DATA_WIDTH = 18;\\n\\n\\tparameter WR2_DATA_WIDTH = 18;\\n\\tparameter RD2_DATA_WIDTH = 18;\\n\\n\\tparameter UPAE_DBITS1 = 12'd10;\\n\\tparameter UPAF_DBITS1 = 12'd10;\\n\\n\\tparameter UPAE_DBITS2 = 11'd10;\\n\\tparameter UPAF_DBITS2 = 11'd10;\\n\\n\\tinput CLK1;\\n\\tinput PUSH1, POP1;\\n\\tinput [WR1_DATA_WIDTH-1:0] DIN1;\\n\\tinput Async_Flush1;\\n\\toutput [RD1_DATA_WIDTH-1:0] DOUT1;\\n\\toutput Almost_Full1, Almost_Empty1;\\n\\toutput Full1, Empty1;\\n\\toutput Full_Watermark1, Empty_Watermark1;\\n\\toutput Overrun_Error1, Underrun_Error1;\\n\\n\\tinput CLK2;\\n\\tinput PUSH2, POP2;\\n\\tinput [WR2_DATA_WIDTH-1:0] DIN2;\\n\\tinput Async_Flush2;\\n\\toutput [RD2_DATA_WIDTH-1:0] DOUT2;\\n\\toutput Almost_Full2, Almost_Empty2;\\n\\toutput Full2, Empty2;\\n\\toutput Full_Watermark2, Empty_Watermark2;\\n\\toutput Overrun_Error2, Underrun_Error2;\\n\\n\\t// Fixed mode settings\\n\\tlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd1;\\n\\tlocalparam [ 0:0] FMODE1_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\n\\tlocalparam [11:0] UPAE1_i       = UPAE_DBITS1;\\n\\tlocalparam [11:0] UPAF1_i       = UPAF_DBITS1;\\n\\n\\tlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd1;\\n\\tlocalparam [ 0:0] FMODE2_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\n\\tlocalparam [10:0] UPAE2_i       = UPAE_DBITS2;\\n\\tlocalparam [10:0] UPAF2_i       = UPAF_DBITS2;\\n\\n\\t// Width mode function\\n\\tfunction [2:0] mode;\\n\\tinput integer width;\\n\\tcase (width)\\n\\t1: mode = 3'b101;\\n\\t2: mode = 3'b110;\\n\\t4: mode = 3'b100;\\n\\t8,9: mode = 3'b001;\\n\\t16, 18: mode = 3'b010;\\n\\t32, 36: mode = 3'b011;\\n\\tdefault: mode = 3'b000;\\n\\tendcase\\n\\tendfunction\\n\\n\\tfunction integer rwmode;\\n\\tinput integer rwwidth;\\n\\tcase (rwwidth)\\n\\t1: rwmode = 1;\\n\\t2: rwmode = 2;\\n\\t4: rwmode = 4;\\n\\t8,9: rwmode = 9;\\n\\t16, 18: rwmode = 18;\\n\\tdefault: rwmode = 18;\\n\\tendcase\\n\\tendfunction\\n\\n\\twire [17:0] in_reg1;\\n\\twire [17:0] out_reg1;\\n\\twire [17:0] fifo1_flags;\\n\\n\\twire [17:0] in_reg2;\\n\\twire [17:0] out_reg2;\\n\\twire [17:0] fifo2_flags;\\n\\n\\twire Push_Clk1, Pop_Clk1;\\n\\twire Push_Clk2, Pop_Clk2;\\n\\tassign Push_Clk1 = CLK1;\\n\\tassign Pop_Clk1 = CLK1;\\n\\tassign Push_Clk2 = CLK2;\\n\\tassign Pop_Clk2 = CLK2;\\n\\n\\tassign Overrun_Error1 = fifo1_flags[0];\\n\\tassign Full_Watermark1 = fifo1_flags[1];\\n\\tassign Almost_Full1 = fifo1_flags[2];\\n\\tassign Full1 = fifo1_flags[3];\\n\\tassign Underrun_Error1 = fifo1_flags[4];\\n\\tassign Empty_Watermark1 = fifo1_flags[5];\\n\\tassign Almost_Empty1 = fifo1_flags[6];\\n\\tassign Empty1 = fifo1_flags[7];\\n\\n\\tassign Overrun_Error2 = fifo2_flags[0];\\n\\tassign Full_Watermark2 = fifo2_flags[1];\\n\\tassign Almost_Full2 = fifo2_flags[2];\\n\\tassign Full2 = fifo2_flags[3];\\n\\tassign Underrun_Error2 = fifo2_flags[4];\\n\\tassign Empty_Watermark2 = fifo2_flags[5];\\n\\tassign Almost_Empty2 = fifo2_flags[6];\\n\\tassign Empty2 = fifo2_flags[7];\\n\\n\\tlocalparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\n\\tlocalparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\n\\tlocalparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);\\n\\tlocalparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);\\n\\tlocalparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);\\n\\tlocalparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);\\n\\n\\tgenerate\\n\\t\\tif (WR1_DATA_WIDTH == 18) begin\\n\\t\\t\\tassign in_reg1[17:0] = DIN1[17:0];\\n\\t\\tend else if (WR1_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg1[17:WR1_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD1_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (WR2_DATA_WIDTH == 18) begin\\n\\t\\t\\tassign in_reg2[17:0] = DIN2[17:0];\\n\\t\\tend else if (WR2_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg2[17:WR2_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD2_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tdefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n\\t};\\n\\n\\t(* is_fifo = 1 *)\\n\\t(* sync_fifo = 1 *)\\n\\t(* is_split = 1 *)\\n\\t(* is_inferred = 0 *)\\n\\t(* port_a1_dwidth = PORT_A1_WRWIDTH *)\\n\\t(* port_a2_dwidth = PORT_A2_WRWIDTH *)\\n\\t(* port_b1_dwidth = PORT_B1_WRWIDTH *)\\n\\t(* port_b2_dwidth = PORT_B2_WRWIDTH *)\\n \\tTDP36K _TECHMAP_REPLACE_ (\\n\\t\\t.RESET_ni(1'b1),\\n\\t\\t.WDATA_A1_i(in_reg1[17:0]),\\n\\t\\t.WDATA_A2_i(in_reg2[17:0]),\\n\\t\\t.RDATA_A1_o(fifo1_flags),\\n\\t\\t.RDATA_A2_o(fifo2_flags),\\n\\t\\t.ADDR_A1_i(14'h0),\\n\\t\\t.ADDR_A2_i(14'h0),\\n\\t\\t.CLK_A1_i(Push_Clk1),\\n\\t\\t.CLK_A2_i(Push_Clk2),\\n\\t\\t.REN_A1_i(1'b1),\\n\\t\\t.REN_A2_i(1'b1),\\n\\t\\t.WEN_A1_i(PUSH1),\\n\\t\\t.WEN_A2_i(PUSH2),\\n\\t\\t.BE_A1_i(2'b11),\\n\\t\\t.BE_A2_i(2'b11),\\n\\n\\t\\t.WDATA_B1_i(18'h0),\\n\\t\\t.WDATA_B2_i(18'h0),\\n\\t\\t.RDATA_B1_o(out_reg1[17:0]),\\n\\t\\t.RDATA_B2_o(out_reg2[17:0]),\\n\\t\\t.ADDR_B1_i(14'h0),\\n\\t\\t.ADDR_B2_i(14'h0),\\n\\t\\t.CLK_B1_i(Pop_Clk1),\\n\\t\\t.CLK_B2_i(Pop_Clk2),\\n\\t\\t.REN_B1_i(POP1),\\n\\t\\t.REN_B2_i(POP2),\\n\\t\\t.WEN_B1_i(1'b0),\\n\\t\\t.WEN_B2_i(1'b0),\\n\\t\\t.BE_B1_i(2'b11),\\n\\t\\t.BE_B2_i(2'b11),\\n\\n\\t\\t.FLUSH1_i(Async_Flush1),\\n\\t\\t.FLUSH2_i(Async_Flush2)\\n\\t);\\n\\nendmodule\\n\\nmodule AFIFO_18K_BLK (\\n\\t\\tDIN,\\n\\t\\tPUSH,\\n\\t\\tPOP,\\n\\t\\tPush_Clk,\\n\\t\\tPop_Clk,\\n\\t\\tAsync_Flush,\\n\\t\\tOverrun_Error,\\n\\t\\tFull_Watermark,\\n\\t\\tAlmost_Full,\\n\\t\\tFull,\\n\\t\\tUnderrun_Error,\\n\\t\\tEmpty_Watermark,\\n\\t\\tAlmost_Empty,\\n\\t\\tEmpty,\\n\\t\\tDOUT\\n);\\n\\n\\tparameter WR_DATA_WIDTH = 18;\\n\\tparameter RD_DATA_WIDTH = 18;\\n\\tparameter UPAE_DBITS = 11'd10;\\n\\tparameter UPAF_DBITS = 11'd10;\\n\\n\\tinput wire Push_Clk, Pop_Clk;\\n\\tinput wire PUSH, POP;\\n\\tinput wire [WR_DATA_WIDTH-1:0] DIN;\\n\\tinput wire Async_Flush;\\n\\toutput wire [RD_DATA_WIDTH-1:0] DOUT;\\n\\toutput wire Almost_Full, Almost_Empty;\\n\\toutput wire Full, Empty;\\n\\toutput wire Full_Watermark, Empty_Watermark;\\n\\toutput wire Overrun_Error, Underrun_Error;\\n\\n \\tBRAM2x18_AFIFO  #(\\n\\t\\t\\t.WR1_DATA_WIDTH(WR_DATA_WIDTH),\\n\\t\\t\\t.RD1_DATA_WIDTH(RD_DATA_WIDTH),\\n\\t\\t\\t.UPAE_DBITS1(UPAE_DBITS),\\n\\t\\t\\t.UPAF_DBITS1(UPAF_DBITS),\\n\\t\\t\\t.WR2_DATA_WIDTH(),\\n\\t\\t\\t.RD2_DATA_WIDTH(),\\n\\t\\t\\t.UPAE_DBITS2(),\\n\\t\\t\\t.UPAF_DBITS2()\\n\\t\\t\\t ) U1\\n\\t\\t\\t(\\n\\t\\t\\t.DIN1(DIN),\\n\\t\\t\\t.PUSH1(PUSH),\\n\\t\\t\\t.POP1(POP),\\n\\t\\t\\t.Push_Clk1(Push_Clk),\\n\\t\\t\\t.Pop_Clk1(Pop_Clk),\\n\\t\\t\\t.Async_Flush1(Async_Flush),\\n\\t\\t\\t.Overrun_Error1(Overrun_Error),\\n\\t\\t\\t.Full_Watermark1(Full_Watermark),\\n\\t\\t\\t.Almost_Full1(Almost_Full),\\n\\t\\t\\t.Full1(Full),\\n\\t\\t\\t.Underrun_Error1(Underrun_Error),\\n\\t\\t\\t.Empty_Watermark1(Empty_Watermark),\\n\\t\\t\\t.Almost_Empty1(Almost_Empty),\\n\\t\\t\\t.Empty1(Empty),\\n\\t\\t\\t.DOUT1(DOUT),\\n\\n\\t\\t\\t.DIN2(18'h0),\\n\\t\\t\\t.PUSH2(1'b0),\\n\\t\\t\\t.POP2(1'b0),\\n\\t\\t\\t.Push_Clk2(1'b0),\\n\\t\\t\\t.Pop_Clk2(1'b0),\\n\\t\\t\\t.Async_Flush2(1'b0),\\n\\t\\t\\t.Overrun_Error2(),\\n\\t\\t\\t.Full_Watermark2(),\\n\\t\\t\\t.Almost_Full2(),\\n\\t\\t\\t.Full2(),\\n\\t\\t\\t.Underrun_Error2(),\\n\\t\\t\\t.Empty_Watermark2(),\\n\\t\\t\\t.Almost_Empty2(),\\n\\t\\t\\t.Empty2(),\\n\\t\\t\\t.DOUT2()\\n\\t);\\n\\nendmodule\\n\\nmodule AFIFO_18K_X2_BLK (\\n\\t\\tDIN1,\\n\\t\\tPUSH1,\\n\\t\\tPOP1,\\n\\t\\tPush_Clk1,\\n\\tPop_Clk1,\\n\\t\\tAsync_Flush1,\\n\\t\\tOverrun_Error1,\\n\\t\\tFull_Watermark1,\\n\\t\\tAlmost_Full1,\\n\\t\\tFull1,\\n\\t\\tUnderrun_Error1,\\n\\t\\tEmpty_Watermark1,\\n\\t\\tAlmost_Empty1,\\n\\t\\tEmpty1,\\n\\t\\tDOUT1,\\n\\n\\t\\tDIN2,\\n\\t\\tPUSH2,\\n\\t\\tPOP2,\\n\\t\\tPush_Clk2,\\n\\tPop_Clk2,\\n\\t\\tAsync_Flush2,\\n\\t\\tOverrun_Error2,\\n\\t\\tFull_Watermark2,\\n\\t\\tAlmost_Full2,\\n\\t\\tFull2,\\n\\t\\tUnderrun_Error2,\\n\\t\\tEmpty_Watermark2,\\n\\t\\tAlmost_Empty2,\\n\\t\\tEmpty2,\\n\\t\\tDOUT2\\n);\\n\\n\\tparameter WR1_DATA_WIDTH = 18;\\n\\tparameter RD1_DATA_WIDTH = 18;\\n\\n\\tparameter WR2_DATA_WIDTH = 18;\\n\\tparameter RD2_DATA_WIDTH = 18;\\n\\n\\tparameter UPAE_DBITS1 = 12'd10;\\n\\tparameter UPAF_DBITS1 = 12'd10;\\n\\n\\tparameter UPAE_DBITS2 = 11'd10;\\n\\tparameter UPAF_DBITS2 = 11'd10;\\n\\n\\tinput Push_Clk1, Pop_Clk1;\\n\\tinput PUSH1, POP1;\\n\\tinput [WR1_DATA_WIDTH-1:0] DIN1;\\n\\tinput Async_Flush1;\\n\\toutput [RD1_DATA_WIDTH-1:0] DOUT1;\\n\\toutput Almost_Full1, Almost_Empty1;\\n\\toutput Full1, Empty1;\\n\\toutput Full_Watermark1, Empty_Watermark1;\\n\\toutput Overrun_Error1, Underrun_Error1;\\n\\n\\tinput Push_Clk2, Pop_Clk2;\\n\\tinput PUSH2, POP2;\\n\\tinput [WR2_DATA_WIDTH-1:0] DIN2;\\n\\tinput Async_Flush2;\\n\\toutput [RD2_DATA_WIDTH-1:0] DOUT2;\\n\\toutput Almost_Full2, Almost_Empty2;\\n\\toutput Full2, Empty2;\\n\\toutput Full_Watermark2, Empty_Watermark2;\\n\\toutput Overrun_Error2, Underrun_Error2;\\n\\n\\t// Fixed mode settings\\n\\tlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\n\\tlocalparam [ 0:0] FMODE1_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\n\\tlocalparam [11:0] UPAE1_i       = UPAE_DBITS1;\\n\\tlocalparam [11:0] UPAF1_i       = UPAF_DBITS1;\\n\\n\\tlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\n\\tlocalparam [ 0:0] FMODE2_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\n\\tlocalparam [10:0] UPAE2_i       = UPAE_DBITS2;\\n\\tlocalparam [10:0] UPAF2_i       = UPAF_DBITS2;\\n\\n\\t// Width mode function\\n\\tfunction [2:0] mode;\\n\\tinput integer width;\\n\\tcase (width)\\n\\t1: mode = 3'b101;\\n\\t2: mode = 3'b110;\\n\\t4: mode = 3'b100;\\n\\t8,9: mode = 3'b001;\\n\\t16, 18: mode = 3'b010;\\n\\t32, 36: mode = 3'b011;\\n\\tdefault: mode = 3'b000;\\n\\tendcase\\n\\tendfunction\\n\\n\\tfunction integer rwmode;\\n\\tinput integer rwwidth;\\n\\tcase (rwwidth)\\n\\t1: rwmode = 1;\\n\\t2: rwmode = 2;\\n\\t4: rwmode = 4;\\n\\t8,9: rwmode = 9;\\n\\t16, 18: rwmode = 18;\\n\\tdefault: rwmode = 18;\\n\\tendcase\\n\\tendfunction\\n\\n\\twire [17:0] in_reg1;\\n\\twire [17:0] out_reg1;\\n\\twire [17:0] fifo1_flags;\\n\\n\\twire [17:0] in_reg2;\\n\\twire [17:0] out_reg2;\\n\\twire [17:0] fifo2_flags;\\n\\n\\twire Push_Clk1, Pop_Clk1;\\n\\twire Push_Clk2, Pop_Clk2;\\n\\n\\tassign Overrun_Error1 = fifo1_flags[0];\\n\\tassign Full_Watermark1 = fifo1_flags[1];\\n\\tassign Almost_Full1 = fifo1_flags[2];\\n\\tassign Full1 = fifo1_flags[3];\\n\\tassign Underrun_Error1 = fifo1_flags[4];\\n\\tassign Empty_Watermark1 = fifo1_flags[5];\\n\\tassign Almost_Empty1 = fifo1_flags[6];\\n\\tassign Empty1 = fifo1_flags[7];\\n\\n\\tassign Overrun_Error2 = fifo2_flags[0];\\n\\tassign Full_Watermark2 = fifo2_flags[1];\\n\\tassign Almost_Full2 = fifo2_flags[2];\\n\\tassign Full2 = fifo2_flags[3];\\n\\tassign Underrun_Error2 = fifo2_flags[4];\\n\\tassign Empty_Watermark2 = fifo2_flags[5];\\n\\tassign Almost_Empty2 = fifo2_flags[6];\\n\\tassign Empty2 = fifo2_flags[7];\\n\\n\\tlocalparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\n\\tlocalparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\n\\tlocalparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);\\n\\tlocalparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);\\n\\tlocalparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);\\n\\tlocalparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);\\n\\n\\tgenerate\\n\\t\\tif (WR1_DATA_WIDTH == 18) begin\\n\\t\\t\\tassign in_reg1[17:0] = DIN1[17:0];\\n\\t\\tend else if (WR1_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg1[17:WR1_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD1_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (WR2_DATA_WIDTH == 18) begin\\n\\t\\t\\tassign in_reg2[17:0] = DIN2[17:0];\\n\\t\\tend else if (WR2_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg2[17:WR2_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD2_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tdefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n\\t};\\n\\n\\t(* is_fifo = 1 *)\\n\\t(* sync_fifo = 0 *)\\n\\t(* is_split = 1 *)\\n\\t(* is_inferred = 0 *)\\n\\t(* port_a1_dwidth = PORT_A1_WRWIDTH *)\\n\\t(* port_a2_dwidth = PORT_A2_WRWIDTH *)\\n\\t(* port_b1_dwidth = PORT_B1_WRWIDTH *)\\n\\t(* port_b2_dwidth = PORT_B2_WRWIDTH *)\\n \\tTDP36K _TECHMAP_REPLACE_ (\\n\\t\\t.RESET_ni(1'b1),\\n\\t\\t.WDATA_A1_i(in_reg1[17:0]),\\n\\t\\t.WDATA_A2_i(in_reg2[17:0]),\\n\\t\\t.RDATA_A1_o(fifo1_flags),\\n\\t\\t.RDATA_A2_o(fifo2_flags),\\n\\t\\t.ADDR_A1_i(14'h0),\\n\\t\\t.ADDR_A2_i(14'h0),\\n\\t\\t.CLK_A1_i(Push_Clk1),\\n\\t\\t.CLK_A2_i(Push_Clk2),\\n\\t\\t.REN_A1_i(1'b1),\\n\\t\\t.REN_A2_i(1'b1),\\n\\t\\t.WEN_A1_i(PUSH1),\\n\\t\\t.WEN_A2_i(PUSH2),\\n\\t\\t.BE_A1_i(2'b11),\\n\\t\\t.BE_A2_i(2'b11),\\n\\n\\t\\t.WDATA_B1_i(18'h0),\\n\\t\\t.WDATA_B2_i(18'h0),\\n\\t\\t.RDATA_B1_o(out_reg1[17:0]),\\n\\t\\t.RDATA_B2_o(out_reg2[17:0]),\\n\\t\\t.ADDR_B1_i(14'h0),\\n\\t\\t.ADDR_B2_i(14'h0),\\n\\t\\t.CLK_B1_i(Pop_Clk1),\\n\\t\\t.CLK_B2_i(Pop_Clk2),\\n\\t\\t.REN_B1_i(POP1),\\n\\t\\t.REN_B2_i(POP2),\\n\\t\\t.WEN_B1_i(1'b0),\\n\\t\\t.WEN_B2_i(1'b0),\\n\\t\\t.BE_B1_i(2'b11),\\n\\t\\t.BE_B2_i(2'b11),\\n\\n\\t\\t.FLUSH1_i(Async_Flush1),\\n\\t\\t.FLUSH2_i(Async_Flush2)\\n\\t);\\n\\nendmodule\\n\\nmodule BRAM2x18_SP (\\n\\t\\tRESET_ni,\\n\\n\\t\\tWEN1_i,\\n\\t\\tREN1_i,\\n\\t\\tWR1_CLK_i,\\n\\t\\tRD1_CLK_i,\\n\\t\\tWR1_BE_i,\\n\\t\\tWR1_ADDR_i,\\n\\t\\tRD1_ADDR_i,\\n\\t\\tWDATA1_i,\\n\\t\\tRDATA1_o,\\n\\n\\t\\tWEN2_i,\\n\\t\\tREN2_i,\\n\\t\\tWR2_CLK_i,\\n\\t\\tRD2_CLK_i,\\n\\t\\tWR2_BE_i,\\n\\t\\tWR2_ADDR_i,\\n\\t\\tRD2_ADDR_i,\\n\\t\\tWDATA2_i,\\n\\t\\tRDATA2_o\\n);\\n\\nparameter WR1_ADDR_WIDTH = 10;\\nparameter RD1_ADDR_WIDTH = 10;\\nparameter WR1_DATA_WIDTH = 18;\\nparameter RD1_DATA_WIDTH = 18;\\nparameter BE1_WIDTH = 2;\\n\\nparameter WR2_ADDR_WIDTH = 10;\\nparameter RD2_ADDR_WIDTH = 10;\\nparameter WR2_DATA_WIDTH = 18;\\nparameter RD2_DATA_WIDTH = 18;\\nparameter BE2_WIDTH = 2;\\n\\ninput wire RESET_ni;\\n\\ninput wire WEN1_i;\\ninput wire REN1_i;\\ninput wire WR1_CLK_i;\\ninput wire RD1_CLK_i;\\ninput wire [BE1_WIDTH-1:0] WR1_BE_i;\\ninput wire [WR1_ADDR_WIDTH-1 :0] WR1_ADDR_i;\\ninput wire [RD1_ADDR_WIDTH-1 :0] RD1_ADDR_i;\\ninput wire [WR1_DATA_WIDTH-1 :0] WDATA1_i;\\noutput wire [RD1_DATA_WIDTH-1 :0] RDATA1_o;\\n\\ninput wire WEN2_i;\\ninput wire REN2_i;\\ninput wire WR2_CLK_i;\\ninput wire RD2_CLK_i;\\ninput wire [BE2_WIDTH-1:0] WR2_BE_i;\\ninput wire [WR2_ADDR_WIDTH-1 :0] WR2_ADDR_i;\\ninput wire [RD2_ADDR_WIDTH-1 :0] RD2_ADDR_i;\\ninput wire [WR2_DATA_WIDTH-1 :0] WDATA2_i;\\noutput wire [RD2_DATA_WIDTH-1 :0] RDATA2_o;\\n\\n// Fixed mode settings\\nlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\nlocalparam [ 0:0] FMODE1_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\nlocalparam [11:0] UPAE1_i       = 12'd10;\\nlocalparam [11:0] UPAF1_i       = 12'd10;\\n\\nlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\nlocalparam [ 0:0] FMODE2_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\nlocalparam [10:0] UPAE2_i       = 11'd10;\\nlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n// Width mode function\\nfunction [2:0] mode;\\ninput integer width;\\ncase (width)\\n1: mode = 3'b101;\\n2: mode = 3'b110;\\n4: mode = 3'b100;\\n8,9: mode = 3'b001;\\n16, 18: mode = 3'b010;\\n32, 36: mode = 3'b011;\\ndefault: mode = 3'b000;\\nendcase\\nendfunction\\n\\nfunction integer rwmode;\\ninput integer rwwidth;\\ncase (rwwidth)\\n1: rwmode = 1;\\n2: rwmode = 2;\\n4: rwmode = 4;\\n8,9: rwmode = 9;\\n16, 18: rwmode = 18;\\ndefault: rwmode = 18;\\nendcase\\nendfunction\\n\\nwire REN_A1_i;\\nwire REN_A2_i;\\n\\nwire REN_B1_i;\\nwire REN_B2_i;\\n\\nwire WEN_A1_i;\\nwire WEN_A2_i;\\n\\nwire WEN_B1_i;\\nwire WEN_B2_i;\\n\\nwire [1:0] BE_A1_i;\\nwire [1:0] BE_A2_i;\\n\\nwire [1:0] BE_B1_i;\\nwire [1:0] BE_B2_i;\\n\\nwire [14:0] ADDR_A1_i;\\nwire [13:0] ADDR_A2_i;\\n\\nwire [14:0] ADDR_B1_i;\\nwire [13:0] ADDR_B2_i;\\n\\nwire [17:0] WDATA_A1_i;\\nwire [17:0] WDATA_A2_i;\\n\\nwire [17:0] WDATA_B1_i;\\nwire [17:0] WDATA_B2_i;\\n\\nwire [17:0] RDATA_A1_o;\\nwire [17:0] RDATA_A2_o;\\n\\nwire [17:0] RDATA_B1_o;\\nwire [17:0] RDATA_B2_o;\\n\\nwire [1:0] WR1_BE;\\nwire [1:0] WR2_BE;\\n\\nwire [17:0] PORT_B1_RDATA;\\nwire [17:0] PORT_A1_WDATA;\\n\\nwire [17:0] PORT_B2_RDATA;\\nwire [17:0] PORT_A2_WDATA;\\n\\nwire [13:0] WR1_ADDR_INT;\\nwire [13:0] RD1_ADDR_INT;\\n\\nwire [13:0] WR2_ADDR_INT;\\nwire [13:0] RD2_ADDR_INT;\\n\\nwire [13:0] PORT_A1_ADDR;\\nwire [13:0] PORT_B1_ADDR;\\n\\nwire [13:0] PORT_A2_ADDR;\\nwire [13:0] PORT_B2_ADDR;\\n\\n\\n// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)\\nlocalparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);\\nlocalparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\nlocalparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);\\nlocalparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);\\nlocalparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\nlocalparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);\\nlocalparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);\\nlocalparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);\\nlocalparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);\\n\\ngenerate\\n\\tif (WR1_ADDR_WIDTH == 14) begin\\n\\t\\tassign WR1_ADDR_INT = WR1_ADDR_i;\\n\\tend else begin\\n\\t\\tassign WR1_ADDR_INT[13:WR1_ADDR_WIDTH] = 0;\\n\\t\\tassign WR1_ADDR_INT[WR1_ADDR_WIDTH-1:0] = WR1_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (WR1_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A1_ADDR = WR1_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (RD1_ADDR_WIDTH == 14) begin\\n\\t\\tassign RD1_ADDR_INT = RD1_ADDR_i;\\n\\tend else begin\\n\\t\\tassign RD1_ADDR_INT[13:RD1_ADDR_WIDTH] = 0;\\n\\t\\tassign RD1_ADDR_INT[RD1_ADDR_WIDTH-1:0] = RD1_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (RD1_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B1_ADDR = RD1_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (WR2_ADDR_WIDTH == 14) begin\\n\\t\\tassign WR2_ADDR_INT = WR2_ADDR_i;\\n\\tend else begin\\n\\t\\tassign WR2_ADDR_INT[13:WR2_ADDR_WIDTH] = 0;\\n\\t\\tassign WR2_ADDR_INT[WR2_ADDR_WIDTH-1:0] = WR2_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (WR2_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A2_ADDR = WR2_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (RD2_ADDR_WIDTH == 14) begin\\n\\t\\tassign RD2_ADDR_INT = RD2_ADDR_i;\\n\\tend else begin\\n\\t\\tassign RD2_ADDR_INT[13:RD2_ADDR_WIDTH] = 0;\\n\\t\\tassign RD2_ADDR_INT[RD2_ADDR_WIDTH-1:0] = RD2_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (RD2_DATA_WIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B2_ADDR = RD2_ADDR_INT;\\n\\tend\\nendcase\\n\\ncase (BE1_WIDTH)\\n\\t2: begin\\n\\t\\tassign WR1_BE = WR1_BE_i[BE1_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign WR1_BE[1:BE1_WIDTH] = 0;\\n\\t\\tassign WR1_BE[BE1_WIDTH-1 :0] = WR1_BE_i[BE1_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\ncase (BE2_WIDTH)\\n\\t2: begin\\n\\t\\tassign WR2_BE = WR2_BE_i[BE2_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign WR2_BE[1:BE2_WIDTH] = 0;\\n\\t\\tassign WR2_BE[BE2_WIDTH-1 :0] = WR2_BE_i[BE2_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\nassign REN_A1_i = 1'b0;\\nassign WEN_A1_i = WEN1_i;\\nassign BE_A1_i = WR1_BE;\\nassign REN_A2_i = 1'b0;\\nassign WEN_A2_i = WEN2_i;\\nassign BE_A2_i = WR2_BE;\\n\\nassign REN_B1_i = REN1_i;\\nassign WEN_B1_i = 1'b0;\\nassign BE_B1_i = 4'h0;\\nassign REN_B2_i = REN2_i;\\nassign WEN_B2_i = 1'b0;\\nassign BE_B2_i = 4'h0;\\n\\ngenerate\\n\\tif (WR1_DATA_WIDTH == 18) begin\\n\\t\\tassign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];\\n\\tend else if (WR1_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_A1_WDATA = {1'b0, WDATA1_i[8], 8'h0, WDATA1_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A1_WDATA[17:WR1_DATA_WIDTH] = 0;\\n\\t\\tassign PORT_A1_WDATA[WR1_DATA_WIDTH-1:0] = WDATA1_i[WR1_DATA_WIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A1_i = PORT_A1_WDATA[17:0];\\nassign WDATA_B1_i = 18'h0;\\n\\ngenerate\\n\\tif (RD1_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B1_RDATA = RDATA_B1_o;\\n\\tend\\nendgenerate\\n\\nassign RDATA1_o = PORT_B1_RDATA[RD1_DATA_WIDTH-1:0];\\n\\ngenerate\\n\\tif (WR2_DATA_WIDTH == 18) begin\\n\\t\\tassign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];\\n\\tend else if (WR2_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_A2_WDATA = {1'b0, WDATA2_i[8], 8'h0, WDATA2_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A2_WDATA[17:WR2_DATA_WIDTH] = 0;\\n\\t\\tassign PORT_A2_WDATA[WR2_DATA_WIDTH-1:0] = WDATA2_i[WR2_DATA_WIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A2_i = PORT_A2_WDATA[17:0];\\nassign WDATA_B2_i = 18'h0;\\n\\ngenerate\\n\\tif (RD2_DATA_WIDTH == 9) begin\\n\\t\\tassign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B2_RDATA = RDATA_B2_o;\\n\\tend\\nendgenerate\\n\\nassign RDATA2_o = PORT_B2_RDATA[RD2_DATA_WIDTH-1:0];\\n\\ndefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n};\\n\\n(* is_inferred = 0 *)\\n(* is_split = 0 *)\\n(* is_fifo = 0 *)\\n(* port_a_dwidth = PORT_A1_WRWIDTH *)\\n(* port_b_dwidth = PORT_B1_WRWIDTH *)\\nTDP36K _TECHMAP_REPLACE_ (\\n\\t.RESET_ni(1'b1),\\n\\n\\t.CLK_A1_i(WR1_CLK_i),\\n\\t.ADDR_A1_i({1'b0,PORT_A1_ADDR}),\\n\\t.WEN_A1_i(WEN_A1_i),\\n\\t.BE_A1_i(BE_A1_i),\\n\\t.WDATA_A1_i(WDATA_A1_i),\\n\\t.REN_A1_i(REN_A1_i),\\n\\t.RDATA_A1_o(RDATA_A1_o),\\n\\n\\t.CLK_A2_i(WR2_CLK_i),\\n\\t.ADDR_A2_i(PORT_A2_ADDR),\\n\\t.WEN_A2_i(WEN_A2_i),\\n\\t.BE_A2_i(BE_A2_i),\\n\\t.WDATA_A2_i(WDATA_A2_i),\\n\\t.REN_A2_i(REN_A2_i),\\n\\t.RDATA_A2_o(RDATA_A2_o),\\n\\n\\t.CLK_B1_i(RD1_CLK_i),\\n\\t.ADDR_B1_i({1'b0,PORT_B1_ADDR}),\\n\\t.WEN_B1_i(WEN_B1_i),\\n\\t.BE_B1_i(BE_B1_i),\\n\\t.WDATA_B1_i(WDATA_B1_i),\\n\\t.REN_B1_i(REN_B1_i),\\n\\t.RDATA_B1_o(RDATA_B1_o),\\n\\n\\t.CLK_B2_i(RD2_CLK_i),\\n\\t.ADDR_B2_i(PORT_B2_ADDR),\\n\\t.WEN_B2_i(WEN_B2_i),\\n\\t.BE_B2_i(BE_B2_i),\\n\\t.WDATA_B2_i(WDATA_B2_i),\\n\\t.REN_B2_i(REN_B2_i),\\n\\t.RDATA_B2_o(RDATA_B2_o),\\n\\n\\t.FLUSH1_i(1'b0),\\n\\t.FLUSH2_i(1'b0)\\n);\\n\\nendmodule\\n\\nmodule BRAM2x18_dP (\\n\\t\\tPORT_A1_CLK_i,\\n\\t\\tPORT_A1_WEN_i,\\n\\t\\tPORT_A1_WR_BE_i,\\n\\t\\tPORT_A1_REN_i,\\n\\t\\tPORT_A1_ADDR_i,\\n\\t\\tPORT_A1_WR_DATA_i,\\n\\t\\tPORT_A1_RD_DATA_o,\\n\\n\\t\\tPORT_B1_CLK_i,\\n\\t\\tPORT_B1_WEN_i,\\n\\t\\tPORT_B1_WR_BE_i,\\n\\t\\tPORT_B1_REN_i,\\n\\t\\tPORT_B1_ADDR_i,\\n\\t\\tPORT_B1_WR_DATA_i,\\n\\t\\tPORT_B1_RD_DATA_o,\\n\\n\\t\\tPORT_A2_CLK_i,\\n\\t\\tPORT_A2_WEN_i,\\n\\t\\tPORT_A2_WR_BE_i,\\n\\t\\tPORT_A2_REN_i,\\n\\t\\tPORT_A2_ADDR_i,\\n\\t\\tPORT_A2_WR_DATA_i,\\n\\t\\tPORT_A2_RD_DATA_o,\\n\\n\\t\\tPORT_B2_CLK_i,\\n\\t\\tPORT_B2_WEN_i,\\n\\t\\tPORT_B2_WR_BE_i,\\n\\t\\tPORT_B2_REN_i,\\n\\t\\tPORT_B2_ADDR_i,\\n\\t\\tPORT_B2_WR_DATA_i,\\n\\t\\tPORT_B2_RD_DATA_o\\n);\\n\\nparameter PORT_A1_AWIDTH = 10;\\nparameter PORT_A1_DWIDTH = 18;\\nparameter PORT_A1_WR_BE_WIDTH = 2;\\n\\nparameter PORT_B1_AWIDTH = 10;\\nparameter PORT_B1_DWIDTH = 18;\\nparameter PORT_B1_WR_BE_WIDTH = 2;\\n\\nparameter PORT_A2_AWIDTH = 10;\\nparameter PORT_A2_DWIDTH = 18;\\nparameter PORT_A2_WR_BE_WIDTH = 2;\\n\\nparameter PORT_B2_AWIDTH = 10;\\nparameter PORT_B2_DWIDTH = 18;\\nparameter PORT_B2_WR_BE_WIDTH = 2;\\n\\ninput PORT_A1_CLK_i;\\ninput [PORT_A1_AWIDTH-1:0] PORT_A1_ADDR_i;\\ninput [PORT_A1_DWIDTH-1:0] PORT_A1_WR_DATA_i;\\ninput PORT_A1_WEN_i;\\ninput [PORT_A1_WR_BE_WIDTH-1:0] PORT_A1_WR_BE_i;\\ninput PORT_A1_REN_i;\\noutput [PORT_A1_DWIDTH-1:0] PORT_A1_RD_DATA_o;\\n\\ninput PORT_B1_CLK_i;\\ninput [PORT_B1_AWIDTH-1:0] PORT_B1_ADDR_i;\\ninput [PORT_B1_DWIDTH-1:0] PORT_B1_WR_DATA_i;\\ninput PORT_B1_WEN_i;\\ninput [PORT_B1_WR_BE_WIDTH-1:0] PORT_B1_WR_BE_i;\\ninput PORT_B1_REN_i;\\noutput [PORT_B1_DWIDTH-1:0] PORT_B1_RD_DATA_o;\\n\\ninput PORT_A2_CLK_i;\\ninput [PORT_A2_AWIDTH-1:0] PORT_A2_ADDR_i;\\ninput [PORT_A2_DWIDTH-1:0] PORT_A2_WR_DATA_i;\\ninput PORT_A2_WEN_i;\\ninput [PORT_A2_WR_BE_WIDTH-1:0] PORT_A2_WR_BE_i;\\ninput PORT_A2_REN_i;\\noutput [PORT_A2_DWIDTH-1:0] PORT_A2_RD_DATA_o;\\n\\ninput PORT_B2_CLK_i;\\ninput [PORT_B2_AWIDTH-1:0] PORT_B2_ADDR_i;\\ninput [PORT_B2_DWIDTH-1:0] PORT_B2_WR_DATA_i;\\ninput PORT_B2_WEN_i;\\ninput [PORT_B2_WR_BE_WIDTH-1:0] PORT_B2_WR_BE_i;\\ninput PORT_B2_REN_i;\\noutput [PORT_B2_DWIDTH-1:0] PORT_B2_RD_DATA_o;\\n\\n\\n// Fixed mode settings\\nlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\nlocalparam [ 0:0] FMODE1_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\nlocalparam [11:0] UPAE1_i       = 12'd10;\\nlocalparam [11:0] UPAF1_i       = 12'd10;\\n\\nlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\nlocalparam [ 0:0] FMODE2_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\nlocalparam [10:0] UPAE2_i       = 11'd10;\\nlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n// Width mode function\\nfunction [2:0] mode;\\ninput integer width;\\ncase (width)\\n1: mode = 3'b101;\\n2: mode = 3'b110;\\n4: mode = 3'b100;\\n8,9: mode = 3'b001;\\n16, 18: mode = 3'b010;\\n32, 36: mode = 3'b011;\\ndefault: mode = 3'b000;\\nendcase\\nendfunction\\n\\nfunction integer rwmode;\\ninput integer rwwidth;\\ncase (rwwidth)\\n1: rwmode = 1;\\n2: rwmode = 2;\\n4: rwmode = 4;\\n8,9: rwmode = 9;\\n16, 18: rwmode = 18;\\ndefault: rwmode = 18;\\nendcase\\nendfunction\\n\\nwire REN_A1_i;\\nwire REN_A2_i;\\n\\nwire REN_B1_i;\\nwire REN_B2_i;\\n\\nwire WEN_A1_i;\\nwire WEN_A2_i;\\n\\nwire WEN_B1_i;\\nwire WEN_B2_i;\\n\\nwire [1:0] BE_A1_i;\\nwire [1:0] BE_A2_i;\\n\\nwire [1:0] BE_B1_i;\\nwire [1:0] BE_B2_i;\\n\\nwire [14:0] ADDR_A1_i;\\nwire [13:0] ADDR_A2_i;\\n\\nwire [14:0] ADDR_B1_i;\\nwire [13:0] ADDR_B2_i;\\n\\nwire [17:0] WDATA_A1_i;\\nwire [17:0] WDATA_A2_i;\\n\\nwire [17:0] WDATA_B1_i;\\nwire [17:0] WDATA_B2_i;\\n\\nwire [17:0] RDATA_A1_o;\\nwire [17:0] RDATA_A2_o;\\n\\nwire [17:0] RDATA_B1_o;\\nwire [17:0] RDATA_B2_o;\\n\\nwire [1:0] PORT_A1_WR_BE;\\nwire [1:0] PORT_B1_WR_BE;\\n\\nwire [1:0] PORT_A2_WR_BE;\\nwire [1:0] PORT_B2_WR_BE;\\n\\nwire [17:0] PORT_B1_WDATA;\\nwire [17:0] PORT_B1_RDATA;\\nwire [17:0] PORT_A1_WDATA;\\nwire [17:0] PORT_A1_RDATA;\\n\\nwire [17:0] PORT_B2_WDATA;\\nwire [17:0] PORT_B2_RDATA;\\nwire [17:0] PORT_A2_WDATA;\\nwire [17:0] PORT_A2_RDATA;\\n\\nwire [13:0] PORT_A1_ADDR_INT;\\nwire [13:0] PORT_B1_ADDR_INT;\\n\\nwire [13:0] PORT_A2_ADDR_INT;\\nwire [13:0] PORT_B2_ADDR_INT;\\n\\nwire [13:0] PORT_A1_ADDR;\\nwire [13:0] PORT_B1_ADDR;\\n\\nwire [13:0] PORT_A2_ADDR;\\nwire [13:0] PORT_B2_ADDR;\\n\\nwire PORT_A1_CLK;\\nwire PORT_B1_CLK;\\n\\nwire PORT_A2_CLK;\\nwire PORT_B2_CLK;\\n\\n// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)\\nlocalparam [ 2:0] RMODE_A1_i    = mode(PORT_A1_DWIDTH);\\nlocalparam [ 2:0] WMODE_A1_i    = mode(PORT_A1_DWIDTH);\\nlocalparam [ 2:0] RMODE_A2_i    = mode(PORT_A2_DWIDTH);\\nlocalparam [ 2:0] WMODE_A2_i    = mode(PORT_A2_DWIDTH);\\n\\nlocalparam [ 2:0] RMODE_B1_i    = mode(PORT_B1_DWIDTH);\\nlocalparam [ 2:0] WMODE_B1_i    = mode(PORT_B1_DWIDTH);\\nlocalparam [ 2:0] RMODE_B2_i    = mode(PORT_B2_DWIDTH);\\nlocalparam [ 2:0] WMODE_B2_i    = mode(PORT_B2_DWIDTH);\\n\\nlocalparam PORT_A1_WRWIDTH = rwmode(PORT_A1_DWIDTH);\\nlocalparam PORT_B1_WRWIDTH = rwmode(PORT_B1_DWIDTH);\\nlocalparam PORT_A2_WRWIDTH = rwmode(PORT_A2_DWIDTH);\\nlocalparam PORT_B2_WRWIDTH = rwmode(PORT_B2_DWIDTH);\\n\\nassign PORT_A1_CLK = PORT_A1_CLK_i;\\nassign PORT_B1_CLK = PORT_B1_CLK_i;\\n\\nassign PORT_A2_CLK = PORT_A2_CLK_i;\\nassign PORT_B2_CLK = PORT_B2_CLK_i;\\n\\ngenerate\\n\\tif (PORT_A1_AWIDTH == 14) begin\\n\\t\\tassign PORT_A1_ADDR_INT = PORT_A1_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_A1_ADDR_INT[13:PORT_A1_AWIDTH] = 0;\\n\\t\\tassign PORT_A1_ADDR_INT[PORT_A1_AWIDTH-1:0] = PORT_A1_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_A1_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A1_ADDR = PORT_A1_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (PORT_B1_AWIDTH == 14) begin\\n\\t\\tassign PORT_B1_ADDR_INT = PORT_B1_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_B1_ADDR_INT[13:PORT_B1_AWIDTH] = 0;\\n\\t\\tassign PORT_B1_ADDR_INT[PORT_B1_AWIDTH-1:0] = PORT_B1_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_B1_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B1_ADDR = PORT_B1_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (PORT_A2_AWIDTH == 14) begin\\n\\t\\tassign PORT_A2_ADDR_INT = PORT_A2_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_A2_ADDR_INT[13:PORT_A2_AWIDTH] = 0;\\n\\t\\tassign PORT_A2_ADDR_INT[PORT_A2_AWIDTH-1:0] = PORT_A2_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_A2_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A2_ADDR = PORT_A2_ADDR_INT;\\n\\tend\\nendcase\\n\\ngenerate\\n\\tif (PORT_B2_AWIDTH == 14) begin\\n\\t\\tassign PORT_B2_ADDR_INT = PORT_B2_ADDR_i;\\n\\tend else begin\\n\\t\\tassign PORT_B2_ADDR_INT[13:PORT_B2_AWIDTH] = 0;\\n\\t\\tassign PORT_B2_ADDR_INT[PORT_B2_AWIDTH-1:0] = PORT_B2_ADDR_i;\\n\\tend\\nendgenerate\\n\\ncase (PORT_B2_DWIDTH)\\n\\t1: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT;\\n\\tend\\n\\t2: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT << 1;\\n\\tend\\n\\t4: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT << 2;\\n\\tend\\n\\t8, 9: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT << 3;\\n\\tend\\n\\t16, 18: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT << 4;\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B2_ADDR = PORT_B2_ADDR_INT;\\n\\tend\\nendcase\\n\\ncase (PORT_A1_WR_BE_WIDTH)\\n\\t2: begin\\n\\t\\tassign PORT_A1_WR_BE = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A1_WR_BE[1:PORT_A1_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_A1_WR_BE[PORT_A1_WR_BE_WIDTH-1 :0] = PORT_A1_WR_BE_i[PORT_A1_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\ncase (PORT_B1_WR_BE_WIDTH)\\n\\t2: begin\\n\\t\\tassign PORT_B1_WR_BE = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B1_WR_BE[1:PORT_B1_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_B1_WR_BE[PORT_B1_WR_BE_WIDTH-1 :0] = PORT_B1_WR_BE_i[PORT_B1_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\ncase (PORT_A2_WR_BE_WIDTH)\\n\\t2: begin\\n\\t\\tassign PORT_A2_WR_BE = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_A2_WR_BE[1:PORT_A2_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_A2_WR_BE[PORT_A2_WR_BE_WIDTH-1 :0] = PORT_A2_WR_BE_i[PORT_A2_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\ncase (PORT_B2_WR_BE_WIDTH)\\n\\t2: begin\\n\\t\\tassign PORT_B2_WR_BE = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];\\n\\tend\\n\\tdefault: begin\\n\\t\\tassign PORT_B2_WR_BE[1:PORT_B2_WR_BE_WIDTH] = 0;\\n\\t\\tassign PORT_B2_WR_BE[PORT_B2_WR_BE_WIDTH-1 :0] = PORT_B2_WR_BE_i[PORT_B2_WR_BE_WIDTH-1 :0];\\n\\tend\\nendcase\\n\\nassign REN_A1_i = PORT_A1_REN_i;\\nassign WEN_A1_i = PORT_A1_WEN_i;\\nassign BE_A1_i  = PORT_A1_WR_BE;\\n\\nassign REN_A2_i = PORT_A2_REN_i;\\nassign WEN_A2_i = PORT_A2_WEN_i;\\nassign BE_A2_i  = PORT_A2_WR_BE;\\n\\nassign REN_B1_i = PORT_B1_REN_i;\\nassign WEN_B1_i = PORT_B1_WEN_i;\\nassign BE_B1_i  = PORT_B1_WR_BE;\\n\\nassign REN_B2_i = PORT_B2_REN_i;\\nassign WEN_B2_i = PORT_B2_WEN_i;\\nassign BE_B2_i  = PORT_B2_WR_BE;\\n\\ngenerate\\n\\tif (PORT_A1_DWIDTH == 18) begin\\n\\t\\tassign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];\\n\\tend else if (PORT_A1_DWIDTH == 9) begin\\n\\t\\tassign PORT_A1_WDATA = {1'b0, PORT_A1_WR_DATA_i[8], 8'h0, PORT_A1_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A1_WDATA[17:PORT_A1_DWIDTH] = 0;\\n\\t\\tassign PORT_A1_WDATA[PORT_A1_DWIDTH-1:0] = PORT_A1_WR_DATA_i[PORT_A1_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A1_i = PORT_A1_WDATA;\\n\\ngenerate\\n\\tif (PORT_A2_DWIDTH == 18) begin\\n\\t\\tassign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];\\n\\tend else if (PORT_A2_DWIDTH == 9) begin\\n\\t\\tassign PORT_A2_WDATA = {1'b0, PORT_A2_WR_DATA_i[8], 8'h0, PORT_A2_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A2_WDATA[17:PORT_A2_DWIDTH] = 0;\\n\\t\\tassign PORT_A2_WDATA[PORT_A2_DWIDTH-1:0] = PORT_A2_WR_DATA_i[PORT_A2_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_A2_i = PORT_A2_WDATA;\\n\\ngenerate\\n\\tif (PORT_A1_DWIDTH == 9) begin\\n\\t\\tassign PORT_A1_RDATA = { 9'h0, RDATA_A1_o[16], RDATA_A1_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A1_RDATA = RDATA_A1_o;\\n\\tend\\nendgenerate\\n\\nassign PORT_A1_RD_DATA_o = PORT_A1_RDATA[PORT_A1_DWIDTH-1:0];\\n\\ngenerate\\n\\tif (PORT_A2_DWIDTH == 9) begin\\n\\t\\tassign PORT_A2_RDATA = { 9'h0, RDATA_A2_o[16], RDATA_A2_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_A2_RDATA = RDATA_A2_o;\\n\\tend\\nendgenerate\\n\\nassign PORT_A2_RD_DATA_o = PORT_A2_RDATA[PORT_A2_DWIDTH-1:0];\\n\\ngenerate\\n\\tif (PORT_B1_DWIDTH == 18) begin\\n\\t\\tassign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];\\n\\tend else if (PORT_B1_DWIDTH == 9) begin\\n\\t\\tassign PORT_B1_WDATA = {1'b0, PORT_B1_WR_DATA_i[8], 8'h0, PORT_B1_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B1_WDATA[17:PORT_B1_DWIDTH] = 0;\\n\\t\\tassign PORT_B1_WDATA[PORT_B1_DWIDTH-1:0] = PORT_B1_WR_DATA_i[PORT_B1_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_B1_i = PORT_B1_WDATA;\\n\\ngenerate\\n\\tif (PORT_B2_DWIDTH == 18) begin\\n\\t\\tassign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];\\n\\tend else if (PORT_B2_DWIDTH == 9) begin\\n\\t\\tassign PORT_B2_WDATA = {1'b0, PORT_B2_WR_DATA_i[8], 8'h0, PORT_B2_WR_DATA_i[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B2_WDATA[17:PORT_B2_DWIDTH] = 0;\\n\\t\\tassign PORT_B2_WDATA[PORT_B2_DWIDTH-1:0] = PORT_B2_WR_DATA_i[PORT_B2_DWIDTH-1:0];\\n\\tend\\nendgenerate\\n\\nassign WDATA_B2_i = PORT_B2_WDATA;\\n\\ngenerate\\n\\tif (PORT_B1_DWIDTH == 9) begin\\n\\t\\tassign PORT_B1_RDATA = { 9'h0, RDATA_B1_o[16], RDATA_B1_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B1_RDATA = RDATA_B1_o;\\n\\tend\\nendgenerate\\n\\nassign PORT_B1_RD_DATA_o = PORT_B1_RDATA[PORT_B1_DWIDTH-1:0];\\n\\ngenerate\\n\\tif (PORT_B2_DWIDTH == 9) begin\\n\\t\\tassign PORT_B2_RDATA = { 9'h0, RDATA_B2_o[16], RDATA_B2_o[7:0]};\\n\\tend else begin\\n\\t\\tassign PORT_B2_RDATA = RDATA_B2_o;\\n\\tend\\nendgenerate\\n\\nassign PORT_B2_RD_DATA_o = PORT_B2_RDATA[PORT_B2_DWIDTH-1:0];\\n\\ndefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n};\\n\\n(* is_inferred = 0 *)\\n(* is_split = 0 *)\\n(* is_fifo = 0 *)\\n(* port_a_dwidth = PORT_A1_WRWIDTH *)\\n(* port_b_dwidth = PORT_B1_WRWIDTH *)\\nTDP36K _TECHMAP_REPLACE_ (\\n\\t.RESET_ni(1'b1),\\n\\n\\t.CLK_A1_i(PORT_A1_CLK),\\n\\t.ADDR_A1_i({1'b0,PORT_A1_ADDR}),\\n\\t.WEN_A1_i(WEN_A1_i),\\n\\t.BE_A1_i(BE_A1_i),\\n\\t.WDATA_A1_i(WDATA_A1_i),\\n\\t.REN_A1_i(REN_A1_i),\\n\\t.RDATA_A1_o(RDATA_A1_o),\\n\\n\\t.CLK_A2_i(PORT_A2_CLK),\\n\\t.ADDR_A2_i(PORT_A2_ADDR),\\n\\t.WEN_A2_i(WEN_A2_i),\\n\\t.BE_A2_i(BE_A2_i),\\n\\t.WDATA_A2_i(WDATA_A2_i),\\n\\t.REN_A2_i(REN_A2_i),\\n\\t.RDATA_A2_o(RDATA_A2_o),\\n\\n\\t.CLK_B1_i(PORT_B1_CLK),\\n\\t.ADDR_B1_i({1'b0,PORT_B1_ADDR}),\\n\\t.WEN_B1_i(WEN_B1_i),\\n\\t.BE_B1_i(BE_B1_i),\\n\\t.WDATA_B1_i(WDATA_B1_i),\\n\\t.REN_B1_i(REN_B1_i),\\n\\t.RDATA_B1_o(RDATA_B1_o),\\n\\n\\t.CLK_B2_i(PORT_B2_CLK),\\n\\t.ADDR_B2_i(PORT_B2_ADDR),\\n\\t.WEN_B2_i(WEN_B2_i),\\n\\t.BE_B2_i(BE_B2_i),\\n\\t.WDATA_B2_i(WDATA_B2_i),\\n\\t.REN_B2_i(REN_B2_i),\\n\\t.RDATA_B2_o(RDATA_B2_o),\\n\\n\\t.FLUSH1_i(1'b0),\\n\\t.FLUSH2_i(1'b0)\\n);\\n\\nendmodule\\n\\n\\nmodule BRAM2x18_SFIFO (\\n\\t\\tDIN1,\\n\\t\\tPUSH1,\\n\\t\\tPOP1,\\n\\t\\tCLK1,\\n\\t\\tAsync_Flush1,\\n\\t\\tOverrun_Error1,\\n\\t\\tFull_Watermark1,\\n\\t\\tAlmost_Full1,\\n\\t\\tFull1,\\n\\t\\tUnderrun_Error1,\\n\\t\\tEmpty_Watermark1,\\n\\t\\tAlmost_Empty1,\\n\\t\\tEmpty1,\\n\\t\\tDOUT1,\\n\\n\\t\\tDIN2,\\n\\t\\tPUSH2,\\n\\t\\tPOP2,\\n\\t\\tCLK2,\\n\\t\\tAsync_Flush2,\\n\\t\\tOverrun_Error2,\\n\\t\\tFull_Watermark2,\\n\\t\\tAlmost_Full2,\\n\\t\\tFull2,\\n\\t\\tUnderrun_Error2,\\n\\t\\tEmpty_Watermark2,\\n\\t\\tAlmost_Empty2,\\n\\t\\tEmpty2,\\n\\t\\tDOUT2\\n);\\n\\n\\tparameter WR1_DATA_WIDTH = 18;\\n\\tparameter RD1_DATA_WIDTH = 18;\\n\\n\\tparameter WR2_DATA_WIDTH = 18;\\n\\tparameter RD2_DATA_WIDTH = 18;\\n\\n\\tparameter UPAE_DBITS1 = 12'd10;\\n\\tparameter UPAF_DBITS1 = 12'd10;\\n\\n\\tparameter UPAE_DBITS2 = 11'd10;\\n\\tparameter UPAF_DBITS2 = 11'd10;\\n\\n\\tinput CLK1;\\n\\tinput PUSH1, POP1;\\n\\tinput [WR1_DATA_WIDTH-1:0] DIN1;\\n\\tinput Async_Flush1;\\n\\toutput [RD1_DATA_WIDTH-1:0] DOUT1;\\n\\toutput Almost_Full1, Almost_Empty1;\\n\\toutput Full1, Empty1;\\n\\toutput Full_Watermark1, Empty_Watermark1;\\n\\toutput Overrun_Error1, Underrun_Error1;\\n\\n\\tinput CLK2;\\n\\tinput PUSH2, POP2;\\n\\tinput [WR2_DATA_WIDTH-1:0] DIN2;\\n\\tinput Async_Flush2;\\n\\toutput [RD2_DATA_WIDTH-1:0] DOUT2;\\n\\toutput Almost_Full2, Almost_Empty2;\\n\\toutput Full2, Empty2;\\n\\toutput Full_Watermark2, Empty_Watermark2;\\n\\toutput Overrun_Error2, Underrun_Error2;\\n\\n\\t// Fixed mode settings\\n\\tlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd1;\\n\\tlocalparam [ 0:0] FMODE1_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\n\\tlocalparam [11:0] UPAE1_i       = UPAE_DBITS1;\\n\\tlocalparam [11:0] UPAF1_i       = UPAF_DBITS1;\\n\\n\\tlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd1;\\n\\tlocalparam [ 0:0] FMODE2_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\n\\tlocalparam [10:0] UPAE2_i       = UPAE_DBITS2;\\n\\tlocalparam [10:0] UPAF2_i       = UPAF_DBITS2;\\n\\n\\t// Width mode function\\n\\tfunction [2:0] mode;\\n\\tinput integer width;\\n\\tcase (width)\\n\\t1: mode = 3'b101;\\n\\t2: mode = 3'b110;\\n\\t4: mode = 3'b100;\\n\\t8,9: mode = 3'b001;\\n\\t16, 18: mode = 3'b010;\\n\\t32, 36: mode = 3'b011;\\n\\tdefault: mode = 3'b000;\\n\\tendcase\\n\\tendfunction\\n\\n\\tfunction integer rwmode;\\n\\tinput integer rwwidth;\\n\\tcase (rwwidth)\\n\\t1: rwmode = 1;\\n\\t2: rwmode = 2;\\n\\t4: rwmode = 4;\\n\\t8,9: rwmode = 9;\\n\\t16, 18: rwmode = 18;\\n\\tdefault: rwmode = 18;\\n\\tendcase\\n\\tendfunction\\n\\n\\twire [17:0] in_reg1;\\n\\twire [17:0] out_reg1;\\n\\twire [17:0] fifo1_flags;\\n\\n\\twire [17:0] in_reg2;\\n\\twire [17:0] out_reg2;\\n\\twire [17:0] fifo2_flags;\\n\\n\\twire Push_Clk1, Pop_Clk1;\\n\\twire Push_Clk2, Pop_Clk2;\\n\\tassign Push_Clk1 = CLK1;\\n\\tassign Pop_Clk1 = CLK1;\\n\\tassign Push_Clk2 = CLK2;\\n\\tassign Pop_Clk2 = CLK2;\\n\\n\\tassign Overrun_Error1 = fifo1_flags[0];\\n\\tassign Full_Watermark1 = fifo1_flags[1];\\n\\tassign Almost_Full1 = fifo1_flags[2];\\n\\tassign Full1 = fifo1_flags[3];\\n\\tassign Underrun_Error1 = fifo1_flags[4];\\n\\tassign Empty_Watermark1 = fifo1_flags[5];\\n\\tassign Almost_Empty1 = fifo1_flags[6];\\n\\tassign Empty1 = fifo1_flags[7];\\n\\n\\tassign Overrun_Error2 = fifo2_flags[0];\\n\\tassign Full_Watermark2 = fifo2_flags[1];\\n\\tassign Almost_Full2 = fifo2_flags[2];\\n\\tassign Full2 = fifo2_flags[3];\\n\\tassign Underrun_Error2 = fifo2_flags[4];\\n\\tassign Empty_Watermark2 = fifo2_flags[5];\\n\\tassign Almost_Empty2 = fifo2_flags[6];\\n\\tassign Empty2 = fifo2_flags[7];\\n\\n\\tlocalparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\n\\tlocalparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\n\\tlocalparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);\\n\\tlocalparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);\\n\\tlocalparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);\\n\\tlocalparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);\\n\\n\\tgenerate\\n\\t\\tif (WR1_DATA_WIDTH == 18) begin\\n\\t\\t\\tassign in_reg1[17:0] = DIN1[17:0];\\n\\t\\tend else if (WR1_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg1[17:WR1_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD1_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (WR2_DATA_WIDTH == 18) begin\\n\\t\\t\\tassign in_reg2[17:0] = DIN2[17:0];\\n\\t\\tend else if (WR2_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg2[17:WR2_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD2_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tdefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n\\t};\\n\\n\\t(* is_fifo = 1 *)\\n\\t(* sync_fifo = 1 *)\\n\\t(* is_split = 0 *)\\n\\t(* is_inferred = 0 *)\\n\\t(* port_a_dwidth = PORT_A1_WRWIDTH *)\\n\\t(* port_b_dwidth = PORT_B1_WRWIDTH *)\\n \\tTDP36K _TECHMAP_REPLACE_ (\\n\\t\\t.RESET_ni(1'b1),\\n\\t\\t.WDATA_A1_i(in_reg1[17:0]),\\n\\t\\t.WDATA_A2_i(in_reg2[17:0]),\\n\\t\\t.RDATA_A1_o(fifo1_flags),\\n\\t\\t.RDATA_A2_o(fifo2_flags),\\n\\t\\t.ADDR_A1_i(14'h0),\\n\\t\\t.ADDR_A2_i(14'h0),\\n\\t\\t.CLK_A1_i(Push_Clk1),\\n\\t\\t.CLK_A2_i(Push_Clk2),\\n\\t\\t.REN_A1_i(1'b1),\\n\\t\\t.REN_A2_i(1'b1),\\n\\t\\t.WEN_A1_i(PUSH1),\\n\\t\\t.WEN_A2_i(PUSH2),\\n\\t\\t.BE_A1_i(2'b11),\\n\\t\\t.BE_A2_i(2'b11),\\n\\n\\t\\t.WDATA_B1_i(18'h0),\\n\\t\\t.WDATA_B2_i(18'h0),\\n\\t\\t.RDATA_B1_o(out_reg1[17:0]),\\n\\t\\t.RDATA_B2_o(out_reg2[17:0]),\\n\\t\\t.ADDR_B1_i(14'h0),\\n\\t\\t.ADDR_B2_i(14'h0),\\n\\t\\t.CLK_B1_i(Pop_Clk1),\\n\\t\\t.CLK_B2_i(Pop_Clk2),\\n\\t\\t.REN_B1_i(POP1),\\n\\t\\t.REN_B2_i(POP2),\\n\\t\\t.WEN_B1_i(1'b0),\\n\\t\\t.WEN_B2_i(1'b0),\\n\\t\\t.BE_B1_i(2'b11),\\n\\t\\t.BE_B2_i(2'b11),\\n\\n\\t\\t.FLUSH1_i(Async_Flush1),\\n\\t\\t.FLUSH2_i(Async_Flush2)\\n\\t);\\n\\nendmodule\\n\\n\\nmodule BRAM2x18_AFIFO (\\n\\t\\tDIN1,\\n\\t\\tPUSH1,\\n\\t\\tPOP1,\\n\\t\\tPush_Clk1,\\n\\tPop_Clk1,\\n\\t\\tAsync_Flush1,\\n\\t\\tOverrun_Error1,\\n\\t\\tFull_Watermark1,\\n\\t\\tAlmost_Full1,\\n\\t\\tFull1,\\n\\t\\tUnderrun_Error1,\\n\\t\\tEmpty_Watermark1,\\n\\t\\tAlmost_Empty1,\\n\\t\\tEmpty1,\\n\\t\\tDOUT1,\\n\\n\\t\\tDIN2,\\n\\t\\tPUSH2,\\n\\t\\tPOP2,\\n\\t\\tPush_Clk2,\\n\\tPop_Clk2,\\n\\t\\tAsync_Flush2,\\n\\t\\tOverrun_Error2,\\n\\t\\tFull_Watermark2,\\n\\t\\tAlmost_Full2,\\n\\t\\tFull2,\\n\\t\\tUnderrun_Error2,\\n\\t\\tEmpty_Watermark2,\\n\\t\\tAlmost_Empty2,\\n\\t\\tEmpty2,\\n\\t\\tDOUT2\\n);\\n\\n\\tparameter WR1_DATA_WIDTH = 18;\\n\\tparameter RD1_DATA_WIDTH = 18;\\n\\n\\tparameter WR2_DATA_WIDTH = 18;\\n\\tparameter RD2_DATA_WIDTH = 18;\\n\\n\\tparameter UPAE_DBITS1 = 12'd10;\\n\\tparameter UPAF_DBITS1 = 12'd10;\\n\\n\\tparameter UPAE_DBITS2 = 11'd10;\\n\\tparameter UPAF_DBITS2 = 11'd10;\\n\\n\\tinput Push_Clk1, Pop_Clk1;\\n\\tinput PUSH1, POP1;\\n\\tinput [WR1_DATA_WIDTH-1:0] DIN1;\\n\\tinput Async_Flush1;\\n\\toutput [RD1_DATA_WIDTH-1:0] DOUT1;\\n\\toutput Almost_Full1, Almost_Empty1;\\n\\toutput Full1, Empty1;\\n\\toutput Full_Watermark1, Empty_Watermark1;\\n\\toutput Overrun_Error1, Underrun_Error1;\\n\\n\\tinput Push_Clk2, Pop_Clk2;\\n\\tinput PUSH2, POP2;\\n\\tinput [WR2_DATA_WIDTH-1:0] DIN2;\\n\\tinput Async_Flush2;\\n\\toutput [RD2_DATA_WIDTH-1:0] DOUT2;\\n\\toutput Almost_Full2, Almost_Empty2;\\n\\toutput Full2, Empty2;\\n\\toutput Full_Watermark2, Empty_Watermark2;\\n\\toutput Overrun_Error2, Underrun_Error2;\\n\\n\\t// Fixed mode settings\\n\\tlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\n\\tlocalparam [ 0:0] FMODE1_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\n\\tlocalparam [11:0] UPAE1_i       = UPAE_DBITS1;\\n\\tlocalparam [11:0] UPAF1_i       = UPAF_DBITS1;\\n\\n\\tlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\n\\tlocalparam [ 0:0] FMODE2_i      = 1'd1;\\n\\tlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\n\\tlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\n\\tlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\n\\tlocalparam [10:0] UPAE2_i       = UPAE_DBITS2;\\n\\tlocalparam [10:0] UPAF2_i       = UPAF_DBITS2;\\n\\n\\t// Width mode function\\n\\tfunction [2:0] mode;\\n\\tinput integer width;\\n\\tcase (width)\\n\\t1: mode = 3'b101;\\n\\t2: mode = 3'b110;\\n\\t4: mode = 3'b100;\\n\\t8,9: mode = 3'b001;\\n\\t16, 18: mode = 3'b010;\\n\\t32, 36: mode = 3'b011;\\n\\tdefault: mode = 3'b000;\\n\\tendcase\\n\\tendfunction\\n\\n\\tfunction integer rwmode;\\n\\tinput integer rwwidth;\\n\\tcase (rwwidth)\\n\\t1: rwmode = 1;\\n\\t2: rwmode = 2;\\n\\t4: rwmode = 4;\\n\\t8,9: rwmode = 9;\\n\\t16, 18: rwmode = 18;\\n\\tdefault: rwmode = 18;\\n\\tendcase\\n\\tendfunction\\n\\n\\twire [17:0] in_reg1;\\n\\twire [17:0] out_reg1;\\n\\twire [17:0] fifo1_flags;\\n\\n\\twire [17:0] in_reg2;\\n\\twire [17:0] out_reg2;\\n\\twire [17:0] fifo2_flags;\\n\\n\\twire Push_Clk1, Pop_Clk1;\\n\\twire Push_Clk2, Pop_Clk2;\\n\\n\\tassign Overrun_Error1 = fifo1_flags[0];\\n\\tassign Full_Watermark1 = fifo1_flags[1];\\n\\tassign Almost_Full1 = fifo1_flags[2];\\n\\tassign Full1 = fifo1_flags[3];\\n\\tassign Underrun_Error1 = fifo1_flags[4];\\n\\tassign Empty_Watermark1 = fifo1_flags[5];\\n\\tassign Almost_Empty1 = fifo1_flags[6];\\n\\tassign Empty1 = fifo1_flags[7];\\n\\n\\tassign Overrun_Error2 = fifo2_flags[0];\\n\\tassign Full_Watermark2 = fifo2_flags[1];\\n\\tassign Almost_Full2 = fifo2_flags[2];\\n\\tassign Full2 = fifo2_flags[3];\\n\\tassign Underrun_Error2 = fifo2_flags[4];\\n\\tassign Empty_Watermark2 = fifo2_flags[5];\\n\\tassign Almost_Empty2 = fifo2_flags[6];\\n\\tassign Empty2 = fifo2_flags[7];\\n\\n\\tlocalparam [ 2:0] RMODE_A1_i    = mode(WR1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A1_i    = mode(WR1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_A2_i    = mode(WR2_DATA_WIDTH);\\n\\n\\tlocalparam [ 2:0] RMODE_B1_i    = mode(RD1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B1_i    = mode(RD1_DATA_WIDTH);\\n\\tlocalparam [ 2:0] RMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\tlocalparam [ 2:0] WMODE_B2_i    = mode(RD2_DATA_WIDTH);\\n\\n\\tlocalparam PORT_A1_WRWIDTH = rwmode(WR1_DATA_WIDTH);\\n\\tlocalparam PORT_B1_WRWIDTH = rwmode(RD1_DATA_WIDTH);\\n\\tlocalparam PORT_A2_WRWIDTH = rwmode(WR2_DATA_WIDTH);\\n\\tlocalparam PORT_B2_WRWIDTH = rwmode(RD2_DATA_WIDTH);\\n\\n\\tgenerate\\n\\t\\tif (WR1_DATA_WIDTH == 18) begin\\n\\t\\t\\tassign in_reg1[17:0] = DIN1[17:0];\\n\\t\\tend else if (WR1_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg1[17:0] = {1'b0, DIN1[8], 8'h0, DIN1[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg1[17:WR1_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg1[WR1_DATA_WIDTH-1:0] = DIN1[WR1_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD1_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign DOUT1[RD1_DATA_WIDTH-1:0] = {out_reg1[16], out_reg1[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign DOUT1[RD1_DATA_WIDTH-1:0] = out_reg1[RD1_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (WR2_DATA_WIDTH == 18) begin\\n\\t\\t\\tassign in_reg2[17:0] = DIN2[17:0];\\n\\t\\tend else if (WR2_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign in_reg2[17:0] = {1'b0, DIN2[8], 8'h0, DIN2[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign in_reg2[17:WR2_DATA_WIDTH]  = 0;\\n\\t\\t\\tassign in_reg2[WR2_DATA_WIDTH-1:0] = DIN2[WR2_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tgenerate\\n\\t\\tif (RD2_DATA_WIDTH == 9) begin\\n\\t\\t\\tassign DOUT2[RD2_DATA_WIDTH-1:0] = {out_reg2[16], out_reg2[7:0]};\\n\\t\\tend else begin\\n\\t\\t\\tassign DOUT2[RD2_DATA_WIDTH-1:0] = out_reg2[RD2_DATA_WIDTH-1:0];\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tdefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b1,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n\\t};\\n\\n\\t(* is_fifo = 1 *)\\n\\t(* sync_fifo = 0 *)\\n\\t(* is_split = 0 *)\\n\\t(* is_inferred = 0 *)\\n\\t(* port_a_dwidth = PORT_A1_WRWIDTH *)\\n\\t(* port_b_dwidth = PORT_B1_WRWIDTH *)\\n \\tTDP36K _TECHMAP_REPLACE_ (\\n\\t\\t.RESET_ni(1'b1),\\n\\t\\t.WDATA_A1_i(in_reg1[17:0]),\\n\\t\\t.WDATA_A2_i(in_reg2[17:0]),\\n\\t\\t.RDATA_A1_o(fifo1_flags),\\n\\t\\t.RDATA_A2_o(fifo2_flags),\\n\\t\\t.ADDR_A1_i(14'h0),\\n\\t\\t.ADDR_A2_i(14'h0),\\n\\t\\t.CLK_A1_i(Push_Clk1),\\n\\t\\t.CLK_A2_i(Push_Clk2),\\n\\t\\t.REN_A1_i(1'b1),\\n\\t\\t.REN_A2_i(1'b1),\\n\\t\\t.WEN_A1_i(PUSH1),\\n\\t\\t.WEN_A2_i(PUSH2),\\n\\t\\t.BE_A1_i(2'b11),\\n\\t\\t.BE_A2_i(2'b11),\\n\\n\\t\\t.WDATA_B1_i(18'h0),\\n\\t\\t.WDATA_B2_i(18'h0),\\n\\t\\t.RDATA_B1_o(out_reg1[17:0]),\\n\\t\\t.RDATA_B2_o(out_reg2[17:0]),\\n\\t\\t.ADDR_B1_i(14'h0),\\n\\t\\t.ADDR_B2_i(14'h0),\\n\\t\\t.CLK_B1_i(Pop_Clk1),\\n\\t\\t.CLK_B2_i(Pop_Clk2),\\n\\t\\t.REN_B1_i(POP1),\\n\\t\\t.REN_B2_i(POP2),\\n\\t\\t.WEN_B1_i(1'b0),\\n\\t\\t.WEN_B2_i(1'b0),\\n\\t\\t.BE_B1_i(2'b11),\\n\\t\\t.BE_B2_i(2'b11),\\n\\n\\t\\t.FLUSH1_i(Async_Flush1),\\n\\t\\t.FLUSH2_i(Async_Flush2)\\n\\t);\\n\\nendmodule\",\n                \"brams_sim.v\": new URL(/* asset import */ __webpack_require__(/*! ./share/quicklogic/qlf_k6n10f/brams_sim.v */ \"./node_modules/@yowasp/yosys/gen/share/quicklogic/qlf_k6n10f/brams_sim.v\"), __webpack_require__.b),\n                \"cells_sim.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\n`timescale 1ps/1ps\\n\\n`default_nettype none\\n(* abc9_lut=1 *)\\nmodule LUT1(output wire O, input wire I0);\\n\\tparameter [1:0] INIT = 0;\\n\\tassign O = I0 ? INIT[1] : INIT[0];\\n\\tspecify\\n\\t\\t(I0 => O) = 74;\\n\\tendspecify\\nendmodule\\n\\n(* abc9_lut=2 *)\\nmodule LUT2(output wire O, input wire I0, I1);\\n\\tparameter [3:0] INIT = 0;\\n\\twire [ 1: 0] s1 = I1 ? INIT[ 3: 2] : INIT[ 1: 0];\\n\\tassign O = I0 ? s1[1] : s1[0];\\n\\tspecify\\n\\t\\t(I0 => O) = 116;\\n\\t\\t(I1 => O) = 74;\\n\\tendspecify\\nendmodule\\n\\n(* abc9_lut=3 *)\\nmodule LUT3(output wire O, input wire I0, I1, I2);\\n\\tparameter [7:0] INIT = 0;\\n\\twire [ 3: 0] s2 = I2 ? INIT[ 7: 4] : INIT[ 3: 0];\\n\\twire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n\\tassign O = I0 ? s1[1] : s1[0];\\n\\tspecify\\n\\t\\t(I0 => O) = 162;\\n\\t\\t(I1 => O) = 116;\\n\\t\\t(I2 => O) = 174;\\n\\tendspecify\\nendmodule\\n\\n(* abc9_lut=3 *)\\nmodule LUT4(output wire O, input wire I0, I1, I2, I3);\\n\\tparameter [15:0] INIT = 0;\\n\\twire [ 7: 0] s3 = I3 ? INIT[15: 8] : INIT[ 7: 0];\\n\\twire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];\\n\\twire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n\\tassign O = I0 ? s1[1] : s1[0];\\n\\tspecify\\n\\t\\t(I0 => O) = 201;\\n\\t\\t(I1 => O) = 162;\\n\\t\\t(I2 => O) = 116;\\n\\t\\t(I3 => O) = 74;\\n\\tendspecify\\nendmodule\\n\\n(* abc9_lut=3 *)\\nmodule LUT5(output wire O, input wire I0, I1, I2, I3, I4);\\n\\tparameter [31:0] INIT = 0;\\n\\twire [15: 0] s4 = I4 ? INIT[31:16] : INIT[15: 0];\\n\\twire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];\\n\\twire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];\\n\\twire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n\\tassign O = I0 ? s1[1] : s1[0];\\n\\tspecify\\n\\t\\t(I0 => O) = 228;\\n\\t\\t(I1 => O) = 189;\\n\\t\\t(I2 => O) = 143;\\n\\t\\t(I3 => O) = 100;\\n\\t\\t(I4 => O) = 55;\\n\\tendspecify\\nendmodule\\n\\n(* abc9_lut=5 *)\\nmodule LUT6(output wire O, input wire I0, I1, I2, I3, I4, I5);\\n\\tparameter [63:0] INIT = 0;\\n\\twire [31: 0] s5 = I5 ? INIT[63:32] : INIT[31: 0];\\n\\twire [15: 0] s4 = I4 ?   s5[31:16] :   s5[15: 0];\\n\\twire [ 7: 0] s3 = I3 ?   s4[15: 8] :   s4[ 7: 0];\\n\\twire [ 3: 0] s2 = I2 ?   s3[ 7: 4] :   s3[ 3: 0];\\n\\twire [ 1: 0] s1 = I1 ?   s2[ 3: 2] :   s2[ 1: 0];\\n\\tassign O = I0 ? s1[1] : s1[0];\\n\\tspecify\\n\\t\\t(I0 => O) = 251;\\n\\t\\t(I1 => O) = 212;\\n\\t\\t(I2 => O) = 166;\\n\\t\\t(I3 => O) = 123;\\n\\t\\t(I4 => O) = 77;\\n\\t\\t(I5 => O) = 43;\\n\\tendspecify\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule sh_dff(\\n\\t\\toutput reg Q,\\n\\t\\tinput wire D,\\n\\t\\t(* clkbuf_sink *)\\n\\t\\tinput wire C\\n);\\n\\n\\t\\tinitial Q = 1'b0;\\n\\t\\talways @(posedge C)\\n\\t\\t\\t\\tQ <= D;\\n\\n\\t\\tspecify\\n\\t\\t\\t(posedge C => (Q +: D)) = 0;\\n\\t\\t\\t$setuphold(posedge C, D, 0, 0);\\n\\t\\tendspecify\\n\\nendmodule\\n\\n(* abc9_box, lib_whitebox *)\\n(* keep *)\\nmodule adder_carry(\\n\\t\\toutput wire sumout,\\n\\t\\t(* abc9_carry *)\\n\\t\\toutput wire cout,\\n\\t\\tinput wire p,\\n\\t\\tinput wire g,\\n\\t\\t(* abc9_carry *)\\n\\t\\tinput wire cin\\n);\\n\\t\\tassign sumout = p ^ cin;\\n\\t\\tassign cout = p ? cin : g;\\n\\n\\t\\tspecify\\n\\t\\t\\t\\t(p => sumout) = 35;\\n\\t\\t\\t\\t(g => sumout) = 35;\\n\\t\\t\\t\\t(cin => sumout) = 40;\\n\\t\\t\\t\\t(p => cout) = 67;\\n\\t\\t\\t\\t(g => cout) = 65;\\n\\t\\t\\t\\t(cin => cout) = 69;\\n\\t\\tendspecify\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule dff(\\n\\t\\toutput reg Q,\\n\\t\\tinput wire D,\\n\\t\\t(* clkbuf_sink *)\\n\\t\\tinput wire C\\n);\\n\\t\\tinitial Q = 1'b0;\\n\\n\\t\\talways @(posedge C)\\n\\t\\t\\tQ <= D;\\n\\n\\t\\tspecify\\n\\t\\t\\t(posedge C=>(Q+:D)) = 285;\\n\\t\\t\\t$setuphold(posedge C, D, 56, 0);\\n\\t\\tendspecify\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule dffn(\\n\\t\\toutput reg Q,\\n\\t\\tinput wire D,\\n\\t\\t(* clkbuf_sink *)\\n\\t\\tinput wire C\\n);\\n\\t\\tinitial Q = 1'b0;\\n\\n\\t\\talways @(negedge C)\\n\\t\\t\\tQ <= D;\\n\\n\\t\\tspecify\\n\\t\\t\\t(negedge C=>(Q+:D)) = 285;\\n\\t\\t\\t$setuphold(negedge C, D, 56, 0);\\n\\t\\tendspecify\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule dffsre(\\n\\t\\toutput reg Q,\\n\\t\\tinput wire D,\\n\\t\\t(* clkbuf_sink *)\\n\\t\\tinput wire C,\\n\\t\\tinput wire E,\\n\\t\\tinput wire R,\\n\\t\\tinput wire S\\n);\\n\\t\\tinitial Q = 1'b0;\\n\\n\\t\\talways @(posedge C or negedge S or negedge R)\\n\\t\\t\\tif (!R)\\n\\t\\t\\t\\tQ <= 1'b0;\\n\\t\\t\\telse if (!S)\\n\\t\\t\\t\\tQ <= 1'b1;\\n\\t\\t\\telse if (E)\\n\\t\\t\\t\\tQ <= D;\\n\\n\\t\\tspecify\\n\\t\\t\\t(posedge C => (Q +: D)) = 280;\\n\\t\\t\\t(R => Q) = 0;\\n\\t\\t\\t(S => Q) = 0;\\n\\t\\t\\t$setuphold(posedge C, D, 56, 0);\\n\\t\\t\\t$setuphold(posedge C, E, 32, 0);\\n\\t\\t\\t$setuphold(posedge C, R, 0, 0);\\n\\t\\t\\t$setuphold(posedge C, S, 0, 0);\\n\\t\\t\\t$recrem(posedge R, posedge C, 0, 0);\\n\\t\\t\\t$recrem(posedge S, posedge C, 0, 0);\\n\\t\\tendspecify\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule dffnsre(\\n\\t\\toutput reg Q,\\n\\t\\tinput wire D,\\n\\t\\t(* clkbuf_sink *)\\n\\t\\tinput wire C,\\n\\t\\tinput wire E,\\n\\t\\tinput wire R,\\n\\t\\tinput wire S\\n);\\n\\t\\tinitial Q = 1'b0;\\n\\n\\t\\talways @(negedge C or negedge S or negedge R)\\n\\t\\t\\tif (!R)\\n\\t\\t\\t\\tQ <= 1'b0;\\n\\t\\t\\telse if (!S)\\n\\t\\t\\t\\tQ <= 1'b1;\\n\\t\\t\\telse if (E)\\n\\t\\t\\t\\tQ <= D;\\n\\n\\t\\tspecify\\n\\t\\t\\t(negedge C => (Q +: D)) = 280;\\n\\t\\t\\t(R => Q) = 0;\\n\\t\\t\\t(S => Q) = 0;\\n\\t\\t\\t$setuphold(negedge C, D, 56, 0);\\n\\t\\t\\t$setuphold(negedge C, E, 32, 0);\\n\\t\\t\\t$setuphold(negedge C, R, 0, 0);\\n\\t\\t\\t$setuphold(negedge C, S, 0, 0);\\n\\t\\t\\t$recrem(posedge R, negedge C, 0, 0);\\n\\t\\t\\t$recrem(posedge S, negedge C, 0, 0);\\n\\t\\tendspecify\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule sdffsre(\\n\\t\\toutput reg Q,\\n\\t\\tinput wire D,\\n\\t\\t(* clkbuf_sink *)\\n\\t\\tinput wire C,\\n\\t\\tinput wire E,\\n\\t\\tinput wire R,\\n\\t\\tinput wire S\\n);\\n\\t\\tinitial Q = 1'b0;\\n\\n\\t\\talways @(posedge C)\\n\\t\\t\\tif (!R)\\n\\t\\t\\t\\tQ <= 1'b0;\\n\\t\\t\\telse if (!S)\\n\\t\\t\\t\\tQ <= 1'b1;\\n\\t\\t\\telse if (E)\\n\\t\\t\\t\\tQ <= D;\\n\\n\\t\\tspecify\\n\\t\\t\\t\\t(posedge C => (Q +: D)) = 280;\\n\\t\\t\\t\\t$setuphold(posedge C, D, 56, 0);\\n\\t\\t\\t\\t$setuphold(posedge C, R, 32, 0);\\n\\t\\t\\t\\t$setuphold(posedge C, S, 0, 0);\\n\\t\\t\\t\\t$setuphold(posedge C, E, 0, 0);\\n\\t\\tendspecify\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule sdffnsre(\\n\\t\\toutput reg Q,\\n\\t\\tinput wire D,\\n\\t\\t(* clkbuf_sink *)\\n\\t\\tinput wire C,\\n\\t\\tinput wire E,\\n\\t\\tinput wire R,\\n\\t\\tinput wire S\\n);\\n\\t\\tinitial Q = 1'b0;\\n\\n\\t\\talways @(negedge C)\\n\\t\\t\\tif (!R)\\n\\t\\t\\t\\tQ <= 1'b0;\\n\\t\\t\\telse if (!S)\\n\\t\\t\\t\\tQ <= 1'b1;\\n\\t\\t\\telse if (E)\\n\\t\\t\\t\\tQ <= D;\\n\\n\\t\\tspecify\\n\\t\\t\\t\\t(negedge C => (Q +: D)) = 280;\\n\\t\\t\\t\\t$setuphold(negedge C, D, 56, 0);\\n\\t\\t\\t\\t$setuphold(negedge C, R, 32, 0);\\n\\t\\t\\t\\t$setuphold(negedge C, S, 0, 0);\\n\\t\\t\\t\\t$setuphold(negedge C, E, 0, 0);\\n\\t\\tendspecify\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule latchsre (\\n\\t\\toutput reg Q,\\n\\t\\tinput wire S,\\n\\t\\tinput wire R,\\n\\t\\tinput wire D,\\n\\t\\tinput wire G,\\n\\t\\tinput wire E\\n);\\n\\t\\tinitial Q = 1'b0;\\n\\n\\t\\talways @*\\n\\t\\t\\tbegin\\n\\t\\t\\t\\tif (!R)\\n\\t\\t\\t\\t\\tQ <= 1'b0;\\n\\t\\t\\t\\telse if (!S)\\n\\t\\t\\t\\t\\tQ <= 1'b1;\\n\\t\\t\\t\\telse if (E && G)\\n\\t\\t\\t\\t\\tQ <= D;\\n\\t\\t\\tend\\n\\n\\t\\tspecify\\n\\t\\t\\t(posedge G => (Q +: D)) = 0;\\n\\t\\t\\t$setuphold(posedge G, D, 0, 0);\\n\\t\\t\\t$setuphold(posedge G, E, 0, 0);\\n\\t\\t\\t$setuphold(posedge G, R, 0, 0);\\n\\t\\t\\t$setuphold(posedge G, S, 0, 0);\\n\\t\\tendspecify\\n\\nendmodule\\n\\n(* abc9_flop, lib_whitebox *)\\nmodule latchnsre (\\n\\t\\toutput reg Q,\\n\\t\\tinput wire S,\\n\\t\\tinput wire R,\\n\\t\\tinput wire D,\\n\\t\\tinput wire G,\\n\\t\\tinput wire E\\n);\\n\\t\\tinitial Q = 1'b0;\\n\\n\\t\\talways @*\\n\\t\\t\\tbegin\\n\\t\\t\\t\\tif (!R)\\n\\t\\t\\t\\t\\tQ <= 1'b0;\\n\\t\\t\\t\\telse if (!S)\\n\\t\\t\\t\\t\\tQ <= 1'b1;\\n\\t\\t\\t\\telse if (E && !G)\\n\\t\\t\\t\\t\\tQ <= D;\\n\\t\\t\\tend\\n\\n\\t\\tspecify\\n\\t\\t\\t(negedge G => (Q +: D)) = 0;\\n\\t\\t\\t$setuphold(negedge G, D, 0, 0);\\n\\t\\t\\t$setuphold(negedge G, E, 0, 0);\\n\\t\\t\\t$setuphold(negedge G, R, 0, 0);\\n\\t\\t\\t$setuphold(negedge G, S, 0, 0);\\n\\t\\tendspecify\\n\\nendmodule\\n\\n\",\n                \"dsp_final_map.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\nmodule dsp_t1_20x18x64_cfg_ports (\\n    input  [19:0] a_i,\\n    input  [17:0] b_i,\\n    input  [ 5:0] acc_fir_i,\\n    output [37:0] z_o,\\n    output [17:0] dly_b_o,\\n\\n    input         clock_i,\\n    input         reset_i,\\n\\n    input  [2:0]  feedback_i,\\n    input         load_acc_i,\\n    input         unsigned_a_i,\\n    input         unsigned_b_i,\\n\\n    input  [2:0]  output_select_i,\\n    input         saturate_enable_i,\\n    input  [5:0]  shift_right_i,\\n    input         round_i,\\n    input         subtract_i,\\n    input         register_inputs_i\\n);\\n\\n    parameter [19:0] COEFF_0 = 20'd0;\\n    parameter [19:0] COEFF_1 = 20'd0;\\n    parameter [19:0] COEFF_2 = 20'd0;\\n    parameter [19:0] COEFF_3 = 20'd0;\\n\\n    QL_DSP2 # (\\n        .MODE_BITS          ({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n    ) _TECHMAP_REPLACE_ (\\n        .a                  (a_i),\\n        .b                  (b_i),\\n        .acc_fir            (acc_fir_i),\\n        .z                  (z_o),\\n        .dly_b              (dly_b_o),\\n\\n        .clk                (clock_i),\\n        .reset              (reset_i),\\n\\n        .feedback           (feedback_i),\\n        .load_acc           (load_acc_i),\\n        .unsigned_a         (unsigned_a_i),\\n        .unsigned_b         (unsigned_b_i),\\n\\n        .f_mode             (1'b0), // No fracturation\\n        .output_select      (output_select_i),\\n        .saturate_enable    (saturate_enable_i),\\n        .shift_right        (shift_right_i),\\n        .round              (round_i),\\n        .subtract           (subtract_i),\\n        .register_inputs    (register_inputs_i)\\n    );\\n\\nendmodule\\n\\nmodule dsp_t1_10x9x32_cfg_ports (\\n    input  [ 9:0] a_i,\\n    input  [ 8:0] b_i,\\n    input  [ 5:0] acc_fir_i,\\n    output [18:0] z_o,\\n    output [ 8:0] dly_b_o,\\n\\n    (* clkbuf_sink *)\\n    input         clock_i,\\n    input         reset_i,\\n\\n    input  [2:0]  feedback_i,\\n    input         load_acc_i,\\n    input         unsigned_a_i,\\n    input         unsigned_b_i,\\n\\n    input  [2:0]  output_select_i,\\n    input         saturate_enable_i,\\n    input  [5:0]  shift_right_i,\\n    input         round_i,\\n    input         subtract_i,\\n    input         register_inputs_i\\n);\\n\\n    parameter [9:0] COEFF_0 = 10'd0;\\n    parameter [9:0] COEFF_1 = 10'd0;\\n    parameter [9:0] COEFF_2 = 10'd0;\\n    parameter [9:0] COEFF_3 = 10'd0;\\n\\n    wire [37:0] z;\\n    wire [17:0] dly_b;\\n\\n    QL_DSP2 # (\\n        .MODE_BITS          ({10'd0, COEFF_3,\\n                              10'd0, COEFF_2,\\n                              10'd0, COEFF_1,\\n                              10'd0, COEFF_0})\\n    ) _TECHMAP_REPLACE_ (\\n        .a                  ({10'd0, a_i}),\\n        .b                  ({ 9'd0, b_i}),\\n        .acc_fir            (acc_fir_i),\\n        .z                  (z),\\n        .dly_b              (dly_b),\\n\\n        .clk                (clock_i),\\n        .reset              (reset_i),\\n\\n        .feedback           (feedback_i),\\n        .load_acc           (load_acc_i),\\n        .unsigned_a         (unsigned_a_i),\\n        .unsigned_b         (unsigned_b_i),\\n\\n        .f_mode             (1'b1), // Enable fractuation, Use the lower half\\n        .output_select      (output_select_i),\\n        .saturate_enable    (saturate_enable_i),\\n        .shift_right        (shift_right_i),\\n        .round              (round_i),\\n        .subtract           (subtract_i),\\n        .register_inputs    (register_inputs_i)\\n    );\\n\\n    assign z_o = z[18:0];\\n    assign dly_b_o = dly_b_o[8:0];\\n\\nendmodule\\n\\nmodule dsp_t1_20x18x64_cfg_params (\\n    input  [19:0] a_i,\\n    input  [17:0] b_i,\\n    input  [ 5:0] acc_fir_i,\\n    output [37:0] z_o,\\n    output [17:0] dly_b_o,\\n\\n    input         clock_i,\\n    input         reset_i,\\n\\n    input  [2:0]  feedback_i,\\n    input         load_acc_i,\\n    input         unsigned_a_i,\\n    input         unsigned_b_i,\\n    input         subtract_i\\n);\\n\\n    parameter [19:0] COEFF_0 = 20'd0;\\n    parameter [19:0] COEFF_1 = 20'd0;\\n    parameter [19:0] COEFF_2 = 20'd0;\\n    parameter [19:0] COEFF_3 = 20'd0;\\n\\n    parameter [2:0] OUTPUT_SELECT   = 3'd0;\\n    parameter [0:0] SATURATE_ENABLE = 1'd0;\\n    parameter [5:0] SHIFT_RIGHT     = 6'd0;\\n    parameter [0:0] ROUND           = 1'd0;\\n    parameter [0:0] REGISTER_INPUTS = 1'd0;\\n\\n    QL_DSP3 # (\\n        .MODE_BITS ({\\n            REGISTER_INPUTS,\\n            ROUND,\\n            SHIFT_RIGHT,\\n            SATURATE_ENABLE,\\n            OUTPUT_SELECT,\\n            1'b0, // Not fractured\\n            COEFF_3,\\n            COEFF_2,\\n            COEFF_1,\\n            COEFF_0\\n        })\\n    ) _TECHMAP_REPLACE_ (\\n        .a                  (a_i),\\n        .b                  (b_i),\\n        .acc_fir            (acc_fir_i),\\n        .z                  (z_o),\\n        .dly_b              (dly_b_o),\\n\\n        .clk                (clock_i),\\n        .reset              (reset_i),\\n\\n        .feedback           (feedback_i),\\n        .load_acc           (load_acc_i),\\n        .unsigned_a         (unsigned_a_i),\\n        .unsigned_b         (unsigned_b_i),\\n        .subtract           (subtract_i)\\n    );\\n\\nendmodule\\n\\nmodule dsp_t1_10x9x32_cfg_params (\\n    input  [ 9:0] a_i,\\n    input  [ 8:0] b_i,\\n    input  [ 5:0] acc_fir_i,\\n    output [18:0] z_o,\\n    output [ 8:0] dly_b_o,\\n\\n    (* clkbuf_sink *)\\n    input         clock_i,\\n    input         reset_i,\\n\\n    input  [2:0]  feedback_i,\\n    input         load_acc_i,\\n    input         unsigned_a_i,\\n    input         unsigned_b_i,\\n    input         subtract_i\\n);\\n\\n    parameter [9:0] COEFF_0 = 10'd0;\\n    parameter [9:0] COEFF_1 = 10'd0;\\n    parameter [9:0] COEFF_2 = 10'd0;\\n    parameter [9:0] COEFF_3 = 10'd0;\\n\\n    parameter [2:0] OUTPUT_SELECT   = 3'd0;\\n    parameter [0:0] SATURATE_ENABLE = 1'd0;\\n    parameter [5:0] SHIFT_RIGHT     = 6'd0;\\n    parameter [0:0] ROUND           = 1'd0;\\n    parameter [0:0] REGISTER_INPUTS = 1'd0;\\n\\n    wire [37:0] z;\\n    wire [17:0] dly_b;\\n\\n    QL_DSP3 # (\\n        .MODE_BITS  ({\\n            REGISTER_INPUTS,\\n            ROUND,\\n            SHIFT_RIGHT,\\n            SATURATE_ENABLE,\\n            OUTPUT_SELECT,\\n            1'b1, // Fractured\\n            10'd0, COEFF_3,\\n            10'd0, COEFF_2,\\n            10'd0, COEFF_1,\\n            10'd0, COEFF_0\\n        })\\n    ) _TECHMAP_REPLACE_ (\\n        .a                  ({10'd0, a_i}),\\n        .b                  ({ 9'd0, b_i}),\\n        .acc_fir            (acc_fir_i),\\n        .z                  (z),\\n        .dly_b              (dly_b),\\n\\n        .clk                (clock_i),\\n        .reset              (reset_i),\\n\\n        .feedback           (feedback_i),\\n        .load_acc           (load_acc_i),\\n        .unsigned_a         (unsigned_a_i),\\n        .unsigned_b         (unsigned_b_i),\\n        .subtract           (subtract_i)\\n    );\\n\\n    assign z_o = z[18:0];\\n    assign dly_b_o = dly_b_o[8:0];\\n\\nendmodule\\n\\n\",\n                \"dsp_map.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\nmodule \\\\$__QL_MUL20X18 (input [19:0] A, input [17:0] B, output [37:0] Y);\\n    parameter A_SIGNED = 0;\\n    parameter B_SIGNED = 0;\\n    parameter A_WIDTH = 0;\\n    parameter B_WIDTH = 0;\\n    parameter Y_WIDTH = 0;\\n\\n    wire [19:0] a;\\n    wire [17:0] b;\\n    wire [37:0] z;\\n\\n    assign a = (A_WIDTH == 20) ? A :\\n               (A_SIGNED) ? {{(20 - A_WIDTH){A[A_WIDTH-1]}}, A} :\\n                            {{(20 - A_WIDTH){1'b0}},         A};\\n\\n    assign b = (B_WIDTH == 18) ? B :\\n               (B_SIGNED) ? {{(18 - B_WIDTH){B[B_WIDTH-1]}}, B} :\\n                            {{(18 - B_WIDTH){1'b0}},         B};\\n\\n    (* is_inferred=1 *)\\n    dsp_t1_20x18x64_cfg_ports _TECHMAP_REPLACE_ (\\n        .a_i                (a),\\n        .b_i                (b),\\n        .acc_fir_i          (6'd0),\\n        .z_o                (z),\\n\\n        .feedback_i         (3'd0),\\n        .load_acc_i         (1'b0),\\n        .unsigned_a_i       (!A_SIGNED),\\n        .unsigned_b_i       (!B_SIGNED),\\n\\n        .output_select_i    (3'd0),\\n        .saturate_enable_i  (1'b0),\\n        .shift_right_i      (6'd0),\\n        .round_i            (1'b0),\\n        .subtract_i         (1'b0),\\n        .register_inputs_i  (1'b0)\\n    );\\n\\n    assign Y = z;\\n\\nendmodule\\n\\nmodule \\\\$__QL_MUL10X9 (input [9:0] A, input [8:0] B, output [18:0] Y);\\n    parameter A_SIGNED = 0;\\n    parameter B_SIGNED = 0;\\n    parameter A_WIDTH = 0;\\n    parameter B_WIDTH = 0;\\n    parameter Y_WIDTH = 0;\\n\\n    wire [ 9:0] a;\\n    wire [ 8:0] b;\\n    wire [18:0] z;\\n\\n    assign a = (A_WIDTH == 10) ? A :\\n               (A_SIGNED) ? {{(10 - A_WIDTH){A[A_WIDTH-1]}}, A} :\\n                            {{(10 - A_WIDTH){1'b0}},         A};\\n\\n    assign b = (B_WIDTH ==  9) ? B :\\n               (B_SIGNED) ? {{( 9 - B_WIDTH){B[B_WIDTH-1]}}, B} :\\n                            {{( 9 - B_WIDTH){1'b0}},         B};\\n\\n    (* is_inferred=1 *)\\n    dsp_t1_10x9x32_cfg_ports _TECHMAP_REPLACE_ (\\n        .a_i                (a),\\n        .b_i                (b),\\n        .acc_fir_i          (6'd0),\\n        .z_o                (z),\\n\\n        .feedback_i         (3'd0),\\n        .load_acc_i         (1'b0),\\n        .unsigned_a_i       (!A_SIGNED),\\n        .unsigned_b_i       (!B_SIGNED),\\n\\n        .output_select_i    (3'd0),\\n        .saturate_enable_i  (1'b0),\\n        .shift_right_i      (6'd0),\\n        .round_i            (1'b0),\\n        .subtract_i         (1'b0),\\n        .register_inputs_i  (1'b0)\\n    );\\n\\n\\n    assign Y = z;\\n\\nendmodule\\n\",\n                \"dsp_sim.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\n`timescale 1ps/1ps\\n\\n`default_nettype none\\n\\n(* blackbox *)\\nmodule QL_DSP1 (\\n\\tinput wire [19:0] a,\\n\\tinput wire [17:0] b,\\n\\t(* clkbuf_sink *)\\n\\tinput wire clk0,\\n\\t(* clkbuf_sink *)\\n\\tinput wire clk1,\\n\\tinput wire [ 1:0] feedback0,\\n\\tinput wire [ 1:0] feedback1,\\n\\tinput wire        load_acc0,\\n\\tinput wire        load_acc1,\\n\\tinput wire        reset0,\\n\\tinput wire        reset1,\\n\\toutput reg [37:0] z\\n);\\n\\tparameter MODE_BITS = 27'b00000000000000000000000000;\\nendmodule  /* QL_DSP1 */\\n\\n\\n\\n// ---------------------------------------- //\\n// ----- DSP cells simulation modules ----- //\\n// --------- Control bits in ports -------- //\\n// ---------------------------------------- //\\n\\nmodule QL_DSP2 ( // TODO: Name subject to change\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\tinput  wire [ 5:0] acc_fir,\\n\\toutput wire [37:0] z,\\n\\toutput wire [17:0] dly_b,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire       clk,\\n\\tinput  wire       reset,\\n\\n\\tinput  wire [2:0] feedback,\\n\\tinput  wire       load_acc,\\n\\tinput  wire       unsigned_a,\\n\\tinput  wire       unsigned_b,\\n\\n\\tinput  wire       f_mode,\\n\\tinput  wire [2:0] output_select,\\n\\tinput  wire       saturate_enable,\\n\\tinput  wire [5:0] shift_right,\\n\\tinput  wire       round,\\n\\tinput  wire       subtract,\\n\\tinput  wire       register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tlocalparam NBITS_ACC = 64;\\n\\tlocalparam NBITS_A = 20;\\n\\tlocalparam NBITS_B = 18;\\n\\tlocalparam NBITS_Z = 38;\\n\\n\\twire [NBITS_Z-1:0] dsp_full_z;\\n\\twire [(NBITS_Z/2)-1:0] dsp_frac0_z;\\n\\twire [(NBITS_Z/2)-1:0] dsp_frac1_z;\\n\\n\\twire [NBITS_B-1:0] dsp_full_dly_b;\\n\\twire [(NBITS_B/2)-1:0] dsp_frac0_dly_b;\\n\\twire [(NBITS_B/2)-1:0] dsp_frac1_dly_b;\\n\\n\\tassign z = f_mode ? {dsp_frac1_z, dsp_frac0_z} : dsp_full_z;\\n\\tassign dly_b = f_mode ? {dsp_frac1_dly_b, dsp_frac0_dly_b} : dsp_full_dly_b;\\n\\n\\t// Output used when fmode == 1\\n\\t\\tdsp_t1_sim_cfg_ports #(\\n\\t\\t.NBITS_A(NBITS_A/2),\\n\\t\\t\\t.NBITS_B(NBITS_B/2),\\n\\t\\t\\t.NBITS_ACC(NBITS_ACC/2),\\n\\t\\t\\t.NBITS_Z(NBITS_Z/2)\\n\\t\\t) dsp_frac0 (\\n\\t\\t\\t.a_i(a[(NBITS_A/2)-1:0]),\\n\\t\\t\\t.b_i(b[(NBITS_B/2)-1:0]),\\n\\t\\t\\t.z_o(dsp_frac0_z),\\n\\t\\t\\t.dly_b_o(dsp_frac0_dly_b),\\n\\n\\t\\t\\t.acc_fir_i(acc_fir),\\n\\t\\t\\t.feedback_i(feedback),\\n\\t\\t\\t.load_acc_i(load_acc),\\n\\n\\t\\t\\t.unsigned_a_i(unsigned_a),\\n\\t\\t\\t.unsigned_b_i(unsigned_b),\\n\\n\\t\\t\\t.clock_i(clk),\\n\\t\\t\\t.s_reset(reset),\\n\\n\\t\\t\\t.saturate_enable_i(saturate_enable),\\n\\t\\t\\t.output_select_i(output_select),\\n\\t\\t\\t.round_i(round),\\n\\t\\t\\t.shift_right_i(shift_right),\\n\\t\\t\\t.subtract_i(subtract),\\n\\t\\t\\t.register_inputs_i(register_inputs),\\n\\t\\t\\t.coef_0_i(COEFF_0[(NBITS_A/2)-1:0]),\\n\\t\\t\\t.coef_1_i(COEFF_1[(NBITS_A/2)-1:0]),\\n\\t\\t\\t.coef_2_i(COEFF_2[(NBITS_A/2)-1:0]),\\n\\t\\t\\t.coef_3_i(COEFF_3[(NBITS_A/2)-1:0])\\n\\t\\t);\\n\\n\\t// Output used when fmode == 1\\n\\t\\tdsp_t1_sim_cfg_ports #(\\n\\t\\t.NBITS_A(NBITS_A/2),\\n\\t\\t\\t.NBITS_B(NBITS_B/2),\\n\\t\\t\\t.NBITS_ACC(NBITS_ACC/2),\\n\\t\\t\\t.NBITS_Z(NBITS_Z/2)\\n\\t\\t) dsp_frac1 (\\n\\t\\t\\t.a_i(a[NBITS_A-1:NBITS_A/2]),\\n\\t\\t\\t.b_i(b[NBITS_B-1:NBITS_B/2]),\\n\\t\\t\\t.z_o(dsp_frac1_z),\\n\\t\\t\\t.dly_b_o(dsp_frac1_dly_b),\\n\\n\\t\\t\\t.acc_fir_i(acc_fir),\\n\\t\\t\\t.feedback_i(feedback),\\n\\t\\t\\t.load_acc_i(load_acc),\\n\\n\\t\\t\\t.unsigned_a_i(unsigned_a),\\n\\t\\t\\t.unsigned_b_i(unsigned_b),\\n\\n\\t\\t\\t.clock_i(clk),\\n\\t\\t\\t.s_reset(reset),\\n\\n\\t\\t\\t.saturate_enable_i(saturate_enable),\\n\\t\\t\\t.output_select_i(output_select),\\n\\t\\t\\t.round_i(round),\\n\\t\\t\\t.shift_right_i(shift_right),\\n\\t\\t\\t.subtract_i(subtract),\\n\\t\\t\\t.register_inputs_i(register_inputs),\\n\\t\\t\\t.coef_0_i(COEFF_0[NBITS_A-1:NBITS_A/2]),\\n\\t\\t\\t.coef_1_i(COEFF_1[NBITS_A-1:NBITS_A/2]),\\n\\t\\t\\t.coef_2_i(COEFF_2[NBITS_A-1:NBITS_A/2]),\\n\\t\\t\\t.coef_3_i(COEFF_3[NBITS_A-1:NBITS_A/2])\\n\\t\\t);\\n\\n\\t// Output used when fmode == 0\\n\\t\\tdsp_t1_sim_cfg_ports #(\\n\\t\\t\\t.NBITS_A(NBITS_A),\\n\\t\\t\\t.NBITS_B(NBITS_B),\\n\\t\\t\\t.NBITS_ACC(NBITS_ACC),\\n\\t\\t\\t.NBITS_Z(NBITS_Z)\\n\\t\\t) dsp_full (\\n\\t\\t\\t.a_i(a),\\n\\t\\t\\t.b_i(b),\\n\\t\\t\\t.z_o(dsp_full_z),\\n\\t\\t\\t.dly_b_o(dsp_full_dly_b),\\n\\n\\t\\t\\t.acc_fir_i(acc_fir),\\n\\t\\t\\t.feedback_i(feedback),\\n\\t\\t\\t.load_acc_i(load_acc),\\n\\n\\t\\t\\t.unsigned_a_i(unsigned_a),\\n\\t\\t\\t.unsigned_b_i(unsigned_b),\\n\\n\\t\\t\\t.clock_i(clk),\\n\\t\\t\\t.s_reset(reset),\\n\\n\\t\\t\\t.saturate_enable_i(saturate_enable),\\n\\t\\t\\t.output_select_i(output_select),\\n\\t\\t\\t.round_i(round),\\n\\t\\t\\t.shift_right_i(shift_right),\\n\\t\\t\\t.subtract_i(subtract),\\n\\t\\t\\t.register_inputs_i(register_inputs),\\n\\t\\t\\t.coef_0_i(COEFF_0),\\n\\t\\t\\t.coef_1_i(COEFF_1),\\n\\t\\t\\t.coef_2_i(COEFF_2),\\n\\t\\t\\t.coef_3_i(COEFF_3)\\n\\t\\t);\\nendmodule\\n\\nmodule QL_DSP2_MULT ( // TODO: Name subject to change\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\tinput  wire       reset,\\n\\n\\tinput  wire [2:0] feedback,\\n\\tinput  wire       unsigned_a,\\n\\tinput  wire       unsigned_b,\\n\\n\\tinput  wire       f_mode,\\n\\tinput  wire [2:0] output_select,\\n\\tinput  wire       register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.acc_fir(6'b0),\\n\\t\\t.z(z),\\n\\t\\t.dly_b(),\\n\\n\\t\\t.clk(1'b0),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.load_acc(1'b0),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.output_select(output_select),      // unregistered output: a * b (0)\\n\\t\\t.saturate_enable(1'b0),\\n\\t\\t.shift_right(6'b0),\\n\\t\\t.round(1'b0),\\n\\t\\t.subtract(1'b0),\\n\\t\\t.register_inputs(register_inputs)   // unregistered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(a[0] => z[0]) = 0;\\n\\t\\t(a[1] => z[0]) = 0;\\n\\t\\t(a[2] => z[0]) = 0;\\n\\t\\t(a[3] => z[0]) = 0;\\n\\t\\t(a[4] => z[0]) = 0;\\n\\t\\t(a[5] => z[0]) = 0;\\n\\t\\t(a[6] => z[0]) = 0;\\n\\t\\t(a[7] => z[0]) = 0;\\n\\t\\t(a[8] => z[0]) = 0;\\n\\t\\t(a[9] => z[0]) = 0;\\n\\t\\t(a[10] => z[0]) = 0;\\n\\t\\t(a[11] => z[0]) = 0;\\n\\t\\t(a[12] => z[0]) = 0;\\n\\t\\t(a[13] => z[0]) = 0;\\n\\t\\t(a[14] => z[0]) = 0;\\n\\t\\t(a[15] => z[0]) = 0;\\n\\t\\t(a[16] => z[0]) = 0;\\n\\t\\t(a[17] => z[0]) = 0;\\n\\t\\t(a[18] => z[0]) = 0;\\n\\t\\t(a[19] => z[0]) = 0;\\n\\t\\t(b[0] => z[0]) = 0;\\n\\t\\t(b[1] => z[0]) = 0;\\n\\t\\t(b[2] => z[0]) = 0;\\n\\t\\t(b[3] => z[0]) = 0;\\n\\t\\t(b[4] => z[0]) = 0;\\n\\t\\t(b[5] => z[0]) = 0;\\n\\t\\t(b[6] => z[0]) = 0;\\n\\t\\t(b[7] => z[0]) = 0;\\n\\t\\t(b[8] => z[0]) = 0;\\n\\t\\t(b[9] => z[0]) = 0;\\n\\t\\t(b[10] => z[0]) = 0;\\n\\t\\t(b[11] => z[0]) = 0;\\n\\t\\t(b[12] => z[0]) = 0;\\n\\t\\t(b[13] => z[0]) = 0;\\n\\t\\t(b[14] => z[0]) = 0;\\n\\t\\t(b[15] => z[0]) = 0;\\n\\t\\t(b[16] => z[0]) = 0;\\n\\t\\t(b[17] => z[0]) = 0;\\n\\t\\t(a[0] => z[1]) = 0;\\n\\t\\t(a[1] => z[1]) = 0;\\n\\t\\t(a[2] => z[1]) = 0;\\n\\t\\t(a[3] => z[1]) = 0;\\n\\t\\t(a[4] => z[1]) = 0;\\n\\t\\t(a[5] => z[1]) = 0;\\n\\t\\t(a[6] => z[1]) = 0;\\n\\t\\t(a[7] => z[1]) = 0;\\n\\t\\t(a[8] => z[1]) = 0;\\n\\t\\t(a[9] => z[1]) = 0;\\n\\t\\t(a[10] => z[1]) = 0;\\n\\t\\t(a[11] => z[1]) = 0;\\n\\t\\t(a[12] => z[1]) = 0;\\n\\t\\t(a[13] => z[1]) = 0;\\n\\t\\t(a[14] => z[1]) = 0;\\n\\t\\t(a[15] => z[1]) = 0;\\n\\t\\t(a[16] => z[1]) = 0;\\n\\t\\t(a[17] => z[1]) = 0;\\n\\t\\t(a[18] => z[1]) = 0;\\n\\t\\t(a[19] => z[1]) = 0;\\n\\t\\t(b[0] => z[1]) = 0;\\n\\t\\t(b[1] => z[1]) = 0;\\n\\t\\t(b[2] => z[1]) = 0;\\n\\t\\t(b[3] => z[1]) = 0;\\n\\t\\t(b[4] => z[1]) = 0;\\n\\t\\t(b[5] => z[1]) = 0;\\n\\t\\t(b[6] => z[1]) = 0;\\n\\t\\t(b[7] => z[1]) = 0;\\n\\t\\t(b[8] => z[1]) = 0;\\n\\t\\t(b[9] => z[1]) = 0;\\n\\t\\t(b[10] => z[1]) = 0;\\n\\t\\t(b[11] => z[1]) = 0;\\n\\t\\t(b[12] => z[1]) = 0;\\n\\t\\t(b[13] => z[1]) = 0;\\n\\t\\t(b[14] => z[1]) = 0;\\n\\t\\t(b[15] => z[1]) = 0;\\n\\t\\t(b[16] => z[1]) = 0;\\n\\t\\t(b[17] => z[1]) = 0;\\n\\t\\t(a[0] => z[2]) = 0;\\n\\t\\t(a[1] => z[2]) = 0;\\n\\t\\t(a[2] => z[2]) = 0;\\n\\t\\t(a[3] => z[2]) = 0;\\n\\t\\t(a[4] => z[2]) = 0;\\n\\t\\t(a[5] => z[2]) = 0;\\n\\t\\t(a[6] => z[2]) = 0;\\n\\t\\t(a[7] => z[2]) = 0;\\n\\t\\t(a[8] => z[2]) = 0;\\n\\t\\t(a[9] => z[2]) = 0;\\n\\t\\t(a[10] => z[2]) = 0;\\n\\t\\t(a[11] => z[2]) = 0;\\n\\t\\t(a[12] => z[2]) = 0;\\n\\t\\t(a[13] => z[2]) = 0;\\n\\t\\t(a[14] => z[2]) = 0;\\n\\t\\t(a[15] => z[2]) = 0;\\n\\t\\t(a[16] => z[2]) = 0;\\n\\t\\t(a[17] => z[2]) = 0;\\n\\t\\t(a[18] => z[2]) = 0;\\n\\t\\t(a[19] => z[2]) = 0;\\n\\t\\t(b[0] => z[2]) = 0;\\n\\t\\t(b[1] => z[2]) = 0;\\n\\t\\t(b[2] => z[2]) = 0;\\n\\t\\t(b[3] => z[2]) = 0;\\n\\t\\t(b[4] => z[2]) = 0;\\n\\t\\t(b[5] => z[2]) = 0;\\n\\t\\t(b[6] => z[2]) = 0;\\n\\t\\t(b[7] => z[2]) = 0;\\n\\t\\t(b[8] => z[2]) = 0;\\n\\t\\t(b[9] => z[2]) = 0;\\n\\t\\t(b[10] => z[2]) = 0;\\n\\t\\t(b[11] => z[2]) = 0;\\n\\t\\t(b[12] => z[2]) = 0;\\n\\t\\t(b[13] => z[2]) = 0;\\n\\t\\t(b[14] => z[2]) = 0;\\n\\t\\t(b[15] => z[2]) = 0;\\n\\t\\t(b[16] => z[2]) = 0;\\n\\t\\t(b[17] => z[2]) = 0;\\n\\t\\t(a[0] => z[3]) = 0;\\n\\t\\t(a[1] => z[3]) = 0;\\n\\t\\t(a[2] => z[3]) = 0;\\n\\t\\t(a[3] => z[3]) = 0;\\n\\t\\t(a[4] => z[3]) = 0;\\n\\t\\t(a[5] => z[3]) = 0;\\n\\t\\t(a[6] => z[3]) = 0;\\n\\t\\t(a[7] => z[3]) = 0;\\n\\t\\t(a[8] => z[3]) = 0;\\n\\t\\t(a[9] => z[3]) = 0;\\n\\t\\t(a[10] => z[3]) = 0;\\n\\t\\t(a[11] => z[3]) = 0;\\n\\t\\t(a[12] => z[3]) = 0;\\n\\t\\t(a[13] => z[3]) = 0;\\n\\t\\t(a[14] => z[3]) = 0;\\n\\t\\t(a[15] => z[3]) = 0;\\n\\t\\t(a[16] => z[3]) = 0;\\n\\t\\t(a[17] => z[3]) = 0;\\n\\t\\t(a[18] => z[3]) = 0;\\n\\t\\t(a[19] => z[3]) = 0;\\n\\t\\t(b[0] => z[3]) = 0;\\n\\t\\t(b[1] => z[3]) = 0;\\n\\t\\t(b[2] => z[3]) = 0;\\n\\t\\t(b[3] => z[3]) = 0;\\n\\t\\t(b[4] => z[3]) = 0;\\n\\t\\t(b[5] => z[3]) = 0;\\n\\t\\t(b[6] => z[3]) = 0;\\n\\t\\t(b[7] => z[3]) = 0;\\n\\t\\t(b[8] => z[3]) = 0;\\n\\t\\t(b[9] => z[3]) = 0;\\n\\t\\t(b[10] => z[3]) = 0;\\n\\t\\t(b[11] => z[3]) = 0;\\n\\t\\t(b[12] => z[3]) = 0;\\n\\t\\t(b[13] => z[3]) = 0;\\n\\t\\t(b[14] => z[3]) = 0;\\n\\t\\t(b[15] => z[3]) = 0;\\n\\t\\t(b[16] => z[3]) = 0;\\n\\t\\t(b[17] => z[3]) = 0;\\n\\t\\t(a[0] => z[4]) = 0;\\n\\t\\t(a[1] => z[4]) = 0;\\n\\t\\t(a[2] => z[4]) = 0;\\n\\t\\t(a[3] => z[4]) = 0;\\n\\t\\t(a[4] => z[4]) = 0;\\n\\t\\t(a[5] => z[4]) = 0;\\n\\t\\t(a[6] => z[4]) = 0;\\n\\t\\t(a[7] => z[4]) = 0;\\n\\t\\t(a[8] => z[4]) = 0;\\n\\t\\t(a[9] => z[4]) = 0;\\n\\t\\t(a[10] => z[4]) = 0;\\n\\t\\t(a[11] => z[4]) = 0;\\n\\t\\t(a[12] => z[4]) = 0;\\n\\t\\t(a[13] => z[4]) = 0;\\n\\t\\t(a[14] => z[4]) = 0;\\n\\t\\t(a[15] => z[4]) = 0;\\n\\t\\t(a[16] => z[4]) = 0;\\n\\t\\t(a[17] => z[4]) = 0;\\n\\t\\t(a[18] => z[4]) = 0;\\n\\t\\t(a[19] => z[4]) = 0;\\n\\t\\t(b[0] => z[4]) = 0;\\n\\t\\t(b[1] => z[4]) = 0;\\n\\t\\t(b[2] => z[4]) = 0;\\n\\t\\t(b[3] => z[4]) = 0;\\n\\t\\t(b[4] => z[4]) = 0;\\n\\t\\t(b[5] => z[4]) = 0;\\n\\t\\t(b[6] => z[4]) = 0;\\n\\t\\t(b[7] => z[4]) = 0;\\n\\t\\t(b[8] => z[4]) = 0;\\n\\t\\t(b[9] => z[4]) = 0;\\n\\t\\t(b[10] => z[4]) = 0;\\n\\t\\t(b[11] => z[4]) = 0;\\n\\t\\t(b[12] => z[4]) = 0;\\n\\t\\t(b[13] => z[4]) = 0;\\n\\t\\t(b[14] => z[4]) = 0;\\n\\t\\t(b[15] => z[4]) = 0;\\n\\t\\t(b[16] => z[4]) = 0;\\n\\t\\t(b[17] => z[4]) = 0;\\n\\t\\t(a[0] => z[5]) = 0;\\n\\t\\t(a[1] => z[5]) = 0;\\n\\t\\t(a[2] => z[5]) = 0;\\n\\t\\t(a[3] => z[5]) = 0;\\n\\t\\t(a[4] => z[5]) = 0;\\n\\t\\t(a[5] => z[5]) = 0;\\n\\t\\t(a[6] => z[5]) = 0;\\n\\t\\t(a[7] => z[5]) = 0;\\n\\t\\t(a[8] => z[5]) = 0;\\n\\t\\t(a[9] => z[5]) = 0;\\n\\t\\t(a[10] => z[5]) = 0;\\n\\t\\t(a[11] => z[5]) = 0;\\n\\t\\t(a[12] => z[5]) = 0;\\n\\t\\t(a[13] => z[5]) = 0;\\n\\t\\t(a[14] => z[5]) = 0;\\n\\t\\t(a[15] => z[5]) = 0;\\n\\t\\t(a[16] => z[5]) = 0;\\n\\t\\t(a[17] => z[5]) = 0;\\n\\t\\t(a[18] => z[5]) = 0;\\n\\t\\t(a[19] => z[5]) = 0;\\n\\t\\t(b[0] => z[5]) = 0;\\n\\t\\t(b[1] => z[5]) = 0;\\n\\t\\t(b[2] => z[5]) = 0;\\n\\t\\t(b[3] => z[5]) = 0;\\n\\t\\t(b[4] => z[5]) = 0;\\n\\t\\t(b[5] => z[5]) = 0;\\n\\t\\t(b[6] => z[5]) = 0;\\n\\t\\t(b[7] => z[5]) = 0;\\n\\t\\t(b[8] => z[5]) = 0;\\n\\t\\t(b[9] => z[5]) = 0;\\n\\t\\t(b[10] => z[5]) = 0;\\n\\t\\t(b[11] => z[5]) = 0;\\n\\t\\t(b[12] => z[5]) = 0;\\n\\t\\t(b[13] => z[5]) = 0;\\n\\t\\t(b[14] => z[5]) = 0;\\n\\t\\t(b[15] => z[5]) = 0;\\n\\t\\t(b[16] => z[5]) = 0;\\n\\t\\t(b[17] => z[5]) = 0;\\n\\t\\t(a[0] => z[6]) = 0;\\n\\t\\t(a[1] => z[6]) = 0;\\n\\t\\t(a[2] => z[6]) = 0;\\n\\t\\t(a[3] => z[6]) = 0;\\n\\t\\t(a[4] => z[6]) = 0;\\n\\t\\t(a[5] => z[6]) = 0;\\n\\t\\t(a[6] => z[6]) = 0;\\n\\t\\t(a[7] => z[6]) = 0;\\n\\t\\t(a[8] => z[6]) = 0;\\n\\t\\t(a[9] => z[6]) = 0;\\n\\t\\t(a[10] => z[6]) = 0;\\n\\t\\t(a[11] => z[6]) = 0;\\n\\t\\t(a[12] => z[6]) = 0;\\n\\t\\t(a[13] => z[6]) = 0;\\n\\t\\t(a[14] => z[6]) = 0;\\n\\t\\t(a[15] => z[6]) = 0;\\n\\t\\t(a[16] => z[6]) = 0;\\n\\t\\t(a[17] => z[6]) = 0;\\n\\t\\t(a[18] => z[6]) = 0;\\n\\t\\t(a[19] => z[6]) = 0;\\n\\t\\t(b[0] => z[6]) = 0;\\n\\t\\t(b[1] => z[6]) = 0;\\n\\t\\t(b[2] => z[6]) = 0;\\n\\t\\t(b[3] => z[6]) = 0;\\n\\t\\t(b[4] => z[6]) = 0;\\n\\t\\t(b[5] => z[6]) = 0;\\n\\t\\t(b[6] => z[6]) = 0;\\n\\t\\t(b[7] => z[6]) = 0;\\n\\t\\t(b[8] => z[6]) = 0;\\n\\t\\t(b[9] => z[6]) = 0;\\n\\t\\t(b[10] => z[6]) = 0;\\n\\t\\t(b[11] => z[6]) = 0;\\n\\t\\t(b[12] => z[6]) = 0;\\n\\t\\t(b[13] => z[6]) = 0;\\n\\t\\t(b[14] => z[6]) = 0;\\n\\t\\t(b[15] => z[6]) = 0;\\n\\t\\t(b[16] => z[6]) = 0;\\n\\t\\t(b[17] => z[6]) = 0;\\n\\t\\t(a[0] => z[7]) = 0;\\n\\t\\t(a[1] => z[7]) = 0;\\n\\t\\t(a[2] => z[7]) = 0;\\n\\t\\t(a[3] => z[7]) = 0;\\n\\t\\t(a[4] => z[7]) = 0;\\n\\t\\t(a[5] => z[7]) = 0;\\n\\t\\t(a[6] => z[7]) = 0;\\n\\t\\t(a[7] => z[7]) = 0;\\n\\t\\t(a[8] => z[7]) = 0;\\n\\t\\t(a[9] => z[7]) = 0;\\n\\t\\t(a[10] => z[7]) = 0;\\n\\t\\t(a[11] => z[7]) = 0;\\n\\t\\t(a[12] => z[7]) = 0;\\n\\t\\t(a[13] => z[7]) = 0;\\n\\t\\t(a[14] => z[7]) = 0;\\n\\t\\t(a[15] => z[7]) = 0;\\n\\t\\t(a[16] => z[7]) = 0;\\n\\t\\t(a[17] => z[7]) = 0;\\n\\t\\t(a[18] => z[7]) = 0;\\n\\t\\t(a[19] => z[7]) = 0;\\n\\t\\t(b[0] => z[7]) = 0;\\n\\t\\t(b[1] => z[7]) = 0;\\n\\t\\t(b[2] => z[7]) = 0;\\n\\t\\t(b[3] => z[7]) = 0;\\n\\t\\t(b[4] => z[7]) = 0;\\n\\t\\t(b[5] => z[7]) = 0;\\n\\t\\t(b[6] => z[7]) = 0;\\n\\t\\t(b[7] => z[7]) = 0;\\n\\t\\t(b[8] => z[7]) = 0;\\n\\t\\t(b[9] => z[7]) = 0;\\n\\t\\t(b[10] => z[7]) = 0;\\n\\t\\t(b[11] => z[7]) = 0;\\n\\t\\t(b[12] => z[7]) = 0;\\n\\t\\t(b[13] => z[7]) = 0;\\n\\t\\t(b[14] => z[7]) = 0;\\n\\t\\t(b[15] => z[7]) = 0;\\n\\t\\t(b[16] => z[7]) = 0;\\n\\t\\t(b[17] => z[7]) = 0;\\n\\t\\t(a[0] => z[8]) = 0;\\n\\t\\t(a[1] => z[8]) = 0;\\n\\t\\t(a[2] => z[8]) = 0;\\n\\t\\t(a[3] => z[8]) = 0;\\n\\t\\t(a[4] => z[8]) = 0;\\n\\t\\t(a[5] => z[8]) = 0;\\n\\t\\t(a[6] => z[8]) = 0;\\n\\t\\t(a[7] => z[8]) = 0;\\n\\t\\t(a[8] => z[8]) = 0;\\n\\t\\t(a[9] => z[8]) = 0;\\n\\t\\t(a[10] => z[8]) = 0;\\n\\t\\t(a[11] => z[8]) = 0;\\n\\t\\t(a[12] => z[8]) = 0;\\n\\t\\t(a[13] => z[8]) = 0;\\n\\t\\t(a[14] => z[8]) = 0;\\n\\t\\t(a[15] => z[8]) = 0;\\n\\t\\t(a[16] => z[8]) = 0;\\n\\t\\t(a[17] => z[8]) = 0;\\n\\t\\t(a[18] => z[8]) = 0;\\n\\t\\t(a[19] => z[8]) = 0;\\n\\t\\t(b[0] => z[8]) = 0;\\n\\t\\t(b[1] => z[8]) = 0;\\n\\t\\t(b[2] => z[8]) = 0;\\n\\t\\t(b[3] => z[8]) = 0;\\n\\t\\t(b[4] => z[8]) = 0;\\n\\t\\t(b[5] => z[8]) = 0;\\n\\t\\t(b[6] => z[8]) = 0;\\n\\t\\t(b[7] => z[8]) = 0;\\n\\t\\t(b[8] => z[8]) = 0;\\n\\t\\t(b[9] => z[8]) = 0;\\n\\t\\t(b[10] => z[8]) = 0;\\n\\t\\t(b[11] => z[8]) = 0;\\n\\t\\t(b[12] => z[8]) = 0;\\n\\t\\t(b[13] => z[8]) = 0;\\n\\t\\t(b[14] => z[8]) = 0;\\n\\t\\t(b[15] => z[8]) = 0;\\n\\t\\t(b[16] => z[8]) = 0;\\n\\t\\t(b[17] => z[8]) = 0;\\n\\t\\t(a[0] => z[9]) = 0;\\n\\t\\t(a[1] => z[9]) = 0;\\n\\t\\t(a[2] => z[9]) = 0;\\n\\t\\t(a[3] => z[9]) = 0;\\n\\t\\t(a[4] => z[9]) = 0;\\n\\t\\t(a[5] => z[9]) = 0;\\n\\t\\t(a[6] => z[9]) = 0;\\n\\t\\t(a[7] => z[9]) = 0;\\n\\t\\t(a[8] => z[9]) = 0;\\n\\t\\t(a[9] => z[9]) = 0;\\n\\t\\t(a[10] => z[9]) = 0;\\n\\t\\t(a[11] => z[9]) = 0;\\n\\t\\t(a[12] => z[9]) = 0;\\n\\t\\t(a[13] => z[9]) = 0;\\n\\t\\t(a[14] => z[9]) = 0;\\n\\t\\t(a[15] => z[9]) = 0;\\n\\t\\t(a[16] => z[9]) = 0;\\n\\t\\t(a[17] => z[9]) = 0;\\n\\t\\t(a[18] => z[9]) = 0;\\n\\t\\t(a[19] => z[9]) = 0;\\n\\t\\t(b[0] => z[9]) = 0;\\n\\t\\t(b[1] => z[9]) = 0;\\n\\t\\t(b[2] => z[9]) = 0;\\n\\t\\t(b[3] => z[9]) = 0;\\n\\t\\t(b[4] => z[9]) = 0;\\n\\t\\t(b[5] => z[9]) = 0;\\n\\t\\t(b[6] => z[9]) = 0;\\n\\t\\t(b[7] => z[9]) = 0;\\n\\t\\t(b[8] => z[9]) = 0;\\n\\t\\t(b[9] => z[9]) = 0;\\n\\t\\t(b[10] => z[9]) = 0;\\n\\t\\t(b[11] => z[9]) = 0;\\n\\t\\t(b[12] => z[9]) = 0;\\n\\t\\t(b[13] => z[9]) = 0;\\n\\t\\t(b[14] => z[9]) = 0;\\n\\t\\t(b[15] => z[9]) = 0;\\n\\t\\t(b[16] => z[9]) = 0;\\n\\t\\t(b[17] => z[9]) = 0;\\n\\t\\t(a[0] => z[10]) = 0;\\n\\t\\t(a[1] => z[10]) = 0;\\n\\t\\t(a[2] => z[10]) = 0;\\n\\t\\t(a[3] => z[10]) = 0;\\n\\t\\t(a[4] => z[10]) = 0;\\n\\t\\t(a[5] => z[10]) = 0;\\n\\t\\t(a[6] => z[10]) = 0;\\n\\t\\t(a[7] => z[10]) = 0;\\n\\t\\t(a[8] => z[10]) = 0;\\n\\t\\t(a[9] => z[10]) = 0;\\n\\t\\t(a[10] => z[10]) = 0;\\n\\t\\t(a[11] => z[10]) = 0;\\n\\t\\t(a[12] => z[10]) = 0;\\n\\t\\t(a[13] => z[10]) = 0;\\n\\t\\t(a[14] => z[10]) = 0;\\n\\t\\t(a[15] => z[10]) = 0;\\n\\t\\t(a[16] => z[10]) = 0;\\n\\t\\t(a[17] => z[10]) = 0;\\n\\t\\t(a[18] => z[10]) = 0;\\n\\t\\t(a[19] => z[10]) = 0;\\n\\t\\t(b[0] => z[10]) = 0;\\n\\t\\t(b[1] => z[10]) = 0;\\n\\t\\t(b[2] => z[10]) = 0;\\n\\t\\t(b[3] => z[10]) = 0;\\n\\t\\t(b[4] => z[10]) = 0;\\n\\t\\t(b[5] => z[10]) = 0;\\n\\t\\t(b[6] => z[10]) = 0;\\n\\t\\t(b[7] => z[10]) = 0;\\n\\t\\t(b[8] => z[10]) = 0;\\n\\t\\t(b[9] => z[10]) = 0;\\n\\t\\t(b[10] => z[10]) = 0;\\n\\t\\t(b[11] => z[10]) = 0;\\n\\t\\t(b[12] => z[10]) = 0;\\n\\t\\t(b[13] => z[10]) = 0;\\n\\t\\t(b[14] => z[10]) = 0;\\n\\t\\t(b[15] => z[10]) = 0;\\n\\t\\t(b[16] => z[10]) = 0;\\n\\t\\t(b[17] => z[10]) = 0;\\n\\t\\t(a[0] => z[11]) = 0;\\n\\t\\t(a[1] => z[11]) = 0;\\n\\t\\t(a[2] => z[11]) = 0;\\n\\t\\t(a[3] => z[11]) = 0;\\n\\t\\t(a[4] => z[11]) = 0;\\n\\t\\t(a[5] => z[11]) = 0;\\n\\t\\t(a[6] => z[11]) = 0;\\n\\t\\t(a[7] => z[11]) = 0;\\n\\t\\t(a[8] => z[11]) = 0;\\n\\t\\t(a[9] => z[11]) = 0;\\n\\t\\t(a[10] => z[11]) = 0;\\n\\t\\t(a[11] => z[11]) = 0;\\n\\t\\t(a[12] => z[11]) = 0;\\n\\t\\t(a[13] => z[11]) = 0;\\n\\t\\t(a[14] => z[11]) = 0;\\n\\t\\t(a[15] => z[11]) = 0;\\n\\t\\t(a[16] => z[11]) = 0;\\n\\t\\t(a[17] => z[11]) = 0;\\n\\t\\t(a[18] => z[11]) = 0;\\n\\t\\t(a[19] => z[11]) = 0;\\n\\t\\t(b[0] => z[11]) = 0;\\n\\t\\t(b[1] => z[11]) = 0;\\n\\t\\t(b[2] => z[11]) = 0;\\n\\t\\t(b[3] => z[11]) = 0;\\n\\t\\t(b[4] => z[11]) = 0;\\n\\t\\t(b[5] => z[11]) = 0;\\n\\t\\t(b[6] => z[11]) = 0;\\n\\t\\t(b[7] => z[11]) = 0;\\n\\t\\t(b[8] => z[11]) = 0;\\n\\t\\t(b[9] => z[11]) = 0;\\n\\t\\t(b[10] => z[11]) = 0;\\n\\t\\t(b[11] => z[11]) = 0;\\n\\t\\t(b[12] => z[11]) = 0;\\n\\t\\t(b[13] => z[11]) = 0;\\n\\t\\t(b[14] => z[11]) = 0;\\n\\t\\t(b[15] => z[11]) = 0;\\n\\t\\t(b[16] => z[11]) = 0;\\n\\t\\t(b[17] => z[11]) = 0;\\n\\t\\t(a[0] => z[12]) = 0;\\n\\t\\t(a[1] => z[12]) = 0;\\n\\t\\t(a[2] => z[12]) = 0;\\n\\t\\t(a[3] => z[12]) = 0;\\n\\t\\t(a[4] => z[12]) = 0;\\n\\t\\t(a[5] => z[12]) = 0;\\n\\t\\t(a[6] => z[12]) = 0;\\n\\t\\t(a[7] => z[12]) = 0;\\n\\t\\t(a[8] => z[12]) = 0;\\n\\t\\t(a[9] => z[12]) = 0;\\n\\t\\t(a[10] => z[12]) = 0;\\n\\t\\t(a[11] => z[12]) = 0;\\n\\t\\t(a[12] => z[12]) = 0;\\n\\t\\t(a[13] => z[12]) = 0;\\n\\t\\t(a[14] => z[12]) = 0;\\n\\t\\t(a[15] => z[12]) = 0;\\n\\t\\t(a[16] => z[12]) = 0;\\n\\t\\t(a[17] => z[12]) = 0;\\n\\t\\t(a[18] => z[12]) = 0;\\n\\t\\t(a[19] => z[12]) = 0;\\n\\t\\t(b[0] => z[12]) = 0;\\n\\t\\t(b[1] => z[12]) = 0;\\n\\t\\t(b[2] => z[12]) = 0;\\n\\t\\t(b[3] => z[12]) = 0;\\n\\t\\t(b[4] => z[12]) = 0;\\n\\t\\t(b[5] => z[12]) = 0;\\n\\t\\t(b[6] => z[12]) = 0;\\n\\t\\t(b[7] => z[12]) = 0;\\n\\t\\t(b[8] => z[12]) = 0;\\n\\t\\t(b[9] => z[12]) = 0;\\n\\t\\t(b[10] => z[12]) = 0;\\n\\t\\t(b[11] => z[12]) = 0;\\n\\t\\t(b[12] => z[12]) = 0;\\n\\t\\t(b[13] => z[12]) = 0;\\n\\t\\t(b[14] => z[12]) = 0;\\n\\t\\t(b[15] => z[12]) = 0;\\n\\t\\t(b[16] => z[12]) = 0;\\n\\t\\t(b[17] => z[12]) = 0;\\n\\t\\t(a[0] => z[13]) = 0;\\n\\t\\t(a[1] => z[13]) = 0;\\n\\t\\t(a[2] => z[13]) = 0;\\n\\t\\t(a[3] => z[13]) = 0;\\n\\t\\t(a[4] => z[13]) = 0;\\n\\t\\t(a[5] => z[13]) = 0;\\n\\t\\t(a[6] => z[13]) = 0;\\n\\t\\t(a[7] => z[13]) = 0;\\n\\t\\t(a[8] => z[13]) = 0;\\n\\t\\t(a[9] => z[13]) = 0;\\n\\t\\t(a[10] => z[13]) = 0;\\n\\t\\t(a[11] => z[13]) = 0;\\n\\t\\t(a[12] => z[13]) = 0;\\n\\t\\t(a[13] => z[13]) = 0;\\n\\t\\t(a[14] => z[13]) = 0;\\n\\t\\t(a[15] => z[13]) = 0;\\n\\t\\t(a[16] => z[13]) = 0;\\n\\t\\t(a[17] => z[13]) = 0;\\n\\t\\t(a[18] => z[13]) = 0;\\n\\t\\t(a[19] => z[13]) = 0;\\n\\t\\t(b[0] => z[13]) = 0;\\n\\t\\t(b[1] => z[13]) = 0;\\n\\t\\t(b[2] => z[13]) = 0;\\n\\t\\t(b[3] => z[13]) = 0;\\n\\t\\t(b[4] => z[13]) = 0;\\n\\t\\t(b[5] => z[13]) = 0;\\n\\t\\t(b[6] => z[13]) = 0;\\n\\t\\t(b[7] => z[13]) = 0;\\n\\t\\t(b[8] => z[13]) = 0;\\n\\t\\t(b[9] => z[13]) = 0;\\n\\t\\t(b[10] => z[13]) = 0;\\n\\t\\t(b[11] => z[13]) = 0;\\n\\t\\t(b[12] => z[13]) = 0;\\n\\t\\t(b[13] => z[13]) = 0;\\n\\t\\t(b[14] => z[13]) = 0;\\n\\t\\t(b[15] => z[13]) = 0;\\n\\t\\t(b[16] => z[13]) = 0;\\n\\t\\t(b[17] => z[13]) = 0;\\n\\t\\t(a[0] => z[14]) = 0;\\n\\t\\t(a[1] => z[14]) = 0;\\n\\t\\t(a[2] => z[14]) = 0;\\n\\t\\t(a[3] => z[14]) = 0;\\n\\t\\t(a[4] => z[14]) = 0;\\n\\t\\t(a[5] => z[14]) = 0;\\n\\t\\t(a[6] => z[14]) = 0;\\n\\t\\t(a[7] => z[14]) = 0;\\n\\t\\t(a[8] => z[14]) = 0;\\n\\t\\t(a[9] => z[14]) = 0;\\n\\t\\t(a[10] => z[14]) = 0;\\n\\t\\t(a[11] => z[14]) = 0;\\n\\t\\t(a[12] => z[14]) = 0;\\n\\t\\t(a[13] => z[14]) = 0;\\n\\t\\t(a[14] => z[14]) = 0;\\n\\t\\t(a[15] => z[14]) = 0;\\n\\t\\t(a[16] => z[14]) = 0;\\n\\t\\t(a[17] => z[14]) = 0;\\n\\t\\t(a[18] => z[14]) = 0;\\n\\t\\t(a[19] => z[14]) = 0;\\n\\t\\t(b[0] => z[14]) = 0;\\n\\t\\t(b[1] => z[14]) = 0;\\n\\t\\t(b[2] => z[14]) = 0;\\n\\t\\t(b[3] => z[14]) = 0;\\n\\t\\t(b[4] => z[14]) = 0;\\n\\t\\t(b[5] => z[14]) = 0;\\n\\t\\t(b[6] => z[14]) = 0;\\n\\t\\t(b[7] => z[14]) = 0;\\n\\t\\t(b[8] => z[14]) = 0;\\n\\t\\t(b[9] => z[14]) = 0;\\n\\t\\t(b[10] => z[14]) = 0;\\n\\t\\t(b[11] => z[14]) = 0;\\n\\t\\t(b[12] => z[14]) = 0;\\n\\t\\t(b[13] => z[14]) = 0;\\n\\t\\t(b[14] => z[14]) = 0;\\n\\t\\t(b[15] => z[14]) = 0;\\n\\t\\t(b[16] => z[14]) = 0;\\n\\t\\t(b[17] => z[14]) = 0;\\n\\t\\t(a[0] => z[15]) = 0;\\n\\t\\t(a[1] => z[15]) = 0;\\n\\t\\t(a[2] => z[15]) = 0;\\n\\t\\t(a[3] => z[15]) = 0;\\n\\t\\t(a[4] => z[15]) = 0;\\n\\t\\t(a[5] => z[15]) = 0;\\n\\t\\t(a[6] => z[15]) = 0;\\n\\t\\t(a[7] => z[15]) = 0;\\n\\t\\t(a[8] => z[15]) = 0;\\n\\t\\t(a[9] => z[15]) = 0;\\n\\t\\t(a[10] => z[15]) = 0;\\n\\t\\t(a[11] => z[15]) = 0;\\n\\t\\t(a[12] => z[15]) = 0;\\n\\t\\t(a[13] => z[15]) = 0;\\n\\t\\t(a[14] => z[15]) = 0;\\n\\t\\t(a[15] => z[15]) = 0;\\n\\t\\t(a[16] => z[15]) = 0;\\n\\t\\t(a[17] => z[15]) = 0;\\n\\t\\t(a[18] => z[15]) = 0;\\n\\t\\t(a[19] => z[15]) = 0;\\n\\t\\t(b[0] => z[15]) = 0;\\n\\t\\t(b[1] => z[15]) = 0;\\n\\t\\t(b[2] => z[15]) = 0;\\n\\t\\t(b[3] => z[15]) = 0;\\n\\t\\t(b[4] => z[15]) = 0;\\n\\t\\t(b[5] => z[15]) = 0;\\n\\t\\t(b[6] => z[15]) = 0;\\n\\t\\t(b[7] => z[15]) = 0;\\n\\t\\t(b[8] => z[15]) = 0;\\n\\t\\t(b[9] => z[15]) = 0;\\n\\t\\t(b[10] => z[15]) = 0;\\n\\t\\t(b[11] => z[15]) = 0;\\n\\t\\t(b[12] => z[15]) = 0;\\n\\t\\t(b[13] => z[15]) = 0;\\n\\t\\t(b[14] => z[15]) = 0;\\n\\t\\t(b[15] => z[15]) = 0;\\n\\t\\t(b[16] => z[15]) = 0;\\n\\t\\t(b[17] => z[15]) = 0;\\n\\t\\t(a[0] => z[16]) = 0;\\n\\t\\t(a[1] => z[16]) = 0;\\n\\t\\t(a[2] => z[16]) = 0;\\n\\t\\t(a[3] => z[16]) = 0;\\n\\t\\t(a[4] => z[16]) = 0;\\n\\t\\t(a[5] => z[16]) = 0;\\n\\t\\t(a[6] => z[16]) = 0;\\n\\t\\t(a[7] => z[16]) = 0;\\n\\t\\t(a[8] => z[16]) = 0;\\n\\t\\t(a[9] => z[16]) = 0;\\n\\t\\t(a[10] => z[16]) = 0;\\n\\t\\t(a[11] => z[16]) = 0;\\n\\t\\t(a[12] => z[16]) = 0;\\n\\t\\t(a[13] => z[16]) = 0;\\n\\t\\t(a[14] => z[16]) = 0;\\n\\t\\t(a[15] => z[16]) = 0;\\n\\t\\t(a[16] => z[16]) = 0;\\n\\t\\t(a[17] => z[16]) = 0;\\n\\t\\t(a[18] => z[16]) = 0;\\n\\t\\t(a[19] => z[16]) = 0;\\n\\t\\t(b[0] => z[16]) = 0;\\n\\t\\t(b[1] => z[16]) = 0;\\n\\t\\t(b[2] => z[16]) = 0;\\n\\t\\t(b[3] => z[16]) = 0;\\n\\t\\t(b[4] => z[16]) = 0;\\n\\t\\t(b[5] => z[16]) = 0;\\n\\t\\t(b[6] => z[16]) = 0;\\n\\t\\t(b[7] => z[16]) = 0;\\n\\t\\t(b[8] => z[16]) = 0;\\n\\t\\t(b[9] => z[16]) = 0;\\n\\t\\t(b[10] => z[16]) = 0;\\n\\t\\t(b[11] => z[16]) = 0;\\n\\t\\t(b[12] => z[16]) = 0;\\n\\t\\t(b[13] => z[16]) = 0;\\n\\t\\t(b[14] => z[16]) = 0;\\n\\t\\t(b[15] => z[16]) = 0;\\n\\t\\t(b[16] => z[16]) = 0;\\n\\t\\t(b[17] => z[16]) = 0;\\n\\t\\t(a[0] => z[17]) = 0;\\n\\t\\t(a[1] => z[17]) = 0;\\n\\t\\t(a[2] => z[17]) = 0;\\n\\t\\t(a[3] => z[17]) = 0;\\n\\t\\t(a[4] => z[17]) = 0;\\n\\t\\t(a[5] => z[17]) = 0;\\n\\t\\t(a[6] => z[17]) = 0;\\n\\t\\t(a[7] => z[17]) = 0;\\n\\t\\t(a[8] => z[17]) = 0;\\n\\t\\t(a[9] => z[17]) = 0;\\n\\t\\t(a[10] => z[17]) = 0;\\n\\t\\t(a[11] => z[17]) = 0;\\n\\t\\t(a[12] => z[17]) = 0;\\n\\t\\t(a[13] => z[17]) = 0;\\n\\t\\t(a[14] => z[17]) = 0;\\n\\t\\t(a[15] => z[17]) = 0;\\n\\t\\t(a[16] => z[17]) = 0;\\n\\t\\t(a[17] => z[17]) = 0;\\n\\t\\t(a[18] => z[17]) = 0;\\n\\t\\t(a[19] => z[17]) = 0;\\n\\t\\t(b[0] => z[17]) = 0;\\n\\t\\t(b[1] => z[17]) = 0;\\n\\t\\t(b[2] => z[17]) = 0;\\n\\t\\t(b[3] => z[17]) = 0;\\n\\t\\t(b[4] => z[17]) = 0;\\n\\t\\t(b[5] => z[17]) = 0;\\n\\t\\t(b[6] => z[17]) = 0;\\n\\t\\t(b[7] => z[17]) = 0;\\n\\t\\t(b[8] => z[17]) = 0;\\n\\t\\t(b[9] => z[17]) = 0;\\n\\t\\t(b[10] => z[17]) = 0;\\n\\t\\t(b[11] => z[17]) = 0;\\n\\t\\t(b[12] => z[17]) = 0;\\n\\t\\t(b[13] => z[17]) = 0;\\n\\t\\t(b[14] => z[17]) = 0;\\n\\t\\t(b[15] => z[17]) = 0;\\n\\t\\t(b[16] => z[17]) = 0;\\n\\t\\t(b[17] => z[17]) = 0;\\n\\t\\t(a[0] => z[18]) = 0;\\n\\t\\t(a[1] => z[18]) = 0;\\n\\t\\t(a[2] => z[18]) = 0;\\n\\t\\t(a[3] => z[18]) = 0;\\n\\t\\t(a[4] => z[18]) = 0;\\n\\t\\t(a[5] => z[18]) = 0;\\n\\t\\t(a[6] => z[18]) = 0;\\n\\t\\t(a[7] => z[18]) = 0;\\n\\t\\t(a[8] => z[18]) = 0;\\n\\t\\t(a[9] => z[18]) = 0;\\n\\t\\t(a[10] => z[18]) = 0;\\n\\t\\t(a[11] => z[18]) = 0;\\n\\t\\t(a[12] => z[18]) = 0;\\n\\t\\t(a[13] => z[18]) = 0;\\n\\t\\t(a[14] => z[18]) = 0;\\n\\t\\t(a[15] => z[18]) = 0;\\n\\t\\t(a[16] => z[18]) = 0;\\n\\t\\t(a[17] => z[18]) = 0;\\n\\t\\t(a[18] => z[18]) = 0;\\n\\t\\t(a[19] => z[18]) = 0;\\n\\t\\t(b[0] => z[18]) = 0;\\n\\t\\t(b[1] => z[18]) = 0;\\n\\t\\t(b[2] => z[18]) = 0;\\n\\t\\t(b[3] => z[18]) = 0;\\n\\t\\t(b[4] => z[18]) = 0;\\n\\t\\t(b[5] => z[18]) = 0;\\n\\t\\t(b[6] => z[18]) = 0;\\n\\t\\t(b[7] => z[18]) = 0;\\n\\t\\t(b[8] => z[18]) = 0;\\n\\t\\t(b[9] => z[18]) = 0;\\n\\t\\t(b[10] => z[18]) = 0;\\n\\t\\t(b[11] => z[18]) = 0;\\n\\t\\t(b[12] => z[18]) = 0;\\n\\t\\t(b[13] => z[18]) = 0;\\n\\t\\t(b[14] => z[18]) = 0;\\n\\t\\t(b[15] => z[18]) = 0;\\n\\t\\t(b[16] => z[18]) = 0;\\n\\t\\t(b[17] => z[18]) = 0;\\n\\t\\t(a[0] => z[19]) = 0;\\n\\t\\t(a[1] => z[19]) = 0;\\n\\t\\t(a[2] => z[19]) = 0;\\n\\t\\t(a[3] => z[19]) = 0;\\n\\t\\t(a[4] => z[19]) = 0;\\n\\t\\t(a[5] => z[19]) = 0;\\n\\t\\t(a[6] => z[19]) = 0;\\n\\t\\t(a[7] => z[19]) = 0;\\n\\t\\t(a[8] => z[19]) = 0;\\n\\t\\t(a[9] => z[19]) = 0;\\n\\t\\t(a[10] => z[19]) = 0;\\n\\t\\t(a[11] => z[19]) = 0;\\n\\t\\t(a[12] => z[19]) = 0;\\n\\t\\t(a[13] => z[19]) = 0;\\n\\t\\t(a[14] => z[19]) = 0;\\n\\t\\t(a[15] => z[19]) = 0;\\n\\t\\t(a[16] => z[19]) = 0;\\n\\t\\t(a[17] => z[19]) = 0;\\n\\t\\t(a[18] => z[19]) = 0;\\n\\t\\t(a[19] => z[19]) = 0;\\n\\t\\t(b[0] => z[19]) = 0;\\n\\t\\t(b[1] => z[19]) = 0;\\n\\t\\t(b[2] => z[19]) = 0;\\n\\t\\t(b[3] => z[19]) = 0;\\n\\t\\t(b[4] => z[19]) = 0;\\n\\t\\t(b[5] => z[19]) = 0;\\n\\t\\t(b[6] => z[19]) = 0;\\n\\t\\t(b[7] => z[19]) = 0;\\n\\t\\t(b[8] => z[19]) = 0;\\n\\t\\t(b[9] => z[19]) = 0;\\n\\t\\t(b[10] => z[19]) = 0;\\n\\t\\t(b[11] => z[19]) = 0;\\n\\t\\t(b[12] => z[19]) = 0;\\n\\t\\t(b[13] => z[19]) = 0;\\n\\t\\t(b[14] => z[19]) = 0;\\n\\t\\t(b[15] => z[19]) = 0;\\n\\t\\t(b[16] => z[19]) = 0;\\n\\t\\t(b[17] => z[19]) = 0;\\n\\t\\t(a[0] => z[20]) = 0;\\n\\t\\t(a[1] => z[20]) = 0;\\n\\t\\t(a[2] => z[20]) = 0;\\n\\t\\t(a[3] => z[20]) = 0;\\n\\t\\t(a[4] => z[20]) = 0;\\n\\t\\t(a[5] => z[20]) = 0;\\n\\t\\t(a[6] => z[20]) = 0;\\n\\t\\t(a[7] => z[20]) = 0;\\n\\t\\t(a[8] => z[20]) = 0;\\n\\t\\t(a[9] => z[20]) = 0;\\n\\t\\t(a[10] => z[20]) = 0;\\n\\t\\t(a[11] => z[20]) = 0;\\n\\t\\t(a[12] => z[20]) = 0;\\n\\t\\t(a[13] => z[20]) = 0;\\n\\t\\t(a[14] => z[20]) = 0;\\n\\t\\t(a[15] => z[20]) = 0;\\n\\t\\t(a[16] => z[20]) = 0;\\n\\t\\t(a[17] => z[20]) = 0;\\n\\t\\t(a[18] => z[20]) = 0;\\n\\t\\t(a[19] => z[20]) = 0;\\n\\t\\t(b[0] => z[20]) = 0;\\n\\t\\t(b[1] => z[20]) = 0;\\n\\t\\t(b[2] => z[20]) = 0;\\n\\t\\t(b[3] => z[20]) = 0;\\n\\t\\t(b[4] => z[20]) = 0;\\n\\t\\t(b[5] => z[20]) = 0;\\n\\t\\t(b[6] => z[20]) = 0;\\n\\t\\t(b[7] => z[20]) = 0;\\n\\t\\t(b[8] => z[20]) = 0;\\n\\t\\t(b[9] => z[20]) = 0;\\n\\t\\t(b[10] => z[20]) = 0;\\n\\t\\t(b[11] => z[20]) = 0;\\n\\t\\t(b[12] => z[20]) = 0;\\n\\t\\t(b[13] => z[20]) = 0;\\n\\t\\t(b[14] => z[20]) = 0;\\n\\t\\t(b[15] => z[20]) = 0;\\n\\t\\t(b[16] => z[20]) = 0;\\n\\t\\t(b[17] => z[20]) = 0;\\n\\t\\t(a[0] => z[21]) = 0;\\n\\t\\t(a[1] => z[21]) = 0;\\n\\t\\t(a[2] => z[21]) = 0;\\n\\t\\t(a[3] => z[21]) = 0;\\n\\t\\t(a[4] => z[21]) = 0;\\n\\t\\t(a[5] => z[21]) = 0;\\n\\t\\t(a[6] => z[21]) = 0;\\n\\t\\t(a[7] => z[21]) = 0;\\n\\t\\t(a[8] => z[21]) = 0;\\n\\t\\t(a[9] => z[21]) = 0;\\n\\t\\t(a[10] => z[21]) = 0;\\n\\t\\t(a[11] => z[21]) = 0;\\n\\t\\t(a[12] => z[21]) = 0;\\n\\t\\t(a[13] => z[21]) = 0;\\n\\t\\t(a[14] => z[21]) = 0;\\n\\t\\t(a[15] => z[21]) = 0;\\n\\t\\t(a[16] => z[21]) = 0;\\n\\t\\t(a[17] => z[21]) = 0;\\n\\t\\t(a[18] => z[21]) = 0;\\n\\t\\t(a[19] => z[21]) = 0;\\n\\t\\t(b[0] => z[21]) = 0;\\n\\t\\t(b[1] => z[21]) = 0;\\n\\t\\t(b[2] => z[21]) = 0;\\n\\t\\t(b[3] => z[21]) = 0;\\n\\t\\t(b[4] => z[21]) = 0;\\n\\t\\t(b[5] => z[21]) = 0;\\n\\t\\t(b[6] => z[21]) = 0;\\n\\t\\t(b[7] => z[21]) = 0;\\n\\t\\t(b[8] => z[21]) = 0;\\n\\t\\t(b[9] => z[21]) = 0;\\n\\t\\t(b[10] => z[21]) = 0;\\n\\t\\t(b[11] => z[21]) = 0;\\n\\t\\t(b[12] => z[21]) = 0;\\n\\t\\t(b[13] => z[21]) = 0;\\n\\t\\t(b[14] => z[21]) = 0;\\n\\t\\t(b[15] => z[21]) = 0;\\n\\t\\t(b[16] => z[21]) = 0;\\n\\t\\t(b[17] => z[21]) = 0;\\n\\t\\t(a[0] => z[22]) = 0;\\n\\t\\t(a[1] => z[22]) = 0;\\n\\t\\t(a[2] => z[22]) = 0;\\n\\t\\t(a[3] => z[22]) = 0;\\n\\t\\t(a[4] => z[22]) = 0;\\n\\t\\t(a[5] => z[22]) = 0;\\n\\t\\t(a[6] => z[22]) = 0;\\n\\t\\t(a[7] => z[22]) = 0;\\n\\t\\t(a[8] => z[22]) = 0;\\n\\t\\t(a[9] => z[22]) = 0;\\n\\t\\t(a[10] => z[22]) = 0;\\n\\t\\t(a[11] => z[22]) = 0;\\n\\t\\t(a[12] => z[22]) = 0;\\n\\t\\t(a[13] => z[22]) = 0;\\n\\t\\t(a[14] => z[22]) = 0;\\n\\t\\t(a[15] => z[22]) = 0;\\n\\t\\t(a[16] => z[22]) = 0;\\n\\t\\t(a[17] => z[22]) = 0;\\n\\t\\t(a[18] => z[22]) = 0;\\n\\t\\t(a[19] => z[22]) = 0;\\n\\t\\t(b[0] => z[22]) = 0;\\n\\t\\t(b[1] => z[22]) = 0;\\n\\t\\t(b[2] => z[22]) = 0;\\n\\t\\t(b[3] => z[22]) = 0;\\n\\t\\t(b[4] => z[22]) = 0;\\n\\t\\t(b[5] => z[22]) = 0;\\n\\t\\t(b[6] => z[22]) = 0;\\n\\t\\t(b[7] => z[22]) = 0;\\n\\t\\t(b[8] => z[22]) = 0;\\n\\t\\t(b[9] => z[22]) = 0;\\n\\t\\t(b[10] => z[22]) = 0;\\n\\t\\t(b[11] => z[22]) = 0;\\n\\t\\t(b[12] => z[22]) = 0;\\n\\t\\t(b[13] => z[22]) = 0;\\n\\t\\t(b[14] => z[22]) = 0;\\n\\t\\t(b[15] => z[22]) = 0;\\n\\t\\t(b[16] => z[22]) = 0;\\n\\t\\t(b[17] => z[22]) = 0;\\n\\t\\t(a[0] => z[23]) = 0;\\n\\t\\t(a[1] => z[23]) = 0;\\n\\t\\t(a[2] => z[23]) = 0;\\n\\t\\t(a[3] => z[23]) = 0;\\n\\t\\t(a[4] => z[23]) = 0;\\n\\t\\t(a[5] => z[23]) = 0;\\n\\t\\t(a[6] => z[23]) = 0;\\n\\t\\t(a[7] => z[23]) = 0;\\n\\t\\t(a[8] => z[23]) = 0;\\n\\t\\t(a[9] => z[23]) = 0;\\n\\t\\t(a[10] => z[23]) = 0;\\n\\t\\t(a[11] => z[23]) = 0;\\n\\t\\t(a[12] => z[23]) = 0;\\n\\t\\t(a[13] => z[23]) = 0;\\n\\t\\t(a[14] => z[23]) = 0;\\n\\t\\t(a[15] => z[23]) = 0;\\n\\t\\t(a[16] => z[23]) = 0;\\n\\t\\t(a[17] => z[23]) = 0;\\n\\t\\t(a[18] => z[23]) = 0;\\n\\t\\t(a[19] => z[23]) = 0;\\n\\t\\t(b[0] => z[23]) = 0;\\n\\t\\t(b[1] => z[23]) = 0;\\n\\t\\t(b[2] => z[23]) = 0;\\n\\t\\t(b[3] => z[23]) = 0;\\n\\t\\t(b[4] => z[23]) = 0;\\n\\t\\t(b[5] => z[23]) = 0;\\n\\t\\t(b[6] => z[23]) = 0;\\n\\t\\t(b[7] => z[23]) = 0;\\n\\t\\t(b[8] => z[23]) = 0;\\n\\t\\t(b[9] => z[23]) = 0;\\n\\t\\t(b[10] => z[23]) = 0;\\n\\t\\t(b[11] => z[23]) = 0;\\n\\t\\t(b[12] => z[23]) = 0;\\n\\t\\t(b[13] => z[23]) = 0;\\n\\t\\t(b[14] => z[23]) = 0;\\n\\t\\t(b[15] => z[23]) = 0;\\n\\t\\t(b[16] => z[23]) = 0;\\n\\t\\t(b[17] => z[23]) = 0;\\n\\t\\t(a[0] => z[24]) = 0;\\n\\t\\t(a[1] => z[24]) = 0;\\n\\t\\t(a[2] => z[24]) = 0;\\n\\t\\t(a[3] => z[24]) = 0;\\n\\t\\t(a[4] => z[24]) = 0;\\n\\t\\t(a[5] => z[24]) = 0;\\n\\t\\t(a[6] => z[24]) = 0;\\n\\t\\t(a[7] => z[24]) = 0;\\n\\t\\t(a[8] => z[24]) = 0;\\n\\t\\t(a[9] => z[24]) = 0;\\n\\t\\t(a[10] => z[24]) = 0;\\n\\t\\t(a[11] => z[24]) = 0;\\n\\t\\t(a[12] => z[24]) = 0;\\n\\t\\t(a[13] => z[24]) = 0;\\n\\t\\t(a[14] => z[24]) = 0;\\n\\t\\t(a[15] => z[24]) = 0;\\n\\t\\t(a[16] => z[24]) = 0;\\n\\t\\t(a[17] => z[24]) = 0;\\n\\t\\t(a[18] => z[24]) = 0;\\n\\t\\t(a[19] => z[24]) = 0;\\n\\t\\t(b[0] => z[24]) = 0;\\n\\t\\t(b[1] => z[24]) = 0;\\n\\t\\t(b[2] => z[24]) = 0;\\n\\t\\t(b[3] => z[24]) = 0;\\n\\t\\t(b[4] => z[24]) = 0;\\n\\t\\t(b[5] => z[24]) = 0;\\n\\t\\t(b[6] => z[24]) = 0;\\n\\t\\t(b[7] => z[24]) = 0;\\n\\t\\t(b[8] => z[24]) = 0;\\n\\t\\t(b[9] => z[24]) = 0;\\n\\t\\t(b[10] => z[24]) = 0;\\n\\t\\t(b[11] => z[24]) = 0;\\n\\t\\t(b[12] => z[24]) = 0;\\n\\t\\t(b[13] => z[24]) = 0;\\n\\t\\t(b[14] => z[24]) = 0;\\n\\t\\t(b[15] => z[24]) = 0;\\n\\t\\t(b[16] => z[24]) = 0;\\n\\t\\t(b[17] => z[24]) = 0;\\n\\t\\t(a[0] => z[25]) = 0;\\n\\t\\t(a[1] => z[25]) = 0;\\n\\t\\t(a[2] => z[25]) = 0;\\n\\t\\t(a[3] => z[25]) = 0;\\n\\t\\t(a[4] => z[25]) = 0;\\n\\t\\t(a[5] => z[25]) = 0;\\n\\t\\t(a[6] => z[25]) = 0;\\n\\t\\t(a[7] => z[25]) = 0;\\n\\t\\t(a[8] => z[25]) = 0;\\n\\t\\t(a[9] => z[25]) = 0;\\n\\t\\t(a[10] => z[25]) = 0;\\n\\t\\t(a[11] => z[25]) = 0;\\n\\t\\t(a[12] => z[25]) = 0;\\n\\t\\t(a[13] => z[25]) = 0;\\n\\t\\t(a[14] => z[25]) = 0;\\n\\t\\t(a[15] => z[25]) = 0;\\n\\t\\t(a[16] => z[25]) = 0;\\n\\t\\t(a[17] => z[25]) = 0;\\n\\t\\t(a[18] => z[25]) = 0;\\n\\t\\t(a[19] => z[25]) = 0;\\n\\t\\t(b[0] => z[25]) = 0;\\n\\t\\t(b[1] => z[25]) = 0;\\n\\t\\t(b[2] => z[25]) = 0;\\n\\t\\t(b[3] => z[25]) = 0;\\n\\t\\t(b[4] => z[25]) = 0;\\n\\t\\t(b[5] => z[25]) = 0;\\n\\t\\t(b[6] => z[25]) = 0;\\n\\t\\t(b[7] => z[25]) = 0;\\n\\t\\t(b[8] => z[25]) = 0;\\n\\t\\t(b[9] => z[25]) = 0;\\n\\t\\t(b[10] => z[25]) = 0;\\n\\t\\t(b[11] => z[25]) = 0;\\n\\t\\t(b[12] => z[25]) = 0;\\n\\t\\t(b[13] => z[25]) = 0;\\n\\t\\t(b[14] => z[25]) = 0;\\n\\t\\t(b[15] => z[25]) = 0;\\n\\t\\t(b[16] => z[25]) = 0;\\n\\t\\t(b[17] => z[25]) = 0;\\n\\t\\t(a[0] => z[26]) = 0;\\n\\t\\t(a[1] => z[26]) = 0;\\n\\t\\t(a[2] => z[26]) = 0;\\n\\t\\t(a[3] => z[26]) = 0;\\n\\t\\t(a[4] => z[26]) = 0;\\n\\t\\t(a[5] => z[26]) = 0;\\n\\t\\t(a[6] => z[26]) = 0;\\n\\t\\t(a[7] => z[26]) = 0;\\n\\t\\t(a[8] => z[26]) = 0;\\n\\t\\t(a[9] => z[26]) = 0;\\n\\t\\t(a[10] => z[26]) = 0;\\n\\t\\t(a[11] => z[26]) = 0;\\n\\t\\t(a[12] => z[26]) = 0;\\n\\t\\t(a[13] => z[26]) = 0;\\n\\t\\t(a[14] => z[26]) = 0;\\n\\t\\t(a[15] => z[26]) = 0;\\n\\t\\t(a[16] => z[26]) = 0;\\n\\t\\t(a[17] => z[26]) = 0;\\n\\t\\t(a[18] => z[26]) = 0;\\n\\t\\t(a[19] => z[26]) = 0;\\n\\t\\t(b[0] => z[26]) = 0;\\n\\t\\t(b[1] => z[26]) = 0;\\n\\t\\t(b[2] => z[26]) = 0;\\n\\t\\t(b[3] => z[26]) = 0;\\n\\t\\t(b[4] => z[26]) = 0;\\n\\t\\t(b[5] => z[26]) = 0;\\n\\t\\t(b[6] => z[26]) = 0;\\n\\t\\t(b[7] => z[26]) = 0;\\n\\t\\t(b[8] => z[26]) = 0;\\n\\t\\t(b[9] => z[26]) = 0;\\n\\t\\t(b[10] => z[26]) = 0;\\n\\t\\t(b[11] => z[26]) = 0;\\n\\t\\t(b[12] => z[26]) = 0;\\n\\t\\t(b[13] => z[26]) = 0;\\n\\t\\t(b[14] => z[26]) = 0;\\n\\t\\t(b[15] => z[26]) = 0;\\n\\t\\t(b[16] => z[26]) = 0;\\n\\t\\t(b[17] => z[26]) = 0;\\n\\t\\t(a[0] => z[27]) = 0;\\n\\t\\t(a[1] => z[27]) = 0;\\n\\t\\t(a[2] => z[27]) = 0;\\n\\t\\t(a[3] => z[27]) = 0;\\n\\t\\t(a[4] => z[27]) = 0;\\n\\t\\t(a[5] => z[27]) = 0;\\n\\t\\t(a[6] => z[27]) = 0;\\n\\t\\t(a[7] => z[27]) = 0;\\n\\t\\t(a[8] => z[27]) = 0;\\n\\t\\t(a[9] => z[27]) = 0;\\n\\t\\t(a[10] => z[27]) = 0;\\n\\t\\t(a[11] => z[27]) = 0;\\n\\t\\t(a[12] => z[27]) = 0;\\n\\t\\t(a[13] => z[27]) = 0;\\n\\t\\t(a[14] => z[27]) = 0;\\n\\t\\t(a[15] => z[27]) = 0;\\n\\t\\t(a[16] => z[27]) = 0;\\n\\t\\t(a[17] => z[27]) = 0;\\n\\t\\t(a[18] => z[27]) = 0;\\n\\t\\t(a[19] => z[27]) = 0;\\n\\t\\t(b[0] => z[27]) = 0;\\n\\t\\t(b[1] => z[27]) = 0;\\n\\t\\t(b[2] => z[27]) = 0;\\n\\t\\t(b[3] => z[27]) = 0;\\n\\t\\t(b[4] => z[27]) = 0;\\n\\t\\t(b[5] => z[27]) = 0;\\n\\t\\t(b[6] => z[27]) = 0;\\n\\t\\t(b[7] => z[27]) = 0;\\n\\t\\t(b[8] => z[27]) = 0;\\n\\t\\t(b[9] => z[27]) = 0;\\n\\t\\t(b[10] => z[27]) = 0;\\n\\t\\t(b[11] => z[27]) = 0;\\n\\t\\t(b[12] => z[27]) = 0;\\n\\t\\t(b[13] => z[27]) = 0;\\n\\t\\t(b[14] => z[27]) = 0;\\n\\t\\t(b[15] => z[27]) = 0;\\n\\t\\t(b[16] => z[27]) = 0;\\n\\t\\t(b[17] => z[27]) = 0;\\n\\t\\t(a[0] => z[28]) = 0;\\n\\t\\t(a[1] => z[28]) = 0;\\n\\t\\t(a[2] => z[28]) = 0;\\n\\t\\t(a[3] => z[28]) = 0;\\n\\t\\t(a[4] => z[28]) = 0;\\n\\t\\t(a[5] => z[28]) = 0;\\n\\t\\t(a[6] => z[28]) = 0;\\n\\t\\t(a[7] => z[28]) = 0;\\n\\t\\t(a[8] => z[28]) = 0;\\n\\t\\t(a[9] => z[28]) = 0;\\n\\t\\t(a[10] => z[28]) = 0;\\n\\t\\t(a[11] => z[28]) = 0;\\n\\t\\t(a[12] => z[28]) = 0;\\n\\t\\t(a[13] => z[28]) = 0;\\n\\t\\t(a[14] => z[28]) = 0;\\n\\t\\t(a[15] => z[28]) = 0;\\n\\t\\t(a[16] => z[28]) = 0;\\n\\t\\t(a[17] => z[28]) = 0;\\n\\t\\t(a[18] => z[28]) = 0;\\n\\t\\t(a[19] => z[28]) = 0;\\n\\t\\t(b[0] => z[28]) = 0;\\n\\t\\t(b[1] => z[28]) = 0;\\n\\t\\t(b[2] => z[28]) = 0;\\n\\t\\t(b[3] => z[28]) = 0;\\n\\t\\t(b[4] => z[28]) = 0;\\n\\t\\t(b[5] => z[28]) = 0;\\n\\t\\t(b[6] => z[28]) = 0;\\n\\t\\t(b[7] => z[28]) = 0;\\n\\t\\t(b[8] => z[28]) = 0;\\n\\t\\t(b[9] => z[28]) = 0;\\n\\t\\t(b[10] => z[28]) = 0;\\n\\t\\t(b[11] => z[28]) = 0;\\n\\t\\t(b[12] => z[28]) = 0;\\n\\t\\t(b[13] => z[28]) = 0;\\n\\t\\t(b[14] => z[28]) = 0;\\n\\t\\t(b[15] => z[28]) = 0;\\n\\t\\t(b[16] => z[28]) = 0;\\n\\t\\t(b[17] => z[28]) = 0;\\n\\t\\t(a[0] => z[29]) = 0;\\n\\t\\t(a[1] => z[29]) = 0;\\n\\t\\t(a[2] => z[29]) = 0;\\n\\t\\t(a[3] => z[29]) = 0;\\n\\t\\t(a[4] => z[29]) = 0;\\n\\t\\t(a[5] => z[29]) = 0;\\n\\t\\t(a[6] => z[29]) = 0;\\n\\t\\t(a[7] => z[29]) = 0;\\n\\t\\t(a[8] => z[29]) = 0;\\n\\t\\t(a[9] => z[29]) = 0;\\n\\t\\t(a[10] => z[29]) = 0;\\n\\t\\t(a[11] => z[29]) = 0;\\n\\t\\t(a[12] => z[29]) = 0;\\n\\t\\t(a[13] => z[29]) = 0;\\n\\t\\t(a[14] => z[29]) = 0;\\n\\t\\t(a[15] => z[29]) = 0;\\n\\t\\t(a[16] => z[29]) = 0;\\n\\t\\t(a[17] => z[29]) = 0;\\n\\t\\t(a[18] => z[29]) = 0;\\n\\t\\t(a[19] => z[29]) = 0;\\n\\t\\t(b[0] => z[29]) = 0;\\n\\t\\t(b[1] => z[29]) = 0;\\n\\t\\t(b[2] => z[29]) = 0;\\n\\t\\t(b[3] => z[29]) = 0;\\n\\t\\t(b[4] => z[29]) = 0;\\n\\t\\t(b[5] => z[29]) = 0;\\n\\t\\t(b[6] => z[29]) = 0;\\n\\t\\t(b[7] => z[29]) = 0;\\n\\t\\t(b[8] => z[29]) = 0;\\n\\t\\t(b[9] => z[29]) = 0;\\n\\t\\t(b[10] => z[29]) = 0;\\n\\t\\t(b[11] => z[29]) = 0;\\n\\t\\t(b[12] => z[29]) = 0;\\n\\t\\t(b[13] => z[29]) = 0;\\n\\t\\t(b[14] => z[29]) = 0;\\n\\t\\t(b[15] => z[29]) = 0;\\n\\t\\t(b[16] => z[29]) = 0;\\n\\t\\t(b[17] => z[29]) = 0;\\n\\t\\t(a[0] => z[30]) = 0;\\n\\t\\t(a[1] => z[30]) = 0;\\n\\t\\t(a[2] => z[30]) = 0;\\n\\t\\t(a[3] => z[30]) = 0;\\n\\t\\t(a[4] => z[30]) = 0;\\n\\t\\t(a[5] => z[30]) = 0;\\n\\t\\t(a[6] => z[30]) = 0;\\n\\t\\t(a[7] => z[30]) = 0;\\n\\t\\t(a[8] => z[30]) = 0;\\n\\t\\t(a[9] => z[30]) = 0;\\n\\t\\t(a[10] => z[30]) = 0;\\n\\t\\t(a[11] => z[30]) = 0;\\n\\t\\t(a[12] => z[30]) = 0;\\n\\t\\t(a[13] => z[30]) = 0;\\n\\t\\t(a[14] => z[30]) = 0;\\n\\t\\t(a[15] => z[30]) = 0;\\n\\t\\t(a[16] => z[30]) = 0;\\n\\t\\t(a[17] => z[30]) = 0;\\n\\t\\t(a[18] => z[30]) = 0;\\n\\t\\t(a[19] => z[30]) = 0;\\n\\t\\t(b[0] => z[30]) = 0;\\n\\t\\t(b[1] => z[30]) = 0;\\n\\t\\t(b[2] => z[30]) = 0;\\n\\t\\t(b[3] => z[30]) = 0;\\n\\t\\t(b[4] => z[30]) = 0;\\n\\t\\t(b[5] => z[30]) = 0;\\n\\t\\t(b[6] => z[30]) = 0;\\n\\t\\t(b[7] => z[30]) = 0;\\n\\t\\t(b[8] => z[30]) = 0;\\n\\t\\t(b[9] => z[30]) = 0;\\n\\t\\t(b[10] => z[30]) = 0;\\n\\t\\t(b[11] => z[30]) = 0;\\n\\t\\t(b[12] => z[30]) = 0;\\n\\t\\t(b[13] => z[30]) = 0;\\n\\t\\t(b[14] => z[30]) = 0;\\n\\t\\t(b[15] => z[30]) = 0;\\n\\t\\t(b[16] => z[30]) = 0;\\n\\t\\t(b[17] => z[30]) = 0;\\n\\t\\t(a[0] => z[31]) = 0;\\n\\t\\t(a[1] => z[31]) = 0;\\n\\t\\t(a[2] => z[31]) = 0;\\n\\t\\t(a[3] => z[31]) = 0;\\n\\t\\t(a[4] => z[31]) = 0;\\n\\t\\t(a[5] => z[31]) = 0;\\n\\t\\t(a[6] => z[31]) = 0;\\n\\t\\t(a[7] => z[31]) = 0;\\n\\t\\t(a[8] => z[31]) = 0;\\n\\t\\t(a[9] => z[31]) = 0;\\n\\t\\t(a[10] => z[31]) = 0;\\n\\t\\t(a[11] => z[31]) = 0;\\n\\t\\t(a[12] => z[31]) = 0;\\n\\t\\t(a[13] => z[31]) = 0;\\n\\t\\t(a[14] => z[31]) = 0;\\n\\t\\t(a[15] => z[31]) = 0;\\n\\t\\t(a[16] => z[31]) = 0;\\n\\t\\t(a[17] => z[31]) = 0;\\n\\t\\t(a[18] => z[31]) = 0;\\n\\t\\t(a[19] => z[31]) = 0;\\n\\t\\t(b[0] => z[31]) = 0;\\n\\t\\t(b[1] => z[31]) = 0;\\n\\t\\t(b[2] => z[31]) = 0;\\n\\t\\t(b[3] => z[31]) = 0;\\n\\t\\t(b[4] => z[31]) = 0;\\n\\t\\t(b[5] => z[31]) = 0;\\n\\t\\t(b[6] => z[31]) = 0;\\n\\t\\t(b[7] => z[31]) = 0;\\n\\t\\t(b[8] => z[31]) = 0;\\n\\t\\t(b[9] => z[31]) = 0;\\n\\t\\t(b[10] => z[31]) = 0;\\n\\t\\t(b[11] => z[31]) = 0;\\n\\t\\t(b[12] => z[31]) = 0;\\n\\t\\t(b[13] => z[31]) = 0;\\n\\t\\t(b[14] => z[31]) = 0;\\n\\t\\t(b[15] => z[31]) = 0;\\n\\t\\t(b[16] => z[31]) = 0;\\n\\t\\t(b[17] => z[31]) = 0;\\n\\t\\t(a[0] => z[32]) = 0;\\n\\t\\t(a[1] => z[32]) = 0;\\n\\t\\t(a[2] => z[32]) = 0;\\n\\t\\t(a[3] => z[32]) = 0;\\n\\t\\t(a[4] => z[32]) = 0;\\n\\t\\t(a[5] => z[32]) = 0;\\n\\t\\t(a[6] => z[32]) = 0;\\n\\t\\t(a[7] => z[32]) = 0;\\n\\t\\t(a[8] => z[32]) = 0;\\n\\t\\t(a[9] => z[32]) = 0;\\n\\t\\t(a[10] => z[32]) = 0;\\n\\t\\t(a[11] => z[32]) = 0;\\n\\t\\t(a[12] => z[32]) = 0;\\n\\t\\t(a[13] => z[32]) = 0;\\n\\t\\t(a[14] => z[32]) = 0;\\n\\t\\t(a[15] => z[32]) = 0;\\n\\t\\t(a[16] => z[32]) = 0;\\n\\t\\t(a[17] => z[32]) = 0;\\n\\t\\t(a[18] => z[32]) = 0;\\n\\t\\t(a[19] => z[32]) = 0;\\n\\t\\t(b[0] => z[32]) = 0;\\n\\t\\t(b[1] => z[32]) = 0;\\n\\t\\t(b[2] => z[32]) = 0;\\n\\t\\t(b[3] => z[32]) = 0;\\n\\t\\t(b[4] => z[32]) = 0;\\n\\t\\t(b[5] => z[32]) = 0;\\n\\t\\t(b[6] => z[32]) = 0;\\n\\t\\t(b[7] => z[32]) = 0;\\n\\t\\t(b[8] => z[32]) = 0;\\n\\t\\t(b[9] => z[32]) = 0;\\n\\t\\t(b[10] => z[32]) = 0;\\n\\t\\t(b[11] => z[32]) = 0;\\n\\t\\t(b[12] => z[32]) = 0;\\n\\t\\t(b[13] => z[32]) = 0;\\n\\t\\t(b[14] => z[32]) = 0;\\n\\t\\t(b[15] => z[32]) = 0;\\n\\t\\t(b[16] => z[32]) = 0;\\n\\t\\t(b[17] => z[32]) = 0;\\n\\t\\t(a[0] => z[33]) = 0;\\n\\t\\t(a[1] => z[33]) = 0;\\n\\t\\t(a[2] => z[33]) = 0;\\n\\t\\t(a[3] => z[33]) = 0;\\n\\t\\t(a[4] => z[33]) = 0;\\n\\t\\t(a[5] => z[33]) = 0;\\n\\t\\t(a[6] => z[33]) = 0;\\n\\t\\t(a[7] => z[33]) = 0;\\n\\t\\t(a[8] => z[33]) = 0;\\n\\t\\t(a[9] => z[33]) = 0;\\n\\t\\t(a[10] => z[33]) = 0;\\n\\t\\t(a[11] => z[33]) = 0;\\n\\t\\t(a[12] => z[33]) = 0;\\n\\t\\t(a[13] => z[33]) = 0;\\n\\t\\t(a[14] => z[33]) = 0;\\n\\t\\t(a[15] => z[33]) = 0;\\n\\t\\t(a[16] => z[33]) = 0;\\n\\t\\t(a[17] => z[33]) = 0;\\n\\t\\t(a[18] => z[33]) = 0;\\n\\t\\t(a[19] => z[33]) = 0;\\n\\t\\t(b[0] => z[33]) = 0;\\n\\t\\t(b[1] => z[33]) = 0;\\n\\t\\t(b[2] => z[33]) = 0;\\n\\t\\t(b[3] => z[33]) = 0;\\n\\t\\t(b[4] => z[33]) = 0;\\n\\t\\t(b[5] => z[33]) = 0;\\n\\t\\t(b[6] => z[33]) = 0;\\n\\t\\t(b[7] => z[33]) = 0;\\n\\t\\t(b[8] => z[33]) = 0;\\n\\t\\t(b[9] => z[33]) = 0;\\n\\t\\t(b[10] => z[33]) = 0;\\n\\t\\t(b[11] => z[33]) = 0;\\n\\t\\t(b[12] => z[33]) = 0;\\n\\t\\t(b[13] => z[33]) = 0;\\n\\t\\t(b[14] => z[33]) = 0;\\n\\t\\t(b[15] => z[33]) = 0;\\n\\t\\t(b[16] => z[33]) = 0;\\n\\t\\t(b[17] => z[33]) = 0;\\n\\t\\t(a[0] => z[34]) = 0;\\n\\t\\t(a[1] => z[34]) = 0;\\n\\t\\t(a[2] => z[34]) = 0;\\n\\t\\t(a[3] => z[34]) = 0;\\n\\t\\t(a[4] => z[34]) = 0;\\n\\t\\t(a[5] => z[34]) = 0;\\n\\t\\t(a[6] => z[34]) = 0;\\n\\t\\t(a[7] => z[34]) = 0;\\n\\t\\t(a[8] => z[34]) = 0;\\n\\t\\t(a[9] => z[34]) = 0;\\n\\t\\t(a[10] => z[34]) = 0;\\n\\t\\t(a[11] => z[34]) = 0;\\n\\t\\t(a[12] => z[34]) = 0;\\n\\t\\t(a[13] => z[34]) = 0;\\n\\t\\t(a[14] => z[34]) = 0;\\n\\t\\t(a[15] => z[34]) = 0;\\n\\t\\t(a[16] => z[34]) = 0;\\n\\t\\t(a[17] => z[34]) = 0;\\n\\t\\t(a[18] => z[34]) = 0;\\n\\t\\t(a[19] => z[34]) = 0;\\n\\t\\t(b[0] => z[34]) = 0;\\n\\t\\t(b[1] => z[34]) = 0;\\n\\t\\t(b[2] => z[34]) = 0;\\n\\t\\t(b[3] => z[34]) = 0;\\n\\t\\t(b[4] => z[34]) = 0;\\n\\t\\t(b[5] => z[34]) = 0;\\n\\t\\t(b[6] => z[34]) = 0;\\n\\t\\t(b[7] => z[34]) = 0;\\n\\t\\t(b[8] => z[34]) = 0;\\n\\t\\t(b[9] => z[34]) = 0;\\n\\t\\t(b[10] => z[34]) = 0;\\n\\t\\t(b[11] => z[34]) = 0;\\n\\t\\t(b[12] => z[34]) = 0;\\n\\t\\t(b[13] => z[34]) = 0;\\n\\t\\t(b[14] => z[34]) = 0;\\n\\t\\t(b[15] => z[34]) = 0;\\n\\t\\t(b[16] => z[34]) = 0;\\n\\t\\t(b[17] => z[34]) = 0;\\n\\t\\t(a[0] => z[35]) = 0;\\n\\t\\t(a[1] => z[35]) = 0;\\n\\t\\t(a[2] => z[35]) = 0;\\n\\t\\t(a[3] => z[35]) = 0;\\n\\t\\t(a[4] => z[35]) = 0;\\n\\t\\t(a[5] => z[35]) = 0;\\n\\t\\t(a[6] => z[35]) = 0;\\n\\t\\t(a[7] => z[35]) = 0;\\n\\t\\t(a[8] => z[35]) = 0;\\n\\t\\t(a[9] => z[35]) = 0;\\n\\t\\t(a[10] => z[35]) = 0;\\n\\t\\t(a[11] => z[35]) = 0;\\n\\t\\t(a[12] => z[35]) = 0;\\n\\t\\t(a[13] => z[35]) = 0;\\n\\t\\t(a[14] => z[35]) = 0;\\n\\t\\t(a[15] => z[35]) = 0;\\n\\t\\t(a[16] => z[35]) = 0;\\n\\t\\t(a[17] => z[35]) = 0;\\n\\t\\t(a[18] => z[35]) = 0;\\n\\t\\t(a[19] => z[35]) = 0;\\n\\t\\t(b[0] => z[35]) = 0;\\n\\t\\t(b[1] => z[35]) = 0;\\n\\t\\t(b[2] => z[35]) = 0;\\n\\t\\t(b[3] => z[35]) = 0;\\n\\t\\t(b[4] => z[35]) = 0;\\n\\t\\t(b[5] => z[35]) = 0;\\n\\t\\t(b[6] => z[35]) = 0;\\n\\t\\t(b[7] => z[35]) = 0;\\n\\t\\t(b[8] => z[35]) = 0;\\n\\t\\t(b[9] => z[35]) = 0;\\n\\t\\t(b[10] => z[35]) = 0;\\n\\t\\t(b[11] => z[35]) = 0;\\n\\t\\t(b[12] => z[35]) = 0;\\n\\t\\t(b[13] => z[35]) = 0;\\n\\t\\t(b[14] => z[35]) = 0;\\n\\t\\t(b[15] => z[35]) = 0;\\n\\t\\t(b[16] => z[35]) = 0;\\n\\t\\t(b[17] => z[35]) = 0;\\n\\t\\t(a[0] => z[36]) = 0;\\n\\t\\t(a[1] => z[36]) = 0;\\n\\t\\t(a[2] => z[36]) = 0;\\n\\t\\t(a[3] => z[36]) = 0;\\n\\t\\t(a[4] => z[36]) = 0;\\n\\t\\t(a[5] => z[36]) = 0;\\n\\t\\t(a[6] => z[36]) = 0;\\n\\t\\t(a[7] => z[36]) = 0;\\n\\t\\t(a[8] => z[36]) = 0;\\n\\t\\t(a[9] => z[36]) = 0;\\n\\t\\t(a[10] => z[36]) = 0;\\n\\t\\t(a[11] => z[36]) = 0;\\n\\t\\t(a[12] => z[36]) = 0;\\n\\t\\t(a[13] => z[36]) = 0;\\n\\t\\t(a[14] => z[36]) = 0;\\n\\t\\t(a[15] => z[36]) = 0;\\n\\t\\t(a[16] => z[36]) = 0;\\n\\t\\t(a[17] => z[36]) = 0;\\n\\t\\t(a[18] => z[36]) = 0;\\n\\t\\t(a[19] => z[36]) = 0;\\n\\t\\t(b[0] => z[36]) = 0;\\n\\t\\t(b[1] => z[36]) = 0;\\n\\t\\t(b[2] => z[36]) = 0;\\n\\t\\t(b[3] => z[36]) = 0;\\n\\t\\t(b[4] => z[36]) = 0;\\n\\t\\t(b[5] => z[36]) = 0;\\n\\t\\t(b[6] => z[36]) = 0;\\n\\t\\t(b[7] => z[36]) = 0;\\n\\t\\t(b[8] => z[36]) = 0;\\n\\t\\t(b[9] => z[36]) = 0;\\n\\t\\t(b[10] => z[36]) = 0;\\n\\t\\t(b[11] => z[36]) = 0;\\n\\t\\t(b[12] => z[36]) = 0;\\n\\t\\t(b[13] => z[36]) = 0;\\n\\t\\t(b[14] => z[36]) = 0;\\n\\t\\t(b[15] => z[36]) = 0;\\n\\t\\t(b[16] => z[36]) = 0;\\n\\t\\t(b[17] => z[36]) = 0;\\n\\t\\t(a[0] => z[37]) = 0;\\n\\t\\t(a[1] => z[37]) = 0;\\n\\t\\t(a[2] => z[37]) = 0;\\n\\t\\t(a[3] => z[37]) = 0;\\n\\t\\t(a[4] => z[37]) = 0;\\n\\t\\t(a[5] => z[37]) = 0;\\n\\t\\t(a[6] => z[37]) = 0;\\n\\t\\t(a[7] => z[37]) = 0;\\n\\t\\t(a[8] => z[37]) = 0;\\n\\t\\t(a[9] => z[37]) = 0;\\n\\t\\t(a[10] => z[37]) = 0;\\n\\t\\t(a[11] => z[37]) = 0;\\n\\t\\t(a[12] => z[37]) = 0;\\n\\t\\t(a[13] => z[37]) = 0;\\n\\t\\t(a[14] => z[37]) = 0;\\n\\t\\t(a[15] => z[37]) = 0;\\n\\t\\t(a[16] => z[37]) = 0;\\n\\t\\t(a[17] => z[37]) = 0;\\n\\t\\t(a[18] => z[37]) = 0;\\n\\t\\t(a[19] => z[37]) = 0;\\n\\t\\t(b[0] => z[37]) = 0;\\n\\t\\t(b[1] => z[37]) = 0;\\n\\t\\t(b[2] => z[37]) = 0;\\n\\t\\t(b[3] => z[37]) = 0;\\n\\t\\t(b[4] => z[37]) = 0;\\n\\t\\t(b[5] => z[37]) = 0;\\n\\t\\t(b[6] => z[37]) = 0;\\n\\t\\t(b[7] => z[37]) = 0;\\n\\t\\t(b[8] => z[37]) = 0;\\n\\t\\t(b[9] => z[37]) = 0;\\n\\t\\t(b[10] => z[37]) = 0;\\n\\t\\t(b[11] => z[37]) = 0;\\n\\t\\t(b[12] => z[37]) = 0;\\n\\t\\t(b[13] => z[37]) = 0;\\n\\t\\t(b[14] => z[37]) = 0;\\n\\t\\t(b[15] => z[37]) = 0;\\n\\t\\t(b[16] => z[37]) = 0;\\n\\t\\t(b[17] => z[37]) = 0;\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULT_REGIN ( // TODO: Name subject to change\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire       clk,\\n\\tinput  wire       reset,\\n\\n\\tinput  wire [2:0] feedback,\\n\\tinput  wire       unsigned_a,\\n\\tinput  wire       unsigned_b,\\n\\n\\tinput  wire       f_mode,\\n\\tinput  wire [2:0] output_select,\\n\\tinput  wire       register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.acc_fir(6'b0),\\n\\t\\t.z(z),\\n\\t\\t.dly_b(),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.load_acc(1'b0),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // unregistered output: a * b (0)\\n\\t\\t.saturate_enable(1'b0),\\n\\t\\t.shift_right(6'b0),\\n\\t\\t.round(1'b0),\\n\\t\\t.subtract(1'b0),\\n\\t\\t.register_inputs(register_inputs)   // registered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULT_REGOUT ( // TODO: Name subject to change\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire       clk,\\n\\tinput  wire       reset,\\n\\n\\tinput  wire [2:0] feedback,\\n\\tinput  wire       unsigned_a,\\n\\tinput  wire       unsigned_b,\\n\\tinput  wire       f_mode,\\n\\tinput  wire [2:0] output_select,\\n\\tinput  wire       register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.acc_fir(6'b0),\\n\\t\\t.z(z),\\n\\t\\t.dly_b(),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.load_acc(1'b0),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // registered output: a * b (4)\\n\\t\\t.saturate_enable(1'b0),\\n\\t\\t.shift_right(6'b0),\\n\\t\\t.round(1'b0),\\n\\t\\t.subtract(1'b0),\\n\\t\\t.register_inputs(register_inputs)   // unregistered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULT_REGIN_REGOUT ( // TODO: Name subject to change\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire       clk,\\n\\tinput  wire       reset,\\n\\n\\tinput  wire [2:0] feedback,\\n\\tinput  wire       unsigned_a,\\n\\tinput  wire       unsigned_b,\\n\\tinput  wire       f_mode,\\n\\tinput  wire [2:0] output_select,\\n\\tinput  wire       register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.acc_fir(6'b0),\\n\\t\\t.z(z),\\n\\t\\t.dly_b(),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.load_acc(1'b0),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // registered output: a * b (4)\\n\\t\\t.saturate_enable(1'b0),\\n\\t\\t.shift_right(6'b0),\\n\\t\\t.round(1'b0),\\n\\t\\t.subtract(1'b0),\\n\\t\\t.register_inputs(register_inputs)   // registered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULTADD (\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\tinput  wire        reset,\\n\\n\\tinput  wire [ 2:0] feedback,\\n\\tinput  wire [ 5:0] acc_fir,\\n\\tinput  wire        load_acc,\\n\\tinput  wire        unsigned_a,\\n\\tinput  wire        unsigned_b,\\n\\n\\tinput  wire        f_mode,\\n\\tinput  wire [ 2:0] output_select,\\n\\tinput  wire        saturate_enable,\\n\\tinput  wire [ 5:0] shift_right,\\n\\tinput  wire        round,\\n\\tinput  wire        subtract,\\n\\tinput  wire        register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.dly_b(),\\n\\t\\t.z(z),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.acc_fir(acc_fir),\\n\\t\\t.load_acc(load_acc),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t//.clk(1'b0),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // unregistered output: ACCin (2, 3)\\n\\t\\t.saturate_enable(saturate_enable),\\n\\t\\t.shift_right(shift_right),\\n\\t\\t.round(round),\\n\\t\\t.subtract(subtract),\\n\\t\\t.register_inputs(register_inputs)   // unregistered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(a[0] => z[0]) = 0;\\n\\t\\t(a[1] => z[0]) = 0;\\n\\t\\t(a[2] => z[0]) = 0;\\n\\t\\t(a[3] => z[0]) = 0;\\n\\t\\t(a[4] => z[0]) = 0;\\n\\t\\t(a[5] => z[0]) = 0;\\n\\t\\t(a[6] => z[0]) = 0;\\n\\t\\t(a[7] => z[0]) = 0;\\n\\t\\t(a[8] => z[0]) = 0;\\n\\t\\t(a[9] => z[0]) = 0;\\n\\t\\t(a[10] => z[0]) = 0;\\n\\t\\t(a[11] => z[0]) = 0;\\n\\t\\t(a[12] => z[0]) = 0;\\n\\t\\t(a[13] => z[0]) = 0;\\n\\t\\t(a[14] => z[0]) = 0;\\n\\t\\t(a[15] => z[0]) = 0;\\n\\t\\t(a[16] => z[0]) = 0;\\n\\t\\t(a[17] => z[0]) = 0;\\n\\t\\t(a[18] => z[0]) = 0;\\n\\t\\t(a[19] => z[0]) = 0;\\n\\t\\t(b[0] => z[0]) = 0;\\n\\t\\t(b[1] => z[0]) = 0;\\n\\t\\t(b[2] => z[0]) = 0;\\n\\t\\t(b[3] => z[0]) = 0;\\n\\t\\t(b[4] => z[0]) = 0;\\n\\t\\t(b[5] => z[0]) = 0;\\n\\t\\t(b[6] => z[0]) = 0;\\n\\t\\t(b[7] => z[0]) = 0;\\n\\t\\t(b[8] => z[0]) = 0;\\n\\t\\t(b[9] => z[0]) = 0;\\n\\t\\t(b[10] => z[0]) = 0;\\n\\t\\t(b[11] => z[0]) = 0;\\n\\t\\t(b[12] => z[0]) = 0;\\n\\t\\t(b[13] => z[0]) = 0;\\n\\t\\t(b[14] => z[0]) = 0;\\n\\t\\t(b[15] => z[0]) = 0;\\n\\t\\t(b[16] => z[0]) = 0;\\n\\t\\t(b[17] => z[0]) = 0;\\n\\t\\t(a[0] => z[1]) = 0;\\n\\t\\t(a[1] => z[1]) = 0;\\n\\t\\t(a[2] => z[1]) = 0;\\n\\t\\t(a[3] => z[1]) = 0;\\n\\t\\t(a[4] => z[1]) = 0;\\n\\t\\t(a[5] => z[1]) = 0;\\n\\t\\t(a[6] => z[1]) = 0;\\n\\t\\t(a[7] => z[1]) = 0;\\n\\t\\t(a[8] => z[1]) = 0;\\n\\t\\t(a[9] => z[1]) = 0;\\n\\t\\t(a[10] => z[1]) = 0;\\n\\t\\t(a[11] => z[1]) = 0;\\n\\t\\t(a[12] => z[1]) = 0;\\n\\t\\t(a[13] => z[1]) = 0;\\n\\t\\t(a[14] => z[1]) = 0;\\n\\t\\t(a[15] => z[1]) = 0;\\n\\t\\t(a[16] => z[1]) = 0;\\n\\t\\t(a[17] => z[1]) = 0;\\n\\t\\t(a[18] => z[1]) = 0;\\n\\t\\t(a[19] => z[1]) = 0;\\n\\t\\t(b[0] => z[1]) = 0;\\n\\t\\t(b[1] => z[1]) = 0;\\n\\t\\t(b[2] => z[1]) = 0;\\n\\t\\t(b[3] => z[1]) = 0;\\n\\t\\t(b[4] => z[1]) = 0;\\n\\t\\t(b[5] => z[1]) = 0;\\n\\t\\t(b[6] => z[1]) = 0;\\n\\t\\t(b[7] => z[1]) = 0;\\n\\t\\t(b[8] => z[1]) = 0;\\n\\t\\t(b[9] => z[1]) = 0;\\n\\t\\t(b[10] => z[1]) = 0;\\n\\t\\t(b[11] => z[1]) = 0;\\n\\t\\t(b[12] => z[1]) = 0;\\n\\t\\t(b[13] => z[1]) = 0;\\n\\t\\t(b[14] => z[1]) = 0;\\n\\t\\t(b[15] => z[1]) = 0;\\n\\t\\t(b[16] => z[1]) = 0;\\n\\t\\t(b[17] => z[1]) = 0;\\n\\t\\t(a[0] => z[2]) = 0;\\n\\t\\t(a[1] => z[2]) = 0;\\n\\t\\t(a[2] => z[2]) = 0;\\n\\t\\t(a[3] => z[2]) = 0;\\n\\t\\t(a[4] => z[2]) = 0;\\n\\t\\t(a[5] => z[2]) = 0;\\n\\t\\t(a[6] => z[2]) = 0;\\n\\t\\t(a[7] => z[2]) = 0;\\n\\t\\t(a[8] => z[2]) = 0;\\n\\t\\t(a[9] => z[2]) = 0;\\n\\t\\t(a[10] => z[2]) = 0;\\n\\t\\t(a[11] => z[2]) = 0;\\n\\t\\t(a[12] => z[2]) = 0;\\n\\t\\t(a[13] => z[2]) = 0;\\n\\t\\t(a[14] => z[2]) = 0;\\n\\t\\t(a[15] => z[2]) = 0;\\n\\t\\t(a[16] => z[2]) = 0;\\n\\t\\t(a[17] => z[2]) = 0;\\n\\t\\t(a[18] => z[2]) = 0;\\n\\t\\t(a[19] => z[2]) = 0;\\n\\t\\t(b[0] => z[2]) = 0;\\n\\t\\t(b[1] => z[2]) = 0;\\n\\t\\t(b[2] => z[2]) = 0;\\n\\t\\t(b[3] => z[2]) = 0;\\n\\t\\t(b[4] => z[2]) = 0;\\n\\t\\t(b[5] => z[2]) = 0;\\n\\t\\t(b[6] => z[2]) = 0;\\n\\t\\t(b[7] => z[2]) = 0;\\n\\t\\t(b[8] => z[2]) = 0;\\n\\t\\t(b[9] => z[2]) = 0;\\n\\t\\t(b[10] => z[2]) = 0;\\n\\t\\t(b[11] => z[2]) = 0;\\n\\t\\t(b[12] => z[2]) = 0;\\n\\t\\t(b[13] => z[2]) = 0;\\n\\t\\t(b[14] => z[2]) = 0;\\n\\t\\t(b[15] => z[2]) = 0;\\n\\t\\t(b[16] => z[2]) = 0;\\n\\t\\t(b[17] => z[2]) = 0;\\n\\t\\t(a[0] => z[3]) = 0;\\n\\t\\t(a[1] => z[3]) = 0;\\n\\t\\t(a[2] => z[3]) = 0;\\n\\t\\t(a[3] => z[3]) = 0;\\n\\t\\t(a[4] => z[3]) = 0;\\n\\t\\t(a[5] => z[3]) = 0;\\n\\t\\t(a[6] => z[3]) = 0;\\n\\t\\t(a[7] => z[3]) = 0;\\n\\t\\t(a[8] => z[3]) = 0;\\n\\t\\t(a[9] => z[3]) = 0;\\n\\t\\t(a[10] => z[3]) = 0;\\n\\t\\t(a[11] => z[3]) = 0;\\n\\t\\t(a[12] => z[3]) = 0;\\n\\t\\t(a[13] => z[3]) = 0;\\n\\t\\t(a[14] => z[3]) = 0;\\n\\t\\t(a[15] => z[3]) = 0;\\n\\t\\t(a[16] => z[3]) = 0;\\n\\t\\t(a[17] => z[3]) = 0;\\n\\t\\t(a[18] => z[3]) = 0;\\n\\t\\t(a[19] => z[3]) = 0;\\n\\t\\t(b[0] => z[3]) = 0;\\n\\t\\t(b[1] => z[3]) = 0;\\n\\t\\t(b[2] => z[3]) = 0;\\n\\t\\t(b[3] => z[3]) = 0;\\n\\t\\t(b[4] => z[3]) = 0;\\n\\t\\t(b[5] => z[3]) = 0;\\n\\t\\t(b[6] => z[3]) = 0;\\n\\t\\t(b[7] => z[3]) = 0;\\n\\t\\t(b[8] => z[3]) = 0;\\n\\t\\t(b[9] => z[3]) = 0;\\n\\t\\t(b[10] => z[3]) = 0;\\n\\t\\t(b[11] => z[3]) = 0;\\n\\t\\t(b[12] => z[3]) = 0;\\n\\t\\t(b[13] => z[3]) = 0;\\n\\t\\t(b[14] => z[3]) = 0;\\n\\t\\t(b[15] => z[3]) = 0;\\n\\t\\t(b[16] => z[3]) = 0;\\n\\t\\t(b[17] => z[3]) = 0;\\n\\t\\t(a[0] => z[4]) = 0;\\n\\t\\t(a[1] => z[4]) = 0;\\n\\t\\t(a[2] => z[4]) = 0;\\n\\t\\t(a[3] => z[4]) = 0;\\n\\t\\t(a[4] => z[4]) = 0;\\n\\t\\t(a[5] => z[4]) = 0;\\n\\t\\t(a[6] => z[4]) = 0;\\n\\t\\t(a[7] => z[4]) = 0;\\n\\t\\t(a[8] => z[4]) = 0;\\n\\t\\t(a[9] => z[4]) = 0;\\n\\t\\t(a[10] => z[4]) = 0;\\n\\t\\t(a[11] => z[4]) = 0;\\n\\t\\t(a[12] => z[4]) = 0;\\n\\t\\t(a[13] => z[4]) = 0;\\n\\t\\t(a[14] => z[4]) = 0;\\n\\t\\t(a[15] => z[4]) = 0;\\n\\t\\t(a[16] => z[4]) = 0;\\n\\t\\t(a[17] => z[4]) = 0;\\n\\t\\t(a[18] => z[4]) = 0;\\n\\t\\t(a[19] => z[4]) = 0;\\n\\t\\t(b[0] => z[4]) = 0;\\n\\t\\t(b[1] => z[4]) = 0;\\n\\t\\t(b[2] => z[4]) = 0;\\n\\t\\t(b[3] => z[4]) = 0;\\n\\t\\t(b[4] => z[4]) = 0;\\n\\t\\t(b[5] => z[4]) = 0;\\n\\t\\t(b[6] => z[4]) = 0;\\n\\t\\t(b[7] => z[4]) = 0;\\n\\t\\t(b[8] => z[4]) = 0;\\n\\t\\t(b[9] => z[4]) = 0;\\n\\t\\t(b[10] => z[4]) = 0;\\n\\t\\t(b[11] => z[4]) = 0;\\n\\t\\t(b[12] => z[4]) = 0;\\n\\t\\t(b[13] => z[4]) = 0;\\n\\t\\t(b[14] => z[4]) = 0;\\n\\t\\t(b[15] => z[4]) = 0;\\n\\t\\t(b[16] => z[4]) = 0;\\n\\t\\t(b[17] => z[4]) = 0;\\n\\t\\t(a[0] => z[5]) = 0;\\n\\t\\t(a[1] => z[5]) = 0;\\n\\t\\t(a[2] => z[5]) = 0;\\n\\t\\t(a[3] => z[5]) = 0;\\n\\t\\t(a[4] => z[5]) = 0;\\n\\t\\t(a[5] => z[5]) = 0;\\n\\t\\t(a[6] => z[5]) = 0;\\n\\t\\t(a[7] => z[5]) = 0;\\n\\t\\t(a[8] => z[5]) = 0;\\n\\t\\t(a[9] => z[5]) = 0;\\n\\t\\t(a[10] => z[5]) = 0;\\n\\t\\t(a[11] => z[5]) = 0;\\n\\t\\t(a[12] => z[5]) = 0;\\n\\t\\t(a[13] => z[5]) = 0;\\n\\t\\t(a[14] => z[5]) = 0;\\n\\t\\t(a[15] => z[5]) = 0;\\n\\t\\t(a[16] => z[5]) = 0;\\n\\t\\t(a[17] => z[5]) = 0;\\n\\t\\t(a[18] => z[5]) = 0;\\n\\t\\t(a[19] => z[5]) = 0;\\n\\t\\t(b[0] => z[5]) = 0;\\n\\t\\t(b[1] => z[5]) = 0;\\n\\t\\t(b[2] => z[5]) = 0;\\n\\t\\t(b[3] => z[5]) = 0;\\n\\t\\t(b[4] => z[5]) = 0;\\n\\t\\t(b[5] => z[5]) = 0;\\n\\t\\t(b[6] => z[5]) = 0;\\n\\t\\t(b[7] => z[5]) = 0;\\n\\t\\t(b[8] => z[5]) = 0;\\n\\t\\t(b[9] => z[5]) = 0;\\n\\t\\t(b[10] => z[5]) = 0;\\n\\t\\t(b[11] => z[5]) = 0;\\n\\t\\t(b[12] => z[5]) = 0;\\n\\t\\t(b[13] => z[5]) = 0;\\n\\t\\t(b[14] => z[5]) = 0;\\n\\t\\t(b[15] => z[5]) = 0;\\n\\t\\t(b[16] => z[5]) = 0;\\n\\t\\t(b[17] => z[5]) = 0;\\n\\t\\t(a[0] => z[6]) = 0;\\n\\t\\t(a[1] => z[6]) = 0;\\n\\t\\t(a[2] => z[6]) = 0;\\n\\t\\t(a[3] => z[6]) = 0;\\n\\t\\t(a[4] => z[6]) = 0;\\n\\t\\t(a[5] => z[6]) = 0;\\n\\t\\t(a[6] => z[6]) = 0;\\n\\t\\t(a[7] => z[6]) = 0;\\n\\t\\t(a[8] => z[6]) = 0;\\n\\t\\t(a[9] => z[6]) = 0;\\n\\t\\t(a[10] => z[6]) = 0;\\n\\t\\t(a[11] => z[6]) = 0;\\n\\t\\t(a[12] => z[6]) = 0;\\n\\t\\t(a[13] => z[6]) = 0;\\n\\t\\t(a[14] => z[6]) = 0;\\n\\t\\t(a[15] => z[6]) = 0;\\n\\t\\t(a[16] => z[6]) = 0;\\n\\t\\t(a[17] => z[6]) = 0;\\n\\t\\t(a[18] => z[6]) = 0;\\n\\t\\t(a[19] => z[6]) = 0;\\n\\t\\t(b[0] => z[6]) = 0;\\n\\t\\t(b[1] => z[6]) = 0;\\n\\t\\t(b[2] => z[6]) = 0;\\n\\t\\t(b[3] => z[6]) = 0;\\n\\t\\t(b[4] => z[6]) = 0;\\n\\t\\t(b[5] => z[6]) = 0;\\n\\t\\t(b[6] => z[6]) = 0;\\n\\t\\t(b[7] => z[6]) = 0;\\n\\t\\t(b[8] => z[6]) = 0;\\n\\t\\t(b[9] => z[6]) = 0;\\n\\t\\t(b[10] => z[6]) = 0;\\n\\t\\t(b[11] => z[6]) = 0;\\n\\t\\t(b[12] => z[6]) = 0;\\n\\t\\t(b[13] => z[6]) = 0;\\n\\t\\t(b[14] => z[6]) = 0;\\n\\t\\t(b[15] => z[6]) = 0;\\n\\t\\t(b[16] => z[6]) = 0;\\n\\t\\t(b[17] => z[6]) = 0;\\n\\t\\t(a[0] => z[7]) = 0;\\n\\t\\t(a[1] => z[7]) = 0;\\n\\t\\t(a[2] => z[7]) = 0;\\n\\t\\t(a[3] => z[7]) = 0;\\n\\t\\t(a[4] => z[7]) = 0;\\n\\t\\t(a[5] => z[7]) = 0;\\n\\t\\t(a[6] => z[7]) = 0;\\n\\t\\t(a[7] => z[7]) = 0;\\n\\t\\t(a[8] => z[7]) = 0;\\n\\t\\t(a[9] => z[7]) = 0;\\n\\t\\t(a[10] => z[7]) = 0;\\n\\t\\t(a[11] => z[7]) = 0;\\n\\t\\t(a[12] => z[7]) = 0;\\n\\t\\t(a[13] => z[7]) = 0;\\n\\t\\t(a[14] => z[7]) = 0;\\n\\t\\t(a[15] => z[7]) = 0;\\n\\t\\t(a[16] => z[7]) = 0;\\n\\t\\t(a[17] => z[7]) = 0;\\n\\t\\t(a[18] => z[7]) = 0;\\n\\t\\t(a[19] => z[7]) = 0;\\n\\t\\t(b[0] => z[7]) = 0;\\n\\t\\t(b[1] => z[7]) = 0;\\n\\t\\t(b[2] => z[7]) = 0;\\n\\t\\t(b[3] => z[7]) = 0;\\n\\t\\t(b[4] => z[7]) = 0;\\n\\t\\t(b[5] => z[7]) = 0;\\n\\t\\t(b[6] => z[7]) = 0;\\n\\t\\t(b[7] => z[7]) = 0;\\n\\t\\t(b[8] => z[7]) = 0;\\n\\t\\t(b[9] => z[7]) = 0;\\n\\t\\t(b[10] => z[7]) = 0;\\n\\t\\t(b[11] => z[7]) = 0;\\n\\t\\t(b[12] => z[7]) = 0;\\n\\t\\t(b[13] => z[7]) = 0;\\n\\t\\t(b[14] => z[7]) = 0;\\n\\t\\t(b[15] => z[7]) = 0;\\n\\t\\t(b[16] => z[7]) = 0;\\n\\t\\t(b[17] => z[7]) = 0;\\n\\t\\t(a[0] => z[8]) = 0;\\n\\t\\t(a[1] => z[8]) = 0;\\n\\t\\t(a[2] => z[8]) = 0;\\n\\t\\t(a[3] => z[8]) = 0;\\n\\t\\t(a[4] => z[8]) = 0;\\n\\t\\t(a[5] => z[8]) = 0;\\n\\t\\t(a[6] => z[8]) = 0;\\n\\t\\t(a[7] => z[8]) = 0;\\n\\t\\t(a[8] => z[8]) = 0;\\n\\t\\t(a[9] => z[8]) = 0;\\n\\t\\t(a[10] => z[8]) = 0;\\n\\t\\t(a[11] => z[8]) = 0;\\n\\t\\t(a[12] => z[8]) = 0;\\n\\t\\t(a[13] => z[8]) = 0;\\n\\t\\t(a[14] => z[8]) = 0;\\n\\t\\t(a[15] => z[8]) = 0;\\n\\t\\t(a[16] => z[8]) = 0;\\n\\t\\t(a[17] => z[8]) = 0;\\n\\t\\t(a[18] => z[8]) = 0;\\n\\t\\t(a[19] => z[8]) = 0;\\n\\t\\t(b[0] => z[8]) = 0;\\n\\t\\t(b[1] => z[8]) = 0;\\n\\t\\t(b[2] => z[8]) = 0;\\n\\t\\t(b[3] => z[8]) = 0;\\n\\t\\t(b[4] => z[8]) = 0;\\n\\t\\t(b[5] => z[8]) = 0;\\n\\t\\t(b[6] => z[8]) = 0;\\n\\t\\t(b[7] => z[8]) = 0;\\n\\t\\t(b[8] => z[8]) = 0;\\n\\t\\t(b[9] => z[8]) = 0;\\n\\t\\t(b[10] => z[8]) = 0;\\n\\t\\t(b[11] => z[8]) = 0;\\n\\t\\t(b[12] => z[8]) = 0;\\n\\t\\t(b[13] => z[8]) = 0;\\n\\t\\t(b[14] => z[8]) = 0;\\n\\t\\t(b[15] => z[8]) = 0;\\n\\t\\t(b[16] => z[8]) = 0;\\n\\t\\t(b[17] => z[8]) = 0;\\n\\t\\t(a[0] => z[9]) = 0;\\n\\t\\t(a[1] => z[9]) = 0;\\n\\t\\t(a[2] => z[9]) = 0;\\n\\t\\t(a[3] => z[9]) = 0;\\n\\t\\t(a[4] => z[9]) = 0;\\n\\t\\t(a[5] => z[9]) = 0;\\n\\t\\t(a[6] => z[9]) = 0;\\n\\t\\t(a[7] => z[9]) = 0;\\n\\t\\t(a[8] => z[9]) = 0;\\n\\t\\t(a[9] => z[9]) = 0;\\n\\t\\t(a[10] => z[9]) = 0;\\n\\t\\t(a[11] => z[9]) = 0;\\n\\t\\t(a[12] => z[9]) = 0;\\n\\t\\t(a[13] => z[9]) = 0;\\n\\t\\t(a[14] => z[9]) = 0;\\n\\t\\t(a[15] => z[9]) = 0;\\n\\t\\t(a[16] => z[9]) = 0;\\n\\t\\t(a[17] => z[9]) = 0;\\n\\t\\t(a[18] => z[9]) = 0;\\n\\t\\t(a[19] => z[9]) = 0;\\n\\t\\t(b[0] => z[9]) = 0;\\n\\t\\t(b[1] => z[9]) = 0;\\n\\t\\t(b[2] => z[9]) = 0;\\n\\t\\t(b[3] => z[9]) = 0;\\n\\t\\t(b[4] => z[9]) = 0;\\n\\t\\t(b[5] => z[9]) = 0;\\n\\t\\t(b[6] => z[9]) = 0;\\n\\t\\t(b[7] => z[9]) = 0;\\n\\t\\t(b[8] => z[9]) = 0;\\n\\t\\t(b[9] => z[9]) = 0;\\n\\t\\t(b[10] => z[9]) = 0;\\n\\t\\t(b[11] => z[9]) = 0;\\n\\t\\t(b[12] => z[9]) = 0;\\n\\t\\t(b[13] => z[9]) = 0;\\n\\t\\t(b[14] => z[9]) = 0;\\n\\t\\t(b[15] => z[9]) = 0;\\n\\t\\t(b[16] => z[9]) = 0;\\n\\t\\t(b[17] => z[9]) = 0;\\n\\t\\t(a[0] => z[10]) = 0;\\n\\t\\t(a[1] => z[10]) = 0;\\n\\t\\t(a[2] => z[10]) = 0;\\n\\t\\t(a[3] => z[10]) = 0;\\n\\t\\t(a[4] => z[10]) = 0;\\n\\t\\t(a[5] => z[10]) = 0;\\n\\t\\t(a[6] => z[10]) = 0;\\n\\t\\t(a[7] => z[10]) = 0;\\n\\t\\t(a[8] => z[10]) = 0;\\n\\t\\t(a[9] => z[10]) = 0;\\n\\t\\t(a[10] => z[10]) = 0;\\n\\t\\t(a[11] => z[10]) = 0;\\n\\t\\t(a[12] => z[10]) = 0;\\n\\t\\t(a[13] => z[10]) = 0;\\n\\t\\t(a[14] => z[10]) = 0;\\n\\t\\t(a[15] => z[10]) = 0;\\n\\t\\t(a[16] => z[10]) = 0;\\n\\t\\t(a[17] => z[10]) = 0;\\n\\t\\t(a[18] => z[10]) = 0;\\n\\t\\t(a[19] => z[10]) = 0;\\n\\t\\t(b[0] => z[10]) = 0;\\n\\t\\t(b[1] => z[10]) = 0;\\n\\t\\t(b[2] => z[10]) = 0;\\n\\t\\t(b[3] => z[10]) = 0;\\n\\t\\t(b[4] => z[10]) = 0;\\n\\t\\t(b[5] => z[10]) = 0;\\n\\t\\t(b[6] => z[10]) = 0;\\n\\t\\t(b[7] => z[10]) = 0;\\n\\t\\t(b[8] => z[10]) = 0;\\n\\t\\t(b[9] => z[10]) = 0;\\n\\t\\t(b[10] => z[10]) = 0;\\n\\t\\t(b[11] => z[10]) = 0;\\n\\t\\t(b[12] => z[10]) = 0;\\n\\t\\t(b[13] => z[10]) = 0;\\n\\t\\t(b[14] => z[10]) = 0;\\n\\t\\t(b[15] => z[10]) = 0;\\n\\t\\t(b[16] => z[10]) = 0;\\n\\t\\t(b[17] => z[10]) = 0;\\n\\t\\t(a[0] => z[11]) = 0;\\n\\t\\t(a[1] => z[11]) = 0;\\n\\t\\t(a[2] => z[11]) = 0;\\n\\t\\t(a[3] => z[11]) = 0;\\n\\t\\t(a[4] => z[11]) = 0;\\n\\t\\t(a[5] => z[11]) = 0;\\n\\t\\t(a[6] => z[11]) = 0;\\n\\t\\t(a[7] => z[11]) = 0;\\n\\t\\t(a[8] => z[11]) = 0;\\n\\t\\t(a[9] => z[11]) = 0;\\n\\t\\t(a[10] => z[11]) = 0;\\n\\t\\t(a[11] => z[11]) = 0;\\n\\t\\t(a[12] => z[11]) = 0;\\n\\t\\t(a[13] => z[11]) = 0;\\n\\t\\t(a[14] => z[11]) = 0;\\n\\t\\t(a[15] => z[11]) = 0;\\n\\t\\t(a[16] => z[11]) = 0;\\n\\t\\t(a[17] => z[11]) = 0;\\n\\t\\t(a[18] => z[11]) = 0;\\n\\t\\t(a[19] => z[11]) = 0;\\n\\t\\t(b[0] => z[11]) = 0;\\n\\t\\t(b[1] => z[11]) = 0;\\n\\t\\t(b[2] => z[11]) = 0;\\n\\t\\t(b[3] => z[11]) = 0;\\n\\t\\t(b[4] => z[11]) = 0;\\n\\t\\t(b[5] => z[11]) = 0;\\n\\t\\t(b[6] => z[11]) = 0;\\n\\t\\t(b[7] => z[11]) = 0;\\n\\t\\t(b[8] => z[11]) = 0;\\n\\t\\t(b[9] => z[11]) = 0;\\n\\t\\t(b[10] => z[11]) = 0;\\n\\t\\t(b[11] => z[11]) = 0;\\n\\t\\t(b[12] => z[11]) = 0;\\n\\t\\t(b[13] => z[11]) = 0;\\n\\t\\t(b[14] => z[11]) = 0;\\n\\t\\t(b[15] => z[11]) = 0;\\n\\t\\t(b[16] => z[11]) = 0;\\n\\t\\t(b[17] => z[11]) = 0;\\n\\t\\t(a[0] => z[12]) = 0;\\n\\t\\t(a[1] => z[12]) = 0;\\n\\t\\t(a[2] => z[12]) = 0;\\n\\t\\t(a[3] => z[12]) = 0;\\n\\t\\t(a[4] => z[12]) = 0;\\n\\t\\t(a[5] => z[12]) = 0;\\n\\t\\t(a[6] => z[12]) = 0;\\n\\t\\t(a[7] => z[12]) = 0;\\n\\t\\t(a[8] => z[12]) = 0;\\n\\t\\t(a[9] => z[12]) = 0;\\n\\t\\t(a[10] => z[12]) = 0;\\n\\t\\t(a[11] => z[12]) = 0;\\n\\t\\t(a[12] => z[12]) = 0;\\n\\t\\t(a[13] => z[12]) = 0;\\n\\t\\t(a[14] => z[12]) = 0;\\n\\t\\t(a[15] => z[12]) = 0;\\n\\t\\t(a[16] => z[12]) = 0;\\n\\t\\t(a[17] => z[12]) = 0;\\n\\t\\t(a[18] => z[12]) = 0;\\n\\t\\t(a[19] => z[12]) = 0;\\n\\t\\t(b[0] => z[12]) = 0;\\n\\t\\t(b[1] => z[12]) = 0;\\n\\t\\t(b[2] => z[12]) = 0;\\n\\t\\t(b[3] => z[12]) = 0;\\n\\t\\t(b[4] => z[12]) = 0;\\n\\t\\t(b[5] => z[12]) = 0;\\n\\t\\t(b[6] => z[12]) = 0;\\n\\t\\t(b[7] => z[12]) = 0;\\n\\t\\t(b[8] => z[12]) = 0;\\n\\t\\t(b[9] => z[12]) = 0;\\n\\t\\t(b[10] => z[12]) = 0;\\n\\t\\t(b[11] => z[12]) = 0;\\n\\t\\t(b[12] => z[12]) = 0;\\n\\t\\t(b[13] => z[12]) = 0;\\n\\t\\t(b[14] => z[12]) = 0;\\n\\t\\t(b[15] => z[12]) = 0;\\n\\t\\t(b[16] => z[12]) = 0;\\n\\t\\t(b[17] => z[12]) = 0;\\n\\t\\t(a[0] => z[13]) = 0;\\n\\t\\t(a[1] => z[13]) = 0;\\n\\t\\t(a[2] => z[13]) = 0;\\n\\t\\t(a[3] => z[13]) = 0;\\n\\t\\t(a[4] => z[13]) = 0;\\n\\t\\t(a[5] => z[13]) = 0;\\n\\t\\t(a[6] => z[13]) = 0;\\n\\t\\t(a[7] => z[13]) = 0;\\n\\t\\t(a[8] => z[13]) = 0;\\n\\t\\t(a[9] => z[13]) = 0;\\n\\t\\t(a[10] => z[13]) = 0;\\n\\t\\t(a[11] => z[13]) = 0;\\n\\t\\t(a[12] => z[13]) = 0;\\n\\t\\t(a[13] => z[13]) = 0;\\n\\t\\t(a[14] => z[13]) = 0;\\n\\t\\t(a[15] => z[13]) = 0;\\n\\t\\t(a[16] => z[13]) = 0;\\n\\t\\t(a[17] => z[13]) = 0;\\n\\t\\t(a[18] => z[13]) = 0;\\n\\t\\t(a[19] => z[13]) = 0;\\n\\t\\t(b[0] => z[13]) = 0;\\n\\t\\t(b[1] => z[13]) = 0;\\n\\t\\t(b[2] => z[13]) = 0;\\n\\t\\t(b[3] => z[13]) = 0;\\n\\t\\t(b[4] => z[13]) = 0;\\n\\t\\t(b[5] => z[13]) = 0;\\n\\t\\t(b[6] => z[13]) = 0;\\n\\t\\t(b[7] => z[13]) = 0;\\n\\t\\t(b[8] => z[13]) = 0;\\n\\t\\t(b[9] => z[13]) = 0;\\n\\t\\t(b[10] => z[13]) = 0;\\n\\t\\t(b[11] => z[13]) = 0;\\n\\t\\t(b[12] => z[13]) = 0;\\n\\t\\t(b[13] => z[13]) = 0;\\n\\t\\t(b[14] => z[13]) = 0;\\n\\t\\t(b[15] => z[13]) = 0;\\n\\t\\t(b[16] => z[13]) = 0;\\n\\t\\t(b[17] => z[13]) = 0;\\n\\t\\t(a[0] => z[14]) = 0;\\n\\t\\t(a[1] => z[14]) = 0;\\n\\t\\t(a[2] => z[14]) = 0;\\n\\t\\t(a[3] => z[14]) = 0;\\n\\t\\t(a[4] => z[14]) = 0;\\n\\t\\t(a[5] => z[14]) = 0;\\n\\t\\t(a[6] => z[14]) = 0;\\n\\t\\t(a[7] => z[14]) = 0;\\n\\t\\t(a[8] => z[14]) = 0;\\n\\t\\t(a[9] => z[14]) = 0;\\n\\t\\t(a[10] => z[14]) = 0;\\n\\t\\t(a[11] => z[14]) = 0;\\n\\t\\t(a[12] => z[14]) = 0;\\n\\t\\t(a[13] => z[14]) = 0;\\n\\t\\t(a[14] => z[14]) = 0;\\n\\t\\t(a[15] => z[14]) = 0;\\n\\t\\t(a[16] => z[14]) = 0;\\n\\t\\t(a[17] => z[14]) = 0;\\n\\t\\t(a[18] => z[14]) = 0;\\n\\t\\t(a[19] => z[14]) = 0;\\n\\t\\t(b[0] => z[14]) = 0;\\n\\t\\t(b[1] => z[14]) = 0;\\n\\t\\t(b[2] => z[14]) = 0;\\n\\t\\t(b[3] => z[14]) = 0;\\n\\t\\t(b[4] => z[14]) = 0;\\n\\t\\t(b[5] => z[14]) = 0;\\n\\t\\t(b[6] => z[14]) = 0;\\n\\t\\t(b[7] => z[14]) = 0;\\n\\t\\t(b[8] => z[14]) = 0;\\n\\t\\t(b[9] => z[14]) = 0;\\n\\t\\t(b[10] => z[14]) = 0;\\n\\t\\t(b[11] => z[14]) = 0;\\n\\t\\t(b[12] => z[14]) = 0;\\n\\t\\t(b[13] => z[14]) = 0;\\n\\t\\t(b[14] => z[14]) = 0;\\n\\t\\t(b[15] => z[14]) = 0;\\n\\t\\t(b[16] => z[14]) = 0;\\n\\t\\t(b[17] => z[14]) = 0;\\n\\t\\t(a[0] => z[15]) = 0;\\n\\t\\t(a[1] => z[15]) = 0;\\n\\t\\t(a[2] => z[15]) = 0;\\n\\t\\t(a[3] => z[15]) = 0;\\n\\t\\t(a[4] => z[15]) = 0;\\n\\t\\t(a[5] => z[15]) = 0;\\n\\t\\t(a[6] => z[15]) = 0;\\n\\t\\t(a[7] => z[15]) = 0;\\n\\t\\t(a[8] => z[15]) = 0;\\n\\t\\t(a[9] => z[15]) = 0;\\n\\t\\t(a[10] => z[15]) = 0;\\n\\t\\t(a[11] => z[15]) = 0;\\n\\t\\t(a[12] => z[15]) = 0;\\n\\t\\t(a[13] => z[15]) = 0;\\n\\t\\t(a[14] => z[15]) = 0;\\n\\t\\t(a[15] => z[15]) = 0;\\n\\t\\t(a[16] => z[15]) = 0;\\n\\t\\t(a[17] => z[15]) = 0;\\n\\t\\t(a[18] => z[15]) = 0;\\n\\t\\t(a[19] => z[15]) = 0;\\n\\t\\t(b[0] => z[15]) = 0;\\n\\t\\t(b[1] => z[15]) = 0;\\n\\t\\t(b[2] => z[15]) = 0;\\n\\t\\t(b[3] => z[15]) = 0;\\n\\t\\t(b[4] => z[15]) = 0;\\n\\t\\t(b[5] => z[15]) = 0;\\n\\t\\t(b[6] => z[15]) = 0;\\n\\t\\t(b[7] => z[15]) = 0;\\n\\t\\t(b[8] => z[15]) = 0;\\n\\t\\t(b[9] => z[15]) = 0;\\n\\t\\t(b[10] => z[15]) = 0;\\n\\t\\t(b[11] => z[15]) = 0;\\n\\t\\t(b[12] => z[15]) = 0;\\n\\t\\t(b[13] => z[15]) = 0;\\n\\t\\t(b[14] => z[15]) = 0;\\n\\t\\t(b[15] => z[15]) = 0;\\n\\t\\t(b[16] => z[15]) = 0;\\n\\t\\t(b[17] => z[15]) = 0;\\n\\t\\t(a[0] => z[16]) = 0;\\n\\t\\t(a[1] => z[16]) = 0;\\n\\t\\t(a[2] => z[16]) = 0;\\n\\t\\t(a[3] => z[16]) = 0;\\n\\t\\t(a[4] => z[16]) = 0;\\n\\t\\t(a[5] => z[16]) = 0;\\n\\t\\t(a[6] => z[16]) = 0;\\n\\t\\t(a[7] => z[16]) = 0;\\n\\t\\t(a[8] => z[16]) = 0;\\n\\t\\t(a[9] => z[16]) = 0;\\n\\t\\t(a[10] => z[16]) = 0;\\n\\t\\t(a[11] => z[16]) = 0;\\n\\t\\t(a[12] => z[16]) = 0;\\n\\t\\t(a[13] => z[16]) = 0;\\n\\t\\t(a[14] => z[16]) = 0;\\n\\t\\t(a[15] => z[16]) = 0;\\n\\t\\t(a[16] => z[16]) = 0;\\n\\t\\t(a[17] => z[16]) = 0;\\n\\t\\t(a[18] => z[16]) = 0;\\n\\t\\t(a[19] => z[16]) = 0;\\n\\t\\t(b[0] => z[16]) = 0;\\n\\t\\t(b[1] => z[16]) = 0;\\n\\t\\t(b[2] => z[16]) = 0;\\n\\t\\t(b[3] => z[16]) = 0;\\n\\t\\t(b[4] => z[16]) = 0;\\n\\t\\t(b[5] => z[16]) = 0;\\n\\t\\t(b[6] => z[16]) = 0;\\n\\t\\t(b[7] => z[16]) = 0;\\n\\t\\t(b[8] => z[16]) = 0;\\n\\t\\t(b[9] => z[16]) = 0;\\n\\t\\t(b[10] => z[16]) = 0;\\n\\t\\t(b[11] => z[16]) = 0;\\n\\t\\t(b[12] => z[16]) = 0;\\n\\t\\t(b[13] => z[16]) = 0;\\n\\t\\t(b[14] => z[16]) = 0;\\n\\t\\t(b[15] => z[16]) = 0;\\n\\t\\t(b[16] => z[16]) = 0;\\n\\t\\t(b[17] => z[16]) = 0;\\n\\t\\t(a[0] => z[17]) = 0;\\n\\t\\t(a[1] => z[17]) = 0;\\n\\t\\t(a[2] => z[17]) = 0;\\n\\t\\t(a[3] => z[17]) = 0;\\n\\t\\t(a[4] => z[17]) = 0;\\n\\t\\t(a[5] => z[17]) = 0;\\n\\t\\t(a[6] => z[17]) = 0;\\n\\t\\t(a[7] => z[17]) = 0;\\n\\t\\t(a[8] => z[17]) = 0;\\n\\t\\t(a[9] => z[17]) = 0;\\n\\t\\t(a[10] => z[17]) = 0;\\n\\t\\t(a[11] => z[17]) = 0;\\n\\t\\t(a[12] => z[17]) = 0;\\n\\t\\t(a[13] => z[17]) = 0;\\n\\t\\t(a[14] => z[17]) = 0;\\n\\t\\t(a[15] => z[17]) = 0;\\n\\t\\t(a[16] => z[17]) = 0;\\n\\t\\t(a[17] => z[17]) = 0;\\n\\t\\t(a[18] => z[17]) = 0;\\n\\t\\t(a[19] => z[17]) = 0;\\n\\t\\t(b[0] => z[17]) = 0;\\n\\t\\t(b[1] => z[17]) = 0;\\n\\t\\t(b[2] => z[17]) = 0;\\n\\t\\t(b[3] => z[17]) = 0;\\n\\t\\t(b[4] => z[17]) = 0;\\n\\t\\t(b[5] => z[17]) = 0;\\n\\t\\t(b[6] => z[17]) = 0;\\n\\t\\t(b[7] => z[17]) = 0;\\n\\t\\t(b[8] => z[17]) = 0;\\n\\t\\t(b[9] => z[17]) = 0;\\n\\t\\t(b[10] => z[17]) = 0;\\n\\t\\t(b[11] => z[17]) = 0;\\n\\t\\t(b[12] => z[17]) = 0;\\n\\t\\t(b[13] => z[17]) = 0;\\n\\t\\t(b[14] => z[17]) = 0;\\n\\t\\t(b[15] => z[17]) = 0;\\n\\t\\t(b[16] => z[17]) = 0;\\n\\t\\t(b[17] => z[17]) = 0;\\n\\t\\t(a[0] => z[18]) = 0;\\n\\t\\t(a[1] => z[18]) = 0;\\n\\t\\t(a[2] => z[18]) = 0;\\n\\t\\t(a[3] => z[18]) = 0;\\n\\t\\t(a[4] => z[18]) = 0;\\n\\t\\t(a[5] => z[18]) = 0;\\n\\t\\t(a[6] => z[18]) = 0;\\n\\t\\t(a[7] => z[18]) = 0;\\n\\t\\t(a[8] => z[18]) = 0;\\n\\t\\t(a[9] => z[18]) = 0;\\n\\t\\t(a[10] => z[18]) = 0;\\n\\t\\t(a[11] => z[18]) = 0;\\n\\t\\t(a[12] => z[18]) = 0;\\n\\t\\t(a[13] => z[18]) = 0;\\n\\t\\t(a[14] => z[18]) = 0;\\n\\t\\t(a[15] => z[18]) = 0;\\n\\t\\t(a[16] => z[18]) = 0;\\n\\t\\t(a[17] => z[18]) = 0;\\n\\t\\t(a[18] => z[18]) = 0;\\n\\t\\t(a[19] => z[18]) = 0;\\n\\t\\t(b[0] => z[18]) = 0;\\n\\t\\t(b[1] => z[18]) = 0;\\n\\t\\t(b[2] => z[18]) = 0;\\n\\t\\t(b[3] => z[18]) = 0;\\n\\t\\t(b[4] => z[18]) = 0;\\n\\t\\t(b[5] => z[18]) = 0;\\n\\t\\t(b[6] => z[18]) = 0;\\n\\t\\t(b[7] => z[18]) = 0;\\n\\t\\t(b[8] => z[18]) = 0;\\n\\t\\t(b[9] => z[18]) = 0;\\n\\t\\t(b[10] => z[18]) = 0;\\n\\t\\t(b[11] => z[18]) = 0;\\n\\t\\t(b[12] => z[18]) = 0;\\n\\t\\t(b[13] => z[18]) = 0;\\n\\t\\t(b[14] => z[18]) = 0;\\n\\t\\t(b[15] => z[18]) = 0;\\n\\t\\t(b[16] => z[18]) = 0;\\n\\t\\t(b[17] => z[18]) = 0;\\n\\t\\t(a[0] => z[19]) = 0;\\n\\t\\t(a[1] => z[19]) = 0;\\n\\t\\t(a[2] => z[19]) = 0;\\n\\t\\t(a[3] => z[19]) = 0;\\n\\t\\t(a[4] => z[19]) = 0;\\n\\t\\t(a[5] => z[19]) = 0;\\n\\t\\t(a[6] => z[19]) = 0;\\n\\t\\t(a[7] => z[19]) = 0;\\n\\t\\t(a[8] => z[19]) = 0;\\n\\t\\t(a[9] => z[19]) = 0;\\n\\t\\t(a[10] => z[19]) = 0;\\n\\t\\t(a[11] => z[19]) = 0;\\n\\t\\t(a[12] => z[19]) = 0;\\n\\t\\t(a[13] => z[19]) = 0;\\n\\t\\t(a[14] => z[19]) = 0;\\n\\t\\t(a[15] => z[19]) = 0;\\n\\t\\t(a[16] => z[19]) = 0;\\n\\t\\t(a[17] => z[19]) = 0;\\n\\t\\t(a[18] => z[19]) = 0;\\n\\t\\t(a[19] => z[19]) = 0;\\n\\t\\t(b[0] => z[19]) = 0;\\n\\t\\t(b[1] => z[19]) = 0;\\n\\t\\t(b[2] => z[19]) = 0;\\n\\t\\t(b[3] => z[19]) = 0;\\n\\t\\t(b[4] => z[19]) = 0;\\n\\t\\t(b[5] => z[19]) = 0;\\n\\t\\t(b[6] => z[19]) = 0;\\n\\t\\t(b[7] => z[19]) = 0;\\n\\t\\t(b[8] => z[19]) = 0;\\n\\t\\t(b[9] => z[19]) = 0;\\n\\t\\t(b[10] => z[19]) = 0;\\n\\t\\t(b[11] => z[19]) = 0;\\n\\t\\t(b[12] => z[19]) = 0;\\n\\t\\t(b[13] => z[19]) = 0;\\n\\t\\t(b[14] => z[19]) = 0;\\n\\t\\t(b[15] => z[19]) = 0;\\n\\t\\t(b[16] => z[19]) = 0;\\n\\t\\t(b[17] => z[19]) = 0;\\n\\t\\t(a[0] => z[20]) = 0;\\n\\t\\t(a[1] => z[20]) = 0;\\n\\t\\t(a[2] => z[20]) = 0;\\n\\t\\t(a[3] => z[20]) = 0;\\n\\t\\t(a[4] => z[20]) = 0;\\n\\t\\t(a[5] => z[20]) = 0;\\n\\t\\t(a[6] => z[20]) = 0;\\n\\t\\t(a[7] => z[20]) = 0;\\n\\t\\t(a[8] => z[20]) = 0;\\n\\t\\t(a[9] => z[20]) = 0;\\n\\t\\t(a[10] => z[20]) = 0;\\n\\t\\t(a[11] => z[20]) = 0;\\n\\t\\t(a[12] => z[20]) = 0;\\n\\t\\t(a[13] => z[20]) = 0;\\n\\t\\t(a[14] => z[20]) = 0;\\n\\t\\t(a[15] => z[20]) = 0;\\n\\t\\t(a[16] => z[20]) = 0;\\n\\t\\t(a[17] => z[20]) = 0;\\n\\t\\t(a[18] => z[20]) = 0;\\n\\t\\t(a[19] => z[20]) = 0;\\n\\t\\t(b[0] => z[20]) = 0;\\n\\t\\t(b[1] => z[20]) = 0;\\n\\t\\t(b[2] => z[20]) = 0;\\n\\t\\t(b[3] => z[20]) = 0;\\n\\t\\t(b[4] => z[20]) = 0;\\n\\t\\t(b[5] => z[20]) = 0;\\n\\t\\t(b[6] => z[20]) = 0;\\n\\t\\t(b[7] => z[20]) = 0;\\n\\t\\t(b[8] => z[20]) = 0;\\n\\t\\t(b[9] => z[20]) = 0;\\n\\t\\t(b[10] => z[20]) = 0;\\n\\t\\t(b[11] => z[20]) = 0;\\n\\t\\t(b[12] => z[20]) = 0;\\n\\t\\t(b[13] => z[20]) = 0;\\n\\t\\t(b[14] => z[20]) = 0;\\n\\t\\t(b[15] => z[20]) = 0;\\n\\t\\t(b[16] => z[20]) = 0;\\n\\t\\t(b[17] => z[20]) = 0;\\n\\t\\t(a[0] => z[21]) = 0;\\n\\t\\t(a[1] => z[21]) = 0;\\n\\t\\t(a[2] => z[21]) = 0;\\n\\t\\t(a[3] => z[21]) = 0;\\n\\t\\t(a[4] => z[21]) = 0;\\n\\t\\t(a[5] => z[21]) = 0;\\n\\t\\t(a[6] => z[21]) = 0;\\n\\t\\t(a[7] => z[21]) = 0;\\n\\t\\t(a[8] => z[21]) = 0;\\n\\t\\t(a[9] => z[21]) = 0;\\n\\t\\t(a[10] => z[21]) = 0;\\n\\t\\t(a[11] => z[21]) = 0;\\n\\t\\t(a[12] => z[21]) = 0;\\n\\t\\t(a[13] => z[21]) = 0;\\n\\t\\t(a[14] => z[21]) = 0;\\n\\t\\t(a[15] => z[21]) = 0;\\n\\t\\t(a[16] => z[21]) = 0;\\n\\t\\t(a[17] => z[21]) = 0;\\n\\t\\t(a[18] => z[21]) = 0;\\n\\t\\t(a[19] => z[21]) = 0;\\n\\t\\t(b[0] => z[21]) = 0;\\n\\t\\t(b[1] => z[21]) = 0;\\n\\t\\t(b[2] => z[21]) = 0;\\n\\t\\t(b[3] => z[21]) = 0;\\n\\t\\t(b[4] => z[21]) = 0;\\n\\t\\t(b[5] => z[21]) = 0;\\n\\t\\t(b[6] => z[21]) = 0;\\n\\t\\t(b[7] => z[21]) = 0;\\n\\t\\t(b[8] => z[21]) = 0;\\n\\t\\t(b[9] => z[21]) = 0;\\n\\t\\t(b[10] => z[21]) = 0;\\n\\t\\t(b[11] => z[21]) = 0;\\n\\t\\t(b[12] => z[21]) = 0;\\n\\t\\t(b[13] => z[21]) = 0;\\n\\t\\t(b[14] => z[21]) = 0;\\n\\t\\t(b[15] => z[21]) = 0;\\n\\t\\t(b[16] => z[21]) = 0;\\n\\t\\t(b[17] => z[21]) = 0;\\n\\t\\t(a[0] => z[22]) = 0;\\n\\t\\t(a[1] => z[22]) = 0;\\n\\t\\t(a[2] => z[22]) = 0;\\n\\t\\t(a[3] => z[22]) = 0;\\n\\t\\t(a[4] => z[22]) = 0;\\n\\t\\t(a[5] => z[22]) = 0;\\n\\t\\t(a[6] => z[22]) = 0;\\n\\t\\t(a[7] => z[22]) = 0;\\n\\t\\t(a[8] => z[22]) = 0;\\n\\t\\t(a[9] => z[22]) = 0;\\n\\t\\t(a[10] => z[22]) = 0;\\n\\t\\t(a[11] => z[22]) = 0;\\n\\t\\t(a[12] => z[22]) = 0;\\n\\t\\t(a[13] => z[22]) = 0;\\n\\t\\t(a[14] => z[22]) = 0;\\n\\t\\t(a[15] => z[22]) = 0;\\n\\t\\t(a[16] => z[22]) = 0;\\n\\t\\t(a[17] => z[22]) = 0;\\n\\t\\t(a[18] => z[22]) = 0;\\n\\t\\t(a[19] => z[22]) = 0;\\n\\t\\t(b[0] => z[22]) = 0;\\n\\t\\t(b[1] => z[22]) = 0;\\n\\t\\t(b[2] => z[22]) = 0;\\n\\t\\t(b[3] => z[22]) = 0;\\n\\t\\t(b[4] => z[22]) = 0;\\n\\t\\t(b[5] => z[22]) = 0;\\n\\t\\t(b[6] => z[22]) = 0;\\n\\t\\t(b[7] => z[22]) = 0;\\n\\t\\t(b[8] => z[22]) = 0;\\n\\t\\t(b[9] => z[22]) = 0;\\n\\t\\t(b[10] => z[22]) = 0;\\n\\t\\t(b[11] => z[22]) = 0;\\n\\t\\t(b[12] => z[22]) = 0;\\n\\t\\t(b[13] => z[22]) = 0;\\n\\t\\t(b[14] => z[22]) = 0;\\n\\t\\t(b[15] => z[22]) = 0;\\n\\t\\t(b[16] => z[22]) = 0;\\n\\t\\t(b[17] => z[22]) = 0;\\n\\t\\t(a[0] => z[23]) = 0;\\n\\t\\t(a[1] => z[23]) = 0;\\n\\t\\t(a[2] => z[23]) = 0;\\n\\t\\t(a[3] => z[23]) = 0;\\n\\t\\t(a[4] => z[23]) = 0;\\n\\t\\t(a[5] => z[23]) = 0;\\n\\t\\t(a[6] => z[23]) = 0;\\n\\t\\t(a[7] => z[23]) = 0;\\n\\t\\t(a[8] => z[23]) = 0;\\n\\t\\t(a[9] => z[23]) = 0;\\n\\t\\t(a[10] => z[23]) = 0;\\n\\t\\t(a[11] => z[23]) = 0;\\n\\t\\t(a[12] => z[23]) = 0;\\n\\t\\t(a[13] => z[23]) = 0;\\n\\t\\t(a[14] => z[23]) = 0;\\n\\t\\t(a[15] => z[23]) = 0;\\n\\t\\t(a[16] => z[23]) = 0;\\n\\t\\t(a[17] => z[23]) = 0;\\n\\t\\t(a[18] => z[23]) = 0;\\n\\t\\t(a[19] => z[23]) = 0;\\n\\t\\t(b[0] => z[23]) = 0;\\n\\t\\t(b[1] => z[23]) = 0;\\n\\t\\t(b[2] => z[23]) = 0;\\n\\t\\t(b[3] => z[23]) = 0;\\n\\t\\t(b[4] => z[23]) = 0;\\n\\t\\t(b[5] => z[23]) = 0;\\n\\t\\t(b[6] => z[23]) = 0;\\n\\t\\t(b[7] => z[23]) = 0;\\n\\t\\t(b[8] => z[23]) = 0;\\n\\t\\t(b[9] => z[23]) = 0;\\n\\t\\t(b[10] => z[23]) = 0;\\n\\t\\t(b[11] => z[23]) = 0;\\n\\t\\t(b[12] => z[23]) = 0;\\n\\t\\t(b[13] => z[23]) = 0;\\n\\t\\t(b[14] => z[23]) = 0;\\n\\t\\t(b[15] => z[23]) = 0;\\n\\t\\t(b[16] => z[23]) = 0;\\n\\t\\t(b[17] => z[23]) = 0;\\n\\t\\t(a[0] => z[24]) = 0;\\n\\t\\t(a[1] => z[24]) = 0;\\n\\t\\t(a[2] => z[24]) = 0;\\n\\t\\t(a[3] => z[24]) = 0;\\n\\t\\t(a[4] => z[24]) = 0;\\n\\t\\t(a[5] => z[24]) = 0;\\n\\t\\t(a[6] => z[24]) = 0;\\n\\t\\t(a[7] => z[24]) = 0;\\n\\t\\t(a[8] => z[24]) = 0;\\n\\t\\t(a[9] => z[24]) = 0;\\n\\t\\t(a[10] => z[24]) = 0;\\n\\t\\t(a[11] => z[24]) = 0;\\n\\t\\t(a[12] => z[24]) = 0;\\n\\t\\t(a[13] => z[24]) = 0;\\n\\t\\t(a[14] => z[24]) = 0;\\n\\t\\t(a[15] => z[24]) = 0;\\n\\t\\t(a[16] => z[24]) = 0;\\n\\t\\t(a[17] => z[24]) = 0;\\n\\t\\t(a[18] => z[24]) = 0;\\n\\t\\t(a[19] => z[24]) = 0;\\n\\t\\t(b[0] => z[24]) = 0;\\n\\t\\t(b[1] => z[24]) = 0;\\n\\t\\t(b[2] => z[24]) = 0;\\n\\t\\t(b[3] => z[24]) = 0;\\n\\t\\t(b[4] => z[24]) = 0;\\n\\t\\t(b[5] => z[24]) = 0;\\n\\t\\t(b[6] => z[24]) = 0;\\n\\t\\t(b[7] => z[24]) = 0;\\n\\t\\t(b[8] => z[24]) = 0;\\n\\t\\t(b[9] => z[24]) = 0;\\n\\t\\t(b[10] => z[24]) = 0;\\n\\t\\t(b[11] => z[24]) = 0;\\n\\t\\t(b[12] => z[24]) = 0;\\n\\t\\t(b[13] => z[24]) = 0;\\n\\t\\t(b[14] => z[24]) = 0;\\n\\t\\t(b[15] => z[24]) = 0;\\n\\t\\t(b[16] => z[24]) = 0;\\n\\t\\t(b[17] => z[24]) = 0;\\n\\t\\t(a[0] => z[25]) = 0;\\n\\t\\t(a[1] => z[25]) = 0;\\n\\t\\t(a[2] => z[25]) = 0;\\n\\t\\t(a[3] => z[25]) = 0;\\n\\t\\t(a[4] => z[25]) = 0;\\n\\t\\t(a[5] => z[25]) = 0;\\n\\t\\t(a[6] => z[25]) = 0;\\n\\t\\t(a[7] => z[25]) = 0;\\n\\t\\t(a[8] => z[25]) = 0;\\n\\t\\t(a[9] => z[25]) = 0;\\n\\t\\t(a[10] => z[25]) = 0;\\n\\t\\t(a[11] => z[25]) = 0;\\n\\t\\t(a[12] => z[25]) = 0;\\n\\t\\t(a[13] => z[25]) = 0;\\n\\t\\t(a[14] => z[25]) = 0;\\n\\t\\t(a[15] => z[25]) = 0;\\n\\t\\t(a[16] => z[25]) = 0;\\n\\t\\t(a[17] => z[25]) = 0;\\n\\t\\t(a[18] => z[25]) = 0;\\n\\t\\t(a[19] => z[25]) = 0;\\n\\t\\t(b[0] => z[25]) = 0;\\n\\t\\t(b[1] => z[25]) = 0;\\n\\t\\t(b[2] => z[25]) = 0;\\n\\t\\t(b[3] => z[25]) = 0;\\n\\t\\t(b[4] => z[25]) = 0;\\n\\t\\t(b[5] => z[25]) = 0;\\n\\t\\t(b[6] => z[25]) = 0;\\n\\t\\t(b[7] => z[25]) = 0;\\n\\t\\t(b[8] => z[25]) = 0;\\n\\t\\t(b[9] => z[25]) = 0;\\n\\t\\t(b[10] => z[25]) = 0;\\n\\t\\t(b[11] => z[25]) = 0;\\n\\t\\t(b[12] => z[25]) = 0;\\n\\t\\t(b[13] => z[25]) = 0;\\n\\t\\t(b[14] => z[25]) = 0;\\n\\t\\t(b[15] => z[25]) = 0;\\n\\t\\t(b[16] => z[25]) = 0;\\n\\t\\t(b[17] => z[25]) = 0;\\n\\t\\t(a[0] => z[26]) = 0;\\n\\t\\t(a[1] => z[26]) = 0;\\n\\t\\t(a[2] => z[26]) = 0;\\n\\t\\t(a[3] => z[26]) = 0;\\n\\t\\t(a[4] => z[26]) = 0;\\n\\t\\t(a[5] => z[26]) = 0;\\n\\t\\t(a[6] => z[26]) = 0;\\n\\t\\t(a[7] => z[26]) = 0;\\n\\t\\t(a[8] => z[26]) = 0;\\n\\t\\t(a[9] => z[26]) = 0;\\n\\t\\t(a[10] => z[26]) = 0;\\n\\t\\t(a[11] => z[26]) = 0;\\n\\t\\t(a[12] => z[26]) = 0;\\n\\t\\t(a[13] => z[26]) = 0;\\n\\t\\t(a[14] => z[26]) = 0;\\n\\t\\t(a[15] => z[26]) = 0;\\n\\t\\t(a[16] => z[26]) = 0;\\n\\t\\t(a[17] => z[26]) = 0;\\n\\t\\t(a[18] => z[26]) = 0;\\n\\t\\t(a[19] => z[26]) = 0;\\n\\t\\t(b[0] => z[26]) = 0;\\n\\t\\t(b[1] => z[26]) = 0;\\n\\t\\t(b[2] => z[26]) = 0;\\n\\t\\t(b[3] => z[26]) = 0;\\n\\t\\t(b[4] => z[26]) = 0;\\n\\t\\t(b[5] => z[26]) = 0;\\n\\t\\t(b[6] => z[26]) = 0;\\n\\t\\t(b[7] => z[26]) = 0;\\n\\t\\t(b[8] => z[26]) = 0;\\n\\t\\t(b[9] => z[26]) = 0;\\n\\t\\t(b[10] => z[26]) = 0;\\n\\t\\t(b[11] => z[26]) = 0;\\n\\t\\t(b[12] => z[26]) = 0;\\n\\t\\t(b[13] => z[26]) = 0;\\n\\t\\t(b[14] => z[26]) = 0;\\n\\t\\t(b[15] => z[26]) = 0;\\n\\t\\t(b[16] => z[26]) = 0;\\n\\t\\t(b[17] => z[26]) = 0;\\n\\t\\t(a[0] => z[27]) = 0;\\n\\t\\t(a[1] => z[27]) = 0;\\n\\t\\t(a[2] => z[27]) = 0;\\n\\t\\t(a[3] => z[27]) = 0;\\n\\t\\t(a[4] => z[27]) = 0;\\n\\t\\t(a[5] => z[27]) = 0;\\n\\t\\t(a[6] => z[27]) = 0;\\n\\t\\t(a[7] => z[27]) = 0;\\n\\t\\t(a[8] => z[27]) = 0;\\n\\t\\t(a[9] => z[27]) = 0;\\n\\t\\t(a[10] => z[27]) = 0;\\n\\t\\t(a[11] => z[27]) = 0;\\n\\t\\t(a[12] => z[27]) = 0;\\n\\t\\t(a[13] => z[27]) = 0;\\n\\t\\t(a[14] => z[27]) = 0;\\n\\t\\t(a[15] => z[27]) = 0;\\n\\t\\t(a[16] => z[27]) = 0;\\n\\t\\t(a[17] => z[27]) = 0;\\n\\t\\t(a[18] => z[27]) = 0;\\n\\t\\t(a[19] => z[27]) = 0;\\n\\t\\t(b[0] => z[27]) = 0;\\n\\t\\t(b[1] => z[27]) = 0;\\n\\t\\t(b[2] => z[27]) = 0;\\n\\t\\t(b[3] => z[27]) = 0;\\n\\t\\t(b[4] => z[27]) = 0;\\n\\t\\t(b[5] => z[27]) = 0;\\n\\t\\t(b[6] => z[27]) = 0;\\n\\t\\t(b[7] => z[27]) = 0;\\n\\t\\t(b[8] => z[27]) = 0;\\n\\t\\t(b[9] => z[27]) = 0;\\n\\t\\t(b[10] => z[27]) = 0;\\n\\t\\t(b[11] => z[27]) = 0;\\n\\t\\t(b[12] => z[27]) = 0;\\n\\t\\t(b[13] => z[27]) = 0;\\n\\t\\t(b[14] => z[27]) = 0;\\n\\t\\t(b[15] => z[27]) = 0;\\n\\t\\t(b[16] => z[27]) = 0;\\n\\t\\t(b[17] => z[27]) = 0;\\n\\t\\t(a[0] => z[28]) = 0;\\n\\t\\t(a[1] => z[28]) = 0;\\n\\t\\t(a[2] => z[28]) = 0;\\n\\t\\t(a[3] => z[28]) = 0;\\n\\t\\t(a[4] => z[28]) = 0;\\n\\t\\t(a[5] => z[28]) = 0;\\n\\t\\t(a[6] => z[28]) = 0;\\n\\t\\t(a[7] => z[28]) = 0;\\n\\t\\t(a[8] => z[28]) = 0;\\n\\t\\t(a[9] => z[28]) = 0;\\n\\t\\t(a[10] => z[28]) = 0;\\n\\t\\t(a[11] => z[28]) = 0;\\n\\t\\t(a[12] => z[28]) = 0;\\n\\t\\t(a[13] => z[28]) = 0;\\n\\t\\t(a[14] => z[28]) = 0;\\n\\t\\t(a[15] => z[28]) = 0;\\n\\t\\t(a[16] => z[28]) = 0;\\n\\t\\t(a[17] => z[28]) = 0;\\n\\t\\t(a[18] => z[28]) = 0;\\n\\t\\t(a[19] => z[28]) = 0;\\n\\t\\t(b[0] => z[28]) = 0;\\n\\t\\t(b[1] => z[28]) = 0;\\n\\t\\t(b[2] => z[28]) = 0;\\n\\t\\t(b[3] => z[28]) = 0;\\n\\t\\t(b[4] => z[28]) = 0;\\n\\t\\t(b[5] => z[28]) = 0;\\n\\t\\t(b[6] => z[28]) = 0;\\n\\t\\t(b[7] => z[28]) = 0;\\n\\t\\t(b[8] => z[28]) = 0;\\n\\t\\t(b[9] => z[28]) = 0;\\n\\t\\t(b[10] => z[28]) = 0;\\n\\t\\t(b[11] => z[28]) = 0;\\n\\t\\t(b[12] => z[28]) = 0;\\n\\t\\t(b[13] => z[28]) = 0;\\n\\t\\t(b[14] => z[28]) = 0;\\n\\t\\t(b[15] => z[28]) = 0;\\n\\t\\t(b[16] => z[28]) = 0;\\n\\t\\t(b[17] => z[28]) = 0;\\n\\t\\t(a[0] => z[29]) = 0;\\n\\t\\t(a[1] => z[29]) = 0;\\n\\t\\t(a[2] => z[29]) = 0;\\n\\t\\t(a[3] => z[29]) = 0;\\n\\t\\t(a[4] => z[29]) = 0;\\n\\t\\t(a[5] => z[29]) = 0;\\n\\t\\t(a[6] => z[29]) = 0;\\n\\t\\t(a[7] => z[29]) = 0;\\n\\t\\t(a[8] => z[29]) = 0;\\n\\t\\t(a[9] => z[29]) = 0;\\n\\t\\t(a[10] => z[29]) = 0;\\n\\t\\t(a[11] => z[29]) = 0;\\n\\t\\t(a[12] => z[29]) = 0;\\n\\t\\t(a[13] => z[29]) = 0;\\n\\t\\t(a[14] => z[29]) = 0;\\n\\t\\t(a[15] => z[29]) = 0;\\n\\t\\t(a[16] => z[29]) = 0;\\n\\t\\t(a[17] => z[29]) = 0;\\n\\t\\t(a[18] => z[29]) = 0;\\n\\t\\t(a[19] => z[29]) = 0;\\n\\t\\t(b[0] => z[29]) = 0;\\n\\t\\t(b[1] => z[29]) = 0;\\n\\t\\t(b[2] => z[29]) = 0;\\n\\t\\t(b[3] => z[29]) = 0;\\n\\t\\t(b[4] => z[29]) = 0;\\n\\t\\t(b[5] => z[29]) = 0;\\n\\t\\t(b[6] => z[29]) = 0;\\n\\t\\t(b[7] => z[29]) = 0;\\n\\t\\t(b[8] => z[29]) = 0;\\n\\t\\t(b[9] => z[29]) = 0;\\n\\t\\t(b[10] => z[29]) = 0;\\n\\t\\t(b[11] => z[29]) = 0;\\n\\t\\t(b[12] => z[29]) = 0;\\n\\t\\t(b[13] => z[29]) = 0;\\n\\t\\t(b[14] => z[29]) = 0;\\n\\t\\t(b[15] => z[29]) = 0;\\n\\t\\t(b[16] => z[29]) = 0;\\n\\t\\t(b[17] => z[29]) = 0;\\n\\t\\t(a[0] => z[30]) = 0;\\n\\t\\t(a[1] => z[30]) = 0;\\n\\t\\t(a[2] => z[30]) = 0;\\n\\t\\t(a[3] => z[30]) = 0;\\n\\t\\t(a[4] => z[30]) = 0;\\n\\t\\t(a[5] => z[30]) = 0;\\n\\t\\t(a[6] => z[30]) = 0;\\n\\t\\t(a[7] => z[30]) = 0;\\n\\t\\t(a[8] => z[30]) = 0;\\n\\t\\t(a[9] => z[30]) = 0;\\n\\t\\t(a[10] => z[30]) = 0;\\n\\t\\t(a[11] => z[30]) = 0;\\n\\t\\t(a[12] => z[30]) = 0;\\n\\t\\t(a[13] => z[30]) = 0;\\n\\t\\t(a[14] => z[30]) = 0;\\n\\t\\t(a[15] => z[30]) = 0;\\n\\t\\t(a[16] => z[30]) = 0;\\n\\t\\t(a[17] => z[30]) = 0;\\n\\t\\t(a[18] => z[30]) = 0;\\n\\t\\t(a[19] => z[30]) = 0;\\n\\t\\t(b[0] => z[30]) = 0;\\n\\t\\t(b[1] => z[30]) = 0;\\n\\t\\t(b[2] => z[30]) = 0;\\n\\t\\t(b[3] => z[30]) = 0;\\n\\t\\t(b[4] => z[30]) = 0;\\n\\t\\t(b[5] => z[30]) = 0;\\n\\t\\t(b[6] => z[30]) = 0;\\n\\t\\t(b[7] => z[30]) = 0;\\n\\t\\t(b[8] => z[30]) = 0;\\n\\t\\t(b[9] => z[30]) = 0;\\n\\t\\t(b[10] => z[30]) = 0;\\n\\t\\t(b[11] => z[30]) = 0;\\n\\t\\t(b[12] => z[30]) = 0;\\n\\t\\t(b[13] => z[30]) = 0;\\n\\t\\t(b[14] => z[30]) = 0;\\n\\t\\t(b[15] => z[30]) = 0;\\n\\t\\t(b[16] => z[30]) = 0;\\n\\t\\t(b[17] => z[30]) = 0;\\n\\t\\t(a[0] => z[31]) = 0;\\n\\t\\t(a[1] => z[31]) = 0;\\n\\t\\t(a[2] => z[31]) = 0;\\n\\t\\t(a[3] => z[31]) = 0;\\n\\t\\t(a[4] => z[31]) = 0;\\n\\t\\t(a[5] => z[31]) = 0;\\n\\t\\t(a[6] => z[31]) = 0;\\n\\t\\t(a[7] => z[31]) = 0;\\n\\t\\t(a[8] => z[31]) = 0;\\n\\t\\t(a[9] => z[31]) = 0;\\n\\t\\t(a[10] => z[31]) = 0;\\n\\t\\t(a[11] => z[31]) = 0;\\n\\t\\t(a[12] => z[31]) = 0;\\n\\t\\t(a[13] => z[31]) = 0;\\n\\t\\t(a[14] => z[31]) = 0;\\n\\t\\t(a[15] => z[31]) = 0;\\n\\t\\t(a[16] => z[31]) = 0;\\n\\t\\t(a[17] => z[31]) = 0;\\n\\t\\t(a[18] => z[31]) = 0;\\n\\t\\t(a[19] => z[31]) = 0;\\n\\t\\t(b[0] => z[31]) = 0;\\n\\t\\t(b[1] => z[31]) = 0;\\n\\t\\t(b[2] => z[31]) = 0;\\n\\t\\t(b[3] => z[31]) = 0;\\n\\t\\t(b[4] => z[31]) = 0;\\n\\t\\t(b[5] => z[31]) = 0;\\n\\t\\t(b[6] => z[31]) = 0;\\n\\t\\t(b[7] => z[31]) = 0;\\n\\t\\t(b[8] => z[31]) = 0;\\n\\t\\t(b[9] => z[31]) = 0;\\n\\t\\t(b[10] => z[31]) = 0;\\n\\t\\t(b[11] => z[31]) = 0;\\n\\t\\t(b[12] => z[31]) = 0;\\n\\t\\t(b[13] => z[31]) = 0;\\n\\t\\t(b[14] => z[31]) = 0;\\n\\t\\t(b[15] => z[31]) = 0;\\n\\t\\t(b[16] => z[31]) = 0;\\n\\t\\t(b[17] => z[31]) = 0;\\n\\t\\t(a[0] => z[32]) = 0;\\n\\t\\t(a[1] => z[32]) = 0;\\n\\t\\t(a[2] => z[32]) = 0;\\n\\t\\t(a[3] => z[32]) = 0;\\n\\t\\t(a[4] => z[32]) = 0;\\n\\t\\t(a[5] => z[32]) = 0;\\n\\t\\t(a[6] => z[32]) = 0;\\n\\t\\t(a[7] => z[32]) = 0;\\n\\t\\t(a[8] => z[32]) = 0;\\n\\t\\t(a[9] => z[32]) = 0;\\n\\t\\t(a[10] => z[32]) = 0;\\n\\t\\t(a[11] => z[32]) = 0;\\n\\t\\t(a[12] => z[32]) = 0;\\n\\t\\t(a[13] => z[32]) = 0;\\n\\t\\t(a[14] => z[32]) = 0;\\n\\t\\t(a[15] => z[32]) = 0;\\n\\t\\t(a[16] => z[32]) = 0;\\n\\t\\t(a[17] => z[32]) = 0;\\n\\t\\t(a[18] => z[32]) = 0;\\n\\t\\t(a[19] => z[32]) = 0;\\n\\t\\t(b[0] => z[32]) = 0;\\n\\t\\t(b[1] => z[32]) = 0;\\n\\t\\t(b[2] => z[32]) = 0;\\n\\t\\t(b[3] => z[32]) = 0;\\n\\t\\t(b[4] => z[32]) = 0;\\n\\t\\t(b[5] => z[32]) = 0;\\n\\t\\t(b[6] => z[32]) = 0;\\n\\t\\t(b[7] => z[32]) = 0;\\n\\t\\t(b[8] => z[32]) = 0;\\n\\t\\t(b[9] => z[32]) = 0;\\n\\t\\t(b[10] => z[32]) = 0;\\n\\t\\t(b[11] => z[32]) = 0;\\n\\t\\t(b[12] => z[32]) = 0;\\n\\t\\t(b[13] => z[32]) = 0;\\n\\t\\t(b[14] => z[32]) = 0;\\n\\t\\t(b[15] => z[32]) = 0;\\n\\t\\t(b[16] => z[32]) = 0;\\n\\t\\t(b[17] => z[32]) = 0;\\n\\t\\t(a[0] => z[33]) = 0;\\n\\t\\t(a[1] => z[33]) = 0;\\n\\t\\t(a[2] => z[33]) = 0;\\n\\t\\t(a[3] => z[33]) = 0;\\n\\t\\t(a[4] => z[33]) = 0;\\n\\t\\t(a[5] => z[33]) = 0;\\n\\t\\t(a[6] => z[33]) = 0;\\n\\t\\t(a[7] => z[33]) = 0;\\n\\t\\t(a[8] => z[33]) = 0;\\n\\t\\t(a[9] => z[33]) = 0;\\n\\t\\t(a[10] => z[33]) = 0;\\n\\t\\t(a[11] => z[33]) = 0;\\n\\t\\t(a[12] => z[33]) = 0;\\n\\t\\t(a[13] => z[33]) = 0;\\n\\t\\t(a[14] => z[33]) = 0;\\n\\t\\t(a[15] => z[33]) = 0;\\n\\t\\t(a[16] => z[33]) = 0;\\n\\t\\t(a[17] => z[33]) = 0;\\n\\t\\t(a[18] => z[33]) = 0;\\n\\t\\t(a[19] => z[33]) = 0;\\n\\t\\t(b[0] => z[33]) = 0;\\n\\t\\t(b[1] => z[33]) = 0;\\n\\t\\t(b[2] => z[33]) = 0;\\n\\t\\t(b[3] => z[33]) = 0;\\n\\t\\t(b[4] => z[33]) = 0;\\n\\t\\t(b[5] => z[33]) = 0;\\n\\t\\t(b[6] => z[33]) = 0;\\n\\t\\t(b[7] => z[33]) = 0;\\n\\t\\t(b[8] => z[33]) = 0;\\n\\t\\t(b[9] => z[33]) = 0;\\n\\t\\t(b[10] => z[33]) = 0;\\n\\t\\t(b[11] => z[33]) = 0;\\n\\t\\t(b[12] => z[33]) = 0;\\n\\t\\t(b[13] => z[33]) = 0;\\n\\t\\t(b[14] => z[33]) = 0;\\n\\t\\t(b[15] => z[33]) = 0;\\n\\t\\t(b[16] => z[33]) = 0;\\n\\t\\t(b[17] => z[33]) = 0;\\n\\t\\t(a[0] => z[34]) = 0;\\n\\t\\t(a[1] => z[34]) = 0;\\n\\t\\t(a[2] => z[34]) = 0;\\n\\t\\t(a[3] => z[34]) = 0;\\n\\t\\t(a[4] => z[34]) = 0;\\n\\t\\t(a[5] => z[34]) = 0;\\n\\t\\t(a[6] => z[34]) = 0;\\n\\t\\t(a[7] => z[34]) = 0;\\n\\t\\t(a[8] => z[34]) = 0;\\n\\t\\t(a[9] => z[34]) = 0;\\n\\t\\t(a[10] => z[34]) = 0;\\n\\t\\t(a[11] => z[34]) = 0;\\n\\t\\t(a[12] => z[34]) = 0;\\n\\t\\t(a[13] => z[34]) = 0;\\n\\t\\t(a[14] => z[34]) = 0;\\n\\t\\t(a[15] => z[34]) = 0;\\n\\t\\t(a[16] => z[34]) = 0;\\n\\t\\t(a[17] => z[34]) = 0;\\n\\t\\t(a[18] => z[34]) = 0;\\n\\t\\t(a[19] => z[34]) = 0;\\n\\t\\t(b[0] => z[34]) = 0;\\n\\t\\t(b[1] => z[34]) = 0;\\n\\t\\t(b[2] => z[34]) = 0;\\n\\t\\t(b[3] => z[34]) = 0;\\n\\t\\t(b[4] => z[34]) = 0;\\n\\t\\t(b[5] => z[34]) = 0;\\n\\t\\t(b[6] => z[34]) = 0;\\n\\t\\t(b[7] => z[34]) = 0;\\n\\t\\t(b[8] => z[34]) = 0;\\n\\t\\t(b[9] => z[34]) = 0;\\n\\t\\t(b[10] => z[34]) = 0;\\n\\t\\t(b[11] => z[34]) = 0;\\n\\t\\t(b[12] => z[34]) = 0;\\n\\t\\t(b[13] => z[34]) = 0;\\n\\t\\t(b[14] => z[34]) = 0;\\n\\t\\t(b[15] => z[34]) = 0;\\n\\t\\t(b[16] => z[34]) = 0;\\n\\t\\t(b[17] => z[34]) = 0;\\n\\t\\t(a[0] => z[35]) = 0;\\n\\t\\t(a[1] => z[35]) = 0;\\n\\t\\t(a[2] => z[35]) = 0;\\n\\t\\t(a[3] => z[35]) = 0;\\n\\t\\t(a[4] => z[35]) = 0;\\n\\t\\t(a[5] => z[35]) = 0;\\n\\t\\t(a[6] => z[35]) = 0;\\n\\t\\t(a[7] => z[35]) = 0;\\n\\t\\t(a[8] => z[35]) = 0;\\n\\t\\t(a[9] => z[35]) = 0;\\n\\t\\t(a[10] => z[35]) = 0;\\n\\t\\t(a[11] => z[35]) = 0;\\n\\t\\t(a[12] => z[35]) = 0;\\n\\t\\t(a[13] => z[35]) = 0;\\n\\t\\t(a[14] => z[35]) = 0;\\n\\t\\t(a[15] => z[35]) = 0;\\n\\t\\t(a[16] => z[35]) = 0;\\n\\t\\t(a[17] => z[35]) = 0;\\n\\t\\t(a[18] => z[35]) = 0;\\n\\t\\t(a[19] => z[35]) = 0;\\n\\t\\t(b[0] => z[35]) = 0;\\n\\t\\t(b[1] => z[35]) = 0;\\n\\t\\t(b[2] => z[35]) = 0;\\n\\t\\t(b[3] => z[35]) = 0;\\n\\t\\t(b[4] => z[35]) = 0;\\n\\t\\t(b[5] => z[35]) = 0;\\n\\t\\t(b[6] => z[35]) = 0;\\n\\t\\t(b[7] => z[35]) = 0;\\n\\t\\t(b[8] => z[35]) = 0;\\n\\t\\t(b[9] => z[35]) = 0;\\n\\t\\t(b[10] => z[35]) = 0;\\n\\t\\t(b[11] => z[35]) = 0;\\n\\t\\t(b[12] => z[35]) = 0;\\n\\t\\t(b[13] => z[35]) = 0;\\n\\t\\t(b[14] => z[35]) = 0;\\n\\t\\t(b[15] => z[35]) = 0;\\n\\t\\t(b[16] => z[35]) = 0;\\n\\t\\t(b[17] => z[35]) = 0;\\n\\t\\t(a[0] => z[36]) = 0;\\n\\t\\t(a[1] => z[36]) = 0;\\n\\t\\t(a[2] => z[36]) = 0;\\n\\t\\t(a[3] => z[36]) = 0;\\n\\t\\t(a[4] => z[36]) = 0;\\n\\t\\t(a[5] => z[36]) = 0;\\n\\t\\t(a[6] => z[36]) = 0;\\n\\t\\t(a[7] => z[36]) = 0;\\n\\t\\t(a[8] => z[36]) = 0;\\n\\t\\t(a[9] => z[36]) = 0;\\n\\t\\t(a[10] => z[36]) = 0;\\n\\t\\t(a[11] => z[36]) = 0;\\n\\t\\t(a[12] => z[36]) = 0;\\n\\t\\t(a[13] => z[36]) = 0;\\n\\t\\t(a[14] => z[36]) = 0;\\n\\t\\t(a[15] => z[36]) = 0;\\n\\t\\t(a[16] => z[36]) = 0;\\n\\t\\t(a[17] => z[36]) = 0;\\n\\t\\t(a[18] => z[36]) = 0;\\n\\t\\t(a[19] => z[36]) = 0;\\n\\t\\t(b[0] => z[36]) = 0;\\n\\t\\t(b[1] => z[36]) = 0;\\n\\t\\t(b[2] => z[36]) = 0;\\n\\t\\t(b[3] => z[36]) = 0;\\n\\t\\t(b[4] => z[36]) = 0;\\n\\t\\t(b[5] => z[36]) = 0;\\n\\t\\t(b[6] => z[36]) = 0;\\n\\t\\t(b[7] => z[36]) = 0;\\n\\t\\t(b[8] => z[36]) = 0;\\n\\t\\t(b[9] => z[36]) = 0;\\n\\t\\t(b[10] => z[36]) = 0;\\n\\t\\t(b[11] => z[36]) = 0;\\n\\t\\t(b[12] => z[36]) = 0;\\n\\t\\t(b[13] => z[36]) = 0;\\n\\t\\t(b[14] => z[36]) = 0;\\n\\t\\t(b[15] => z[36]) = 0;\\n\\t\\t(b[16] => z[36]) = 0;\\n\\t\\t(b[17] => z[36]) = 0;\\n\\t\\t(a[0] => z[37]) = 0;\\n\\t\\t(a[1] => z[37]) = 0;\\n\\t\\t(a[2] => z[37]) = 0;\\n\\t\\t(a[3] => z[37]) = 0;\\n\\t\\t(a[4] => z[37]) = 0;\\n\\t\\t(a[5] => z[37]) = 0;\\n\\t\\t(a[6] => z[37]) = 0;\\n\\t\\t(a[7] => z[37]) = 0;\\n\\t\\t(a[8] => z[37]) = 0;\\n\\t\\t(a[9] => z[37]) = 0;\\n\\t\\t(a[10] => z[37]) = 0;\\n\\t\\t(a[11] => z[37]) = 0;\\n\\t\\t(a[12] => z[37]) = 0;\\n\\t\\t(a[13] => z[37]) = 0;\\n\\t\\t(a[14] => z[37]) = 0;\\n\\t\\t(a[15] => z[37]) = 0;\\n\\t\\t(a[16] => z[37]) = 0;\\n\\t\\t(a[17] => z[37]) = 0;\\n\\t\\t(a[18] => z[37]) = 0;\\n\\t\\t(a[19] => z[37]) = 0;\\n\\t\\t(b[0] => z[37]) = 0;\\n\\t\\t(b[1] => z[37]) = 0;\\n\\t\\t(b[2] => z[37]) = 0;\\n\\t\\t(b[3] => z[37]) = 0;\\n\\t\\t(b[4] => z[37]) = 0;\\n\\t\\t(b[5] => z[37]) = 0;\\n\\t\\t(b[6] => z[37]) = 0;\\n\\t\\t(b[7] => z[37]) = 0;\\n\\t\\t(b[8] => z[37]) = 0;\\n\\t\\t(b[9] => z[37]) = 0;\\n\\t\\t(b[10] => z[37]) = 0;\\n\\t\\t(b[11] => z[37]) = 0;\\n\\t\\t(b[12] => z[37]) = 0;\\n\\t\\t(b[13] => z[37]) = 0;\\n\\t\\t(b[14] => z[37]) = 0;\\n\\t\\t(b[15] => z[37]) = 0;\\n\\t\\t(b[16] => z[37]) = 0;\\n\\t\\t(b[17] => z[37]) = 0;\\n\\t\\t(subtract => z[0]) = 0;\\n\\t\\t(subtract => z[1]) = 0;\\n\\t\\t(subtract => z[2]) = 0;\\n\\t\\t(subtract => z[3]) = 0;\\n\\t\\t(subtract => z[4]) = 0;\\n\\t\\t(subtract => z[5]) = 0;\\n\\t\\t(subtract => z[6]) = 0;\\n\\t\\t(subtract => z[7]) = 0;\\n\\t\\t(subtract => z[8]) = 0;\\n\\t\\t(subtract => z[9]) = 0;\\n\\t\\t(subtract => z[10]) = 0;\\n\\t\\t(subtract => z[11]) = 0;\\n\\t\\t(subtract => z[12]) = 0;\\n\\t\\t(subtract => z[13]) = 0;\\n\\t\\t(subtract => z[14]) = 0;\\n\\t\\t(subtract => z[15]) = 0;\\n\\t\\t(subtract => z[16]) = 0;\\n\\t\\t(subtract => z[17]) = 0;\\n\\t\\t(subtract => z[18]) = 0;\\n\\t\\t(subtract => z[19]) = 0;\\n\\t\\t(subtract => z[20]) = 0;\\n\\t\\t(subtract => z[21]) = 0;\\n\\t\\t(subtract => z[22]) = 0;\\n\\t\\t(subtract => z[23]) = 0;\\n\\t\\t(subtract => z[24]) = 0;\\n\\t\\t(subtract => z[25]) = 0;\\n\\t\\t(subtract => z[26]) = 0;\\n\\t\\t(subtract => z[27]) = 0;\\n\\t\\t(subtract => z[28]) = 0;\\n\\t\\t(subtract => z[29]) = 0;\\n\\t\\t(subtract => z[30]) = 0;\\n\\t\\t(subtract => z[31]) = 0;\\n\\t\\t(subtract => z[32]) = 0;\\n\\t\\t(subtract => z[33]) = 0;\\n\\t\\t(subtract => z[34]) = 0;\\n\\t\\t(subtract => z[35]) = 0;\\n\\t\\t(subtract => z[36]) = 0;\\n\\t\\t(subtract => z[37]) = 0;\\n\\t\\t(acc_fir[0] => z[0]) = 0;\\n\\t\\t(acc_fir[1] => z[0]) = 0;\\n\\t\\t(acc_fir[2] => z[0]) = 0;\\n\\t\\t(acc_fir[3] => z[0]) = 0;\\n\\t\\t(acc_fir[4] => z[0]) = 0;\\n\\t\\t(acc_fir[5] => z[0]) = 0;\\n\\t\\t(acc_fir[0] => z[1]) = 0;\\n\\t\\t(acc_fir[1] => z[1]) = 0;\\n\\t\\t(acc_fir[2] => z[1]) = 0;\\n\\t\\t(acc_fir[3] => z[1]) = 0;\\n\\t\\t(acc_fir[4] => z[1]) = 0;\\n\\t\\t(acc_fir[5] => z[1]) = 0;\\n\\t\\t(acc_fir[0] => z[2]) = 0;\\n\\t\\t(acc_fir[1] => z[2]) = 0;\\n\\t\\t(acc_fir[2] => z[2]) = 0;\\n\\t\\t(acc_fir[3] => z[2]) = 0;\\n\\t\\t(acc_fir[4] => z[2]) = 0;\\n\\t\\t(acc_fir[5] => z[2]) = 0;\\n\\t\\t(acc_fir[0] => z[3]) = 0;\\n\\t\\t(acc_fir[1] => z[3]) = 0;\\n\\t\\t(acc_fir[2] => z[3]) = 0;\\n\\t\\t(acc_fir[3] => z[3]) = 0;\\n\\t\\t(acc_fir[4] => z[3]) = 0;\\n\\t\\t(acc_fir[5] => z[3]) = 0;\\n\\t\\t(acc_fir[0] => z[4]) = 0;\\n\\t\\t(acc_fir[1] => z[4]) = 0;\\n\\t\\t(acc_fir[2] => z[4]) = 0;\\n\\t\\t(acc_fir[3] => z[4]) = 0;\\n\\t\\t(acc_fir[4] => z[4]) = 0;\\n\\t\\t(acc_fir[5] => z[4]) = 0;\\n\\t\\t(acc_fir[0] => z[5]) = 0;\\n\\t\\t(acc_fir[1] => z[5]) = 0;\\n\\t\\t(acc_fir[2] => z[5]) = 0;\\n\\t\\t(acc_fir[3] => z[5]) = 0;\\n\\t\\t(acc_fir[4] => z[5]) = 0;\\n\\t\\t(acc_fir[5] => z[5]) = 0;\\n\\t\\t(acc_fir[0] => z[6]) = 0;\\n\\t\\t(acc_fir[1] => z[6]) = 0;\\n\\t\\t(acc_fir[2] => z[6]) = 0;\\n\\t\\t(acc_fir[3] => z[6]) = 0;\\n\\t\\t(acc_fir[4] => z[6]) = 0;\\n\\t\\t(acc_fir[5] => z[6]) = 0;\\n\\t\\t(acc_fir[0] => z[7]) = 0;\\n\\t\\t(acc_fir[1] => z[7]) = 0;\\n\\t\\t(acc_fir[2] => z[7]) = 0;\\n\\t\\t(acc_fir[3] => z[7]) = 0;\\n\\t\\t(acc_fir[4] => z[7]) = 0;\\n\\t\\t(acc_fir[5] => z[7]) = 0;\\n\\t\\t(acc_fir[0] => z[8]) = 0;\\n\\t\\t(acc_fir[1] => z[8]) = 0;\\n\\t\\t(acc_fir[2] => z[8]) = 0;\\n\\t\\t(acc_fir[3] => z[8]) = 0;\\n\\t\\t(acc_fir[4] => z[8]) = 0;\\n\\t\\t(acc_fir[5] => z[8]) = 0;\\n\\t\\t(acc_fir[0] => z[9]) = 0;\\n\\t\\t(acc_fir[1] => z[9]) = 0;\\n\\t\\t(acc_fir[2] => z[9]) = 0;\\n\\t\\t(acc_fir[3] => z[9]) = 0;\\n\\t\\t(acc_fir[4] => z[9]) = 0;\\n\\t\\t(acc_fir[5] => z[9]) = 0;\\n\\t\\t(acc_fir[0] => z[10]) = 0;\\n\\t\\t(acc_fir[1] => z[10]) = 0;\\n\\t\\t(acc_fir[2] => z[10]) = 0;\\n\\t\\t(acc_fir[3] => z[10]) = 0;\\n\\t\\t(acc_fir[4] => z[10]) = 0;\\n\\t\\t(acc_fir[5] => z[10]) = 0;\\n\\t\\t(acc_fir[0] => z[11]) = 0;\\n\\t\\t(acc_fir[1] => z[11]) = 0;\\n\\t\\t(acc_fir[2] => z[11]) = 0;\\n\\t\\t(acc_fir[3] => z[11]) = 0;\\n\\t\\t(acc_fir[4] => z[11]) = 0;\\n\\t\\t(acc_fir[5] => z[11]) = 0;\\n\\t\\t(acc_fir[0] => z[12]) = 0;\\n\\t\\t(acc_fir[1] => z[12]) = 0;\\n\\t\\t(acc_fir[2] => z[12]) = 0;\\n\\t\\t(acc_fir[3] => z[12]) = 0;\\n\\t\\t(acc_fir[4] => z[12]) = 0;\\n\\t\\t(acc_fir[5] => z[12]) = 0;\\n\\t\\t(acc_fir[0] => z[13]) = 0;\\n\\t\\t(acc_fir[1] => z[13]) = 0;\\n\\t\\t(acc_fir[2] => z[13]) = 0;\\n\\t\\t(acc_fir[3] => z[13]) = 0;\\n\\t\\t(acc_fir[4] => z[13]) = 0;\\n\\t\\t(acc_fir[5] => z[13]) = 0;\\n\\t\\t(acc_fir[0] => z[14]) = 0;\\n\\t\\t(acc_fir[1] => z[14]) = 0;\\n\\t\\t(acc_fir[2] => z[14]) = 0;\\n\\t\\t(acc_fir[3] => z[14]) = 0;\\n\\t\\t(acc_fir[4] => z[14]) = 0;\\n\\t\\t(acc_fir[5] => z[14]) = 0;\\n\\t\\t(acc_fir[0] => z[15]) = 0;\\n\\t\\t(acc_fir[1] => z[15]) = 0;\\n\\t\\t(acc_fir[2] => z[15]) = 0;\\n\\t\\t(acc_fir[3] => z[15]) = 0;\\n\\t\\t(acc_fir[4] => z[15]) = 0;\\n\\t\\t(acc_fir[5] => z[15]) = 0;\\n\\t\\t(acc_fir[0] => z[16]) = 0;\\n\\t\\t(acc_fir[1] => z[16]) = 0;\\n\\t\\t(acc_fir[2] => z[16]) = 0;\\n\\t\\t(acc_fir[3] => z[16]) = 0;\\n\\t\\t(acc_fir[4] => z[16]) = 0;\\n\\t\\t(acc_fir[5] => z[16]) = 0;\\n\\t\\t(acc_fir[0] => z[17]) = 0;\\n\\t\\t(acc_fir[1] => z[17]) = 0;\\n\\t\\t(acc_fir[2] => z[17]) = 0;\\n\\t\\t(acc_fir[3] => z[17]) = 0;\\n\\t\\t(acc_fir[4] => z[17]) = 0;\\n\\t\\t(acc_fir[5] => z[17]) = 0;\\n\\t\\t(acc_fir[0] => z[18]) = 0;\\n\\t\\t(acc_fir[1] => z[18]) = 0;\\n\\t\\t(acc_fir[2] => z[18]) = 0;\\n\\t\\t(acc_fir[3] => z[18]) = 0;\\n\\t\\t(acc_fir[4] => z[18]) = 0;\\n\\t\\t(acc_fir[5] => z[18]) = 0;\\n\\t\\t(acc_fir[0] => z[19]) = 0;\\n\\t\\t(acc_fir[1] => z[19]) = 0;\\n\\t\\t(acc_fir[2] => z[19]) = 0;\\n\\t\\t(acc_fir[3] => z[19]) = 0;\\n\\t\\t(acc_fir[4] => z[19]) = 0;\\n\\t\\t(acc_fir[5] => z[19]) = 0;\\n\\t\\t(acc_fir[0] => z[20]) = 0;\\n\\t\\t(acc_fir[1] => z[20]) = 0;\\n\\t\\t(acc_fir[2] => z[20]) = 0;\\n\\t\\t(acc_fir[3] => z[20]) = 0;\\n\\t\\t(acc_fir[4] => z[20]) = 0;\\n\\t\\t(acc_fir[5] => z[20]) = 0;\\n\\t\\t(acc_fir[0] => z[21]) = 0;\\n\\t\\t(acc_fir[1] => z[21]) = 0;\\n\\t\\t(acc_fir[2] => z[21]) = 0;\\n\\t\\t(acc_fir[3] => z[21]) = 0;\\n\\t\\t(acc_fir[4] => z[21]) = 0;\\n\\t\\t(acc_fir[5] => z[21]) = 0;\\n\\t\\t(acc_fir[0] => z[22]) = 0;\\n\\t\\t(acc_fir[1] => z[22]) = 0;\\n\\t\\t(acc_fir[2] => z[22]) = 0;\\n\\t\\t(acc_fir[3] => z[22]) = 0;\\n\\t\\t(acc_fir[4] => z[22]) = 0;\\n\\t\\t(acc_fir[5] => z[22]) = 0;\\n\\t\\t(acc_fir[0] => z[23]) = 0;\\n\\t\\t(acc_fir[1] => z[23]) = 0;\\n\\t\\t(acc_fir[2] => z[23]) = 0;\\n\\t\\t(acc_fir[3] => z[23]) = 0;\\n\\t\\t(acc_fir[4] => z[23]) = 0;\\n\\t\\t(acc_fir[5] => z[23]) = 0;\\n\\t\\t(acc_fir[0] => z[24]) = 0;\\n\\t\\t(acc_fir[1] => z[24]) = 0;\\n\\t\\t(acc_fir[2] => z[24]) = 0;\\n\\t\\t(acc_fir[3] => z[24]) = 0;\\n\\t\\t(acc_fir[4] => z[24]) = 0;\\n\\t\\t(acc_fir[5] => z[24]) = 0;\\n\\t\\t(acc_fir[0] => z[25]) = 0;\\n\\t\\t(acc_fir[1] => z[25]) = 0;\\n\\t\\t(acc_fir[2] => z[25]) = 0;\\n\\t\\t(acc_fir[3] => z[25]) = 0;\\n\\t\\t(acc_fir[4] => z[25]) = 0;\\n\\t\\t(acc_fir[5] => z[25]) = 0;\\n\\t\\t(acc_fir[0] => z[26]) = 0;\\n\\t\\t(acc_fir[1] => z[26]) = 0;\\n\\t\\t(acc_fir[2] => z[26]) = 0;\\n\\t\\t(acc_fir[3] => z[26]) = 0;\\n\\t\\t(acc_fir[4] => z[26]) = 0;\\n\\t\\t(acc_fir[5] => z[26]) = 0;\\n\\t\\t(acc_fir[0] => z[27]) = 0;\\n\\t\\t(acc_fir[1] => z[27]) = 0;\\n\\t\\t(acc_fir[2] => z[27]) = 0;\\n\\t\\t(acc_fir[3] => z[27]) = 0;\\n\\t\\t(acc_fir[4] => z[27]) = 0;\\n\\t\\t(acc_fir[5] => z[27]) = 0;\\n\\t\\t(acc_fir[0] => z[28]) = 0;\\n\\t\\t(acc_fir[1] => z[28]) = 0;\\n\\t\\t(acc_fir[2] => z[28]) = 0;\\n\\t\\t(acc_fir[3] => z[28]) = 0;\\n\\t\\t(acc_fir[4] => z[28]) = 0;\\n\\t\\t(acc_fir[5] => z[28]) = 0;\\n\\t\\t(acc_fir[0] => z[29]) = 0;\\n\\t\\t(acc_fir[1] => z[29]) = 0;\\n\\t\\t(acc_fir[2] => z[29]) = 0;\\n\\t\\t(acc_fir[3] => z[29]) = 0;\\n\\t\\t(acc_fir[4] => z[29]) = 0;\\n\\t\\t(acc_fir[5] => z[29]) = 0;\\n\\t\\t(acc_fir[0] => z[30]) = 0;\\n\\t\\t(acc_fir[1] => z[30]) = 0;\\n\\t\\t(acc_fir[2] => z[30]) = 0;\\n\\t\\t(acc_fir[3] => z[30]) = 0;\\n\\t\\t(acc_fir[4] => z[30]) = 0;\\n\\t\\t(acc_fir[5] => z[30]) = 0;\\n\\t\\t(acc_fir[0] => z[31]) = 0;\\n\\t\\t(acc_fir[1] => z[31]) = 0;\\n\\t\\t(acc_fir[2] => z[31]) = 0;\\n\\t\\t(acc_fir[3] => z[31]) = 0;\\n\\t\\t(acc_fir[4] => z[31]) = 0;\\n\\t\\t(acc_fir[5] => z[31]) = 0;\\n\\t\\t(acc_fir[0] => z[32]) = 0;\\n\\t\\t(acc_fir[1] => z[32]) = 0;\\n\\t\\t(acc_fir[2] => z[32]) = 0;\\n\\t\\t(acc_fir[3] => z[32]) = 0;\\n\\t\\t(acc_fir[4] => z[32]) = 0;\\n\\t\\t(acc_fir[5] => z[32]) = 0;\\n\\t\\t(acc_fir[0] => z[33]) = 0;\\n\\t\\t(acc_fir[1] => z[33]) = 0;\\n\\t\\t(acc_fir[2] => z[33]) = 0;\\n\\t\\t(acc_fir[3] => z[33]) = 0;\\n\\t\\t(acc_fir[4] => z[33]) = 0;\\n\\t\\t(acc_fir[5] => z[33]) = 0;\\n\\t\\t(acc_fir[0] => z[34]) = 0;\\n\\t\\t(acc_fir[1] => z[34]) = 0;\\n\\t\\t(acc_fir[2] => z[34]) = 0;\\n\\t\\t(acc_fir[3] => z[34]) = 0;\\n\\t\\t(acc_fir[4] => z[34]) = 0;\\n\\t\\t(acc_fir[5] => z[34]) = 0;\\n\\t\\t(acc_fir[0] => z[35]) = 0;\\n\\t\\t(acc_fir[1] => z[35]) = 0;\\n\\t\\t(acc_fir[2] => z[35]) = 0;\\n\\t\\t(acc_fir[3] => z[35]) = 0;\\n\\t\\t(acc_fir[4] => z[35]) = 0;\\n\\t\\t(acc_fir[5] => z[35]) = 0;\\n\\t\\t(acc_fir[0] => z[36]) = 0;\\n\\t\\t(acc_fir[1] => z[36]) = 0;\\n\\t\\t(acc_fir[2] => z[36]) = 0;\\n\\t\\t(acc_fir[3] => z[36]) = 0;\\n\\t\\t(acc_fir[4] => z[36]) = 0;\\n\\t\\t(acc_fir[5] => z[36]) = 0;\\n\\t\\t(acc_fir[0] => z[37]) = 0;\\n\\t\\t(acc_fir[1] => z[37]) = 0;\\n\\t\\t(acc_fir[2] => z[37]) = 0;\\n\\t\\t(acc_fir[3] => z[37]) = 0;\\n\\t\\t(acc_fir[4] => z[37]) = 0;\\n\\t\\t(acc_fir[5] => z[37]) = 0;\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULTADD_REGIN (\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire        clk,\\n\\tinput  wire        reset,\\n\\n\\tinput  wire [ 2:0] feedback,\\n\\tinput  wire [ 5:0] acc_fir,\\n\\tinput  wire        load_acc,\\n\\tinput  wire        unsigned_a,\\n\\tinput  wire        unsigned_b,\\n\\n\\tinput  wire        f_mode,\\n\\tinput  wire [ 2:0] output_select,\\n\\tinput  wire        saturate_enable,\\n\\tinput  wire [ 5:0] shift_right,\\n\\tinput  wire        round,\\n\\tinput  wire        subtract,\\n\\tinput  wire        register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.dly_b(),\\n\\t\\t.z(z),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.acc_fir(acc_fir),\\n\\t\\t.load_acc(load_acc),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // unregistered output: ACCin (2, 3)\\n\\t\\t.saturate_enable(saturate_enable),\\n\\t\\t.shift_right(shift_right),\\n\\t\\t.round(round),\\n\\t\\t.subtract(subtract),\\n\\t\\t.register_inputs(register_inputs)   // registered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\t\\t$setuphold(posedge clk, load_acc, 0, 0);\\n\\t\\t$setuphold(posedge clk, subtract, 0, 0);\\n\\t\\t$setuphold(posedge clk, acc_fir, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULTADD_REGOUT (\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire        clk,\\n\\tinput  wire        reset,\\n\\n\\tinput  wire [ 2:0] feedback,\\n\\tinput  wire [ 5:0] acc_fir,\\n\\tinput  wire        load_acc,\\n\\tinput  wire        unsigned_a,\\n\\tinput  wire        unsigned_b,\\n\\n\\tinput  wire        f_mode,\\n\\tinput  wire [ 2:0] output_select,\\n\\tinput  wire        saturate_enable,\\n\\tinput  wire [ 5:0] shift_right,\\n\\tinput  wire        round,\\n\\tinput  wire        subtract,\\n\\tinput  wire        register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.dly_b(),\\n\\t\\t.z(z),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.acc_fir(acc_fir),\\n\\t\\t.load_acc(load_acc),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // registered output: ACCin (6, 7)\\n\\t\\t.saturate_enable(saturate_enable),\\n\\t\\t.shift_right(shift_right),\\n\\t\\t.round(round),\\n\\t\\t.subtract(subtract),\\n\\t\\t.register_inputs(register_inputs)   // unregistered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\t\\t$setuphold(posedge clk, load_acc, 0, 0);\\n\\t\\t$setuphold(posedge clk, subtract, 0, 0);\\n\\t\\t$setuphold(posedge clk, acc_fir, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULTADD_REGIN_REGOUT (\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire        clk,\\n\\tinput  wire        reset,\\n\\n\\tinput  wire [ 2:0] feedback,\\n\\tinput  wire [ 5:0] acc_fir,\\n\\tinput  wire        load_acc,\\n\\tinput  wire        unsigned_a,\\n\\tinput  wire        unsigned_b,\\n\\n\\tinput  wire        f_mode,\\n\\tinput  wire [ 2:0] output_select,\\n\\tinput  wire        saturate_enable,\\n\\tinput  wire [ 5:0] shift_right,\\n\\tinput  wire        round,\\n\\tinput  wire        subtract,\\n\\tinput  wire        register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.dly_b(),\\n\\t\\t.z(z),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.acc_fir(acc_fir),\\n\\t\\t.load_acc(load_acc),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // registered output: ACCin (6, 7)\\n\\t\\t.saturate_enable(saturate_enable),\\n\\t\\t.shift_right(shift_right),\\n\\t\\t.round(round),\\n\\t\\t.subtract(subtract),\\n\\t\\t.register_inputs(register_inputs)   // registered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\t\\t$setuphold(posedge clk, load_acc, 0, 0);\\n\\t\\t$setuphold(posedge clk, subtract, 0, 0);\\n\\t\\t$setuphold(posedge clk, acc_fir, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULTACC (\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire        clk,\\n\\tinput  wire        reset,\\n\\n\\tinput  wire        load_acc,\\n\\tinput  wire [ 2:0] feedback,\\n\\tinput  wire        unsigned_a,\\n\\tinput  wire        unsigned_b,\\n\\n\\tinput  wire        f_mode,\\n\\tinput  wire [ 2:0] output_select,\\n\\tinput  wire        saturate_enable,\\n\\tinput  wire [ 5:0] shift_right,\\n\\tinput  wire        round,\\n\\tinput  wire        subtract,\\n\\tinput  wire        register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.acc_fir(6'b0),\\n\\t\\t.z(z),\\n\\t\\t.dly_b(),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.load_acc(load_acc),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // unregistered output: ACCout (1)\\n\\t\\t.saturate_enable(saturate_enable),\\n\\t\\t.shift_right(shift_right),\\n\\t\\t.round(round),\\n\\t\\t.subtract(subtract),\\n\\t\\t.register_inputs(register_inputs)   // unregistered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\t\\t$setuphold(posedge clk, load_acc, 0, 0);\\n\\t\\t$setuphold(posedge clk, subtract, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULTACC_REGIN (\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire        clk,\\n\\tinput  wire        reset,\\n\\n\\tinput  wire [ 2:0] feedback,\\n\\tinput  wire        load_acc,\\n\\tinput  wire        unsigned_a,\\n\\tinput  wire        unsigned_b,\\n\\n\\tinput  wire        f_mode,\\n\\tinput  wire [ 2:0] output_select,\\n\\tinput  wire        saturate_enable,\\n\\tinput  wire [ 5:0] shift_right,\\n\\tinput  wire        round,\\n\\tinput  wire        subtract,\\n\\tinput  wire        register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.acc_fir(6'b0),\\n\\t\\t.z(z),\\n\\t\\t.dly_b(),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.load_acc(load_acc),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // unregistered output: ACCout (1)\\n\\t\\t.saturate_enable(saturate_enable),\\n\\t\\t.shift_right(shift_right),\\n\\t\\t.round(round),\\n\\t\\t.subtract(subtract),\\n\\t\\t.register_inputs(register_inputs)   // registered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\t\\t$setuphold(posedge clk, load_acc, 0, 0);\\n\\t\\t$setuphold(posedge clk, subtract, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULTACC_REGOUT (\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire        clk,\\n\\tinput  wire        reset,\\n\\n\\tinput  wire [ 2:0] feedback,\\n\\tinput  wire        load_acc,\\n\\tinput  wire        unsigned_a,\\n\\tinput  wire        unsigned_b,\\n\\n\\tinput  wire        f_mode,\\n\\tinput  wire [ 2:0] output_select,\\n\\tinput  wire        saturate_enable,\\n\\tinput  wire [ 5:0] shift_right,\\n\\tinput  wire        round,\\n\\tinput  wire        subtract,\\n\\tinput  wire        register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.acc_fir(6'b0),\\n\\t\\t.z(z),\\n\\t\\t.dly_b(),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.load_acc(load_acc),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // registered output: ACCout (5)\\n\\t\\t.saturate_enable(saturate_enable),\\n\\t\\t.shift_right(shift_right),\\n\\t\\t.round(round),\\n\\t\\t.subtract(subtract),\\n\\t\\t.register_inputs(register_inputs)   // unregistered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\t\\t$setuphold(posedge clk, load_acc, 0, 0);\\n\\t\\t$setuphold(posedge clk, subtract, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule QL_DSP2_MULTACC_REGIN_REGOUT (\\n\\tinput  wire [19:0] a,\\n\\tinput  wire [17:0] b,\\n\\toutput wire [37:0] z,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire        clk,\\n\\tinput  wire        reset,\\n\\n\\tinput  wire [ 2:0] feedback,\\n\\tinput  wire        load_acc,\\n\\tinput  wire        unsigned_a,\\n\\tinput  wire        unsigned_b,\\n\\n\\tinput  wire        f_mode,\\n\\tinput  wire [ 2:0] output_select,\\n\\tinput  wire        saturate_enable,\\n\\tinput  wire [ 5:0] shift_right,\\n\\tinput  wire        round,\\n\\tinput  wire        subtract,\\n\\tinput  wire        register_inputs\\n);\\n\\n\\tparameter [79:0] MODE_BITS = 80'd0;\\n\\n\\tlocalparam [19:0] COEFF_0 = MODE_BITS[19:0];\\n\\tlocalparam [19:0] COEFF_1 = MODE_BITS[39:20];\\n\\tlocalparam [19:0] COEFF_2 = MODE_BITS[59:40];\\n\\tlocalparam [19:0] COEFF_3 = MODE_BITS[79:60];\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a),\\n\\t\\t.b(b),\\n\\t\\t.acc_fir(6'b0),\\n\\t\\t.z(z),\\n\\t\\t.dly_b(),\\n\\n\\t\\t.f_mode(f_mode),\\n\\n\\t\\t.feedback(feedback),\\n\\t\\t.load_acc(load_acc),\\n\\n\\t\\t.unsigned_a(unsigned_a),\\n\\t\\t.unsigned_b(unsigned_b),\\n\\n\\t\\t.clk(clk),\\n\\t\\t.reset(reset),\\n\\n\\t\\t.output_select(output_select),      // registered output: ACCout (5)\\n\\t\\t.saturate_enable(saturate_enable),\\n\\t\\t.shift_right(shift_right),\\n\\t\\t.round(round),\\n\\t\\t.subtract(subtract),\\n\\t\\t.register_inputs(register_inputs)   // registered inputs\\n\\t);\\n\\n`ifdef SDF_SIM\\n\\tspecify\\n\\t\\t(posedge clk => (z +: a)) = 0;\\n\\t\\t(posedge clk => (z +: b)) = 0;\\n\\t\\t$setuphold(posedge clk, a, 0, 0);\\n\\t\\t$setuphold(posedge clk, b, 0, 0);\\n\\t\\t$setuphold(posedge clk, feedback, 0, 0);\\n\\t\\t$setuphold(posedge clk, load_acc, 0, 0);\\n\\t\\t$setuphold(posedge clk, subtract, 0, 0);\\n\\tendspecify\\n`endif\\n\\nendmodule\\n\\nmodule dsp_t1_20x18x64_cfg_ports (\\n\\tinput  wire [19:0] a_i,\\n\\tinput  wire [17:0] b_i,\\n\\tinput  wire [ 5:0] acc_fir_i,\\n\\toutput wire [37:0] z_o,\\n\\toutput wire [17:0] dly_b_o,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire        clock_i,\\n\\tinput  wire        reset_i,\\n\\n\\tinput  wire [ 2:0] feedback_i,\\n\\tinput  wire        load_acc_i,\\n\\tinput  wire        unsigned_a_i,\\n\\tinput  wire        unsigned_b_i,\\n\\n\\tinput  wire [ 2:0] output_select_i,\\n\\tinput  wire        saturate_enable_i,\\n\\tinput  wire [ 5:0] shift_right_i,\\n\\tinput  wire        round_i,\\n\\tinput  wire        subtract_i,\\n\\tinput  wire        register_inputs_i\\n);\\n\\n\\tparameter [19:0] COEFF_0 = 20'd0;\\n\\tparameter [19:0] COEFF_1 = 20'd0;\\n\\tparameter [19:0] COEFF_2 = 20'd0;\\n\\tparameter [19:0] COEFF_3 = 20'd0;\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({COEFF_3, COEFF_2, COEFF_1, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a(a_i),\\n\\t\\t.b(b_i),\\n\\t\\t.z(z_o),\\n\\t\\t.dly_b(dly_b_o),\\n\\n\\t\\t.f_mode(1'b0),  // 20x18x64 DSP\\n\\n\\t\\t.acc_fir(acc_fir_i),\\n\\t\\t.feedback(feedback_i),\\n\\t\\t.load_acc(load_acc_i),\\n\\n\\t\\t.unsigned_a(unsigned_a_i),\\n\\t\\t.unsigned_b(unsigned_b_i),\\n\\n\\t\\t.clk(clock_i),\\n\\t\\t.reset(reset_i),\\n\\n\\t\\t.saturate_enable(saturate_enable_i),\\n\\t\\t.output_select(output_select_i),\\n\\t\\t.round(round_i),\\n\\t\\t.shift_right(shift_right_i),\\n\\t\\t.subtract(subtract_i),\\n\\t\\t.register_inputs(register_inputs_i)\\n\\t);\\nendmodule\\n\\nmodule dsp_t1_10x9x32_cfg_ports (\\n\\tinput  wire [ 9:0] a_i,\\n\\tinput  wire [ 8:0] b_i,\\n\\tinput  wire [ 5:0] acc_fir_i,\\n\\toutput wire [18:0] z_o,\\n\\toutput wire [ 8:0] dly_b_o,\\n\\n\\t(* clkbuf_sink *)\\n\\tinput  wire        clock_i,\\n\\tinput  wire        reset_i,\\n\\n\\tinput  wire [ 2:0] feedback_i,\\n\\tinput  wire        load_acc_i,\\n\\tinput  wire        unsigned_a_i,\\n\\tinput  wire        unsigned_b_i,\\n\\n\\tinput  wire [ 2:0] output_select_i,\\n\\tinput  wire        saturate_enable_i,\\n\\tinput  wire [ 5:0] shift_right_i,\\n\\tinput  wire        round_i,\\n\\tinput  wire        subtract_i,\\n\\tinput  wire        register_inputs_i\\n);\\n\\n\\tparameter [9:0] COEFF_0 = 10'd0;\\n\\tparameter [9:0] COEFF_1 = 10'd0;\\n\\tparameter [9:0] COEFF_2 = 10'd0;\\n\\tparameter [9:0] COEFF_3 = 10'd0;\\n\\n\\twire [18:0] z_rem;\\n\\twire [8:0] dly_b_rem;\\n\\n\\tQL_DSP2 #(\\n\\t\\t.MODE_BITS({10'd0, COEFF_3,\\n\\t\\t\\t\\t\\t10'd0, COEFF_2,\\n\\t\\t\\t\\t\\t10'd0, COEFF_1,\\n\\t\\t\\t\\t\\t10'd0, COEFF_0})\\n\\t) dsp (\\n\\t\\t.a({10'd0, a_i}),\\n\\t\\t.b({9'd0, b_i}),\\n\\t\\t.z({z_rem, z_o}),\\n\\t\\t.dly_b({dly_b_rem, dly_b_o}),\\n\\n\\t\\t.f_mode(1'b1),  // 10x9x32 DSP\\n\\n\\t\\t.acc_fir(acc_fir_i),\\n\\t\\t.feedback(feedback_i),\\n\\t\\t.load_acc(load_acc_i),\\n\\n\\t\\t.unsigned_a(unsigned_a_i),\\n\\t\\t.unsigned_b(unsigned_b_i),\\n\\n\\t\\t.clk(clock_i),\\n\\t\\t.reset(reset_i),\\n\\n\\t\\t.saturate_enable(saturate_enable_i),\\n\\t\\t.output_select(output_select_i),\\n\\t\\t.round(round_i),\\n\\t\\t.shift_right(shift_right_i),\\n\\t\\t.subtract(subtract_i),\\n\\t\\t.register_inputs(register_inputs_i)\\n\\t);\\nendmodule\\n\\nmodule dsp_t1_sim_cfg_ports # (\\n\\tparameter NBITS_ACC  = 64,\\n\\tparameter NBITS_A    = 20,\\n\\tparameter NBITS_B    = 18,\\n\\tparameter NBITS_Z    = 38\\n)(\\n\\tinput  wire [NBITS_A-1:0] a_i,\\n\\tinput  wire [NBITS_B-1:0] b_i,\\n\\toutput wire [NBITS_Z-1:0] z_o,\\n\\toutput reg  [NBITS_B-1:0] dly_b_o,\\n\\n\\tinput  wire [5:0]         acc_fir_i,\\n\\tinput  wire [2:0]         feedback_i,\\n\\tinput  wire               load_acc_i,\\n\\n\\tinput  wire               unsigned_a_i,\\n\\tinput  wire               unsigned_b_i,\\n\\n\\tinput  wire               clock_i,\\n\\tinput  wire               s_reset,\\n\\n\\tinput  wire               saturate_enable_i,\\n\\tinput  wire [2:0]         output_select_i,\\n\\tinput  wire               round_i,\\n\\tinput  wire [5:0]         shift_right_i,\\n\\tinput  wire               subtract_i,\\n\\tinput  wire               register_inputs_i,\\n\\tinput  wire [NBITS_A-1:0] coef_0_i,\\n\\tinput  wire [NBITS_A-1:0] coef_1_i,\\n\\tinput  wire [NBITS_A-1:0] coef_2_i,\\n\\tinput  wire [NBITS_A-1:0] coef_3_i\\n);\\n\\n// FIXME: The version of Icarus Verilog from Conda seems not to recognize the\\n// $error macro. Disable this sanity check for now because of that.\\n\\n\\n\\t// Input registers\\n\\treg  [NBITS_A-1:0]  r_a;\\n\\treg  [NBITS_B-1:0]  r_b;\\n\\treg  [5:0]          r_acc_fir;\\n\\treg                 r_unsigned_a;\\n\\treg                 r_unsigned_b;\\n\\treg                 r_load_acc;\\n\\treg  [2:0]          r_feedback;\\n\\treg  [5:0]          r_shift_d1;\\n\\treg  [5:0]          r_shift_d2;\\n\\treg         r_subtract;\\n\\treg         r_sat;\\n\\treg         r_rnd;\\n\\treg [NBITS_ACC-1:0] acc;\\n\\n\\tinitial begin\\n\\t\\tr_a          <= 0;\\n\\t\\tr_b          <= 0;\\n\\n\\t\\tr_acc_fir    <= 0;\\n\\t\\tr_unsigned_a <= 0;\\n\\t\\tr_unsigned_b <= 0;\\n\\t\\tr_feedback   <= 0;\\n\\t\\tr_shift_d1   <= 0;\\n\\t\\tr_shift_d2   <= 0;\\n\\t\\tr_subtract   <= 0;\\n\\t\\tr_load_acc   <= 0;\\n\\t\\tr_sat        <= 0;\\n\\t\\tr_rnd        <= 0;\\n\\tend\\n\\n\\talways @(posedge clock_i or posedge s_reset) begin\\n\\t\\tif (s_reset) begin\\n\\n\\t\\t\\tr_a <= 'h0;\\n\\t\\t\\tr_b <= 'h0;\\n\\n\\t\\t\\tr_acc_fir    <= 0;\\n\\t\\t\\tr_unsigned_a <= 0;\\n\\t\\t\\tr_unsigned_b <= 0;\\n\\t\\t\\tr_feedback   <= 0;\\n\\t\\t\\tr_shift_d1   <= 0;\\n\\t\\t\\tr_shift_d2   <= 0;\\n\\t\\t\\tr_subtract   <= 0;\\n\\t\\t\\tr_load_acc   <= 0;\\n\\t\\t\\tr_sat    <= 0;\\n\\t\\t\\tr_rnd    <= 0;\\n\\n\\t\\tend else begin\\n\\n\\t\\t\\tr_a <= a_i;\\n\\t\\t\\tr_b <= b_i;\\n\\n\\t\\t\\tr_acc_fir    <= acc_fir_i;\\n\\t\\t\\tr_unsigned_a <= unsigned_a_i;\\n\\t\\t\\tr_unsigned_b <= unsigned_b_i;\\n\\t\\t\\tr_feedback   <= feedback_i;\\n\\t\\t\\tr_shift_d1   <= shift_right_i;\\n\\t\\t\\tr_shift_d2   <= r_shift_d1;\\n\\t\\t\\tr_subtract   <= subtract_i;\\n\\t\\t\\tr_load_acc   <= load_acc_i;\\n\\t\\t\\tr_sat    <= r_sat;\\n\\t\\t\\tr_rnd    <= r_rnd;\\n\\n\\t\\tend\\n\\tend\\n\\n\\t// Registered / non-registered input path select\\n\\twire [NBITS_A-1:0]  a = register_inputs_i ? r_a : a_i;\\n\\twire [NBITS_B-1:0]  b = register_inputs_i ? r_b : b_i;\\n\\n\\twire [5:0] acc_fir = register_inputs_i ? r_acc_fir : acc_fir_i;\\n\\twire       unsigned_a = register_inputs_i ? r_unsigned_a : unsigned_a_i;\\n\\twire       unsigned_b = register_inputs_i ? r_unsigned_b : unsigned_b_i;\\n\\twire [2:0] feedback   = register_inputs_i ? r_feedback   : feedback_i;\\n\\twire       load_acc   = register_inputs_i ? r_load_acc   : load_acc_i;\\n\\twire       subtract   = register_inputs_i ? r_subtract   : subtract_i;\\n\\twire       sat    = register_inputs_i ? r_sat : saturate_enable_i;\\n\\twire       rnd    = register_inputs_i ? r_rnd : round_i;\\n\\n\\t// Shift right control\\n\\twire [5:0] shift_d1 = register_inputs_i ? r_shift_d1 : shift_right_i;\\n\\twire [5:0] shift_d2 = output_select_i[1] ? shift_d1 : r_shift_d2;\\n\\n\\t// Multiplier\\n\\twire unsigned_mode = unsigned_a & unsigned_b;\\n\\twire [NBITS_A-1:0] mult_a;\\n\\tassign mult_a = (feedback == 3'h0) ?   a :\\n\\t\\t\\t\\t\\t(feedback == 3'h1) ?   a :\\n\\t\\t\\t\\t\\t(feedback == 3'h2) ?   a :\\n\\t\\t\\t\\t\\t(feedback == 3'h3) ?   acc[NBITS_A-1:0] :\\n\\t\\t\\t\\t\\t(feedback == 3'h4) ?   coef_0_i :\\n\\t\\t\\t\\t\\t(feedback == 3'h5) ?   coef_1_i :\\n\\t\\t\\t\\t\\t(feedback == 3'h6) ?   coef_2_i :\\n\\t\\t\\t\\t\\t   coef_3_i;    // if feedback == 3'h7\\n\\n\\twire [NBITS_B-1:0] mult_b = (feedback == 2'h2) ? {NBITS_B{1'b0}}  : b;\\n\\n\\twire [NBITS_A-1:0] mult_sgn_a = mult_a[NBITS_A-1];\\n\\twire [NBITS_A-1:0] mult_mag_a = (mult_sgn_a && !unsigned_a) ? (~mult_a + 1) : mult_a;\\n\\twire [NBITS_B-1:0] mult_sgn_b = mult_b[NBITS_B-1];\\n\\twire [NBITS_B-1:0] mult_mag_b = (mult_sgn_b && !unsigned_b) ? (~mult_b + 1) : mult_b;\\n\\n\\twire [NBITS_A+NBITS_B-1:0] mult_mag = mult_mag_a * mult_mag_b;\\n\\twire mult_sgn = (mult_sgn_a && !unsigned_a) ^ (mult_sgn_b && !unsigned_b);\\n\\n\\twire [NBITS_A+NBITS_B-1:0] mult = (unsigned_a && unsigned_b) ?\\n\\t\\t(mult_a * mult_b) : (mult_sgn ? (~mult_mag + 1) : mult_mag);\\n\\n\\t// Sign extension\\n\\twire [NBITS_ACC-1:0] mult_xtnd = unsigned_mode ?\\n\\t\\t{{(NBITS_ACC-NBITS_A-NBITS_B){1'b0}},                    mult[NBITS_A+NBITS_B-1:0]} :\\n\\t\\t{{(NBITS_ACC-NBITS_A-NBITS_B){mult[NBITS_A+NBITS_B-1]}}, mult[NBITS_A+NBITS_B-1:0]};\\n\\n\\t// Adder\\n\\twire [NBITS_ACC-1:0] acc_fir_int = unsigned_a ? {{(NBITS_ACC-NBITS_A){1'b0}},         a} :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{{(NBITS_ACC-NBITS_A){a[NBITS_A-1]}}, a} ;\\n\\n\\twire [NBITS_ACC-1:0] add_a = (subtract) ? (~mult_xtnd + 1) : mult_xtnd;\\n\\twire [NBITS_ACC-1:0] add_b = (feedback_i == 3'h0) ? acc :\\n\\t\\t\\t\\t\\t\\t\\t\\t (feedback_i == 3'h1) ? {{NBITS_ACC}{1'b0}} : (acc_fir_int << acc_fir);\\n\\n\\twire [NBITS_ACC-1:0] add_o = add_a + add_b;\\n\\n\\t// Accumulator\\n\\tinitial acc <= 0;\\n\\n\\talways @(posedge clock_i or posedge s_reset)\\n\\t\\tif (s_reset) acc <= 'h0;\\n\\t\\telse begin\\n\\t\\t\\tif (load_acc)\\n\\t\\t\\t\\tacc <= add_o;\\n\\t\\t\\telse\\n\\t\\t\\t\\tacc <= acc;\\n\\t\\tend\\n\\n\\t// Adder/accumulator output selection\\n\\twire [NBITS_ACC-1:0] acc_out = (output_select_i[1]) ? add_o : acc;\\n\\n\\t// Round, shift, saturate\\n\\twire [NBITS_ACC-1:0] acc_rnd = (rnd && (shift_right_i != 0)) ? (acc_out + ({{(NBITS_ACC-1){1'b0}}, 1'b1} << (shift_right_i - 1))) :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tacc_out;\\n\\n\\twire [NBITS_ACC-1:0] acc_shr = (unsigned_mode) ? (acc_rnd  >> shift_right_i) :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t (acc_rnd >>> shift_right_i);\\n\\n\\twire [NBITS_ACC-1:0] acc_sat_u = (acc_shr[NBITS_ACC-1:NBITS_Z] != 0) ? {{(NBITS_ACC-NBITS_Z){1'b0}},{NBITS_Z{1'b1}}} :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   {{(NBITS_ACC-NBITS_Z){1'b0}},{acc_shr[NBITS_Z-1:0]}};\\n\\n\\twire [NBITS_ACC-1:0] acc_sat_s = ((|acc_shr[NBITS_ACC-1:NBITS_Z-1] == 1'b0) ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  (&acc_shr[NBITS_ACC-1:NBITS_Z-1] == 1'b1)) ? {{(NBITS_ACC-NBITS_Z){1'b0}},{acc_shr[NBITS_Z-1:0]}} :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   {{(NBITS_ACC-NBITS_Z){1'b0}},{acc_shr[NBITS_ACC-1],{NBITS_Z-1{~acc_shr[NBITS_ACC-1]}}}};\\n\\n\\twire [NBITS_ACC-1:0] acc_sat = (sat) ? ((unsigned_mode) ? acc_sat_u : acc_sat_s) : acc_shr;\\n\\n\\t// Output signals\\n\\twire [NBITS_Z-1:0]  z0;\\n\\treg  [NBITS_Z-1:0]  z1;\\n\\twire [NBITS_Z-1:0]  z2;\\n\\n\\tassign z0 = mult_xtnd[NBITS_Z-1:0];\\n\\tassign z2 = acc_sat[NBITS_Z-1:0];\\n\\n\\tinitial z1 <= 0;\\n\\n\\talways @(posedge clock_i or posedge s_reset)\\n\\t\\tif (s_reset)\\n\\t\\t\\tz1 <= 0;\\n\\t\\telse begin\\n\\t\\t\\tz1 <= (output_select_i == 3'b100) ? z0 : z2;\\n\\t\\tend\\n\\n\\t// Output mux\\n\\tassign z_o = (output_select_i == 3'h0) ?   z0 :\\n\\t\\t\\t\\t (output_select_i == 3'h1) ?   z2 :\\n\\t\\t\\t\\t (output_select_i == 3'h2) ?   z2 :\\n\\t\\t\\t\\t (output_select_i == 3'h3) ?   z2 :\\n\\t\\t\\t\\t (output_select_i == 3'h4) ?   z1 :\\n\\t\\t\\t\\t (output_select_i == 3'h5) ?   z1 :\\n\\t\\t\\t\\t (output_select_i == 3'h6) ?   z1 :\\n\\t\\t\\t\\t\\t\\t   z1;  // if output_select_i == 3'h7\\n\\n\\t// B input delayed passthrough\\n\\tinitial dly_b_o <= 0;\\n\\n\\talways @(posedge clock_i or posedge s_reset)\\n\\t\\tif (s_reset)\\n\\t\\t\\tdly_b_o <= 0;\\n\\t\\telse\\n\\t\\t\\tdly_b_o <= b_i;\\n\\nendmodule\\n\",\n                \"ffs_map.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\n// DFF, asynchronous set/reset, enable\\nmodule \\\\$_DFFSRE_PNNP_ (C, S, R, E, D, Q);\\n\\tinput  C;\\n\\tinput  S;\\n\\tinput  R;\\n\\tinput  E;\\n\\tinput  D;\\n\\toutput Q;\\n\\tdffsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(S));\\nendmodule\\n\\nmodule \\\\$_DFFSRE_NNNP_ (C, S, R, E, D, Q);\\n\\tinput  C;\\n\\tinput  S;\\n\\tinput  R;\\n\\tinput  E;\\n\\tinput  D;\\n\\toutput Q;\\n\\tdffnsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(S));\\nendmodule\\n\\n// DFF, synchronous set or reset, enable\\nmodule \\\\$_SDFFE_PN0P_ (D, C, R, E, Q);\\n\\tinput  D;\\n\\tinput  C;\\n\\tinput  R;\\n\\tinput  E;\\n\\toutput Q;\\n\\tsdffsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(1'b1));\\nendmodule\\n\\nmodule \\\\$_SDFFE_PN1P_ (D, C, R, E, Q);\\n\\tinput  D;\\n\\tinput  C;\\n\\tinput  R;\\n\\tinput  E;\\n\\toutput Q;\\n\\tsdffsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(1'b1), .S(R));\\nendmodule\\n\\nmodule \\\\$_SDFFE_NN0P_ (D, C, R, E, Q);\\n\\tinput  D;\\n\\tinput  C;\\n\\tinput  R;\\n\\tinput  E;\\n\\toutput Q;\\n\\tsdffnsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(R), .S(1'b1));\\nendmodule\\n\\nmodule \\\\$_SDFFE_NN1P_ (D, C, R, E, Q);\\n\\tinput  D;\\n\\tinput  C;\\n\\tinput  R;\\n\\tinput  E;\\n\\toutput Q;\\n\\tsdffnsre _TECHMAP_REPLACE_ (.Q(Q), .D(D), .C(C), .E(E), .R(1'b1), .S(R));\\nendmodule\\n\\n// Latch, no set/reset, no enable\\nmodule  \\\\$_DLATCH_P_ (input E, D, output Q);\\n\\tlatchsre  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E), .R(1'b1), .S(1'b1));\\nendmodule\\n\\nmodule  \\\\$_DLATCH_N_ (input E, D, output Q);\\n\\tlatchnsre _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E), .R(1'b1), .S(1'b1));\\nendmodule\\n\\n// Latch with async set and reset and enable\\nmodule  \\\\$_DLATCHSR_PPP_ (input E, S, R, D, output Q);\\n\\tlatchsre  _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E),  .R(!R), .S(!S));\\nendmodule\\n\\nmodule  \\\\$_DLATCHSR_NPP_ (input E, S, R, D, output Q);\\n\\tlatchnsre _TECHMAP_REPLACE_ (.D(D), .Q(Q), .E(1'b1), .G(E),  .R(!R), .S(!S));\\nendmodule\\n\\nmodule \\\\$__SHREG_DFF_P_ (D, Q, C);\\n\\tinput  D;\\n\\tinput  C;\\n\\toutput Q;\\n\\n\\tparameter DEPTH = 2;\\n\\n\\treg [DEPTH-2:0] q;\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < DEPTH; i = i + 1) begin: slice\\n\\n\\t\\t// First in chain\\n\\t\\tgenerate if (i == 0) begin\\n\\t\\t\\t\\t sh_dff #() shreg_beg (\\n\\t\\t\\t\\t\\t.Q(q[i]),\\n\\t\\t\\t\\t\\t.D(D),\\n\\t\\t\\t\\t\\t.C(C)\\n\\t\\t\\t\\t);\\n\\t\\tend endgenerate\\n\\t\\t// Middle in chain\\n\\t\\tgenerate if (i > 0 && i != DEPTH-1) begin\\n\\t\\t\\t\\t sh_dff #() shreg_mid (\\n\\t\\t\\t\\t\\t.Q(q[i]),\\n\\t\\t\\t\\t\\t.D(q[i-1]),\\n\\t\\t\\t\\t\\t.C(C)\\n\\t\\t\\t\\t);\\n\\t\\tend endgenerate\\n\\t\\t// Last in chain\\n\\t\\tgenerate if (i == DEPTH-1) begin\\n\\t\\t\\t\\t sh_dff #() shreg_end (\\n\\t\\t\\t\\t\\t.Q(Q),\\n\\t\\t\\t\\t\\t.D(q[i-1]),\\n\\t\\t\\t\\t\\t.C(C)\\n\\t\\t\\t\\t);\\n\\t\\tend endgenerate\\n   end: slice\\n   endgenerate\\n\\nendmodule\\n\\n\",\n                \"libmap_brams.txt\": \"ram block $__QLF_TDP36K {\\n\\tinit any;\\n\\tbyte 9;\\n\\toption \\\"SPLIT\\\" 0 {\\n\\t\\tabits 15;\\n\\t\\twidths 1 2 4 9 18 36 per_port;\\n\\t}\\n\\toption \\\"SPLIT\\\" 1 {\\n\\t\\tabits 14;\\n\\t\\twidths 1 2 4 9 18 per_port;\\n\\t}\\n\\tcost 65;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\twidth tied;\\n\\t\\tclock posedge;\\n\\t\\t# wen causes read even when ren is low\\n\\t\\t# map clken = wen || ren\\n\\t\\tclken;\\n\\t\\twrbe_separate;\\n\\t\\trdwr old;\\n\\t}\\n}\\n\",\n                \"libmap_brams_map.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\nmodule \\\\$__QLF_TDP36K (PORT_A_CLK, PORT_A_ADDR, PORT_A_WR_DATA, PORT_A_WR_EN, PORT_A_WR_BE, PORT_A_CLK_EN, PORT_A_RD_DATA,\\n\\t\\t\\t\\t\\t   PORT_B_CLK, PORT_B_ADDR, PORT_B_WR_DATA, PORT_B_WR_EN, PORT_B_WR_BE, PORT_B_CLK_EN, PORT_B_RD_DATA);  \\n\\nparameter INIT = 0;\\n\\nparameter OPTION_SPLIT = 0;\\n\\nparameter PORT_A_WIDTH = 1;\\nparameter PORT_A_WR_BE_WIDTH = 1;\\n\\nparameter PORT_B_WIDTH = 1;\\nparameter PORT_B_WR_BE_WIDTH = 1;\\n\\ninput PORT_A_CLK;\\ninput [14:0] PORT_A_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\ninput PORT_A_WR_EN;\\ninput [PORT_A_WR_BE_WIDTH-1:0] PORT_A_WR_BE;\\ninput PORT_A_CLK_EN;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\n\\ninput PORT_B_CLK;\\ninput [14:0] PORT_B_ADDR;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\ninput PORT_B_WR_EN;\\ninput [PORT_B_WR_BE_WIDTH-1:0] PORT_B_WR_BE;\\ninput PORT_B_CLK_EN;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\n\\n\\n// Fixed mode settings\\nlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\nlocalparam [ 0:0] FMODE1_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\nlocalparam [11:0] UPAE1_i       = 12'd10;\\nlocalparam [11:0] UPAF1_i       = 12'd10;\\n\\nlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\nlocalparam [ 0:0] FMODE2_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\nlocalparam [10:0] UPAE2_i       = 11'd10;\\nlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n// Width mode function\\nfunction [2:0] mode;\\ninput integer width;\\ncase (width)\\n1: mode = 3'b101;\\n2: mode = 3'b110;\\n4: mode = 3'b100;\\n8,9: mode = 3'b001;\\n16, 18: mode = 3'b010;\\n32, 36: mode = 3'b011;\\ndefault: mode = 3'b000;\\nendcase\\nendfunction\\n\\nfunction [36863:0] pack_init;\\n\\tinteger i;\\n\\treg [35:0] ri;\\n\\tfor (i = 0; i < (OPTION_SPLIT ? 512 : 1024); i = i + 1) begin\\n\\t\\tri = INIT[i*36 +: 36];\\n\\t\\tpack_init[i*36 +: 36] = {ri[35], ri[26], ri[34:27], ri[25:18],\\n\\t\\t\\t\\t\\t\\t\\t\\t ri[17], ri[8], ri[16:9], ri[7:0]};\\n\\tend\\n\\tif (OPTION_SPLIT)\\n\\t\\tpack_init[36863:18432] = 18432'bx;\\nendfunction\\n\\nwire REN_A1_i;\\nwire REN_A2_i;\\n\\nwire REN_B1_i;\\nwire REN_B2_i;\\n\\nwire WEN_A1_i;\\nwire WEN_A2_i;\\n\\nwire WEN_B1_i;\\nwire WEN_B2_i;\\n\\nwire [1:0] BE_A1_i;\\nwire [1:0] BE_A2_i;\\n\\nwire [1:0] BE_B1_i;\\nwire [1:0] BE_B2_i;\\n\\nwire [14:0] ADDR_A1_i;\\nwire [13:0] ADDR_A2_i;\\n\\nwire [14:0] ADDR_B1_i;\\nwire [13:0] ADDR_B2_i;\\n\\nwire [17:0] WDATA_A1_i;\\nwire [17:0] WDATA_A2_i;\\n\\nwire [17:0] WDATA_B1_i;\\nwire [17:0] WDATA_B2_i;\\n\\nwire [17:0] RDATA_A1_o;\\nwire [17:0] RDATA_A2_o;\\n\\nwire [17:0] RDATA_B1_o;\\nwire [17:0] RDATA_B2_o;\\n\\n\\n// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)\\nlocalparam [ 2:0] RMODE_A1_i    = mode(PORT_A_WIDTH);\\nlocalparam [ 2:0] WMODE_A1_i    = mode(PORT_A_WIDTH);\\nlocalparam [ 2:0] RMODE_A2_i    = mode(PORT_A_WIDTH);\\nlocalparam [ 2:0] WMODE_A2_i    = mode(PORT_A_WIDTH);\\n\\nlocalparam [ 2:0] RMODE_B1_i    = mode(PORT_B_WIDTH);\\nlocalparam [ 2:0] WMODE_B1_i    = mode(PORT_B_WIDTH);\\nlocalparam [ 2:0] RMODE_B2_i    = mode(PORT_B_WIDTH);\\nlocalparam [ 2:0] WMODE_B2_i    = mode(PORT_B_WIDTH);\\n\\nassign REN_A1_i = PORT_A_CLK_EN;\\nassign WEN_A1_i = PORT_A_CLK_EN & PORT_A_WR_EN;\\nassign {BE_A2_i, BE_A1_i} = PORT_A_WR_BE;\\n\\nassign REN_B1_i = PORT_B_CLK_EN;\\nassign WEN_B1_i = PORT_B_CLK_EN & PORT_B_WR_EN;\\nassign {BE_B2_i, BE_B1_i} = PORT_B_WR_BE;\\n\\ncase (PORT_A_WIDTH)\\n9: assign { WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A_WR_DATA;\\n18: assign { WDATA_A1_i[17], WDATA_A1_i[15:8], WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A_WR_DATA;\\n36: assign { WDATA_A2_i[17], WDATA_A2_i[15:8], WDATA_A2_i[16], WDATA_A2_i[7:0], WDATA_A1_i[17], WDATA_A1_i[15:8], WDATA_A1_i[16], WDATA_A1_i[7:0]} = PORT_A_WR_DATA;\\ndefault: assign WDATA_A1_i = PORT_A_WR_DATA; // 1,2,4\\nendcase\\n\\ncase (PORT_B_WIDTH)\\n9: assign { WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B_WR_DATA;\\n18: assign { WDATA_B1_i[17], WDATA_B1_i[15:8], WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B_WR_DATA;\\n36: assign { WDATA_B2_i[17], WDATA_B2_i[15:8], WDATA_B2_i[16], WDATA_B2_i[7:0], WDATA_B1_i[17], WDATA_B1_i[15:8], WDATA_B1_i[16], WDATA_B1_i[7:0]} = PORT_B_WR_DATA;\\ndefault: assign WDATA_B1_i = PORT_B_WR_DATA; // 1,2,4\\nendcase\\n\\ncase (PORT_A_WIDTH)\\n9: assign PORT_A_RD_DATA = { RDATA_A1_o[16], RDATA_A1_o[7:0] };\\n18: assign PORT_A_RD_DATA = { RDATA_A1_o[17], RDATA_A1_o[15:8], RDATA_A1_o[16], RDATA_A1_o[7:0] };\\n36: assign PORT_A_RD_DATA = { RDATA_A2_o[17], RDATA_A2_o[15:8], RDATA_A2_o[16], RDATA_A2_o[7:0], RDATA_A1_o[17], RDATA_A1_o[15:8], RDATA_A1_o[16], RDATA_A1_o[7:0]};\\ndefault: assign PORT_A_RD_DATA = RDATA_A1_o; // 1,2,4\\nendcase\\n\\ncase (PORT_B_WIDTH)\\n9: assign PORT_B_RD_DATA = { RDATA_B1_o[16], RDATA_B1_o[7:0] };\\n18: assign PORT_B_RD_DATA = { RDATA_B1_o[17], RDATA_B1_o[15:8], RDATA_B1_o[16], RDATA_B1_o[7:0] };\\n36: assign PORT_B_RD_DATA = { RDATA_B2_o[17], RDATA_B2_o[15:8], RDATA_B2_o[16], RDATA_B2_o[7:0], RDATA_B1_o[17], RDATA_B1_o[15:8], RDATA_B1_o[16], RDATA_B1_o[7:0]};\\ndefault: assign PORT_B_RD_DATA = RDATA_B1_o; // 1,2,4\\nendcase\\n\\ndefparam _TECHMAP_REPLACE_.MODE_BITS = { 1'b0,\\n\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n};\\n\\n(* is_inferred = 1 *)\\n(* is_split = 0 *)\\n(* was_split_candidate = OPTION_SPLIT *)\\n(* port_a_width = PORT_A_WIDTH *)\\n(* port_b_width = PORT_B_WIDTH *)\\nTDP36K #(\\n\\t.RAM_INIT(pack_init()),\\n) _TECHMAP_REPLACE_ (\\n\\t.RESET_ni(1'b1),\\n\\n\\t.CLK_A1_i(PORT_A_CLK),\\n\\t.ADDR_A1_i(PORT_A_ADDR),\\n\\t.WEN_A1_i(WEN_A1_i),\\n\\t.BE_A1_i(BE_A1_i),\\n\\t.WDATA_A1_i(WDATA_A1_i),\\n\\t.REN_A1_i(REN_A1_i),\\n\\t.RDATA_A1_o(RDATA_A1_o),\\n\\n\\t.CLK_A2_i(PORT_A_CLK),\\n\\t.ADDR_A2_i(PORT_A_ADDR[13:0]),\\n\\t.WEN_A2_i(WEN_A1_i),\\n\\t.BE_A2_i(BE_A2_i),\\n\\t.WDATA_A2_i(WDATA_A2_i),\\n\\t.REN_A2_i(REN_A1_i),\\n\\t.RDATA_A2_o(RDATA_A2_o),\\n\\n\\t.CLK_B1_i(PORT_B_CLK),\\n\\t.ADDR_B1_i(PORT_B_ADDR),\\n\\t.WEN_B1_i(WEN_B1_i),\\n\\t.BE_B1_i(BE_B1_i),\\n\\t.WDATA_B1_i(WDATA_B1_i),\\n\\t.REN_B1_i(REN_B1_i),\\n\\t.RDATA_B1_o(RDATA_B1_o),\\n\\n\\t.CLK_B2_i(PORT_B_CLK),\\n\\t.ADDR_B2_i(PORT_B_ADDR[13:0]),\\n\\t.WEN_B2_i(WEN_B1_i),\\n\\t.BE_B2_i(BE_B2_i),\\n\\t.WDATA_B2_i(WDATA_B2_i),\\n\\t.REN_B2_i(REN_B1_i),\\n\\t.RDATA_B2_o(RDATA_B2_o),\\n\\n\\t.FLUSH1_i(1'b0),\\n\\t.FLUSH2_i(1'b0)\\n);\\n\\nendmodule\\n\\n\\nmodule \\\\$__QLF_TDP36K_MERGED (...);\\n\\nparameter INIT1 = 0;\\n\\nparameter PORT_A1_WIDTH = 1;\\nparameter PORT_B1_WIDTH = 1;\\n\\nparameter PORT_A1_WR_BE_WIDTH = 1;\\nparameter PORT_B1_WR_BE_WIDTH = 1;\\n\\ninput PORT_A1_CLK;\\ninput [14:0] PORT_A1_ADDR;\\ninput [PORT_A1_WIDTH-1:0] PORT_A1_WR_DATA;\\ninput PORT_A1_WR_EN;\\ninput [PORT_A1_WR_BE_WIDTH-1:0] PORT_A1_WR_BE;\\ninput PORT_A1_CLK_EN;\\noutput [PORT_A1_WIDTH-1:0] PORT_A1_RD_DATA;\\n\\ninput PORT_B1_CLK;\\ninput [14:0] PORT_B1_ADDR;\\ninput [PORT_B1_WIDTH-1:0] PORT_B1_WR_DATA;\\ninput PORT_B1_WR_EN;\\ninput [PORT_B1_WR_BE_WIDTH-1:0] PORT_B1_WR_BE;\\ninput PORT_B1_CLK_EN;\\noutput [PORT_B1_WIDTH-1:0] PORT_B1_RD_DATA;\\n\\nparameter INIT2 = 0;\\n\\nparameter PORT_A2_WIDTH = 1;\\nparameter PORT_B2_WIDTH = 1;\\nparameter PORT_A2_WR_BE_WIDTH = 1;\\nparameter PORT_B2_WR_BE_WIDTH = 1;\\n\\ninput PORT_A2_CLK;\\ninput [14:0] PORT_A2_ADDR;\\ninput [PORT_A2_WIDTH-1:0] PORT_A2_WR_DATA;\\ninput PORT_A2_WR_EN;\\ninput [PORT_A2_WR_BE_WIDTH-1:0] PORT_A2_WR_BE;\\ninput PORT_A2_CLK_EN;\\noutput [PORT_A2_WIDTH-1:0] PORT_A2_RD_DATA;\\n\\ninput PORT_B2_CLK;\\ninput [14:0] PORT_B2_ADDR;\\ninput [PORT_B2_WIDTH-1:0] PORT_B2_WR_DATA;\\ninput PORT_B2_WR_EN;\\ninput [PORT_B2_WR_BE_WIDTH-1:0] PORT_B2_WR_BE;\\ninput PORT_B2_CLK_EN;\\noutput [PORT_B2_WIDTH-1:0] PORT_B2_RD_DATA;\\n\\n\\n// Fixed mode settings\\nlocalparam [ 0:0] SYNC_FIFO1_i  = 1'd0;\\nlocalparam [ 0:0] FMODE1_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN1_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP1_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT1_i    = 1'd0;\\nlocalparam [11:0] UPAE1_i       = 12'd10;\\nlocalparam [11:0] UPAF1_i       = 12'd10;\\n\\nlocalparam [ 0:0] SYNC_FIFO2_i  = 1'd0;\\nlocalparam [ 0:0] FMODE2_i      = 1'd0;\\nlocalparam [ 0:0] POWERDN2_i    = 1'd0;\\nlocalparam [ 0:0] SLEEP2_i      = 1'd0;\\nlocalparam [ 0:0] PROTECT2_i    = 1'd0;\\nlocalparam [10:0] UPAE2_i       = 11'd10;\\nlocalparam [10:0] UPAF2_i       = 11'd10;\\n\\n// Width mode function\\nfunction [2:0] mode;\\ninput integer width;\\ncase (width)\\n1: mode = 3'b101;\\n2: mode = 3'b110;\\n4: mode = 3'b100;\\n8,9: mode = 3'b001;\\n16, 18: mode = 3'b010;\\ndefault: mode = 3'b000;\\nendcase\\nendfunction\\n\\nfunction [36863:0] pack_init;\\n\\tinteger i;\\n\\treg [35:0] ri;\\n\\tfor (i = 0; i < 1024; i = i + 1) begin\\n\\t\\tri = {INIT2[i*18 +: 18], INIT1[i*18 +: 18]};\\n\\t\\tpack_init[i*36 +: 36] = {ri[35], ri[26], ri[34:27], ri[25:18], ri[17], ri[8], ri[16:9], ri[7:0]};\\n\\tend\\nendfunction\\n\\nwire REN_A1_i;\\nwire REN_A2_i;\\n\\nwire REN_B1_i;\\nwire REN_B2_i;\\n\\nwire WEN_A1_i;\\nwire WEN_A2_i;\\n\\nwire WEN_B1_i;\\nwire WEN_B2_i;\\n\\nwire [1:0] BE_A1_i;\\nwire [1:0] BE_A2_i;\\n\\nwire [1:0] BE_B1_i;\\nwire [1:0] BE_B2_i;\\n\\nwire [14:0] ADDR_A1_i;\\nwire [13:0] ADDR_A2_i;\\n\\nwire [14:0] ADDR_B1_i;\\nwire [13:0] ADDR_B2_i;\\n\\nwire [17:0] WDATA_A1_i;\\nwire [17:0] WDATA_A2_i;\\n\\nwire [17:0] WDATA_B1_i;\\nwire [17:0] WDATA_B2_i;\\n\\nwire [17:0] RDATA_A1_o;\\nwire [17:0] RDATA_A2_o;\\n\\nwire [17:0] RDATA_B1_o;\\nwire [17:0] RDATA_B2_o;\\n\\n\\n// Set port width mode (In non-split mode A2/B2 is not active. Set same values anyway to match previous behavior.)\\nlocalparam [ 2:0] RMODE_A1_i    = mode(PORT_A1_WIDTH);\\nlocalparam [ 2:0] WMODE_A1_i    = mode(PORT_A1_WIDTH);\\nlocalparam [ 2:0] RMODE_B1_i    = mode(PORT_B1_WIDTH);\\nlocalparam [ 2:0] WMODE_B1_i    = mode(PORT_B1_WIDTH);\\n\\nlocalparam [ 2:0] RMODE_A2_i    = mode(PORT_A2_WIDTH);\\nlocalparam [ 2:0] WMODE_A2_i    = mode(PORT_A2_WIDTH);\\nlocalparam [ 2:0] RMODE_B2_i    = mode(PORT_B2_WIDTH);\\nlocalparam [ 2:0] WMODE_B2_i    = mode(PORT_B2_WIDTH);\\n\\nassign REN_A1_i = PORT_A1_CLK_EN;\\nassign WEN_A1_i = PORT_A1_CLK_EN & PORT_A1_WR_EN;\\nassign BE_A1_i = PORT_A1_WR_BE;\\n\\nassign REN_B1_i = PORT_B1_CLK_EN;\\nassign WEN_B1_i = PORT_B1_CLK_EN & PORT_B1_WR_EN;\\nassign BE_B1_i = PORT_B1_WR_BE;\\n\\nassign REN_A2_i = PORT_A2_CLK_EN;\\nassign WEN_A2_i = PORT_A2_CLK_EN & PORT_A2_WR_EN;\\nassign BE_A2_i = PORT_A2_WR_BE;\\n\\nassign REN_B2_i = PORT_B2_CLK_EN;\\nassign WEN_B2_i = PORT_B2_CLK_EN & PORT_B2_WR_EN;\\nassign BE_B2_i = PORT_B2_WR_BE;\\n\\nassign ADDR_A1_i = PORT_A1_ADDR;\\nassign ADDR_B1_i = PORT_B1_ADDR;\\nassign ADDR_A2_i = PORT_A2_ADDR;\\nassign ADDR_B2_i = PORT_B2_ADDR;\\n\\ncase (PORT_A1_WIDTH)\\n9: assign { WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A1_WR_DATA;\\n18: assign { WDATA_A1_i[17], WDATA_A1_i[15:8], WDATA_A1_i[16], WDATA_A1_i[7:0] } = PORT_A1_WR_DATA;\\ndefault: assign WDATA_A1_i = PORT_A1_WR_DATA; // 1,2,4,8,16\\nendcase\\n\\ncase (PORT_B1_WIDTH)\\n9: assign { WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B1_WR_DATA;\\n18: assign { WDATA_B1_i[17], WDATA_B1_i[15:8], WDATA_B1_i[16], WDATA_B1_i[7:0] } = PORT_B1_WR_DATA;\\ndefault: assign WDATA_B1_i = PORT_B1_WR_DATA; // 1,2,4,8,16\\nendcase\\n\\ncase (PORT_A1_WIDTH)\\n9: assign PORT_A1_RD_DATA = { RDATA_A1_o[16], RDATA_A1_o[7:0] };\\n18: assign PORT_A1_RD_DATA = { RDATA_A1_o[17], RDATA_A1_o[15:8], RDATA_A1_o[16], RDATA_A1_o[7:0] };\\ndefault: assign PORT_A1_RD_DATA = RDATA_A1_o; // 1,2,4,8,16\\nendcase\\n\\ncase (PORT_B1_WIDTH)\\n9: assign PORT_B1_RD_DATA = { RDATA_B1_o[16], RDATA_B1_o[7:0] };\\n18: assign PORT_B1_RD_DATA = { RDATA_B1_o[17], RDATA_B1_o[15:8], RDATA_B1_o[16], RDATA_B1_o[7:0] };\\ndefault: assign PORT_B1_RD_DATA = RDATA_B1_o; // 1,2,4,8,16\\nendcase\\n\\ncase (PORT_A2_WIDTH)\\n9: assign { WDATA_A2_i[16], WDATA_A2_i[7:0] } = PORT_A2_WR_DATA;\\n18: assign { WDATA_A2_i[17], WDATA_A2_i[15:8], WDATA_A2_i[16], WDATA_A2_i[7:0] } = PORT_A2_WR_DATA;\\ndefault: assign WDATA_A2_i = PORT_A2_WR_DATA; // 1,2,4,8,16\\nendcase\\n\\ncase (PORT_B2_WIDTH)\\n9: assign { WDATA_B2_i[16], WDATA_B2_i[7:0] } = PORT_B2_WR_DATA;\\n18: assign { WDATA_B2_i[17], WDATA_B2_i[15:8], WDATA_B2_i[16], WDATA_B2_i[7:0] } = PORT_B2_WR_DATA;\\ndefault: assign WDATA_B2_i = PORT_B2_WR_DATA; // 1,2,4,8,16\\nendcase\\n\\ncase (PORT_A2_WIDTH)\\n9: assign PORT_A2_RD_DATA = { RDATA_A2_o[16], RDATA_A2_o[7:0] };\\n18: assign PORT_A2_RD_DATA = { RDATA_A2_o[17], RDATA_A2_o[15:8], RDATA_A2_o[16], RDATA_A2_o[7:0] };\\ndefault: assign PORT_A2_RD_DATA = RDATA_A2_o; // 1,2,4,8,16\\nendcase\\n\\ncase (PORT_B2_WIDTH)\\n9: assign PORT_B2_RD_DATA = { RDATA_B2_o[16], RDATA_B2_o[7:0] };\\n18: assign PORT_B2_RD_DATA = { RDATA_B2_o[17], RDATA_B2_o[15:8], RDATA_B2_o[16], RDATA_B2_o[7:0] };\\ndefault: assign PORT_B2_RD_DATA = RDATA_B2_o; // 1,2,4,8,16\\nendcase\\n\\ndefparam _TECHMAP_REPLACE_.MODE_BITS = {1'b1,\\n\\t\\t\\tUPAF2_i, UPAE2_i, PROTECT2_i, SLEEP2_i, POWERDN2_i, FMODE2_i, WMODE_B2_i, WMODE_A2_i, RMODE_B2_i, RMODE_A2_i, SYNC_FIFO2_i,\\n\\t\\t\\tUPAF1_i, UPAE1_i, PROTECT1_i, SLEEP1_i, POWERDN1_i, FMODE1_i, WMODE_B1_i, WMODE_A1_i, RMODE_B1_i, RMODE_A1_i, SYNC_FIFO1_i\\n\\t\\t};\\n\\n(* is_inferred = 1 *)\\n(* is_split = 1 *)\\n(* port_a1_width = PORT_A1_WIDTH *)\\n(* port_a2_width = PORT_A2_WIDTH *)\\n(* port_b1_width = PORT_B1_WIDTH *)\\n(* port_b2_width = PORT_B2_WIDTH *)\\nTDP36K #(\\n\\t.RAM_INIT(pack_init()),\\n) _TECHMAP_REPLACE_ (\\n\\t.RESET_ni(1'b1),\\n\\t.WDATA_A1_i(WDATA_A1_i),\\n\\t.WDATA_A2_i(WDATA_A2_i),\\n\\t.RDATA_A1_o(RDATA_A1_o),\\n\\t.RDATA_A2_o(RDATA_A2_o),\\n\\t.ADDR_A1_i(ADDR_A1_i),\\n\\t.ADDR_A2_i(ADDR_A2_i),\\n\\t.CLK_A1_i(PORT_A1_CLK),\\n\\t.CLK_A2_i(PORT_A2_CLK),\\n\\t.REN_A1_i(REN_A1_i),\\n\\t.REN_A2_i(REN_A2_i),\\n\\t.WEN_A1_i(WEN_A1_i),\\n\\t.WEN_A2_i(WEN_A2_i),\\n\\t.BE_A1_i(BE_A1_i),\\n\\t.BE_A2_i(BE_A2_i),\\n\\n\\t.WDATA_B1_i(WDATA_B1_i),\\n\\t.WDATA_B2_i(WDATA_B2_i),\\n\\t.RDATA_B1_o(RDATA_B1_o),\\n\\t.RDATA_B2_o(RDATA_B2_o),\\n\\t.ADDR_B1_i(ADDR_B1_i),\\n\\t.ADDR_B2_i(ADDR_B2_i),\\n\\t.CLK_B1_i(PORT_B1_CLK),\\n\\t.CLK_B2_i(PORT_B2_CLK),\\n\\t.REN_B1_i(REN_B1_i),\\n\\t.REN_B2_i(REN_B2_i),\\n\\t.WEN_B1_i(WEN_B1_i),\\n\\t.WEN_B2_i(WEN_B2_i),\\n\\t.BE_B1_i(BE_B1_i),\\n\\t.BE_B2_i(BE_B2_i),\\n\\n\\t.FLUSH1_i(1'b0),\\n\\t.FLUSH2_i(1'b0)\\n);\\n\\nendmodule\",\n                \"sram1024x18_mem.v\": \"`default_nettype none\\nmodule sram1024x18 (\\n\\tclk_a,\\n\\tcen_a,\\n\\twen_a,\\n\\taddr_a,\\n\\twmsk_a,\\n\\twdata_a,\\n\\trdata_a,\\n\\tclk_b,\\n\\tcen_b,\\n\\twen_b,\\n\\taddr_b,\\n\\twmsk_b,\\n\\twdata_b,\\n\\trdata_b\\n);\\n\\tparameter [1024*18-1:0] init = 18431'bx;\\n\\t(* clkbuf_sink *)\\n\\tinput wire clk_a;\\n\\tinput wire cen_a;\\n\\tinput wire wen_a;\\n\\tinput wire [9:0] addr_a;\\n\\tinput wire [17:0] wmsk_a;\\n\\tinput wire [17:0] wdata_a;\\n\\toutput reg [17:0] rdata_a;\\n\\t(* clkbuf_sink *)\\n\\tinput wire clk_b;\\n\\tinput wire cen_b;\\n\\tinput wire wen_b;\\n\\tinput wire [9:0] addr_b;\\n\\tinput wire [17:0] wmsk_b;\\n\\tinput wire [17:0] wdata_b;\\n\\toutput reg [17:0] rdata_b;\\n\\treg [17:0] ram [1023:0];\\n\\tinteger i;\\n\\tinitial begin\\n\\t\\tfor (i = 0; i < 1024; i = i + 1) begin\\n\\t\\t\\tram[i] = init[18*i +: 18];\\n\\t\\tend\\n\\tend\\n\\n\\talways @(posedge clk_a) begin\\n\\t\\tif (!cen_a) begin\\n\\t \\t\\tif (!wen_a)\\n\\t\\t\\t\\tfor (i = 0; i < 18; i++) begin\\n\\t\\t\\t\\t\\tif (!wmsk_a[i]) ram[addr_a][i] <= wdata_a[i];\\n\\t\\t\\t\\tend\\n\\t\\t\\trdata_a <= ram[addr_a];\\n\\t\\tend\\n\\tend\\n\\n\\talways @(posedge clk_b) begin\\n\\t\\tif (!cen_b) begin\\n\\t \\t\\tif (!wen_b)\\n\\t\\t\\t\\tfor (i = 0; i < 18; i++) begin\\n\\t\\t\\t\\t\\tif (!wmsk_b[i]) ram[addr_b][i] <= wdata_b[i];\\n\\t\\t\\t\\tend\\n\\t\\t\\trdata_b <= ram[addr_b];\\n\\t\\tend\\n\\tend\\n\\nendmodule\\n\\n\",\n                \"ufifo_ctl.v\": \"// Copyright 2020-2022 F4PGA Authors\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\n`default_nettype wire\\nmodule fifo_ctl (\\n\\traddr,\\n\\twaddr,\\n\\tfflags,\\n\\tren_o,\\n\\tsync,\\n\\trmode,\\n\\twmode,\\n\\trclk,\\n\\trst_R_n,\\n\\twclk,\\n\\trst_W_n,\\n\\tren,\\n\\twen,\\n\\tupaf,\\n\\tupae\\n);\\n\\tparameter ADDR_WIDTH = 11;\\n\\tparameter FIFO_WIDTH = 3'd2;\\n\\tparameter DEPTH = 6;\\n\\toutput wire [ADDR_WIDTH - 1:0] raddr;\\n\\toutput wire [ADDR_WIDTH - 1:0] waddr;\\n\\toutput wire [7:0] fflags;\\n\\toutput wire ren_o;\\n\\tinput wire sync;\\n\\tinput wire [1:0] rmode;\\n\\tinput wire [1:0] wmode;\\n\\t(* clkbuf_sink *)\\n\\tinput wire rclk;\\n\\tinput wire rst_R_n;\\n\\t(* clkbuf_sink *)\\n\\tinput wire wclk;\\n\\tinput wire rst_W_n;\\n\\tinput wire ren;\\n\\tinput wire wen;\\n\\tinput wire [ADDR_WIDTH - 1:0] upaf;\\n\\tinput wire [ADDR_WIDTH - 1:0] upae;\\n\\tlocalparam ADDR_PLUS_ONE = ADDR_WIDTH + 1;\\n\\treg [ADDR_WIDTH:0] pushtopop1;\\n\\treg [ADDR_WIDTH:0] pushtopop2;\\n\\treg [ADDR_WIDTH:0] poptopush1;\\n\\treg [ADDR_WIDTH:0] poptopush2;\\n\\twire [ADDR_WIDTH:0] pushtopop0;\\n\\twire [ADDR_WIDTH:0] poptopush0;\\n\\twire [ADDR_WIDTH:0] smux_poptopush;\\n\\twire [ADDR_WIDTH:0] smux_pushtopop;\\n\\tassign smux_poptopush = (sync ? poptopush0 : poptopush2);\\n\\tassign smux_pushtopop = (sync ? pushtopop0 : pushtopop2);\\n\\talways @(posedge rclk or negedge rst_R_n)\\n\\t\\tif (~rst_R_n) begin\\n\\t\\t\\tpushtopop1 <= 'h0;\\n\\t\\t\\tpushtopop2 <= 'h0;\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\tpushtopop1 = pushtopop0;\\n\\t\\t\\tpushtopop2 = pushtopop1;\\n\\t\\tend\\n\\talways @(posedge wclk or negedge rst_W_n)\\n\\t\\tif (~rst_W_n) begin\\n\\t\\t\\tpoptopush1 <= 'h0;\\n\\t\\t\\tpoptopush2 <= 'h0;\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\tpoptopush1 <= poptopush0;\\n\\t\\t\\tpoptopush2 <= poptopush1;\\n\\t\\tend\\n\\tfifo_push #(\\n\\t\\t.ADDR_WIDTH(ADDR_WIDTH),\\n\\t\\t.DEPTH(DEPTH)\\n\\t) u_fifo_push(\\n\\t\\t.wclk(wclk),\\n\\t\\t.wen(wen),\\n\\t\\t.rst_n(rst_W_n),\\n\\t\\t.rmode(rmode),\\n\\t\\t.wmode(wmode),\\n\\t\\t.gcout(pushtopop0),\\n\\t\\t.gcin(smux_poptopush),\\n\\t\\t.ff_waddr(waddr),\\n\\t\\t.pushflags(fflags[7:4]),\\n\\t\\t.upaf(upaf)\\n\\t);\\n\\tfifo_pop #(\\n\\t\\t.ADDR_WIDTH(ADDR_WIDTH),\\n\\t\\t.FIFO_WIDTH(FIFO_WIDTH),\\n\\t\\t.DEPTH(DEPTH)\\n\\t) u_fifo_pop(\\n\\t\\t.rclk(rclk),\\n\\t\\t.ren_in(ren),\\n\\t\\t.rst_n(rst_R_n),\\n\\t\\t.rmode(rmode),\\n\\t\\t.wmode(wmode),\\n\\t\\t.ren_o(ren_o),\\n\\t\\t.gcout(poptopush0),\\n\\t\\t.gcin(smux_pushtopop),\\n\\t\\t.out_raddr(raddr),\\n\\t\\t.popflags(fflags[3:0]),\\n\\t\\t.upae(upae)\\n\\t);\\nendmodule\\nmodule fifo_push (\\n\\tpushflags,\\n\\tgcout,\\n\\tff_waddr,\\n\\trst_n,\\n\\twclk,\\n\\twen,\\n\\trmode,\\n\\twmode,\\n\\tgcin,\\n\\tupaf\\n);\\n\\tparameter ADDR_WIDTH = 11;\\n\\tparameter DEPTH = 6;\\n\\toutput wire [3:0] pushflags;\\n\\toutput wire [ADDR_WIDTH:0] gcout;\\n\\toutput wire [ADDR_WIDTH - 1:0] ff_waddr;\\n\\tinput rst_n;\\n\\t(* clkbuf_sink *)\\n\\tinput wclk;\\n\\tinput wen;\\n\\tinput [1:0] rmode;\\n\\tinput [1:0] wmode;\\n\\tinput [ADDR_WIDTH:0] gcin;\\n\\tinput [ADDR_WIDTH - 1:0] upaf;\\n\\tlocalparam ADDR_PLUS_ONE = ADDR_WIDTH + 1;\\n\\treg full_next;\\n\\treg full;\\n\\treg paf_next;\\n\\treg paf;\\n\\treg fmo;\\n\\treg fmo_next;\\n\\treg overflow;\\n\\treg p1;\\n\\treg p2;\\n\\treg f1;\\n\\treg f2;\\n\\treg q1;\\n\\treg q2;\\n\\treg [1:0] gmode;\\n\\treg [ADDR_WIDTH:0] waddr;\\n\\treg [ADDR_WIDTH:0] raddr;\\n\\treg [ADDR_WIDTH:0] gcout_reg;\\n\\treg [ADDR_WIDTH:0] gcout_next;\\n\\treg [ADDR_WIDTH:0] raddr_next;\\n\\treg [ADDR_WIDTH - 1:0] paf_thresh;\\n\\twire overflow_next;\\n\\twire [ADDR_WIDTH:0] waddr_next;\\n\\twire [ADDR_WIDTH:0] gc8out_next;\\n\\twire [ADDR_WIDTH - 1:0] gc16out_next;\\n\\twire [ADDR_WIDTH - 2:0] gc32out_next;\\n\\twire [ADDR_WIDTH:0] tmp;\\n\\twire [ADDR_WIDTH:0] next_count;\\n\\twire [ADDR_WIDTH:0] count;\\n\\twire [ADDR_WIDTH:0] fbytes;\\n\\tgenvar i;\\n\\tassign next_count = fbytes - (waddr_next >= raddr_next ? waddr_next - raddr_next : (~raddr_next + waddr_next) + 1);\\n\\tassign count = fbytes - (waddr >= raddr ? waddr - raddr : (~raddr + waddr) + 1);\\n\\tassign fbytes = 1 << (DEPTH + 5);\\n\\talways @(*) begin\\n\\t\\tpaf_thresh = wmode[1] ? upaf : (wmode[0] ? upaf << 1 : upaf << 2);\\n\\tend\\n\\talways @(*)\\n\\t\\tcase (wmode)\\n\\t\\t\\t2'h0, 2'h1, 2'h2: begin\\n\\t\\t\\t\\tfull_next = (wen ? f1 : f2);\\n\\t\\t\\t\\tfmo_next = (wen ? p1 : p2);\\n\\t\\t\\t\\tpaf_next = (wen ? q1 : q2);\\n\\t\\t\\tend\\n\\t\\t\\tdefault: begin\\n\\t\\t\\t\\tfull_next = 1'b0;\\n\\t\\t\\t\\tfmo_next = 1'b0;\\n\\t\\t\\t\\tpaf_next = 1'b0;\\n\\t\\t\\tend\\n\\t\\tendcase\\n\\talways @(*) begin : PUSH_FULL_FLAGS\\n\\t\\tf1 = 1'b0;\\n\\t\\tf2 = 1'b0;\\n\\t\\tp1 = 1'b0;\\n\\t\\tp2 = 1'b0;\\n\\t\\tq1 = next_count < {1'b0, paf_thresh};\\n\\t\\tq2 = count < {1'b0, paf_thresh};\\n\\t\\tcase (wmode)\\n\\t\\t\\t2'h0:\\n\\t\\t\\t\\tcase (DEPTH)\\n\\t\\t\\t\\t\\t3'h6: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[11], waddr_next[10:2]} == raddr_next[11:2];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[11], waddr[10:2]} == raddr_next[11:2];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[10:2] + 1) & 9'h1ff) == raddr_next[10:2];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[10:2] + 1) & 9'h1ff) == raddr_next[10:2];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h5: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[10], waddr_next[9:2]} == raddr_next[10:2];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[10], waddr[9:2]} == raddr_next[10:2];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[9:2] + 1) & 8'hff) == raddr_next[9:2];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[9:2] + 1) & 8'hff) == raddr_next[9:2];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h4: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[9], waddr_next[8:2]} == raddr_next[9:2];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[9], waddr[8:2]} == raddr_next[9:2];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[8:2] + 1) & 7'h7f) == raddr_next[8:2];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[8:2] + 1) & 7'h7f) == raddr_next[8:2];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h3: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[8], waddr_next[7:2]} == raddr_next[8:2];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[8], waddr[7:2]} == raddr_next[8:2];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[7:2] + 1) & 6'h3f) == raddr_next[7:2];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[7:2] + 1) & 6'h3f) == raddr_next[7:2];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h2: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[7], waddr_next[6:2]} == raddr_next[7:2];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[7], waddr[6:2]} == raddr_next[7:2];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[6:2] + 1) & 5'h1f) == raddr_next[6:2];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[6:2] + 1) & 5'h1f) == raddr_next[6:2];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h1: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[6], waddr_next[5:2]} == raddr_next[6:2];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[6], waddr[5:2]} == raddr_next[6:2];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[5:2] + 1) & 4'hf) == raddr_next[5:2];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[5:2] + 1) & 4'hf) == raddr_next[5:2];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h0: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[5], waddr_next[4:2]} == raddr_next[5:2];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[5], waddr[4:2]} == raddr_next[5:2];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[4:2] + 1) & 3'h7) == raddr_next[4:2];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[4:2] + 1) & 3'h7) == raddr_next[4:2];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h7: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[ADDR_WIDTH], waddr_next[ADDR_WIDTH - 1:2]} == raddr_next[ADDR_WIDTH:2];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[ADDR_WIDTH], waddr[ADDR_WIDTH - 1:2]} == raddr_next[ADDR_WIDTH:2];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[ADDR_WIDTH - 1:2] + 1) & {ADDR_WIDTH - 2 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:2];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[ADDR_WIDTH - 1:2] + 1) & {ADDR_WIDTH - 2 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:2];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tendcase\\n\\t\\t\\t2'h1:\\n\\t\\t\\t\\tcase (DEPTH)\\n\\t\\t\\t\\t\\t3'h6: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[11], waddr_next[10:1]} == raddr_next[11:1];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[11], waddr[10:1]} == raddr_next[11:1];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[10:1] + 1) & 10'h3ff) == raddr_next[10:1];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[10:1] + 1) & 10'h3ff) == raddr_next[10:1];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h5: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[10], waddr_next[9:1]} == raddr_next[10:1];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[10], waddr[9:1]} == raddr_next[10:1];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[9:1] + 1) & 9'h1ff) == raddr_next[9:1];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[9:1] + 1) & 9'h1ff) == raddr_next[9:1];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h4: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[9], waddr_next[8:1]} == raddr_next[9:1];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[9], waddr[8:1]} == raddr_next[9:1];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[8:1] + 1) & 8'hff) == raddr_next[8:1];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[8:1] + 1) & 8'hff) == raddr_next[8:1];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h3: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[8], waddr_next[7:1]} == raddr_next[8:1];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[8], waddr[7:1]} == raddr_next[8:1];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[7:1] + 1) & 7'h7f) == raddr_next[7:1];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[7:1] + 1) & 7'h7f) == raddr_next[7:1];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h2: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[7], waddr_next[6:1]} == raddr_next[7:1];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[7], waddr[6:1]} == raddr_next[7:1];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[6:1] + 1) & 6'h3f) == raddr_next[6:1];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[6:1] + 1) & 6'h3f) == raddr_next[6:1];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h1: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[6], waddr_next[5:1]} == raddr_next[6:1];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[6], waddr[5:1]} == raddr_next[6:1];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[5:1] + 1) & 5'h1f) == raddr_next[5:1];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[5:1] + 1) & 5'h1f) == raddr_next[5:1];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h0: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[5], waddr_next[4:1]} == raddr_next[5:1];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[5], waddr[4:1]} == raddr_next[5:1];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[4:1] + 1) & 4'hf) == raddr_next[4:1];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[4:1] + 1) & 4'hf) == raddr_next[4:1];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h7: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[ADDR_WIDTH], waddr_next[ADDR_WIDTH - 1:1]} == raddr_next[ADDR_WIDTH:1];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[ADDR_WIDTH], waddr[ADDR_WIDTH - 1:1]} == raddr_next[ADDR_WIDTH:1];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[ADDR_WIDTH - 1:1] + 1) & {ADDR_WIDTH - 1 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:1];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[ADDR_WIDTH - 1:1] + 1) & {ADDR_WIDTH - 1 {1'b1}}) == raddr_next[ADDR_WIDTH - 1:1];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tendcase\\n\\t\\t\\t2'h2:\\n\\t\\t\\t\\tcase (DEPTH)\\n\\t\\t\\t\\t\\t3'h6: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[11], waddr_next[10:0]} == raddr_next[11:0];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[11], waddr[10:0]} == raddr_next[11:0];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[10:0] + 1) & 11'h7ff) == raddr_next[10:0];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[10:0] + 1) & 11'h7ff) == raddr_next[10:0];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h5: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[10], waddr_next[9:0]} == raddr_next[10:0];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[10], waddr[9:0]} == raddr_next[10:0];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[9:0] + 1) & 10'h3ff) == raddr_next[9:0];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[9:0] + 1) & 10'h3ff) == raddr_next[9:0];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h4: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[9], waddr_next[8:0]} == raddr_next[9:0];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[9], waddr[8:0]} == raddr_next[9:0];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[8:0] + 1) & 9'h1ff) == raddr_next[8:0];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[8:0] + 1) & 9'h1ff) == raddr_next[8:0];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h3: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[8], waddr_next[7:0]} == raddr_next[8:0];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[8], waddr[7:0]} == raddr_next[8:0];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[7:0] + 1) & 8'hff) == raddr_next[7:0];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[7:0] + 1) & 8'hff) == raddr_next[7:0];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h2: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[7], waddr_next[6:0]} == raddr_next[7:0];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[7], waddr[6:0]} == raddr_next[7:0];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[6:0] + 1) & 7'h7f) == raddr_next[6:0];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[6:0] + 1) & 7'h7f) == raddr_next[6:0];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h1: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[6], waddr_next[5:0]} == raddr_next[6:0];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[6], waddr[5:0]} == raddr_next[6:0];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[5:0] + 1) & 6'h3f) == raddr_next[5:0];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[5:0] + 1) & 6'h3f) == raddr_next[5:0];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h0: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[5], waddr_next[4:0]} == raddr_next[5:0];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[5], waddr[4:0]} == raddr_next[5:0];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[4:0] + 1) & 5'h1f) == raddr_next[4:0];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[4:0] + 1) & 5'h1f) == raddr_next[4:0];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\t\\t3'h7: begin\\n\\t\\t\\t\\t\\t\\tf1 = {~waddr_next[ADDR_WIDTH], waddr_next[ADDR_WIDTH - 1:0]} == raddr_next[ADDR_WIDTH:0];\\n\\t\\t\\t\\t\\t\\tf2 = {~waddr[ADDR_WIDTH], waddr[ADDR_WIDTH - 1:0]} == raddr_next[ADDR_WIDTH:0];\\n\\t\\t\\t\\t\\t\\tp1 = ((waddr_next[ADDR_WIDTH - 1:0] + 1) & {ADDR_WIDTH {1'b1}}) == raddr_next[ADDR_WIDTH - 1:0];\\n\\t\\t\\t\\t\\t\\tp2 = ((waddr[ADDR_WIDTH - 1:0] + 1) & {ADDR_WIDTH {1'b1}}) == raddr_next[ADDR_WIDTH - 1:0];\\n\\t\\t\\t\\t\\tend\\n\\t\\t\\t\\tendcase\\n\\t\\t\\t2'h3: begin\\n\\t\\t\\t\\tf1 = 1'b0;\\n\\t\\t\\t\\tf2 = 1'b0;\\n\\t\\t\\t\\tp1 = 1'b0;\\n\\t\\t\\t\\tp2 = 1'b0;\\n\\t\\t\\tend\\n\\t\\tendcase\\n\\tend\\n\\talways @(*)\\n\\t\\tcase (wmode)\\n\\t\\t\\t2'h0: gmode = 2'h0;\\n\\t\\t\\t2'h1: gmode = (rmode == 2'h0 ? 2'h0 : 2'h1);\\n\\t\\t\\t2'h2: gmode = (rmode == 2'h2 ? 2'h2 : rmode);\\n\\t\\t\\t2'h3: gmode = 2'h3;\\n\\t\\tendcase\\n\\tassign gc8out_next = (waddr_next >> 1) ^ waddr_next;\\n\\tassign gc16out_next = (waddr_next >> 2) ^ (waddr_next >> 1);\\n\\tassign gc32out_next = (waddr_next >> 3) ^ (waddr_next >> 2);\\n\\talways @(*)\\n\\t\\tif (wen)\\n\\t\\t\\tcase (gmode)\\n\\t\\t\\t\\t2'h2: gcout_next = gc8out_next;\\n\\t\\t\\t\\t2'h1: gcout_next = {1'b0, gc16out_next};\\n\\t\\t\\t\\t2'h0: gcout_next = {2'b00, gc32out_next};\\n\\t\\t\\t\\tdefault: gcout_next = {ADDR_PLUS_ONE {1'b0}};\\n\\t\\t\\tendcase\\n\\t\\telse\\n\\t\\t\\tgcout_next = {ADDR_PLUS_ONE {1'b0}};\\n\\talways @(posedge wclk or negedge rst_n)\\n\\t\\tif (~rst_n) begin\\n\\t\\t\\tfull <= 1'b0;\\n\\t\\t\\tfmo <= 1'b0;\\n\\t\\t\\tpaf <= 1'b0;\\n\\t\\t\\traddr <= {ADDR_PLUS_ONE {1'b0}};\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\tfull <= full_next;\\n\\t\\t\\tfmo <= fmo_next;\\n\\t\\t\\tpaf <= paf_next;\\n\\t\\t\\tcase (gmode)\\n\\t\\t\\t\\t0: raddr <= raddr_next & {{ADDR_WIDTH - 1 {1'b1}}, 2'b00};\\n\\t\\t\\t\\t1: raddr <= raddr_next & {{ADDR_WIDTH {1'b1}}, 1'b0};\\n\\t\\t\\t\\t2: raddr <= raddr_next & {ADDR_WIDTH + 1 {1'b1}};\\n\\t\\t\\t\\t3: raddr <= 12'h000;\\n\\t\\t\\tendcase\\n\\t\\tend\\n\\tassign overflow_next = full & wen;\\n\\talways @(posedge wclk or negedge rst_n)\\n\\t\\tif (~rst_n)\\n\\t\\t\\toverflow <= 1'b0;\\n\\t\\telse if (wen == 1'b1)\\n\\t\\t\\toverflow <= overflow_next;\\n\\talways @(posedge wclk or negedge rst_n)\\n\\t\\tif (~rst_n) begin\\n\\t\\t\\twaddr <= {ADDR_WIDTH + 1 {1'b0}};\\n\\t\\t\\tgcout_reg <= {ADDR_WIDTH + 1 {1'b0}};\\n\\t\\tend\\n\\t\\telse if (wen == 1'b1) begin\\n\\t\\t\\twaddr <= waddr_next;\\n\\t\\t\\tgcout_reg <= gcout_next;\\n\\t\\tend\\n\\tassign gcout = gcout_reg;\\n\\tgenerate\\n\\t\\tfor (i = 0; i < (ADDR_WIDTH + 1); i = i + 1) begin : genblk1\\n\\t\\t\\tassign tmp[i] = ^(gcin >> i);\\n\\t\\tend\\n\\tendgenerate\\n\\talways @(*)\\n\\t\\tcase (gmode)\\n\\t\\t\\t2'h0: raddr_next = {tmp[ADDR_WIDTH - 2:0], 2'b00} & {{ADDR_WIDTH - 1 {1'b1}}, 2'b00};\\n\\t\\t\\t2'h1: raddr_next = {tmp[ADDR_WIDTH - 1:0], 1'b0} & {{ADDR_WIDTH {1'b1}}, 1'b0};\\n\\t\\t\\t2'h2: raddr_next = {tmp[ADDR_WIDTH:0]} & {ADDR_WIDTH + 1 {1'b1}};\\n\\t\\t\\tdefault: raddr_next = {ADDR_WIDTH + 1 {1'b0}};\\n\\t\\tendcase\\n\\tassign ff_waddr = waddr[ADDR_WIDTH - 1:0];\\n\\tassign pushflags = {full, fmo, paf, overflow};\\n\\tassign waddr_next = waddr + (wmode == 2'h0 ? 'h4 : (wmode == 2'h1 ? 'h2 : 'h1));\\nendmodule\\nmodule fifo_pop (\\n\\tren_o,\\n\\tpopflags,\\n\\tout_raddr,\\n\\tgcout,\\n\\trst_n,\\n\\trclk,\\n\\tren_in,\\n\\trmode,\\n\\twmode,\\n\\tgcin,\\n\\tupae\\n);\\n\\tparameter ADDR_WIDTH = 11;\\n\\tparameter FIFO_WIDTH = 3'd2;\\n\\tparameter DEPTH = 6;\\n\\toutput wire ren_o;\\n\\toutput wire [3:0] popflags;\\n\\toutput reg [ADDR_WIDTH - 1:0] out_raddr;\\n\\toutput wire [ADDR_WIDTH:0] gcout;\\n\\tinput rst_n;\\n\\t(* clkbuf_sink *)\\n\\tinput rclk;\\n\\tinput ren_in;\\n\\tinput [1:0] rmode;\\n\\tinput [1:0] wmode;\\n\\tinput [ADDR_WIDTH:0] gcin;\\n\\tinput [ADDR_WIDTH - 1:0] upae;\\n\\tlocalparam ADDR_PLUS_ONE = ADDR_WIDTH + 1;\\n\\treg empty;\\n\\treg epo;\\n\\treg pae;\\n\\treg underflow;\\n\\treg e1;\\n\\treg e2;\\n\\treg o1;\\n\\treg o2;\\n\\treg q1;\\n\\treg q2;\\n\\treg [1:0] bwl_sel;\\n\\treg [1:0] gmode;\\n\\treg [ADDR_WIDTH - 1:0] ff_raddr;\\n\\treg [ADDR_WIDTH:0] waddr;\\n\\treg [ADDR_WIDTH:0] raddr;\\n\\treg [ADDR_WIDTH:0] gcout_reg;\\n\\treg [ADDR_WIDTH:0] gcout_next;\\n\\treg [ADDR_WIDTH:0] waddr_next;\\n\\treg [ADDR_WIDTH - 1:0] pae_thresh;\\n\\twire ren_out;\\n\\twire empty_next;\\n\\twire pae_next;\\n\\twire epo_next;\\n\\twire [ADDR_WIDTH - 2:0] gc32out_next;\\n\\twire [ADDR_WIDTH - 1:0] gc16out_next;\\n\\twire [ADDR_WIDTH:0] gc8out_next;\\n\\twire [ADDR_WIDTH:0] raddr_next;\\n\\twire [ADDR_WIDTH - 1:0] ff_raddr_next;\\n\\twire [ADDR_WIDTH:0] tmp;\\n\\twire [ADDR_PLUS_ONE:0] next_count;\\n\\twire [ADDR_PLUS_ONE:0] count;\\n\\twire [ADDR_PLUS_ONE:0] fbytes;\\n\\tgenvar i;\\n\\tassign next_count = waddr - raddr_next;\\n\\tassign count = waddr - raddr;\\n\\tassign fbytes = 1 << (DEPTH + 5);\\n\\talways @(*) pae_thresh = rmode[1] ? upae : (rmode[0] ? upae << 1 : upae << 2);\\n\\tassign ren_out = (empty ? 1'b1 : ren_in);\\n\\talways @(*)\\n\\t\\tcase (rmode)\\n\\t\\t\\t2'h0: gmode = 2'h0;\\n\\t\\t\\t2'h1: gmode = (wmode == 2'h0 ? 2'h0 : 2'h1);\\n\\t\\t\\t2'h2: gmode = (wmode == 2'h2 ? 2'h2 : wmode);\\n\\t\\t\\t2'h3: gmode = 2'h3;\\n\\t\\tendcase\\n\\talways @(*) begin\\n\\t\\te1 = 1'b0;\\n\\t\\te2 = 1'b0;\\n\\t\\to1 = 1'b0;\\n\\t\\to2 = 1'b0;\\n\\t\\tq1 = next_count < {1'b0, pae_thresh};\\n\\t\\tq2 = count < {1'b0, pae_thresh};\\n\\t\\tcase (rmode)\\n\\t\\t\\t2'h0: begin\\n\\t\\t\\t\\te1 = raddr_next[ADDR_WIDTH:2] == waddr_next[ADDR_WIDTH:2];\\n\\t\\t\\t\\te2 = raddr[ADDR_WIDTH:2] == waddr_next[ADDR_WIDTH:2];\\n\\t\\t\\t\\to1 = (raddr_next[ADDR_WIDTH:2] + 1) == waddr_next[ADDR_WIDTH:2];\\n\\t\\t\\t\\to2 = (raddr[ADDR_WIDTH:2] + 1) == waddr_next[ADDR_WIDTH:2];\\n\\t\\t\\tend\\n\\t\\t\\t2'h1: begin\\n\\t\\t\\t\\te1 = raddr_next[ADDR_WIDTH:1] == waddr_next[ADDR_WIDTH:1];\\n\\t\\t\\t\\te2 = raddr[ADDR_WIDTH:1] == waddr_next[ADDR_WIDTH:1];\\n\\t\\t\\t\\to1 = (raddr_next[ADDR_WIDTH:1] + 1) == waddr_next[ADDR_WIDTH:1];\\n\\t\\t\\t\\to2 = (raddr[ADDR_WIDTH:1] + 1) == waddr_next[ADDR_WIDTH:1];\\n\\t\\t\\tend\\n\\t\\t\\t2'h2: begin\\n\\t\\t\\t\\te1 = raddr_next[ADDR_WIDTH:0] == waddr_next[ADDR_WIDTH:0];\\n\\t\\t\\t\\te2 = raddr[ADDR_WIDTH:0] == waddr_next[ADDR_WIDTH:0];\\n\\t\\t\\t\\to1 = (raddr_next[ADDR_WIDTH:0] + 1) == waddr_next[ADDR_WIDTH:0];\\n\\t\\t\\t\\to2 = (raddr[ADDR_WIDTH:0] + 1) == waddr_next[11:0];\\n\\t\\t\\tend\\n\\t\\t\\t2'h3: begin\\n\\t\\t\\t\\te1 = 1'b0;\\n\\t\\t\\t\\te2 = 1'b0;\\n\\t\\t\\t\\to1 = 1'b0;\\n\\t\\t\\t\\to2 = 1'b0;\\n\\t\\t\\tend\\n\\t\\tendcase\\n\\tend\\n\\tassign empty_next = (ren_in & !empty ? e1 : e2);\\n\\tassign epo_next = (ren_in & !empty ? o1 : o2);\\n\\tassign pae_next = (ren_in & !empty ? q1 : q2);\\n\\talways @(posedge rclk or negedge rst_n)\\n\\t\\tif (~rst_n) begin\\n\\t\\t\\tempty <= 1'b1;\\n\\t\\t\\tpae <= 1'b1;\\n\\t\\t\\tepo <= 1'b0;\\n\\t\\tend\\n\\t\\telse begin\\n\\t\\t\\tempty <= empty_next;\\n\\t\\t\\tpae <= pae_next;\\n\\t\\t\\tepo <= epo_next;\\n\\t\\tend\\n\\tassign gc8out_next = (raddr_next >> 1) ^ raddr_next;\\n\\tassign gc16out_next = (raddr_next >> 2) ^ (raddr_next >> 1);\\n\\tassign gc32out_next = (raddr_next >> 3) ^ (raddr_next >> 2);\\n\\talways @(*)\\n\\t\\tif (ren_in)\\n\\t\\t\\tcase (gmode)\\n\\t\\t\\t\\t2'h2: gcout_next = gc8out_next;\\n\\t\\t\\t\\t2'h1: gcout_next = {1'b0, gc16out_next};\\n\\t\\t\\t\\t2'h0: gcout_next = {2'b00, gc32out_next};\\n\\t\\t\\t\\tdefault: gcout_next = 'h0;\\n\\t\\t\\tendcase\\n\\t\\telse\\n\\t\\t\\tgcout_next = 'h0;\\n\\talways @(posedge rclk or negedge rst_n)\\n\\t\\tif (~rst_n)\\n\\t\\t\\twaddr <= 12'h000;\\n\\t\\telse\\n\\t\\t\\twaddr <= waddr_next;\\n\\talways @(posedge rclk or negedge rst_n)\\n\\t\\tif (~rst_n) begin\\n\\t\\t\\tunderflow <= 1'b0;\\n\\t\\t\\tbwl_sel <= 2'h0;\\n\\t\\t\\tgcout_reg <= 12'h000;\\n\\t\\tend\\n\\t\\telse if (ren_in) begin\\n\\t\\t\\tunderflow <= empty;\\n\\t\\t\\tif (!empty) begin\\n\\t\\t\\t\\tbwl_sel <= raddr_next[1:0];\\n\\t\\t\\t\\tgcout_reg <= gcout_next;\\n\\t\\t\\tend\\n\\t\\tend\\n\\tgenerate\\n\\t\\tfor (i = 0; i < (ADDR_WIDTH + 1); i = i + 1) begin : genblk1\\n\\t\\t\\tassign tmp[i] = ^(gcin >> i);\\n\\t\\tend\\n\\tendgenerate\\n\\talways @(*)\\n\\t\\tcase (gmode)\\n\\t\\t\\t2'h0: waddr_next = {tmp[ADDR_WIDTH - 2:0], 2'b00} & {{ADDR_WIDTH - 1 {1'b1}}, 2'b00};\\n\\t\\t\\t2'h1: waddr_next = {tmp[ADDR_WIDTH - 1:0], 1'b0} & {{ADDR_WIDTH {1'b1}}, 1'b0};\\n\\t\\t\\t2'h2: waddr_next = {tmp[ADDR_WIDTH:0]} & {ADDR_PLUS_ONE {1'b1}};\\n\\t\\t\\tdefault: waddr_next = {ADDR_PLUS_ONE {1'b0}};\\n\\t\\tendcase\\n\\tassign ff_raddr_next = ff_raddr + (rmode == 2'h0 ? 'h4 : (rmode == 2'h1 ? 'h2 : 'h1));\\n\\tassign raddr_next = raddr + (rmode == 2'h0 ? 'h4 : (rmode == 2'h1 ? 'h2 : 'h1));\\n\\talways @(posedge rclk or negedge rst_n)\\n\\t\\tif (~rst_n)\\n\\t\\t\\tff_raddr <= 1'sb0;\\n\\t\\telse if (empty & ~empty_next)\\n\\t\\t\\tff_raddr <= raddr_next[ADDR_WIDTH - 1:0];\\n\\t\\telse if ((ren_in & !empty) & ~empty_next)\\n\\t\\t\\tff_raddr <= ff_raddr_next;\\n\\talways @(posedge rclk or negedge rst_n)\\n\\t\\tif (~rst_n)\\n\\t\\t\\traddr <= 12'h000;\\n\\t\\telse if (ren_in & !empty)\\n\\t\\t\\traddr <= raddr_next;\\n\\talways @(*)\\n\\t\\tcase (FIFO_WIDTH)\\n\\t\\t\\t3'h2: out_raddr = {ff_raddr[ADDR_WIDTH - 1:1], bwl_sel[0]};\\n\\t\\t\\t3'h4: out_raddr = {ff_raddr[ADDR_WIDTH - 1:2], bwl_sel};\\n\\t\\t\\tdefault: out_raddr = ff_raddr[ADDR_WIDTH - 1:0];\\n\\t\\tendcase\\n\\tassign ren_o = ren_out;\\n\\tassign gcout = gcout_reg;\\n\\tassign popflags = {empty, epo, pae, underflow};\\nendmodule\\n`default_nettype none\\n\",\n            },\n        },\n        \"sf2\": {\n            \"arith_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule \\\\$__SF2_ALU (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 2;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] AA, BB;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(AA));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(BB));\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] C = {CO, CI};\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice\\n\\t\\tARI1 #(\\n\\t\\t\\t// G = F1 = A[i] & (B[i]^BI)\\n\\t\\t\\t// Y = F0 = A[i]^B[i]^BI\\n\\t\\t\\t// P = Y\\n\\t\\t\\t//\\t\\t ADCB\\n\\t\\t\\t.INIT(20'b 01_11_0010_1000_1001_0110)\\n\\t\\t) carry (\\n\\t\\t\\t.A(1'b0),\\n\\t\\t\\t.B(AA[i]),\\n\\t\\t\\t.C(BB[i]),\\n\\t\\t\\t.D(BI),\\n\\t\\t\\t.FCI(C[i]),\\n\\t\\t\\t.Y(X[i]),\\n\\t\\t\\t.S(Y[i]),\\n\\t\\t\\t.FCO(CO[i])\\n\\t\\t);\\n\\tend endgenerate\\nendmodule\\n\\n\",\n            \"cells_map.v\": \"module \\\\$_DFFE_PN0P_ (input D, C, R, E, output Q);\\n  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(R), .ADn(1'b1), .SLn(1'b1), .SD(1'b0), .LAT(1'b0), .Q(Q));\\nendmodule\\n\\nmodule \\\\$_DFFE_PN1P_ (input D, C, R, E, output Q);\\n  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(R), .ADn(1'b0), .SLn(1'b1), .SD(1'b0), .LAT(1'b0), .Q(Q));\\nendmodule\\n\\nmodule \\\\$_SDFFCE_PN0P_ (input D, C, R, E, output Q);\\n  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(1'b1), .ADn(1'b0), .SLn(R), .SD(1'b0), .LAT(1'b0), .Q(Q));\\nendmodule\\n\\nmodule \\\\$_SDFFCE_PN1P_ (input D, C, R, E, output Q);\\n  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(C), .EN(E), .ALn(1'b1), .ADn(1'b0), .SLn(R), .SD(1'b1), .LAT(1'b0), .Q(Q));\\nendmodule\\n\\nmodule \\\\$_DLATCH_PN0_ (input D, R, E, output Q);\\n  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(E), .EN(1'b1), .ALn(R), .ADn(1'b1), .SLn(1'b1), .SD(1'b0), .LAT(1'b1), .Q(Q));\\nendmodule\\n\\nmodule \\\\$_DLATCH_PN1_ (input D, R, E, output Q);\\n  SLE _TECHMAP_REPLACE_ (.D(D), .CLK(E), .EN(1'b1), .ALn(R), .ADn(1'b0), .SLn(1'b1), .SD(1'b0), .LAT(1'b1), .Q(Q));\\nendmodule\\n\\n`ifndef NO_LUT\\nmodule \\\\$lut (A, Y);\\n  parameter WIDTH = 0;\\n  parameter LUT = 0;\\n\\n  (* force_downto *)\\n  input [WIDTH-1:0] A;\\n  output Y;\\n\\n  generate\\n    if (WIDTH == 1) begin\\n      CFG1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]));\\n    end else\\n    if (WIDTH == 2) begin\\n      CFG2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]));\\n    end else\\n    if (WIDTH == 3) begin\\n      CFG3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]), .C(A[2]));\\n    end else\\n    if (WIDTH == 4) begin\\n      CFG4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.Y(Y), .A(A[0]), .B(A[1]), .C(A[2]), .D(A[3]));\\n    end else begin\\n      wire _TECHMAP_FAIL_ = 1;\\n    end\\n  endgenerate\\nendmodule\\n`endif\\n\",\n            \"cells_sim.v\": \"// https://coredocs.s3.amazonaws.com/Libero/12_0_0/Tool/sf2_mlg.pdf\\n\\nmodule AND2 (\\n\\tinput A, B,\\n\\toutput Y\\n);\\n\\tassign Y = A & B;\\nendmodule\\n\\nmodule AND3 (\\n\\tinput A, B, C,\\n\\toutput Y\\n);\\n\\tassign Y = A & B & C;\\nendmodule\\n\\nmodule AND4 (\\n\\tinput A, B, C, D,\\n\\toutput Y\\n);\\n\\tassign Y = A & B & C & D;\\nendmodule\\n\\nmodule CFG1 (\\n\\toutput Y,\\n\\tinput A\\n);\\n\\tparameter [1:0] INIT = 2'h0;\\n\\tassign Y = INIT >> A;\\nendmodule\\n\\nmodule CFG2 (\\n\\toutput Y,\\n\\tinput A,\\n\\tinput B\\n);\\n\\tparameter [3:0] INIT = 4'h0;\\n\\tassign Y = INIT >> {B, A};\\nendmodule\\n\\nmodule CFG3 (\\n\\toutput Y,\\n\\tinput A,\\n\\tinput B,\\n\\tinput C\\n);\\n\\tparameter [7:0] INIT = 8'h0;\\n\\tassign Y = INIT >> {C, B, A};\\nendmodule\\n\\nmodule CFG4 (\\n\\toutput Y,\\n\\tinput A,\\n\\tinput B,\\n\\tinput C,\\n\\tinput D\\n);\\n\\tparameter [15:0] INIT = 16'h0;\\n\\tassign Y = INIT >> {D, C, B, A};\\nendmodule\\n\\nmodule BUFF (\\n\\tinput A,\\n\\toutput Y\\n);\\n\\tassign Y = A;\\nendmodule\\n\\nmodule BUFD (\\n\\tinput A,\\n\\toutput Y\\n);\\n\\tassign Y = A;\\nendmodule\\n\\nmodule CLKINT (\\n\\tinput A,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\n\\tassign Y = A;\\nendmodule\\n\\nmodule CLKINT_PRESERVE (\\n\\tinput A,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\n\\tassign Y = A;\\nendmodule\\n\\nmodule GCLKINT (\\n\\tinput A, EN,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\n\\tassign Y = A & EN;\\nendmodule\\n\\nmodule RCLKINT (\\n\\tinput A,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\n\\tassign Y = A;\\nendmodule\\n\\nmodule RGCLKINT (\\n\\tinput A, EN,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\n\\tassign Y = A & EN;\\nendmodule\\n\\nmodule SLE (\\n\\toutput Q,\\n\\tinput ADn,\\n\\tinput ALn,\\n\\t(* clkbuf_sink *)\\n\\tinput CLK,\\n\\tinput D,\\n\\tinput LAT,\\n\\tinput SD,\\n\\tinput EN,\\n\\tinput SLn\\n);\\n\\treg q_latch, q_ff;\\n\\n\\talways @(posedge CLK, negedge ALn) begin\\n\\t\\tif (!ALn) begin\\n\\t\\t\\tq_ff <= !ADn;\\n\\t\\tend else if (EN) begin\\n\\t\\t\\tif (!SLn)\\n\\t\\t\\t\\tq_ff <= SD;\\n\\t\\t\\telse\\n\\t\\t\\t\\tq_ff <= D;\\n\\t\\tend\\n\\tend\\n\\n\\talways @* begin\\n\\t\\tif (!ALn) begin\\n\\t\\t\\tq_latch <= !ADn;\\n\\t\\tend else if (CLK && EN) begin\\n\\t\\t\\tif (!SLn)\\n\\t\\t\\t\\tq_ff <= SD;\\n\\t\\t\\telse\\n\\t\\t\\t\\tq_ff <= D;\\n\\t\\tend\\n\\tend\\n\\n\\tassign Q = LAT ? q_latch : q_ff;\\nendmodule\\n\\nmodule ARI1 (\\n\\tinput A, B, C, D, FCI,\\n\\toutput Y, S, FCO\\n);\\n\\tparameter [19:0] INIT = 20'h0;\\n\\twire [2:0] Fsel = {D, C, B};\\n\\twire F0 = INIT[Fsel];\\n\\twire F1 = INIT[8 + Fsel];\\n\\twire Yout = A ? F1 : F0;\\n\\tassign Y = Yout;\\n\\tassign S = FCI ^ Yout;\\n\\twire G = INIT[16] ? (INIT[17] ? F1 : F0) : INIT[17];\\n\\twire P = INIT[19] ? 1'b1 : (INIT[18] ? Yout : 1'b0);\\n\\tassign FCO = P ? FCI : G;\\nendmodule\\n\\n// module FCEND_BUFF\\n// module FCINIT_BUFF\\n// module FLASH_FREEZE\\n// module OSCILLATOR\\n// module SYSCTRL_RESET_STATUS\\n// module LIVE_PROBE_FB\\n\\n(* blackbox *)\\nmodule GCLKBUF (\\n\\t(* iopad_external_pin *)\\n\\tinput PAD,\\n\\tinput EN,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule GCLKBUF_DIFF (\\n\\t(* iopad_external_pin *)\\n\\tinput PADP,\\n\\t(* iopad_external_pin *)\\n\\tinput PADN,\\n\\tinput EN,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\nendmodule\\n\\n(* blackbox *)\\nmodule GCLKBIBUF (\\n\\tinput D,\\n\\tinput E,\\n\\tinput EN,\\n\\t(* iopad_external_pin *)\\n\\tinout PAD,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\nendmodule\\n\\n// module DFN1\\n// module DFN1C0\\n// module DFN1E1\\n// module DFN1E1C0\\n// module DFN1E1P0\\n// module DFN1P0\\n// module DLN1\\n// module DLN1C0\\n// module DLN1P0\\n\\nmodule INV (\\n\\tinput A,\\n\\toutput Y\\n);\\n\\tassign Y = !A;\\nendmodule\\n\\nmodule INVD (\\n\\tinput A,\\n\\toutput Y\\n);\\n\\tassign Y = !A;\\nendmodule\\n\\nmodule MX2 (\\n\\tinput A, B, S,\\n\\toutput Y\\n);\\n\\tassign Y = S ? B : A;\\nendmodule\\n\\nmodule MX4 (\\n\\tinput D0, D1, D2, D3, S0, S1,\\n\\toutput Y\\n);\\n\\tassign Y = S1 ? (S0 ? D3 : D2) : (S0 ? D1 : D0);\\nendmodule\\n\\nmodule NAND2 (\\n\\tinput A, B,\\n\\toutput Y\\n);\\n\\tassign Y = !(A & B);\\nendmodule\\n\\nmodule NAND3 (\\n\\tinput A, B, C,\\n\\toutput Y\\n);\\n\\tassign Y = !(A & B & C);\\nendmodule\\n\\nmodule NAND4 (\\n\\tinput A, B, C, D,\\n\\toutput Y\\n);\\n\\tassign Y = !(A & B & C & D);\\nendmodule\\n\\nmodule NOR2 (\\n\\tinput A, B,\\n\\toutput Y\\n);\\n\\tassign Y = !(A | B);\\nendmodule\\n\\nmodule NOR3 (\\n\\tinput A, B, C,\\n\\toutput Y\\n);\\n\\tassign Y = !(A | B | C);\\nendmodule\\n\\nmodule NOR4 (\\n\\tinput A, B, C, D,\\n\\toutput Y\\n);\\n\\tassign Y = !(A | B | C | D);\\nendmodule\\n\\nmodule OR2 (\\n\\tinput A, B,\\n\\toutput Y\\n);\\n\\tassign Y = A | B;\\nendmodule\\n\\nmodule OR3 (\\n\\tinput A, B, C,\\n\\toutput Y\\n);\\n\\tassign Y = A | B | C;\\nendmodule\\n\\nmodule OR4 (\\n\\tinput A, B, C, D,\\n\\toutput Y\\n);\\n\\tassign Y = A | B | C | D;\\nendmodule\\n\\nmodule XOR2 (\\n\\tinput A, B,\\n\\toutput Y\\n);\\n\\tassign Y = A ^ B;\\nendmodule\\n\\nmodule XOR3 (\\n\\tinput A, B, C,\\n\\toutput Y\\n);\\n\\tassign Y = A ^ B ^ C;\\nendmodule\\n\\nmodule XOR4 (\\n\\tinput A, B, C, D,\\n\\toutput Y\\n);\\n\\tassign Y = A ^ B ^ C ^ D;\\nendmodule\\n\\nmodule XOR8 (\\n\\tinput A, B, C, D, E, F, G, H,\\n\\toutput Y\\n);\\n\\tassign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H;\\nendmodule\\n\\n// module UJTAG\\n\\nmodule BIBUF (\\n\\tinput D,\\n\\tinput E,\\n\\t(* iopad_external_pin *)\\n\\tinout PAD,\\n\\toutput Y\\n);\\n\\tparameter IOSTD = \\\"\\\";\\n\\tassign PAD = E ? D : 1'bz;\\n\\tassign Y = PAD;\\nendmodule\\n\\n(* blackbox *)\\nmodule BIBUF_DIFF (\\n\\tinput D,\\n\\tinput E,\\n\\t(* iopad_external_pin *)\\n\\tinout PADP,\\n\\t(* iopad_external_pin *)\\n\\tinout PADN,\\n\\toutput Y\\n);\\n\\tparameter IOSTD = \\\"\\\";\\nendmodule\\n\\nmodule CLKBIBUF (\\n\\tinput D,\\n\\tinput E,\\n\\t(* iopad_external_pin *)\\n\\tinout PAD,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\n\\tparameter IOSTD = \\\"\\\";\\n\\tassign PAD = E ? D : 1'bz;\\n\\tassign Y = PAD;\\nendmodule\\n\\nmodule CLKBUF (\\n\\t(* iopad_external_pin *)\\n\\tinput PAD,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\n\\tparameter IOSTD = \\\"\\\";\\n\\tassign Y = PAD;\\nendmodule\\n\\n(* blackbox *)\\nmodule CLKBUF_DIFF (\\n\\t(* iopad_external_pin *)\\n\\tinput PADP,\\n\\t(* iopad_external_pin *)\\n\\tinput PADN,\\n\\t(* clkbuf_driver *)\\n\\toutput Y\\n);\\n\\tparameter IOSTD = \\\"\\\";\\nendmodule\\n\\nmodule INBUF (\\n\\t(* iopad_external_pin *)\\n\\tinput PAD,\\n\\toutput Y\\n);\\n\\tparameter IOSTD = \\\"\\\";\\n\\tassign Y = PAD;\\nendmodule\\n\\n(* blackbox *)\\nmodule INBUF_DIFF (\\n\\t(* iopad_external_pin *)\\n\\tinput PADP,\\n\\t(* iopad_external_pin *)\\n\\tinput PADN,\\n\\toutput Y\\n);\\n\\tparameter IOSTD = \\\"\\\";\\nendmodule\\n\\nmodule OUTBUF (\\n\\tinput D,\\n\\t(* iopad_external_pin *)\\n\\toutput PAD\\n);\\n\\tparameter IOSTD = \\\"\\\";\\n\\tassign PAD = D;\\nendmodule\\n\\n(* blackbox *)\\nmodule OUTBUF_DIFF (\\n\\tinput D,\\n\\t(* iopad_external_pin *)\\n\\toutput PADP,\\n\\t(* iopad_external_pin *)\\n\\toutput PADN\\n);\\n\\tparameter IOSTD = \\\"\\\";\\nendmodule\\n\\nmodule TRIBUFF (\\n\\tinput D,\\n\\tinput E,\\n\\t(* iopad_external_pin *)\\n\\toutput PAD\\n);\\n\\tparameter IOSTD = \\\"\\\";\\n\\tassign PAD = E ? D : 1'bz;\\nendmodule\\n\\n(* blackbox *)\\nmodule TRIBUFF_DIFF (\\n\\tinput D,\\n\\tinput E,\\n\\t(* iopad_external_pin *)\\n\\toutput PADP,\\n\\t(* iopad_external_pin *)\\n\\toutput PADN\\n);\\n\\tparameter IOSTD = \\\"\\\";\\nendmodule\\n\\n// module DDR_IN\\n// module DDR_OUT\\n// module RAM1K18\\n// module RAM64x18\\n// module MACC\\n\\n(* blackbox *)\\nmodule SYSRESET (\\n\\t(* iopad_external_pin *)\\n\\tinput  DEVRST_N,\\n\\toutput POWER_ON_RESET_N);\\nendmodule\\n\\n\\n(* blackbox *)\\nmodule XTLOSC (\\n\\t(* iopad_external_pin *)\\n\\tinput  XTL,\\n\\toutput CLKOUT);\\n\\tparameter [1:0] MODE = 2'h3;\\n\\tparameter real FREQUENCY = 20.0;\\nendmodule\\n\\n(* blackbox *)\\nmodule RAM1K18 (\\n\\tinput [13:0]  A_ADDR,\\n\\tinput [2:0]   A_BLK,\\n\\t(* clkbuf_sink *)\\n\\tinput\\t      A_CLK,\\n\\tinput [17:0]  A_DIN,\\n\\toutput [17:0] A_DOUT,\\n\\tinput [1:0]   A_WEN,\\n\\tinput [2:0]   A_WIDTH,\\n\\tinput\\t      A_WMODE,\\n\\tinput\\t      A_ARST_N,\\n\\tinput\\t      A_DOUT_LAT,\\n\\tinput\\t      A_DOUT_ARST_N,\\n\\t(* clkbuf_sink *)\\n\\tinput\\t      A_DOUT_CLK,\\n\\tinput\\t      A_DOUT_EN,\\n\\tinput\\t      A_DOUT_SRST_N,\\n\\n\\tinput [13:0]  B_ADDR,\\n\\tinput [2:0]   B_BLK,\\n\\t(* clkbuf_sink *)\\n\\tinput\\t      B_CLK,\\n\\tinput [17:0]  B_DIN,\\n\\toutput [17:0] B_DOUT,\\n\\tinput [1:0]   B_WEN,\\n\\tinput [2:0]   B_WIDTH,\\n\\tinput\\t      B_WMODE,\\n\\tinput\\t      B_ARST_N,\\n\\tinput\\t      B_DOUT_LAT,\\n\\tinput\\t      B_DOUT_ARST_N,\\n\\t(* clkbuf_sink *)\\n\\tinput\\t      B_DOUT_CLK,\\n\\tinput\\t      B_DOUT_EN,\\n\\tinput\\t      B_DOUT_SRST_N,\\n\\n\\tinput\\t      A_EN,\\n\\tinput\\t      B_EN,\\n\\tinput\\t      SII_LOCK,\\n\\toutput\\t      BUSY);\\nendmodule\\n\\n(* blackbox *)\\nmodule RAM64x18 (\\n\\tinput [9:0]   A_ADDR,\\n\\tinput [1:0]   A_BLK,\\n\\tinput [2:0]   A_WIDTH,\\n\\toutput [17:0] A_DOUT,\\n\\tinput\\t      A_DOUT_ARST_N,\\n\\t(* clkbuf_sink *)\\n\\tinput\\t      A_DOUT_CLK,\\n\\tinput\\t      A_DOUT_EN,\\n\\tinput\\t      A_DOUT_LAT,\\n\\tinput\\t      A_DOUT_SRST_N,\\n\\t(* clkbuf_sink *)\\n\\tinput\\t      A_ADDR_CLK,\\n\\tinput\\t      A_ADDR_EN,\\n\\tinput\\t      A_ADDR_LAT,\\n\\tinput\\t      A_ADDR_SRST_N,\\n\\tinput\\t      A_ADDR_ARST_N,\\n\\n\\tinput [9:0]   B_ADDR,\\n\\tinput [1:0]   B_BLK,\\n\\tinput [2:0]   B_WIDTH,\\n\\toutput [17:0] B_DOUT,\\n\\tinput\\t      B_DOUT_ARST_N,\\n\\t(* clkbuf_sink *)\\n\\tinput\\t      B_DOUT_CLK,\\n\\tinput\\t      B_DOUT_EN,\\n\\tinput\\t      B_DOUT_LAT,\\n\\tinput\\t      B_DOUT_SRST_N,\\n\\t(* clkbuf_sink *)\\n\\tinput\\t      B_ADDR_CLK,\\n\\tinput\\t      B_ADDR_EN,\\n\\tinput\\t      B_ADDR_LAT,\\n\\tinput\\t      B_ADDR_SRST_N,\\n\\tinput\\t      B_ADDR_ARST_N,\\n\\n\\tinput [9:0]   C_ADDR,\\n\\t(* clkbuf_sink *)\\n\\tinput\\t      C_CLK,\\n\\tinput [17:0]  C_DIN,\\n\\tinput\\t      C_WEN,\\n\\tinput [1:0]   C_BLK,\\n\\tinput [2:0]   C_WIDTH,\\n\\n\\tinput\\t      A_EN,\\n\\tinput\\t      B_EN,\\n\\tinput\\t      C_EN,\\n\\tinput\\t      SII_LOCK,\\n\\toutput\\t      BUSY);\\nendmodule\\n\",\n        },\n        \"simcells.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n *  ---\\n *\\n *  The internal logic cell simulation library.\\n *\\n *  This Verilog library contains simple simulation models for the internal\\n *  logic cells ($_NOT_ , $_AND_ , ...) that are generated by the default technology\\n *  mapper (see \\\"techmap.v\\\" in this directory) and expected by the \\\"abc\\\" pass.\\n *\\n */\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_BUF_ (A, Y)\\n//-\\n//- A buffer. This cell type is always optimized away by the opt_clean pass.\\n//-\\n//- Truth table:    A | Y\\n//-                ---+---\\n//-                 0 | 0\\n//-                 1 | 1\\n//-\\nmodule \\\\$_BUF_ (A, Y);\\ninput A;\\noutput Y;\\nassign Y = A;\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_NOT_ (A, Y)\\n//-\\n//- An inverter gate.\\n//-\\n//- Truth table:    A | Y\\n//-                ---+---\\n//-                 0 | 1\\n//-                 1 | 0\\n//-\\nmodule \\\\$_NOT_ (A, Y);\\ninput A;\\noutput Y;\\nassign Y = ~A;\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_AND_ (A, B, Y)\\n//-\\n//- A 2-input AND gate.\\n//-\\n//- Truth table:    A B | Y\\n//-                -----+---\\n//-                 0 0 | 0\\n//-                 0 1 | 0\\n//-                 1 0 | 0\\n//-                 1 1 | 1\\n//-\\nmodule \\\\$_AND_ (A, B, Y);\\ninput A, B;\\noutput Y;\\nassign Y = A & B;\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_NAND_ (A, B, Y)\\n//-\\n//- A 2-input NAND gate.\\n//-\\n//- Truth table:    A B | Y\\n//-                -----+---\\n//-                 0 0 | 1\\n//-                 0 1 | 1\\n//-                 1 0 | 1\\n//-                 1 1 | 0\\n//-\\nmodule \\\\$_NAND_ (A, B, Y);\\ninput A, B;\\noutput Y;\\nassign Y = ~(A & B);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_OR_ (A, B, Y)\\n//-\\n//- A 2-input OR gate.\\n//-\\n//- Truth table:    A B | Y\\n//-                -----+---\\n//-                 0 0 | 0\\n//-                 0 1 | 1\\n//-                 1 0 | 1\\n//-                 1 1 | 1\\n//-\\nmodule \\\\$_OR_ (A, B, Y);\\ninput A, B;\\noutput Y;\\nassign Y = A | B;\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_NOR_ (A, B, Y)\\n//-\\n//- A 2-input NOR gate.\\n//-\\n//- Truth table:    A B | Y\\n//-                -----+---\\n//-                 0 0 | 1\\n//-                 0 1 | 0\\n//-                 1 0 | 0\\n//-                 1 1 | 0\\n//-\\nmodule \\\\$_NOR_ (A, B, Y);\\ninput A, B;\\noutput Y;\\nassign Y = ~(A | B);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_XOR_ (A, B, Y)\\n//-\\n//- A 2-input XOR gate.\\n//-\\n//- Truth table:    A B | Y\\n//-                -----+---\\n//-                 0 0 | 0\\n//-                 0 1 | 1\\n//-                 1 0 | 1\\n//-                 1 1 | 0\\n//-\\nmodule \\\\$_XOR_ (A, B, Y);\\ninput A, B;\\noutput Y;\\nassign Y = A ^ B;\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_XNOR_ (A, B, Y)\\n//-\\n//- A 2-input XNOR gate.\\n//-\\n//- Truth table:    A B | Y\\n//-                -----+---\\n//-                 0 0 | 1\\n//-                 0 1 | 0\\n//-                 1 0 | 0\\n//-                 1 1 | 1\\n//-\\nmodule \\\\$_XNOR_ (A, B, Y);\\ninput A, B;\\noutput Y;\\nassign Y = ~(A ^ B);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ANDNOT_ (A, B, Y)\\n//-\\n//- A 2-input AND-NOT gate.\\n//-\\n//- Truth table:    A B | Y\\n//-                -----+---\\n//-                 0 0 | 0\\n//-                 0 1 | 0\\n//-                 1 0 | 1\\n//-                 1 1 | 0\\n//-\\nmodule \\\\$_ANDNOT_ (A, B, Y);\\ninput A, B;\\noutput Y;\\nassign Y = A & (~B);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ORNOT_ (A, B, Y)\\n//-\\n//- A 2-input OR-NOT gate.\\n//-\\n//- Truth table:    A B | Y\\n//-                -----+---\\n//-                 0 0 | 1\\n//-                 0 1 | 0\\n//-                 1 0 | 1\\n//-                 1 1 | 1\\n//-\\nmodule \\\\$_ORNOT_ (A, B, Y);\\ninput A, B;\\noutput Y;\\nassign Y = A | (~B);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_MUX_ (A, B, S, Y)\\n//-\\n//- A 2-input MUX gate.\\n//-\\n//- Truth table:    A B S | Y\\n//-                -------+---\\n//-                 a - 0 | a\\n//-                 - b 1 | b\\n//-\\nmodule \\\\$_MUX_ (A, B, S, Y);\\ninput A, B, S;\\noutput Y;\\nassign Y = S ? B : A;\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_NMUX_ (A, B, S, Y)\\n//-\\n//- A 2-input inverting MUX gate.\\n//-\\n//- Truth table:    A B S | Y\\n//-                -------+---\\n//-                 0 - 0 | 1\\n//-                 1 - 0 | 0\\n//-                 - 0 1 | 1\\n//-                 - 1 1 | 0\\n//-\\nmodule \\\\$_NMUX_ (A, B, S, Y);\\ninput A, B, S;\\noutput Y;\\nassign Y = S ? !B : !A;\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_MUX4_ (A, B, C, D, S, T, Y)\\n//-\\n//- A 4-input MUX gate.\\n//-\\n//- Truth table:    A B C D S T | Y\\n//-                -------------+---\\n//-                 a - - - 0 0 | a\\n//-                 - b - - 1 0 | b\\n//-                 - - c - 0 1 | c\\n//-                 - - - d 1 1 | d\\n//-\\nmodule \\\\$_MUX4_ (A, B, C, D, S, T, Y);\\ninput A, B, C, D, S, T;\\noutput Y;\\nassign Y = T ? (S ? D : C) :\\n               (S ? B : A);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y)\\n//-\\n//- An 8-input MUX gate.\\n//-\\n//- Truth table:    A B C D E F G H S T U | Y\\n//-                -----------------------+---\\n//-                 a - - - - - - - 0 0 0 | a\\n//-                 - b - - - - - - 1 0 0 | b\\n//-                 - - c - - - - - 0 1 0 | c\\n//-                 - - - d - - - - 1 1 0 | d\\n//-                 - - - - e - - - 0 0 1 | e\\n//-                 - - - - - f - - 1 0 1 | f\\n//-                 - - - - - - g - 0 1 1 | g\\n//-                 - - - - - - - h 1 1 1 | h\\n//-\\nmodule \\\\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);\\ninput A, B, C, D, E, F, G, H, S, T, U;\\noutput Y;\\nassign Y = U ? T ? (S ? H : G) :\\n                   (S ? F : E) :\\n               T ? (S ? D : C) :\\n                   (S ? B : A);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y)\\n//-\\n//- A 16-input MUX gate.\\n//-\\n//- Truth table:    A B C D E F G H I J K L M N O P S T U V | Y\\n//-                -----------------------------------------+---\\n//-                 a - - - - - - - - - - - - - - - 0 0 0 0 | a\\n//-                 - b - - - - - - - - - - - - - - 1 0 0 0 | b\\n//-                 - - c - - - - - - - - - - - - - 0 1 0 0 | c\\n//-                 - - - d - - - - - - - - - - - - 1 1 0 0 | d\\n//-                 - - - - e - - - - - - - - - - - 0 0 1 0 | e\\n//-                 - - - - - f - - - - - - - - - - 1 0 1 0 | f\\n//-                 - - - - - - g - - - - - - - - - 0 1 1 0 | g\\n//-                 - - - - - - - h - - - - - - - - 1 1 1 0 | h\\n//-                 - - - - - - - - i - - - - - - - 0 0 0 1 | i\\n//-                 - - - - - - - - - j - - - - - - 1 0 0 1 | j\\n//-                 - - - - - - - - - - k - - - - - 0 1 0 1 | k\\n//-                 - - - - - - - - - - - l - - - - 1 1 0 1 | l\\n//-                 - - - - - - - - - - - - m - - - 0 0 1 1 | m\\n//-                 - - - - - - - - - - - - - n - - 1 0 1 1 | n\\n//-                 - - - - - - - - - - - - - - o - 0 1 1 1 | o\\n//-                 - - - - - - - - - - - - - - - p 1 1 1 1 | p\\n//-\\nmodule \\\\$_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y);\\ninput A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V;\\noutput Y;\\nassign Y = V ? U ? T ? (S ? P : O) :\\n                       (S ? N : M) :\\n                   T ? (S ? L : K) :\\n                       (S ? J : I) :\\n               U ? T ? (S ? H : G) :\\n                       (S ? F : E) :\\n                   T ? (S ? D : C) :\\n                       (S ? B : A);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_AOI3_ (A, B, C, Y)\\n//-\\n//- A 3-input And-Or-Invert gate.\\n//-\\n//- Truth table:    A B C | Y\\n//-                -------+---\\n//-                 0 0 0 | 1\\n//-                 0 0 1 | 0\\n//-                 0 1 0 | 1\\n//-                 0 1 1 | 0\\n//-                 1 0 0 | 1\\n//-                 1 0 1 | 0\\n//-                 1 1 0 | 0\\n//-                 1 1 1 | 0\\n//-\\nmodule \\\\$_AOI3_ (A, B, C, Y);\\ninput A, B, C;\\noutput Y;\\nassign Y = ~((A & B) | C);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_OAI3_ (A, B, C, Y)\\n//-\\n//- A 3-input Or-And-Invert gate.\\n//-\\n//- Truth table:    A B C | Y\\n//-                -------+---\\n//-                 0 0 0 | 1\\n//-                 0 0 1 | 1\\n//-                 0 1 0 | 1\\n//-                 0 1 1 | 0\\n//-                 1 0 0 | 1\\n//-                 1 0 1 | 0\\n//-                 1 1 0 | 1\\n//-                 1 1 1 | 0\\n//-\\nmodule \\\\$_OAI3_ (A, B, C, Y);\\ninput A, B, C;\\noutput Y;\\nassign Y = ~((A | B) & C);\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_AOI4_ (A, B, C, Y)\\n//-\\n//- A 4-input And-Or-Invert gate.\\n//-\\n//- Truth table:    A B C D | Y\\n//-                ---------+---\\n//-                 0 0 0 0 | 1\\n//-                 0 0 0 1 | 1\\n//-                 0 0 1 0 | 1\\n//-                 0 0 1 1 | 0\\n//-                 0 1 0 0 | 1\\n//-                 0 1 0 1 | 1\\n//-                 0 1 1 0 | 1\\n//-                 0 1 1 1 | 0\\n//-                 1 0 0 0 | 1\\n//-                 1 0 0 1 | 1\\n//-                 1 0 1 0 | 1\\n//-                 1 0 1 1 | 0\\n//-                 1 1 0 0 | 0\\n//-                 1 1 0 1 | 0\\n//-                 1 1 1 0 | 0\\n//-                 1 1 1 1 | 0\\n//-\\nmodule \\\\$_AOI4_ (A, B, C, D, Y);\\ninput A, B, C, D;\\noutput Y;\\nassign Y = ~((A & B) | (C & D));\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_OAI4_ (A, B, C, Y)\\n//-\\n//- A 4-input Or-And-Invert gate.\\n//-\\n//- Truth table:    A B C D | Y\\n//-                ---------+---\\n//-                 0 0 0 0 | 1\\n//-                 0 0 0 1 | 1\\n//-                 0 0 1 0 | 1\\n//-                 0 0 1 1 | 1\\n//-                 0 1 0 0 | 1\\n//-                 0 1 0 1 | 0\\n//-                 0 1 1 0 | 0\\n//-                 0 1 1 1 | 0\\n//-                 1 0 0 0 | 1\\n//-                 1 0 0 1 | 0\\n//-                 1 0 1 0 | 0\\n//-                 1 0 1 1 | 0\\n//-                 1 1 0 0 | 1\\n//-                 1 1 0 1 | 0\\n//-                 1 1 1 0 | 0\\n//-                 1 1 1 1 | 0\\n//-\\nmodule \\\\$_OAI4_ (A, B, C, D, Y);\\ninput A, B, C, D;\\noutput Y;\\nassign Y = ~((A | B) & (C | D));\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_TBUF_ (A, E, Y)\\n//-\\n//- A tri-state buffer.\\n//-\\n//- Truth table:    A E | Y\\n//-                -----+---\\n//-                 a 1 | a\\n//-                 - 0 | z\\n//-\\nmodule \\\\$_TBUF_ (A, E, Y);\\ninput A, E;\\noutput Y;\\nassign Y = E ? A : 1'bz;\\nendmodule\\n\\n// NOTE: the following cell types are autogenerated.  DO NOT EDIT them manually,\\n// instead edit the templates in gen_ff_types.py and rerun it.\\n\\n// START AUTOGENERATED CELL TYPES\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SR_NN_ (S, R, Q)\\n//-\\n//- A set-reset latch with negative polarity SET and negative polarity RESET.\\n//-\\n//- Truth table:    S R | Q\\n//-                -----+---\\n//-                 - 0 | 0\\n//-                 0 - | 1\\n//-                 - - | q\\n//-\\nmodule \\\\$_SR_NN_ (S, R, Q);\\ninput S, R;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SR_NP_ (S, R, Q)\\n//-\\n//- A set-reset latch with negative polarity SET and positive polarity RESET.\\n//-\\n//- Truth table:    S R | Q\\n//-                -----+---\\n//-                 - 1 | 0\\n//-                 0 - | 1\\n//-                 - - | q\\n//-\\nmodule \\\\$_SR_NP_ (S, R, Q);\\ninput S, R;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SR_PN_ (S, R, Q)\\n//-\\n//- A set-reset latch with positive polarity SET and negative polarity RESET.\\n//-\\n//- Truth table:    S R | Q\\n//-                -----+---\\n//-                 - 0 | 0\\n//-                 1 - | 1\\n//-                 - - | q\\n//-\\nmodule \\\\$_SR_PN_ (S, R, Q);\\ninput S, R;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SR_PP_ (S, R, Q)\\n//-\\n//- A set-reset latch with positive polarity SET and positive polarity RESET.\\n//-\\n//- Truth table:    S R | Q\\n//-                -----+---\\n//-                 - 1 | 0\\n//-                 1 - | 1\\n//-                 - - | q\\n//-\\nmodule \\\\$_SR_PP_ (S, R, Q);\\ninput S, R;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\nend\\nendmodule\\n\\n`ifdef SIMCELLS_FF\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_FF_ (D, Q)\\n//-\\n//- A D-type flip-flop that is clocked from the implicit global clock. (This cell\\n//- type is usually only used in netlists for formal verification.)\\n//-\\nmodule \\\\$_FF_ (D, Q);\\ninput D;\\noutput reg Q;\\nalways @($global_clock) begin\\n\\tQ <= D;\\nend\\nendmodule\\n`endif\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_N_ (D, C, Q)\\n//-\\n//- A negative edge D-type flip-flop.\\n//-\\n//- Truth table:    D C | Q\\n//-                -----+---\\n//-                 d \\\\ | d\\n//-                 - - | q\\n//-\\nmodule \\\\$_DFF_N_ (D, C, Q);\\ninput D, C;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_P_ (D, C, Q)\\n//-\\n//- A positive edge D-type flip-flop.\\n//-\\n//- Truth table:    D C | Q\\n//-                -----+---\\n//-                 d / | d\\n//-                 - - | q\\n//-\\nmodule \\\\$_DFF_P_ (D, C, Q);\\ninput D, C;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NN_ (D, C, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity enable.\\n//-\\n//- Truth table:    D C E | Q\\n//-                -------+---\\n//-                 d \\\\ 0 | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFFE_NN_ (D, C, E, Q);\\ninput D, C, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (!E) Q <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NP_ (D, C, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity enable.\\n//-\\n//- Truth table:    D C E | Q\\n//-                -------+---\\n//-                 d \\\\ 1 | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFFE_NP_ (D, C, E, Q);\\ninput D, C, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (E) Q <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PN_ (D, C, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity enable.\\n//-\\n//- Truth table:    D C E | Q\\n//-                -------+---\\n//-                 d / 0 | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFFE_PN_ (D, C, E, Q);\\ninput D, C, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (!E) Q <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PP_ (D, C, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity enable.\\n//-\\n//- Truth table:    D C E | Q\\n//-                -------+---\\n//-                 d / 1 | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFFE_PP_ (D, C, E, Q);\\ninput D, C, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (E) Q <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_NN0_ (D, C, R, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity reset.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - - 0 | 0\\n//-                 d \\\\ - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFF_NN0_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(negedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_NN1_ (D, C, R, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity set.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - - 0 | 1\\n//-                 d \\\\ - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFF_NN1_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(negedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_NP0_ (D, C, R, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity reset.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - - 1 | 0\\n//-                 d \\\\ - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFF_NP0_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(negedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_NP1_ (D, C, R, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity set.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - - 1 | 1\\n//-                 d \\\\ - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFF_NP1_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(negedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_PN0_ (D, C, R, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity reset.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - - 0 | 0\\n//-                 d / - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFF_PN0_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(posedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_PN1_ (D, C, R, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity set.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - - 0 | 1\\n//-                 d / - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFF_PN1_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(posedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_PP0_ (D, C, R, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity reset.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - - 1 | 0\\n//-                 d / - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFF_PP0_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(posedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFF_PP1_ (D, C, R, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity set.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - - 1 | 1\\n//-                 d / - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DFF_PP1_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(posedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NN0N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity reset and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_NN0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NN0P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity reset and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_NN0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NN1N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity set and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 0 - | 1\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_NN1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NN1P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity set and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 0 - | 1\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_NN1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NP0N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity reset and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_NP0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NP0P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity reset and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_NP0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NP1N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity set and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 1 - | 1\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_NP1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_NP1P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity set and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 1 - | 1\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_NP1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PN0N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity reset and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_PN0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PN0P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity reset and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_PN0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PN1N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity set and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 0 - | 1\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_PN1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PN1P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity set and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 0 - | 1\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_PN1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C or negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PP0N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity reset and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_PP0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PP0P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity reset and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_PP0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PP1N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity set and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 1 - | 1\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_PP1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFE_PP1P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity set and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - - 1 - | 1\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFE_PP1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C or posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFF_NN_ (D, C, L, AD, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity async load.\\n//-\\n//- Truth table:    D C L AD | Q\\n//-                ----------+---\\n//-                 - - 0 a  | a\\n//-                 d \\\\ - -  | d\\n//-                 - - - -  | q\\n//-\\nmodule \\\\$_ALDFF_NN_ (D, C, L, AD, Q);\\ninput D, C, L, AD;\\noutput reg Q;\\nalways @(negedge C or negedge L) begin\\n\\tif (L == 0)\\n\\t\\tQ <= AD;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFF_NP_ (D, C, L, AD, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity async load.\\n//-\\n//- Truth table:    D C L AD | Q\\n//-                ----------+---\\n//-                 - - 1 a  | a\\n//-                 d \\\\ - -  | d\\n//-                 - - - -  | q\\n//-\\nmodule \\\\$_ALDFF_NP_ (D, C, L, AD, Q);\\ninput D, C, L, AD;\\noutput reg Q;\\nalways @(negedge C or posedge L) begin\\n\\tif (L == 1)\\n\\t\\tQ <= AD;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFF_PN_ (D, C, L, AD, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity async load.\\n//-\\n//- Truth table:    D C L AD | Q\\n//-                ----------+---\\n//-                 - - 0 a  | a\\n//-                 d / - -  | d\\n//-                 - - - -  | q\\n//-\\nmodule \\\\$_ALDFF_PN_ (D, C, L, AD, Q);\\ninput D, C, L, AD;\\noutput reg Q;\\nalways @(posedge C or negedge L) begin\\n\\tif (L == 0)\\n\\t\\tQ <= AD;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFF_PP_ (D, C, L, AD, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity async load.\\n//-\\n//- Truth table:    D C L AD | Q\\n//-                ----------+---\\n//-                 - - 1 a  | a\\n//-                 d / - -  | d\\n//-                 - - - -  | q\\n//-\\nmodule \\\\$_ALDFF_PP_ (D, C, L, AD, Q);\\ninput D, C, L, AD;\\noutput reg Q;\\nalways @(posedge C or posedge L) begin\\n\\tif (L == 1)\\n\\t\\tQ <= AD;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFFE_NNN_ (D, C, L, AD, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity async load and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C L AD E | Q\\n//-                ------------+---\\n//-                 - - 0 a  - | a\\n//-                 d \\\\ - -  0 | d\\n//-                 - - - -  - | q\\n//-\\nmodule \\\\$_ALDFFE_NNN_ (D, C, L, AD, E, Q);\\ninput D, C, L, AD, E;\\noutput reg Q;\\nalways @(negedge C or negedge L) begin\\n\\tif (L == 0)\\n\\t\\tQ <= AD;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFFE_NNP_ (D, C, L, AD, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity async load and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C L AD E | Q\\n//-                ------------+---\\n//-                 - - 0 a  - | a\\n//-                 d \\\\ - -  1 | d\\n//-                 - - - -  - | q\\n//-\\nmodule \\\\$_ALDFFE_NNP_ (D, C, L, AD, E, Q);\\ninput D, C, L, AD, E;\\noutput reg Q;\\nalways @(negedge C or negedge L) begin\\n\\tif (L == 0)\\n\\t\\tQ <= AD;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFFE_NPN_ (D, C, L, AD, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity async load and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C L AD E | Q\\n//-                ------------+---\\n//-                 - - 1 a  - | a\\n//-                 d \\\\ - -  0 | d\\n//-                 - - - -  - | q\\n//-\\nmodule \\\\$_ALDFFE_NPN_ (D, C, L, AD, E, Q);\\ninput D, C, L, AD, E;\\noutput reg Q;\\nalways @(negedge C or posedge L) begin\\n\\tif (L == 1)\\n\\t\\tQ <= AD;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFFE_NPP_ (D, C, L, AD, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity async load and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C L AD E | Q\\n//-                ------------+---\\n//-                 - - 1 a  - | a\\n//-                 d \\\\ - -  1 | d\\n//-                 - - - -  - | q\\n//-\\nmodule \\\\$_ALDFFE_NPP_ (D, C, L, AD, E, Q);\\ninput D, C, L, AD, E;\\noutput reg Q;\\nalways @(negedge C or posedge L) begin\\n\\tif (L == 1)\\n\\t\\tQ <= AD;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFFE_PNN_ (D, C, L, AD, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity async load and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C L AD E | Q\\n//-                ------------+---\\n//-                 - - 0 a  - | a\\n//-                 d / - -  0 | d\\n//-                 - - - -  - | q\\n//-\\nmodule \\\\$_ALDFFE_PNN_ (D, C, L, AD, E, Q);\\ninput D, C, L, AD, E;\\noutput reg Q;\\nalways @(posedge C or negedge L) begin\\n\\tif (L == 0)\\n\\t\\tQ <= AD;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFFE_PNP_ (D, C, L, AD, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity async load and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C L AD E | Q\\n//-                ------------+---\\n//-                 - - 0 a  - | a\\n//-                 d / - -  1 | d\\n//-                 - - - -  - | q\\n//-\\nmodule \\\\$_ALDFFE_PNP_ (D, C, L, AD, E, Q);\\ninput D, C, L, AD, E;\\noutput reg Q;\\nalways @(posedge C or negedge L) begin\\n\\tif (L == 0)\\n\\t\\tQ <= AD;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFFE_PPN_ (D, C, L, AD, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity async load and negative\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C L AD E | Q\\n//-                ------------+---\\n//-                 - - 1 a  - | a\\n//-                 d / - -  0 | d\\n//-                 - - - -  - | q\\n//-\\nmodule \\\\$_ALDFFE_PPN_ (D, C, L, AD, E, Q);\\ninput D, C, L, AD, E;\\noutput reg Q;\\nalways @(posedge C or posedge L) begin\\n\\tif (L == 1)\\n\\t\\tQ <= AD;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_ALDFFE_PPP_ (D, C, L, AD, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity async load and positive\\n//- polarity clock enable.\\n//-\\n//- Truth table:    D C L AD E | Q\\n//-                ------------+---\\n//-                 - - 1 a  - | a\\n//-                 d / - -  1 | d\\n//-                 - - - -  - | q\\n//-\\nmodule \\\\$_ALDFFE_PPP_ (D, C, L, AD, E, Q);\\ninput D, C, L, AD, E;\\noutput reg Q;\\nalways @(posedge C or posedge L) begin\\n\\tif (L == 1)\\n\\t\\tQ <= AD;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSR_NNN_ (C, S, R, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity set and negative\\n//- polarity reset.\\n//-\\n//- Truth table:    C S R D | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 - 0 - - | 1\\n//-                 \\\\ - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFSR_NNN_ (C, S, R, D, Q);\\ninput C, S, R, D;\\noutput reg Q;\\nalways @(negedge C, negedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSR_NNP_ (C, S, R, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity set and positive\\n//- polarity reset.\\n//-\\n//- Truth table:    C S R D | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 - 0 - - | 1\\n//-                 \\\\ - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFSR_NNP_ (C, S, R, D, Q);\\ninput C, S, R, D;\\noutput reg Q;\\nalways @(negedge C, negedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSR_NPN_ (C, S, R, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity set and negative\\n//- polarity reset.\\n//-\\n//- Truth table:    C S R D | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 - 1 - - | 1\\n//-                 \\\\ - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFSR_NPN_ (C, S, R, D, Q);\\ninput C, S, R, D;\\noutput reg Q;\\nalways @(negedge C, posedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSR_NPP_ (C, S, R, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity set and positive\\n//- polarity reset.\\n//-\\n//- Truth table:    C S R D | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 - 1 - - | 1\\n//-                 \\\\ - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFSR_NPP_ (C, S, R, D, Q);\\ninput C, S, R, D;\\noutput reg Q;\\nalways @(negedge C, posedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSR_PNN_ (C, S, R, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity set and negative\\n//- polarity reset.\\n//-\\n//- Truth table:    C S R D | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 - 0 - - | 1\\n//-                 / - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFSR_PNN_ (C, S, R, D, Q);\\ninput C, S, R, D;\\noutput reg Q;\\nalways @(posedge C, negedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSR_PNP_ (C, S, R, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity set and positive\\n//- polarity reset.\\n//-\\n//- Truth table:    C S R D | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 - 0 - - | 1\\n//-                 / - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFSR_PNP_ (C, S, R, D, Q);\\ninput C, S, R, D;\\noutput reg Q;\\nalways @(posedge C, negedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSR_PPN_ (C, S, R, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity set and negative\\n//- polarity reset.\\n//-\\n//- Truth table:    C S R D | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 - 1 - - | 1\\n//-                 / - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFSR_PPN_ (C, S, R, D, Q);\\ninput C, S, R, D;\\noutput reg Q;\\nalways @(posedge C, posedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSR_PPP_ (C, S, R, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity set and positive\\n//- polarity reset.\\n//-\\n//- Truth table:    C S R D | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 - 1 - - | 1\\n//-                 / - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DFFSR_PPP_ (C, S, R, D, Q);\\ninput C, S, R, D;\\noutput reg Q;\\nalways @(posedge C, posedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_NNNN_ (C, S, R, E, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity set, negative\\n//- polarity reset and negative polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 0 - - | 0\\n//-                 - 0 - - - | 1\\n//-                 \\\\ - - 0 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_NNNN_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(negedge C, negedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n        else if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_NNNP_ (C, S, R, E, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity set, negative\\n//- polarity reset and positive polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 0 - - | 0\\n//-                 - 0 - - - | 1\\n//-                 \\\\ - - 1 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_NNNP_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(negedge C, negedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n        else if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_NNPN_ (C, S, R, E, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity set, positive\\n//- polarity reset and negative polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 1 - - | 0\\n//-                 - 0 - - - | 1\\n//-                 \\\\ - - 0 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_NNPN_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(negedge C, negedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n        else if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_NNPP_ (C, S, R, E, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity set, positive\\n//- polarity reset and positive polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 1 - - | 0\\n//-                 - 0 - - - | 1\\n//-                 \\\\ - - 1 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_NNPP_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(negedge C, negedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n        else if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_NPNN_ (C, S, R, E, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity set, negative\\n//- polarity reset and negative polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 0 - - | 0\\n//-                 - 1 - - - | 1\\n//-                 \\\\ - - 0 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_NPNN_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(negedge C, posedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n        else if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_NPNP_ (C, S, R, E, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity set, negative\\n//- polarity reset and positive polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 0 - - | 0\\n//-                 - 1 - - - | 1\\n//-                 \\\\ - - 1 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_NPNP_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(negedge C, posedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n        else if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_NPPN_ (C, S, R, E, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity set, positive\\n//- polarity reset and negative polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 1 - - | 0\\n//-                 - 1 - - - | 1\\n//-                 \\\\ - - 0 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_NPPN_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(negedge C, posedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n        else if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_NPPP_ (C, S, R, E, D, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity set, positive\\n//- polarity reset and positive polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 1 - - | 0\\n//-                 - 1 - - - | 1\\n//-                 \\\\ - - 1 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_NPPP_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(negedge C, posedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n        else if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_PNNN_ (C, S, R, E, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity set, negative\\n//- polarity reset and negative polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 0 - - | 0\\n//-                 - 0 - - - | 1\\n//-                 / - - 0 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_PNNN_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(posedge C, negedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n        else if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_PNNP_ (C, S, R, E, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity set, negative\\n//- polarity reset and positive polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 0 - - | 0\\n//-                 - 0 - - - | 1\\n//-                 / - - 1 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_PNNP_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(posedge C, negedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n        else if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_PNPN_ (C, S, R, E, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity set, positive\\n//- polarity reset and negative polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 1 - - | 0\\n//-                 - 0 - - - | 1\\n//-                 / - - 0 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_PNPN_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(posedge C, negedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n        else if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_PNPP_ (C, S, R, E, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity set, positive\\n//- polarity reset and positive polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 1 - - | 0\\n//-                 - 0 - - - | 1\\n//-                 / - - 1 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_PNPP_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(posedge C, negedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n        else if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_PPNN_ (C, S, R, E, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity set, negative\\n//- polarity reset and negative polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 0 - - | 0\\n//-                 - 1 - - - | 1\\n//-                 / - - 0 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_PPNN_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(posedge C, posedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n        else if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_PPNP_ (C, S, R, E, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity set, negative\\n//- polarity reset and positive polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 0 - - | 0\\n//-                 - 1 - - - | 1\\n//-                 / - - 1 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_PPNP_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(posedge C, posedge S, negedge R) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n        else if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_PPPN_ (C, S, R, E, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity set, positive\\n//- polarity reset and negative polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 1 - - | 0\\n//-                 - 1 - - - | 1\\n//-                 / - - 0 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_PPPN_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(posedge C, posedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n        else if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DFFSRE_PPPP_ (C, S, R, E, D, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity set, positive\\n//- polarity reset and positive polarity clock enable.\\n//-\\n//- Truth table:    C S R E D | Q\\n//-                -----------+---\\n//-                 - - 1 - - | 0\\n//-                 - 1 - - - | 1\\n//-                 / - - 1 d | d\\n//-                 - - - - - | q\\n//-\\nmodule \\\\$_DFFSRE_PPPP_ (C, S, R, E, D, Q);\\ninput C, S, R, E, D;\\noutput reg Q;\\nalways @(posedge C, posedge S, posedge R) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n        else if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFF_NN0_ (D, C, R, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous reset.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - \\\\ 0 | 0\\n//-                 d \\\\ - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_SDFF_NN0_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFF_NN1_ (D, C, R, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous set.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - \\\\ 0 | 1\\n//-                 d \\\\ - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_SDFF_NN1_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFF_NP0_ (D, C, R, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous reset.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - \\\\ 1 | 0\\n//-                 d \\\\ - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_SDFF_NP0_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFF_NP1_ (D, C, R, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous set.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - \\\\ 1 | 1\\n//-                 d \\\\ - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_SDFF_NP1_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFF_PN0_ (D, C, R, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous reset.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - / 0 | 0\\n//-                 d / - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_SDFF_PN0_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFF_PN1_ (D, C, R, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous set.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - / 0 | 1\\n//-                 d / - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_SDFF_PN1_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFF_PP0_ (D, C, R, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous reset.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - / 1 | 0\\n//-                 d / - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_SDFF_PP0_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFF_PP1_ (D, C, R, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous set.\\n//-\\n//- Truth table:    D C R | Q\\n//-                -------+---\\n//-                 - / 1 | 1\\n//-                 d / - | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_SDFF_PP1_ (D, C, R, Q);\\ninput D, C, R;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_NN0N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous reset and negative\\n//- polarity clock enable (with reset having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 0 - | 0\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_NN0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_NN0P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous reset and positive\\n//- polarity clock enable (with reset having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 0 - | 0\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_NN0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_NN1N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous set and negative\\n//- polarity clock enable (with set having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 0 - | 1\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_NN1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_NN1P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous set and positive\\n//- polarity clock enable (with set having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 0 - | 1\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_NN1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_NP0N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous reset and negative\\n//- polarity clock enable (with reset having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 1 - | 0\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_NP0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_NP0P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous reset and positive\\n//- polarity clock enable (with reset having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 1 - | 0\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_NP0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_NP1N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous set and negative\\n//- polarity clock enable (with set having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 1 - | 1\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_NP1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_NP1P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous set and positive\\n//- polarity clock enable (with set having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 1 - | 1\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_NP1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_PN0N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous reset and negative\\n//- polarity clock enable (with reset having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 0 - | 0\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_PN0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_PN0P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous reset and positive\\n//- polarity clock enable (with reset having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 0 - | 0\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_PN0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_PN1N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous set and negative\\n//- polarity clock enable (with set having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 0 - | 1\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_PN1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_PN1P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous set and positive\\n//- polarity clock enable (with set having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 0 - | 1\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_PN1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_PP0N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous reset and negative\\n//- polarity clock enable (with reset having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 1 - | 0\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_PP0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_PP0P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous reset and positive\\n//- polarity clock enable (with reset having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 1 - | 0\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_PP0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_PP1N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous set and negative\\n//- polarity clock enable (with set having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 1 - | 1\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_PP1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFE_PP1P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous set and positive\\n//- polarity clock enable (with set having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 1 - | 1\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFE_PP1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (R == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_NN0N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous reset and negative\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 0 0 | 0\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_NN0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (E == 0) begin\\n\\t\\tif (R == 0)\\n\\t\\t\\tQ <= 0;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_NN0P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous reset and positive\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 0 1 | 0\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_NN0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (E == 1) begin\\n\\t\\tif (R == 0)\\n\\t\\t\\tQ <= 0;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_NN1N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous set and negative\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 0 0 | 1\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_NN1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (E == 0) begin\\n\\t\\tif (R == 0)\\n\\t\\t\\tQ <= 1;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_NN1P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with negative polarity synchronous set and positive\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 0 1 | 1\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_NN1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (E == 1) begin\\n\\t\\tif (R == 0)\\n\\t\\t\\tQ <= 1;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_NP0N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous reset and negative\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 1 0 | 0\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_NP0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (E == 0) begin\\n\\t\\tif (R == 1)\\n\\t\\t\\tQ <= 0;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_NP0P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous reset and positive\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 1 1 | 0\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_NP0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (E == 1) begin\\n\\t\\tif (R == 1)\\n\\t\\t\\tQ <= 0;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_NP1N_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous set and negative\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 1 0 | 1\\n//-                 d \\\\ - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_NP1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (E == 0) begin\\n\\t\\tif (R == 1)\\n\\t\\t\\tQ <= 1;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_NP1P_ (D, C, R, E, Q)\\n//-\\n//- A negative edge D-type flip-flop with positive polarity synchronous set and positive\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - \\\\ 1 1 | 1\\n//-                 d \\\\ - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_NP1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(negedge C) begin\\n\\tif (E == 1) begin\\n\\t\\tif (R == 1)\\n\\t\\t\\tQ <= 1;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_PN0N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous reset and negative\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 0 0 | 0\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_PN0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (E == 0) begin\\n\\t\\tif (R == 0)\\n\\t\\t\\tQ <= 0;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_PN0P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous reset and positive\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 0 1 | 0\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_PN0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (E == 1) begin\\n\\t\\tif (R == 0)\\n\\t\\t\\tQ <= 0;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_PN1N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous set and negative\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 0 0 | 1\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_PN1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (E == 0) begin\\n\\t\\tif (R == 0)\\n\\t\\t\\tQ <= 1;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_PN1P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with negative polarity synchronous set and positive\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 0 1 | 1\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_PN1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (E == 1) begin\\n\\t\\tif (R == 0)\\n\\t\\t\\tQ <= 1;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_PP0N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous reset and negative\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 1 0 | 0\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_PP0N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (E == 0) begin\\n\\t\\tif (R == 1)\\n\\t\\t\\tQ <= 0;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_PP0P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous reset and positive\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 1 1 | 0\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_PP0P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (E == 1) begin\\n\\t\\tif (R == 1)\\n\\t\\t\\tQ <= 0;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_PP1N_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous set and negative\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 1 0 | 1\\n//-                 d / - 0 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_PP1N_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (E == 0) begin\\n\\t\\tif (R == 1)\\n\\t\\t\\tQ <= 1;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_SDFFCE_PP1P_ (D, C, R, E, Q)\\n//-\\n//- A positive edge D-type flip-flop with positive polarity synchronous set and positive\\n//- polarity clock enable (with clock enable having priority).\\n//-\\n//- Truth table:    D C R E | Q\\n//-                ---------+---\\n//-                 - / 1 1 | 1\\n//-                 d / - 1 | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_SDFFCE_PP1P_ (D, C, R, E, Q);\\ninput D, C, R, E;\\noutput reg Q;\\nalways @(posedge C) begin\\n\\tif (E == 1) begin\\n\\t\\tif (R == 1)\\n\\t\\t\\tQ <= 1;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_N_ (E, D, Q)\\n//-\\n//- A negative enable D-type latch.\\n//-\\n//- Truth table:    E D | Q\\n//-                -----+---\\n//-                 0 d | d\\n//-                 - - | q\\n//-\\nmodule \\\\$_DLATCH_N_ (E, D, Q);\\ninput E, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_P_ (E, D, Q)\\n//-\\n//- A positive enable D-type latch.\\n//-\\n//- Truth table:    E D | Q\\n//-                -----+---\\n//-                 1 d | d\\n//-                 - - | q\\n//-\\nmodule \\\\$_DLATCH_P_ (E, D, Q);\\ninput E, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_NN0_ (E, R, D, Q)\\n//-\\n//- A negative enable D-type latch with negative polarity reset.\\n//-\\n//- Truth table:    E R D | Q\\n//-                -------+---\\n//-                 - 0 - | 0\\n//-                 0 - d | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DLATCH_NN0_ (E, R, D, Q);\\ninput E, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n                Q <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_NN1_ (E, R, D, Q)\\n//-\\n//- A negative enable D-type latch with negative polarity set.\\n//-\\n//- Truth table:    E R D | Q\\n//-                -------+---\\n//-                 - 0 - | 1\\n//-                 0 - d | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DLATCH_NN1_ (E, R, D, Q);\\ninput E, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n                Q <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_NP0_ (E, R, D, Q)\\n//-\\n//- A negative enable D-type latch with positive polarity reset.\\n//-\\n//- Truth table:    E R D | Q\\n//-                -------+---\\n//-                 - 1 - | 0\\n//-                 0 - d | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DLATCH_NP0_ (E, R, D, Q);\\ninput E, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n                Q <= 0;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_NP1_ (E, R, D, Q)\\n//-\\n//- A negative enable D-type latch with positive polarity set.\\n//-\\n//- Truth table:    E R D | Q\\n//-                -------+---\\n//-                 - 1 - | 1\\n//-                 0 - d | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DLATCH_NP1_ (E, R, D, Q);\\ninput E, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n                Q <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_PN0_ (E, R, D, Q)\\n//-\\n//- A positive enable D-type latch with negative polarity reset.\\n//-\\n//- Truth table:    E R D | Q\\n//-                -------+---\\n//-                 - 0 - | 0\\n//-                 1 - d | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DLATCH_PN0_ (E, R, D, Q);\\ninput E, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n                Q <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_PN1_ (E, R, D, Q)\\n//-\\n//- A positive enable D-type latch with negative polarity set.\\n//-\\n//- Truth table:    E R D | Q\\n//-                -------+---\\n//-                 - 0 - | 1\\n//-                 1 - d | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DLATCH_PN1_ (E, R, D, Q);\\ninput E, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n                Q <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_PP0_ (E, R, D, Q)\\n//-\\n//- A positive enable D-type latch with positive polarity reset.\\n//-\\n//- Truth table:    E R D | Q\\n//-                -------+---\\n//-                 - 1 - | 0\\n//-                 1 - d | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DLATCH_PP0_ (E, R, D, Q);\\ninput E, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n                Q <= 0;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCH_PP1_ (E, R, D, Q)\\n//-\\n//- A positive enable D-type latch with positive polarity set.\\n//-\\n//- Truth table:    E R D | Q\\n//-                -------+---\\n//-                 - 1 - | 1\\n//-                 1 - d | d\\n//-                 - - - | q\\n//-\\nmodule \\\\$_DLATCH_PP1_ (E, R, D, Q);\\ninput E, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n                Q <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCHSR_NNN_ (E, S, R, D, Q)\\n//-\\n//- A negative enable D-type latch with negative polarity set and negative\\n//- polarity reset.\\n//-\\n//- Truth table:    E S R D | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 - 0 - - | 1\\n//-                 0 - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DLATCHSR_NNN_ (E, S, R, D, Q);\\ninput E, S, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCHSR_NNP_ (E, S, R, D, Q)\\n//-\\n//- A negative enable D-type latch with negative polarity set and positive\\n//- polarity reset.\\n//-\\n//- Truth table:    E S R D | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 - 0 - - | 1\\n//-                 0 - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DLATCHSR_NNP_ (E, S, R, D, Q);\\ninput E, S, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCHSR_NPN_ (E, S, R, D, Q)\\n//-\\n//- A negative enable D-type latch with positive polarity set and negative\\n//- polarity reset.\\n//-\\n//- Truth table:    E S R D | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 - 1 - - | 1\\n//-                 0 - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DLATCHSR_NPN_ (E, S, R, D, Q);\\ninput E, S, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCHSR_NPP_ (E, S, R, D, Q)\\n//-\\n//- A negative enable D-type latch with positive polarity set and positive\\n//- polarity reset.\\n//-\\n//- Truth table:    E S R D | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 - 1 - - | 1\\n//-                 0 - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DLATCHSR_NPP_ (E, S, R, D, Q);\\ninput E, S, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 0)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCHSR_PNN_ (E, S, R, D, Q)\\n//-\\n//- A positive enable D-type latch with negative polarity set and negative\\n//- polarity reset.\\n//-\\n//- Truth table:    E S R D | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 - 0 - - | 1\\n//-                 1 - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DLATCHSR_PNN_ (E, S, R, D, Q);\\ninput E, S, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCHSR_PNP_ (E, S, R, D, Q)\\n//-\\n//- A positive enable D-type latch with negative polarity set and positive\\n//- polarity reset.\\n//-\\n//- Truth table:    E S R D | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 - 0 - - | 1\\n//-                 1 - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DLATCHSR_PNP_ (E, S, R, D, Q);\\ninput E, S, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 0)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCHSR_PPN_ (E, S, R, D, Q)\\n//-\\n//- A positive enable D-type latch with positive polarity set and negative\\n//- polarity reset.\\n//-\\n//- Truth table:    E S R D | Q\\n//-                ---------+---\\n//-                 - - 0 - | 0\\n//-                 - 1 - - | 1\\n//-                 1 - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DLATCHSR_PPN_ (E, S, R, D, Q);\\ninput E, S, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 0)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $_DLATCHSR_PPP_ (E, S, R, D, Q)\\n//-\\n//- A positive enable D-type latch with positive polarity set and positive\\n//- polarity reset.\\n//-\\n//- Truth table:    E S R D | Q\\n//-                ---------+---\\n//-                 - - 1 - | 0\\n//-                 - 1 - - | 1\\n//-                 1 - - d | d\\n//-                 - - - - | q\\n//-\\nmodule \\\\$_DLATCHSR_PPP_ (E, S, R, D, Q);\\ninput E, S, R, D;\\noutput reg Q;\\nalways @* begin\\n\\tif (R == 1)\\n\\t\\tQ <= 0;\\n\\telse if (S == 1)\\n\\t\\tQ <= 1;\\n\\telse if (E == 1)\\n\\t\\tQ <= D;\\nend\\nendmodule\\n\",\n        \"simlib.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n *  ---\\n *\\n *  The Simulation Library.\\n *\\n *  This Verilog library contains simple simulation models for the internal\\n *  cells ($not, ...) generated by the frontends and used in most passes.\\n *\\n *  This library can be used to verify the internal netlists as generated\\n *  by the different frontends and passes.\\n *\\n *  Note that memory can only be simulated when all $memrd and $memwr cells\\n *  have been merged to stand-alone $mem cells (this is what the \\\"memory_collect\\\"\\n *  pass is doing).\\n *\\n */\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $not (A, Y)\\n//-\\n//- A bit-wise inverter. This corresponds to the Verilog unary prefix '~' operator.\\n//-\\nmodule \\\\$not (A, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = ~$signed(A);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = ~A;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $pos (A, Y)\\n//-\\n//- A buffer. This corresponds to the Verilog unary prefix '+' operator.\\n//-\\nmodule \\\\$pos (A, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $neg (A, Y)\\n//-\\n//- An arithmetic inverter. This corresponds to the Verilog unary prefix '-' operator.\\n//-\\nmodule \\\\$neg (A, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = -$signed(A);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = -A;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $and (A, B, Y)\\n//-\\n//- A bit-wise AND. This corresponds to the Verilog '&' operator.\\n//-\\nmodule \\\\$and (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) & $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A & B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $or (A, B, Y)\\n//-\\n//- A bit-wise OR. This corresponds to the Verilog '|' operator.\\n//-\\nmodule \\\\$or (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) | $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A | B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $xor (A, B, Y)\\n//-\\n//- A bit-wise XOR. This corresponds to the Verilog '^' operator.\\n//-\\nmodule \\\\$xor (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) ^ $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A ^ B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $xnor (A, B, Y)\\n//-\\n//- A bit-wise XNOR. This corresponds to the Verilog '~^' operator.\\n//-\\nmodule \\\\$xnor (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) ~^ $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A ~^ B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $reduce_and (A, Y)\\n//-\\n//- An AND reduction. This corresponds to the Verilog unary prefix '&' operator.\\n//-\\nmodule \\\\$reduce_and (A, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = &$signed(A);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = &A;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $reduce_or (A, Y)\\n//-\\n//- An OR reduction. This corresponds to the Verilog unary prefix '|' operator.\\n//-\\nmodule \\\\$reduce_or (A, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = |$signed(A);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = |A;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $reduce_xor (A, Y)\\n//-\\n//- A XOR reduction. This corresponds to the Verilog unary prefix '^' operator.\\n//-\\nmodule \\\\$reduce_xor (A, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = ^$signed(A);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = ^A;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $reduce_xnor (A, Y)\\n//-\\n//- A XNOR reduction. This corresponds to the Verilog unary prefix '~^' operator.\\n//-\\nmodule \\\\$reduce_xnor (A, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = ~^$signed(A);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = ~^A;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $reduce_bool (A, Y)\\n//-\\n//- An OR reduction. This cell type is used instead of $reduce_or when a signal is\\n//- implicitly converted to a boolean signal, e.g. for operands of '&&' and '||'.\\n//-\\nmodule \\\\$reduce_bool (A, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = !(!$signed(A));\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = !(!A);\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$shl (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) << B;\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A << B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$shr (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) >> B;\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A >> B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$sshl (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) <<< B;\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A <<< B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$sshr (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) >>> B;\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A >>> B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$shift (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tif (B_SIGNED) begin:BLOCK2\\n\\t\\t\\tassign Y = $signed(B) < 0 ? $signed(A) << -B : $signed(A) >> B;\\n\\t\\tend else begin:BLOCK3\\n\\t\\t\\tassign Y = $signed(A) >> B;\\n\\t\\tend\\n\\tend else begin:BLOCK4\\n\\t\\tif (B_SIGNED) begin:BLOCK5\\n\\t\\t\\tassign Y = $signed(B) < 0 ? A << -B : A >> B;\\n\\t\\tend else begin:BLOCK6\\n\\t\\t\\tassign Y = A >> B;\\n\\t\\tend\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$shiftx (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (Y_WIDTH > 0)\\n\\t\\tif (B_SIGNED) begin:BLOCK1\\n\\t\\t\\tassign Y = A[$signed(B) +: Y_WIDTH];\\n\\t\\tend else begin:BLOCK2\\n\\t\\t\\tassign Y = A[B +: Y_WIDTH];\\n\\t\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$fa (A, B, C, X, Y);\\n\\nparameter WIDTH = 1;\\n\\ninput [WIDTH-1:0] A, B, C;\\noutput [WIDTH-1:0] X, Y;\\n\\nwire [WIDTH-1:0] t1, t2, t3;\\n\\nassign t1 = A ^ B, t2 = A & B, t3 = C & t1;\\nassign Y = t1 ^ C, X = (t2 | t3) ^ (Y ^ Y);\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $lcu (P, G, CI, CO)\\n//-\\n//- Lookahead carry unit\\n//- A building block dedicated to fast computation of carry-bits used in binary\\n//- arithmetic operations. By replacing the ripple carry structure used in full-adder\\n//- blocks, the more significant  bits of the sum can be expected to be computed more\\n//- quickly.\\n//- Typically created during `techmap` of $alu cells (see the \\\"_90_alu\\\" rule in\\n//- +/techmap.v).\\nmodule \\\\$lcu (P, G, CI, CO);\\n\\nparameter WIDTH = 1;\\n\\ninput [WIDTH-1:0] P;    // Propagate\\ninput [WIDTH-1:0] G;    // Generate\\ninput CI;               // Carry-in\\n\\noutput reg [WIDTH-1:0] CO; // Carry-out\\n\\ninteger i;\\nalways @* begin\\n\\tCO = 'bx;\\n\\tif (^{P, G, CI} !== 1'bx) begin\\n\\t\\tCO[0] = G[0] || (P[0] && CI);\\n\\t\\tfor (i = 1; i < WIDTH; i = i+1)\\n\\t\\t\\tCO[i] = G[i] || (P[i] && CO[i-1]);\\n\\tend\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $alu (A, B, CI, BI, X, Y, CO)\\n//-\\n//- Arithmetic logic unit.\\n//- A building block supporting both binary addition/subtraction operations, and\\n//- indirectly, comparison operations.\\n//- Typically created by the `alumacc` pass, which transforms:\\n//-   $add, $sub, $lt, $le, $ge, $gt, $eq, $eqx, $ne, $nex\\n//- cells into this $alu cell.\\n//-\\nmodule \\\\$alu (A, B, CI, BI, X, Y, CO);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 1;\\nparameter B_WIDTH = 1;\\nparameter Y_WIDTH = 1;\\n\\ninput [A_WIDTH-1:0] A;      // Input operand\\ninput [B_WIDTH-1:0] B;      // Input operand\\noutput [Y_WIDTH-1:0] X;     // A xor B (sign-extended, optional B inversion,\\n                            //          used in combination with\\n                            //          reduction-AND for $eq/$ne ops)\\noutput [Y_WIDTH-1:0] Y;     // Sum\\n\\ninput CI;                   // Carry-in (set for $sub)\\ninput BI;                   // Invert-B (set for $sub)\\noutput [Y_WIDTH-1:0] CO;    // Carry-out\\n\\nwire [Y_WIDTH-1:0] AA, BB;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign AA = $signed(A), BB = BI ? ~$signed(B) : $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign AA = $unsigned(A), BB = BI ? ~$unsigned(B) : $unsigned(B);\\n\\tend\\nendgenerate\\n\\n// this is 'x' if Y and CO should be all 'x', and '0' otherwise\\nwire y_co_undef = ^{A, A, B, B, CI, CI, BI, BI};\\n\\nassign X = AA ^ BB;\\n// Full adder\\nassign Y = (AA + BB + CI) ^ {Y_WIDTH{y_co_undef}};\\n\\nfunction get_carry;\\n\\tinput a, b, c;\\n\\tget_carry = (a&b) | (a&c) | (b&c);\\nendfunction\\n\\ngenvar i;\\ngenerate\\n\\tassign CO[0] = get_carry(AA[0], BB[0], CI) ^ y_co_undef;\\n\\tfor (i = 1; i < Y_WIDTH; i = i+1) begin:BLOCK3\\n\\t\\tassign CO[i] = get_carry(AA[i], BB[i], CO[i-1]) ^ y_co_undef;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$lt (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) < $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A < B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$le (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) <= $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A <= B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$eq (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) == $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A == B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$ne (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) != $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A != B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$eqx (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) === $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A === B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$nex (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) !== $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A !== B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$ge (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) >= $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A >= B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$gt (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) > $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A > B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$add (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) + $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A + B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$sub (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) - $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A - B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$mul (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) * $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A * B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $macc (A, B, Y)\\n//-\\n//- Multiply and accumulate.\\n//- A building block for summing any number of negated and unnegated signals\\n//- and arithmetic products of pairs of signals. Cell port A concatenates pairs\\n//- of signals to be multiplied together. When the second signal in a pair is zero\\n//- length, a constant 1 is used instead as the second factor. Cell port B\\n//- concatenates 1-bit-wide signals to also be summed, such as \\\"carry in\\\" in adders.\\n//- Typically created by the `alumacc` pass, which transforms $add and $mul\\n//- into $macc cells.\\nmodule \\\\$macc (A, B, Y);\\n\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n// CONFIG determines the layout of A, as explained below\\nparameter CONFIG = 4'b0000;\\nparameter CONFIG_WIDTH = 4;\\n\\n// In the terms used for this cell, there's mixed meanings for the term \\\"port\\\". To disambiguate:\\n// A cell port is for example the A input (it is constructed in C++ as cell->setPort(ID::A, ...))\\n// Multiplier ports are pairs of multiplier inputs (\\\"factors\\\").\\n// If the second signal in such a pair is zero length, no multiplication is necessary, and the first signal is just added to the sum.\\ninput [A_WIDTH-1:0] A; // Cell port A is the concatenation of all arithmetic ports\\ninput [B_WIDTH-1:0] B; // Cell port B is the concatenation of single-bit unsigned signals to be also added to the sum\\noutput reg [Y_WIDTH-1:0] Y; // Output sum\\n\\n// Xilinx XSIM does not like $clog2() below..\\nfunction integer my_clog2;\\n\\tinput integer v;\\n\\tbegin\\n\\t\\tif (v > 0)\\n\\t\\t\\tv = v - 1;\\n\\t\\tmy_clog2 = 0;\\n\\t\\twhile (v) begin\\n\\t\\t\\tv = v >> 1;\\n\\t\\t\\tmy_clog2 = my_clog2 + 1;\\n\\t\\tend\\n\\tend\\nendfunction\\n\\n// Bits that a factor's length field in CONFIG per factor in cell port A\\nlocalparam integer num_bits = CONFIG[3:0] > 0 ? CONFIG[3:0] : 1;\\n// Number of multiplier ports\\nlocalparam integer num_ports = (CONFIG_WIDTH-4) / (2 + 2*num_bits);\\n// Minium bit width of an induction variable to iterate over all bits of cell port A\\nlocalparam integer num_abits = my_clog2(A_WIDTH) > 0 ? my_clog2(A_WIDTH) : 1;\\n\\n// In this pseudocode, u(foo) means an unsigned int that's foo bits long.\\n// The CONFIG parameter carries the following information:\\n//\\tstruct CONFIG {\\n//\\t\\tu4 num_bits;\\n//\\t\\tstruct port_field {\\n//\\t\\t\\tbool is_signed;\\n//\\t\\t\\tbool is_subtract;\\n//\\t\\t\\tu(num_bits) factor1_len;\\n//\\t\\t\\tu(num_bits) factor2_len;\\n//\\t\\t}[num_ports];\\n//\\t};\\n\\n// The A cell port carries the following information:\\n//\\tstruct A {\\n//\\t\\tu(CONFIG.port_field[0].factor1_len) port0factor1;\\n//\\t\\tu(CONFIG.port_field[0].factor2_len) port0factor2;\\n//\\t\\tu(CONFIG.port_field[1].factor1_len) port1factor1;\\n//\\t\\tu(CONFIG.port_field[1].factor2_len) port1factor2;\\n//\\t\\t...\\n//\\t};\\n// and log(sizeof(A)) is num_abits.\\n// No factor1 may have a zero length.\\n// A factor2 having a zero length implies factor2 is replaced with a constant 1.\\n\\n// Additionally, B is an array of 1-bit-wide unsigned integers to also be summed up.\\n// Finally, we have:\\n// Y = port0factor1 * port0factor2 + port1factor1 * port1factor2 + ...\\n//     * B[0] + B[1] + ...\\n\\nfunction [2*num_ports*num_abits-1:0] get_port_offsets;\\n\\tinput [CONFIG_WIDTH-1:0] cfg;\\n\\tinteger i, cursor;\\n\\tbegin\\n\\t\\tcursor = 0;\\n\\t\\tget_port_offsets = 0;\\n\\t\\tfor (i = 0; i < num_ports; i = i+1) begin\\n\\t\\t\\tget_port_offsets[(2*i + 0)*num_abits +: num_abits] = cursor;\\n\\t\\t\\tcursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 +: num_bits];\\n\\t\\t\\tget_port_offsets[(2*i + 1)*num_abits +: num_abits] = cursor;\\n\\t\\t\\tcursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits];\\n\\t\\tend\\n\\tend\\nendfunction\\n\\nlocalparam [2*num_ports*num_abits-1:0] port_offsets = get_port_offsets(CONFIG);\\n\\n`define PORT_IS_SIGNED   (0 + CONFIG[4 + i*(2 + 2*num_bits)])\\n`define PORT_DO_SUBTRACT (0 + CONFIG[4 + i*(2 + 2*num_bits) + 1])\\n`define PORT_SIZE_A      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 +: num_bits])\\n`define PORT_SIZE_B      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits])\\n`define PORT_OFFSET_A    (0 + port_offsets[2*i*num_abits +: num_abits])\\n`define PORT_OFFSET_B    (0 + port_offsets[2*i*num_abits + num_abits +: num_abits])\\n\\ninteger i, j;\\nreg [Y_WIDTH-1:0] tmp_a, tmp_b;\\n\\nalways @* begin\\n\\tY = 0;\\n\\tfor (i = 0; i < num_ports; i = i+1)\\n\\tbegin\\n\\t\\ttmp_a = 0;\\n\\t\\ttmp_b = 0;\\n\\n\\t\\tfor (j = 0; j < `PORT_SIZE_A; j = j+1)\\n\\t\\t\\ttmp_a[j] = A[`PORT_OFFSET_A + j];\\n\\n\\t\\tif (`PORT_IS_SIGNED && `PORT_SIZE_A > 0)\\n\\t\\t\\tfor (j = `PORT_SIZE_A; j < Y_WIDTH; j = j+1)\\n\\t\\t\\t\\ttmp_a[j] = tmp_a[`PORT_SIZE_A-1];\\n\\n\\t\\tfor (j = 0; j < `PORT_SIZE_B; j = j+1)\\n\\t\\t\\ttmp_b[j] = A[`PORT_OFFSET_B + j];\\n\\n\\t\\tif (`PORT_IS_SIGNED && `PORT_SIZE_B > 0)\\n\\t\\t\\tfor (j = `PORT_SIZE_B; j < Y_WIDTH; j = j+1)\\n\\t\\t\\t\\ttmp_b[j] = tmp_b[`PORT_SIZE_B-1];\\n\\n\\t\\tif (`PORT_SIZE_B > 0)\\n\\t\\t\\ttmp_a = tmp_a * tmp_b;\\n\\n\\t\\tif (`PORT_DO_SUBTRACT)\\n\\t\\t\\tY = Y - tmp_a;\\n\\t\\telse\\n\\t\\t\\tY = Y + tmp_a;\\n\\tend\\n\\tfor (i = 0; i < B_WIDTH; i = i+1) begin\\n\\t\\tY = Y + B[i];\\n\\tend\\nend\\n\\n`undef PORT_IS_SIGNED\\n`undef PORT_DO_SUBTRACT\\n`undef PORT_SIZE_A\\n`undef PORT_SIZE_B\\n`undef PORT_OFFSET_A\\n`undef PORT_OFFSET_B\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $div (A, B, Y)\\n//-\\n//- Division with truncated result (rounded towards 0).\\n//-\\nmodule \\\\$div (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) / $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A / B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $mod (A, B, Y)\\n//-\\n//- Modulo/remainder of division with truncated result (rounded towards 0).\\n//-\\n//- Invariant: $div(A, B) * B + $mod(A, B) == A\\n//-\\nmodule \\\\$mod (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) % $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A % B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $divfloor (A, B, Y)\\n//-\\n//- Division with floored result (rounded towards negative infinity).\\n//-\\nmodule \\\\$divfloor (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tlocalparam WIDTH =\\n\\t\\t\\t\\tA_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :\\n\\t\\t\\t\\tB_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;\\n\\t\\twire [WIDTH:0] A_buf, B_buf, N_buf;\\n\\t\\tassign A_buf = $signed(A);\\n\\t\\tassign B_buf = $signed(B);\\n\\t\\tassign N_buf = (A[A_WIDTH-1] == B[B_WIDTH-1]) || A == 0 ? A_buf : $signed(A_buf - (B[B_WIDTH-1] ? B_buf+1 : B_buf-1));\\n\\t\\tassign Y = $signed(N_buf) / $signed(B_buf);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A / B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n//  |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|\\n//-\\n//-     $modfloor (A, B, Y)\\n//-\\n//- Modulo/remainder of division with floored result (rounded towards negative infinity).\\n//-\\n//- Invariant: $divfloor(A, B) * B + $modfloor(A, B) == A\\n//-\\nmodule \\\\$modfloor (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tlocalparam WIDTH = B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;\\n\\t\\twire [WIDTH-1:0] B_buf, Y_trunc;\\n\\t\\tassign B_buf = $signed(B);\\n\\t\\tassign Y_trunc = $signed(A) % $signed(B);\\n\\t\\t// flooring mod is the same as truncating mod for positive division results (A and B have\\n\\t\\t// the same sign), as well as when there's no remainder.\\n\\t\\t// For all other cases, they behave as `floor - trunc = B`\\n\\t\\tassign Y = (A[A_WIDTH-1] == B[B_WIDTH-1]) || Y_trunc == 0 ? Y_trunc : $signed(B_buf) + $signed(Y_trunc);\\n\\tend else begin:BLOCK2\\n\\t\\t// no difference between truncating and flooring for unsigned\\n\\t\\tassign Y = A % B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n`ifndef SIMLIB_NOPOW\\n\\nmodule \\\\$pow (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) ** $signed(B);\\n\\tend else if (A_SIGNED) begin:BLOCK2\\n\\t\\tassign Y = $signed(A) ** B;\\n\\tend else if (B_SIGNED) begin:BLOCK3\\n\\t\\tassign Y = A ** $signed(B);\\n\\tend else begin:BLOCK4\\n\\t\\tassign Y = A ** B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n`endif\\n// --------------------------------------------------------\\n\\nmodule \\\\$logic_not (A, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = !$signed(A);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = !A;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$logic_and (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) && $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A && B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$logic_or (A, B, Y);\\n\\nparameter A_SIGNED = 0;\\nparameter B_SIGNED = 0;\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [Y_WIDTH-1:0] Y;\\n\\ngenerate\\n\\tif (A_SIGNED && B_SIGNED) begin:BLOCK1\\n\\t\\tassign Y = $signed(A) || $signed(B);\\n\\tend else begin:BLOCK2\\n\\t\\tassign Y = A || B;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$slice (A, Y);\\n\\nparameter OFFSET = 0;\\nparameter A_WIDTH = 0;\\nparameter Y_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\noutput [Y_WIDTH-1:0] Y;\\n\\nassign Y = A >> OFFSET;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$concat (A, B, Y);\\n\\nparameter A_WIDTH = 0;\\nparameter B_WIDTH = 0;\\n\\ninput [A_WIDTH-1:0] A;\\ninput [B_WIDTH-1:0] B;\\noutput [A_WIDTH+B_WIDTH-1:0] Y;\\n\\nassign Y = {B, A};\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$mux (A, B, S, Y);\\n\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] A, B;\\ninput S;\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = S ? B : A;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$bmux (A, S, Y);\\n\\nparameter WIDTH = 0;\\nparameter S_WIDTH = 0;\\n\\ninput [(WIDTH << S_WIDTH)-1:0] A;\\ninput [S_WIDTH-1:0] S;\\noutput [WIDTH-1:0] Y;\\n\\nwire [WIDTH-1:0] bm0_out, bm1_out;\\n\\ngenerate\\n\\tif (S_WIDTH > 1) begin:muxlogic\\n\\t\\t\\\\$bmux #(.WIDTH(WIDTH), .S_WIDTH(S_WIDTH-1)) bm0 (.A(A[(WIDTH << (S_WIDTH - 1))-1:0]), .S(S[S_WIDTH-2:0]), .Y(bm0_out));\\n\\t\\t\\\\$bmux #(.WIDTH(WIDTH), .S_WIDTH(S_WIDTH-1)) bm1 (.A(A[(WIDTH << S_WIDTH)-1:WIDTH << (S_WIDTH - 1)]), .S(S[S_WIDTH-2:0]), .Y(bm1_out));\\n\\t\\tassign Y = S[S_WIDTH-1] ? bm1_out : bm0_out;\\n\\tend else if (S_WIDTH == 1) begin:simple\\n\\t\\tassign Y = S ? A[2*WIDTH-1:WIDTH] : A[WIDTH-1:0];\\n\\tend else begin:passthru\\n\\t\\tassign Y = A;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$pmux (A, B, S, Y);\\n\\nparameter WIDTH = 0;\\nparameter S_WIDTH = 0;\\n\\ninput [WIDTH-1:0] A;\\ninput [WIDTH*S_WIDTH-1:0] B;\\ninput [S_WIDTH-1:0] S;\\noutput reg [WIDTH-1:0] Y;\\n\\ninteger i;\\nreg found_active_sel_bit;\\n\\nalways @* begin\\n\\tY = A;\\n\\tfound_active_sel_bit = 0;\\n\\tfor (i = 0; i < S_WIDTH; i = i+1)\\n\\t\\tcase (S[i])\\n\\t\\t\\t1'b1: begin\\n\\t\\t\\t\\tY = found_active_sel_bit ? 'bx : B >> (WIDTH*i);\\n\\t\\t\\t\\tfound_active_sel_bit = 1;\\n\\t\\t\\tend\\n\\t\\t\\t1'b0: ;\\n\\t\\t\\t1'bx: begin\\n\\t\\t\\t\\tY = 'bx;\\n\\t\\t\\t\\tfound_active_sel_bit = 'bx;\\n\\t\\t\\tend\\n\\t\\tendcase\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$demux (A, S, Y);\\n\\nparameter WIDTH = 1;\\nparameter S_WIDTH = 1;\\n\\ninput [WIDTH-1:0] A;\\ninput [S_WIDTH-1:0] S;\\noutput [(WIDTH << S_WIDTH)-1:0] Y;\\n\\ngenvar i;\\ngenerate\\n\\tfor (i = 0; i < (1 << S_WIDTH); i = i + 1) begin:slices\\n\\t\\tassign Y[i*WIDTH+:WIDTH] = (S == i) ? A : 0;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n`ifndef SIMLIB_NOLUT\\n\\nmodule \\\\$lut (A, Y);\\n\\nparameter WIDTH = 0;\\nparameter LUT = 0;\\n\\ninput [WIDTH-1:0] A;\\noutput Y;\\n\\n\\\\$bmux #(.WIDTH(1), .S_WIDTH(WIDTH)) mux(.A(LUT[(1<<WIDTH)-1:0]), .S(A), .Y(Y));\\n\\nendmodule\\n\\n`endif\\n// --------------------------------------------------------\\n\\nmodule \\\\$sop (A, Y);\\n\\nparameter WIDTH = 0;\\nparameter DEPTH = 0;\\nparameter TABLE = 0;\\n\\ninput [WIDTH-1:0] A;\\noutput reg Y;\\n\\ninteger i, j;\\nreg match;\\n\\nalways @* begin\\n\\tY = 0;\\n\\tfor (i = 0; i < DEPTH; i=i+1) begin\\n\\t\\tmatch = 1;\\n\\t\\tfor (j = 0; j < WIDTH; j=j+1) begin\\n\\t\\t\\tif (TABLE[2*WIDTH*i + 2*j + 0] && A[j]) match = 0;\\n\\t\\t\\tif (TABLE[2*WIDTH*i + 2*j + 1] && !A[j]) match = 0;\\n\\t\\tend\\n\\t\\tif (match) Y = 1;\\n\\tend\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$tribuf (A, EN, Y);\\n\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] A;\\ninput EN;\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = EN ? A : 'bz;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$specify2 (EN, SRC, DST);\\n\\nparameter FULL = 0;\\nparameter SRC_WIDTH = 1;\\nparameter DST_WIDTH = 1;\\n\\nparameter SRC_DST_PEN = 0;\\nparameter SRC_DST_POL = 0;\\n\\nparameter T_RISE_MIN = 0;\\nparameter T_RISE_TYP = 0;\\nparameter T_RISE_MAX = 0;\\n\\nparameter T_FALL_MIN = 0;\\nparameter T_FALL_TYP = 0;\\nparameter T_FALL_MAX = 0;\\n\\ninput EN;\\ninput [SRC_WIDTH-1:0] SRC;\\ninput [DST_WIDTH-1:0] DST;\\n\\nlocalparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;\\n\\n`ifdef SIMLIB_SPECIFY\\nspecify\\n\\tif (EN && SD==0 && !FULL) (SRC  => DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && SD==0 &&  FULL) (SRC  *> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && SD==1 && !FULL) (SRC +=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && SD==1 &&  FULL) (SRC +*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && SD==2 && !FULL) (SRC -=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && SD==2 &&  FULL) (SRC -*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\nendspecify\\n`endif\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$specify3 (EN, SRC, DST, DAT);\\n\\nparameter FULL = 0;\\nparameter SRC_WIDTH = 1;\\nparameter DST_WIDTH = 1;\\n\\nparameter EDGE_EN = 0;\\nparameter EDGE_POL = 0;\\n\\nparameter SRC_DST_PEN = 0;\\nparameter SRC_DST_POL = 0;\\n\\nparameter DAT_DST_PEN = 0;\\nparameter DAT_DST_POL = 0;\\n\\nparameter T_RISE_MIN = 0;\\nparameter T_RISE_TYP = 0;\\nparameter T_RISE_MAX = 0;\\n\\nparameter T_FALL_MIN = 0;\\nparameter T_FALL_TYP = 0;\\nparameter T_FALL_MAX = 0;\\n\\ninput EN;\\ninput [SRC_WIDTH-1:0] SRC;\\ninput [DST_WIDTH-1:0] DST, DAT;\\n\\nlocalparam ED = EDGE_EN     ? (EDGE_POL    ? 1 : 2) : 0;\\nlocalparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;\\nlocalparam DD = DAT_DST_PEN ? (DAT_DST_POL ? 1 : 2) : 0;\\n\\n`ifdef SIMLIB_SPECIFY\\nspecify\\n\\t// DD=0\\n\\n\\tif (EN && DD==0 && SD==0 && ED==0 && !FULL) (        SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\n\\tif (EN && DD==0 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\n\\tif (EN && DD==0 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==0 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\n\\t// DD=1\\n\\n\\tif (EN && DD==1 && SD==0 && ED==0 && !FULL) (        SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\n\\tif (EN && DD==1 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\n\\tif (EN && DD==1 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==1 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\n\\t// DD=2\\n\\n\\tif (EN && DD==2 && SD==0 && ED==0 && !FULL) (        SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\n\\tif (EN && DD==2 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\n\\tif (EN && DD==2 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\n\\tif (EN && DD==2 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\\nendspecify\\n`endif\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$specrule (EN_SRC, EN_DST, SRC, DST);\\n\\nparameter TYPE = \\\"\\\";\\nparameter T_LIMIT = 0;\\nparameter T_LIMIT2 = 0;\\n\\nparameter SRC_WIDTH = 1;\\nparameter DST_WIDTH = 1;\\n\\nparameter SRC_PEN = 0;\\nparameter SRC_POL = 0;\\n\\nparameter DST_PEN = 0;\\nparameter DST_POL = 0;\\n\\ninput EN_SRC, EN_DST;\\ninput [SRC_WIDTH-1:0] SRC;\\ninput [DST_WIDTH-1:0] DST;\\n\\n`ifdef SIMLIB_SPECIFY\\nspecify\\n\\t// TBD\\nendspecify\\n`endif\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$bweqx (A, B, Y);\\n\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] A, B;\\noutput [WIDTH-1:0] Y;\\n\\ngenvar i;\\ngenerate\\n\\tfor (i = 0; i < WIDTH; i = i + 1) begin:slices\\n\\t\\tassign Y[i] = A[i] === B[i];\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$bwmux (A, B, S, Y);\\n\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] A, B;\\ninput [WIDTH-1:0] S;\\noutput [WIDTH-1:0] Y;\\n\\ngenvar i;\\ngenerate\\n\\tfor (i = 0; i < WIDTH; i = i + 1) begin:slices\\n\\t\\tassign Y[i] = S[i] ? B[i] : A[i];\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$assert (A, EN);\\n\\ninput A, EN;\\n\\n`ifndef SIMLIB_NOCHECKS\\nalways @* begin\\n\\tif (A !== 1'b1 && EN === 1'b1) begin\\n\\t\\t$display(\\\"Assertion %m failed!\\\");\\n\\t\\t$stop;\\n\\tend\\nend\\n`endif\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$assume (A, EN);\\n\\ninput A, EN;\\n\\n`ifndef SIMLIB_NOCHECKS\\nalways @* begin\\n\\tif (A !== 1'b1 && EN === 1'b1) begin\\n\\t\\t$display(\\\"Assumption %m failed!\\\");\\n\\t\\t$stop;\\n\\tend\\nend\\n`endif\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$live (A, EN);\\n\\ninput A, EN;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$fair (A, EN);\\n\\ninput A, EN;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$cover (A, EN);\\n\\ninput A, EN;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$initstate (Y);\\n\\noutput reg Y = 1;\\nreg [3:0] cnt = 1;\\nreg trig = 0;\\n\\ninitial trig <= 1;\\n\\nalways @(cnt, trig) begin\\n\\tY <= |cnt;\\n\\tcnt <= cnt + |cnt;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$anyconst (Y);\\n\\nparameter WIDTH = 0;\\n\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = 'bx;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$anyseq (Y);\\n\\nparameter WIDTH = 0;\\n\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = 'bx;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n`ifdef SIMLIB_FF\\n`ifndef SIMLIB_GLOBAL_CLOCK\\n`define SIMLIB_GLOBAL_CLOCK $global_clk\\n`endif\\nmodule \\\\$anyinit (D, Q);\\n\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\n\\ninitial Q <= 'bx;\\n\\nalways @(`SIMLIB_GLOBAL_CLOCK) begin\\n\\tQ <= D;\\nend\\n\\nendmodule\\n`endif\\n// --------------------------------------------------------\\n\\nmodule \\\\$allconst (Y);\\n\\nparameter WIDTH = 0;\\n\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = 'bx;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$allseq (Y);\\n\\nparameter WIDTH = 0;\\n\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = 'bx;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$equiv (A, B, Y);\\n\\ninput A, B;\\noutput Y;\\n\\nassign Y = (A !== 1'bx && A !== B) ? 1'bx : A;\\n\\n`ifndef SIMLIB_NOCHECKS\\nalways @* begin\\n\\tif (A !== 1'bx && A !== B) begin\\n\\t\\t$display(\\\"Equivalence failed!\\\");\\n\\t\\t$stop;\\n\\tend\\nend\\n`endif\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$print (EN, TRG, ARGS);\\n\\nparameter PRIORITY = 0;\\n\\nparameter FORMAT = \\\"\\\";\\nparameter ARGS_WIDTH = 0;\\n\\nparameter TRG_ENABLE = 1;\\nparameter TRG_WIDTH = 0;\\nparameter TRG_POLARITY = 0;\\n\\ninput EN;\\ninput [TRG_WIDTH-1:0] TRG;\\ninput [ARGS_WIDTH-1:0] ARGS;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$check (A, EN, TRG, ARGS);\\n\\nparameter FLAVOR = \\\"\\\";\\nparameter PRIORITY = 0;\\n\\nparameter FORMAT = \\\"\\\";\\nparameter ARGS_WIDTH = 0;\\n\\nparameter TRG_ENABLE = 1;\\nparameter TRG_WIDTH = 0;\\nparameter TRG_POLARITY = 0;\\n\\ninput A;\\ninput EN;\\ninput [TRG_WIDTH-1:0] TRG;\\ninput [ARGS_WIDTH-1:0] ARGS;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n`ifndef SIMLIB_NOSR\\n\\nmodule \\\\$sr (SET, CLR, Q);\\n\\nparameter WIDTH = 0;\\nparameter SET_POLARITY = 1'b1;\\nparameter CLR_POLARITY = 1'b1;\\n\\ninput [WIDTH-1:0] SET, CLR;\\noutput reg [WIDTH-1:0] Q;\\n\\nwire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\\nwire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\\n\\ngenvar i;\\ngenerate\\n\\tfor (i = 0; i < WIDTH; i = i+1) begin:bitslices\\n\\t\\talways @*\\n\\t\\t\\tif (pos_clr[i])\\n\\t\\t\\t\\tQ[i] <= 0;\\n\\t\\t\\telse if (pos_set[i])\\n\\t\\t\\t\\tQ[i] <= 1;\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n`endif\\n// --------------------------------------------------------\\n`ifdef SIMLIB_FF\\n`ifndef SIMLIB_GLOBAL_CLOCK\\n`define SIMLIB_GLOBAL_CLOCK $global_clk\\n`endif\\n\\nmodule \\\\$ff (D, Q);\\n\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\n\\nalways @(`SIMLIB_GLOBAL_CLOCK) begin\\n\\tQ <= D;\\nend\\n\\nendmodule\\n\\n`endif\\n// --------------------------------------------------------\\n\\nmodule \\\\$dff (CLK, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\n\\ninput CLK;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\nwire pos_clk = CLK == CLK_POLARITY;\\n\\nalways @(posedge pos_clk) begin\\n\\tQ <= D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$dffe (CLK, EN, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter EN_POLARITY = 1'b1;\\n\\ninput CLK, EN;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\nwire pos_clk = CLK == CLK_POLARITY;\\n\\nalways @(posedge pos_clk) begin\\n\\tif (EN == EN_POLARITY) Q <= D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n`ifndef SIMLIB_NOSR\\n\\nmodule \\\\$dffsr (CLK, SET, CLR, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter SET_POLARITY = 1'b1;\\nparameter CLR_POLARITY = 1'b1;\\n\\ninput CLK;\\ninput [WIDTH-1:0] SET, CLR, D;\\noutput reg [WIDTH-1:0] Q;\\n\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\\nwire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\\n\\ngenvar i;\\ngenerate\\n\\tfor (i = 0; i < WIDTH; i = i+1) begin:bitslices\\n\\t\\talways @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)\\n\\t\\t\\tif (pos_clr[i])\\n\\t\\t\\t\\tQ[i] <= 0;\\n\\t\\t\\telse if (pos_set[i])\\n\\t\\t\\t\\tQ[i] <= 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tQ[i] <= D[i];\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$dffsre (CLK, SET, CLR, EN, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter SET_POLARITY = 1'b1;\\nparameter CLR_POLARITY = 1'b1;\\nparameter EN_POLARITY = 1'b1;\\n\\ninput CLK, EN;\\ninput [WIDTH-1:0] SET, CLR, D;\\noutput reg [WIDTH-1:0] Q;\\n\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\\nwire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\\n\\ngenvar i;\\ngenerate\\n\\tfor (i = 0; i < WIDTH; i = i+1) begin:bitslices\\n\\t\\talways @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)\\n\\t\\t\\tif (pos_clr[i])\\n\\t\\t\\t\\tQ[i] <= 0;\\n\\t\\t\\telse if (pos_set[i])\\n\\t\\t\\t\\tQ[i] <= 1;\\n\\t\\t\\telse if (EN == EN_POLARITY)\\n\\t\\t\\t\\tQ[i] <= D[i];\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n`endif\\n// --------------------------------------------------------\\n\\nmodule \\\\$adff (CLK, ARST, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter ARST_POLARITY = 1'b1;\\nparameter ARST_VALUE = 0;\\n\\ninput CLK, ARST;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire pos_arst = ARST == ARST_POLARITY;\\n\\nalways @(posedge pos_clk, posedge pos_arst) begin\\n\\tif (pos_arst)\\n\\t\\tQ <= ARST_VALUE;\\n\\telse\\n\\t\\tQ <= D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$aldff (CLK, ALOAD, AD, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter ALOAD_POLARITY = 1'b1;\\n\\ninput CLK, ALOAD;\\ninput [WIDTH-1:0] AD;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire pos_aload = ALOAD == ALOAD_POLARITY;\\n\\nalways @(posedge pos_clk, posedge pos_aload) begin\\n\\tif (pos_aload)\\n\\t\\tQ <= AD;\\n\\telse\\n\\t\\tQ <= D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$sdff (CLK, SRST, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter SRST_POLARITY = 1'b1;\\nparameter SRST_VALUE = 0;\\n\\ninput CLK, SRST;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire pos_srst = SRST == SRST_POLARITY;\\n\\nalways @(posedge pos_clk) begin\\n\\tif (pos_srst)\\n\\t\\tQ <= SRST_VALUE;\\n\\telse\\n\\t\\tQ <= D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$adffe (CLK, ARST, EN, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter EN_POLARITY = 1'b1;\\nparameter ARST_POLARITY = 1'b1;\\nparameter ARST_VALUE = 0;\\n\\ninput CLK, ARST, EN;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire pos_arst = ARST == ARST_POLARITY;\\n\\nalways @(posedge pos_clk, posedge pos_arst) begin\\n\\tif (pos_arst)\\n\\t\\tQ <= ARST_VALUE;\\n\\telse if (EN == EN_POLARITY)\\n\\t\\tQ <= D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$aldffe (CLK, ALOAD, AD, EN, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter EN_POLARITY = 1'b1;\\nparameter ALOAD_POLARITY = 1'b1;\\n\\ninput CLK, ALOAD, EN;\\ninput [WIDTH-1:0] D;\\ninput [WIDTH-1:0] AD;\\noutput reg [WIDTH-1:0] Q;\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire pos_aload = ALOAD == ALOAD_POLARITY;\\n\\nalways @(posedge pos_clk, posedge pos_aload) begin\\n\\tif (pos_aload)\\n\\t\\tQ <= AD;\\n\\telse if (EN == EN_POLARITY)\\n\\t\\tQ <= D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$sdffe (CLK, SRST, EN, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter EN_POLARITY = 1'b1;\\nparameter SRST_POLARITY = 1'b1;\\nparameter SRST_VALUE = 0;\\n\\ninput CLK, SRST, EN;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire pos_srst = SRST == SRST_POLARITY;\\n\\nalways @(posedge pos_clk) begin\\n\\tif (pos_srst)\\n\\t\\tQ <= SRST_VALUE;\\n\\telse if (EN == EN_POLARITY)\\n\\t\\tQ <= D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$sdffce (CLK, SRST, EN, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter CLK_POLARITY = 1'b1;\\nparameter EN_POLARITY = 1'b1;\\nparameter SRST_POLARITY = 1'b1;\\nparameter SRST_VALUE = 0;\\n\\ninput CLK, SRST, EN;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire pos_srst = SRST == SRST_POLARITY;\\n\\nalways @(posedge pos_clk) begin\\n\\tif (EN == EN_POLARITY) begin\\n\\t\\tif (pos_srst)\\n\\t\\t\\tQ <= SRST_VALUE;\\n\\t\\telse\\n\\t\\t\\tQ <= D;\\n\\tend\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$dlatch (EN, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter EN_POLARITY = 1'b1;\\n\\ninput EN;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\n\\nalways @* begin\\n\\tif (EN == EN_POLARITY)\\n\\t\\tQ = D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$adlatch (EN, ARST, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter EN_POLARITY = 1'b1;\\nparameter ARST_POLARITY = 1'b1;\\nparameter ARST_VALUE = 0;\\n\\ninput EN, ARST;\\ninput [WIDTH-1:0] D;\\noutput reg [WIDTH-1:0] Q;\\n\\nalways @* begin\\n\\tif (ARST == ARST_POLARITY)\\n\\t\\tQ = ARST_VALUE;\\n\\telse if (EN == EN_POLARITY)\\n\\t\\tQ = D;\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n`ifndef SIMLIB_NOSR\\n\\nmodule \\\\$dlatchsr (EN, SET, CLR, D, Q);\\n\\nparameter WIDTH = 0;\\nparameter EN_POLARITY = 1'b1;\\nparameter SET_POLARITY = 1'b1;\\nparameter CLR_POLARITY = 1'b1;\\n\\ninput EN;\\ninput [WIDTH-1:0] SET, CLR, D;\\noutput reg [WIDTH-1:0] Q;\\n\\nwire pos_en = EN == EN_POLARITY;\\nwire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\\nwire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\\n\\ngenvar i;\\ngenerate\\n\\tfor (i = 0; i < WIDTH; i = i+1) begin:bitslices\\n\\t\\talways @*\\n\\t\\t\\tif (pos_clr[i])\\n\\t\\t\\t\\tQ[i] = 0;\\n\\t\\t\\telse if (pos_set[i])\\n\\t\\t\\t\\tQ[i] = 1;\\n\\t\\t\\telse if (pos_en)\\n\\t\\t\\t\\tQ[i] = D[i];\\n\\tend\\nendgenerate\\n\\nendmodule\\n\\n`endif\\n// --------------------------------------------------------\\n\\nmodule \\\\$fsm (CLK, ARST, CTRL_IN, CTRL_OUT);\\n\\nparameter NAME = \\\"\\\";\\n\\nparameter CLK_POLARITY = 1'b1;\\nparameter ARST_POLARITY = 1'b1;\\n\\nparameter CTRL_IN_WIDTH = 1;\\nparameter CTRL_OUT_WIDTH = 1;\\n\\nparameter STATE_BITS = 1;\\nparameter STATE_NUM = 1;\\nparameter STATE_NUM_LOG2 = 1;\\nparameter STATE_RST = 0;\\nparameter STATE_TABLE = 1'b0;\\n\\nparameter TRANS_NUM = 1;\\nparameter TRANS_TABLE = 4'b0x0x;\\n\\ninput CLK, ARST;\\ninput [CTRL_IN_WIDTH-1:0] CTRL_IN;\\noutput reg [CTRL_OUT_WIDTH-1:0] CTRL_OUT;\\n\\nwire pos_clk = CLK == CLK_POLARITY;\\nwire pos_arst = ARST == ARST_POLARITY;\\n\\nreg [STATE_BITS-1:0] state;\\nreg [STATE_BITS-1:0] state_tmp;\\nreg [STATE_BITS-1:0] next_state;\\n\\nreg [STATE_BITS-1:0] tr_state_in;\\nreg [STATE_BITS-1:0] tr_state_out;\\nreg [CTRL_IN_WIDTH-1:0] tr_ctrl_in;\\nreg [CTRL_OUT_WIDTH-1:0] tr_ctrl_out;\\n\\ninteger i;\\n\\ntask tr_fetch;\\n\\tinput [31:0] tr_num;\\n\\treg [31:0] tr_pos;\\n\\treg [STATE_NUM_LOG2-1:0] state_num;\\n\\tbegin\\n\\t\\ttr_pos = (2*STATE_NUM_LOG2+CTRL_IN_WIDTH+CTRL_OUT_WIDTH)*tr_num;\\n\\t\\ttr_ctrl_out = TRANS_TABLE >> tr_pos;\\n\\t\\ttr_pos = tr_pos + CTRL_OUT_WIDTH;\\n\\t\\tstate_num = TRANS_TABLE >> tr_pos;\\n\\t\\ttr_state_out = STATE_TABLE >> (STATE_BITS*state_num);\\n\\t\\ttr_pos = tr_pos + STATE_NUM_LOG2;\\n\\t\\ttr_ctrl_in = TRANS_TABLE >> tr_pos;\\n\\t\\ttr_pos = tr_pos + CTRL_IN_WIDTH;\\n\\t\\tstate_num = TRANS_TABLE >> tr_pos;\\n\\t\\ttr_state_in = STATE_TABLE >> (STATE_BITS*state_num);\\n\\t\\ttr_pos = tr_pos + STATE_NUM_LOG2;\\n\\tend\\nendtask\\n\\nalways @(posedge pos_clk, posedge pos_arst) begin\\n\\tif (pos_arst) begin\\n\\t\\tstate_tmp = STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];\\n\\t\\tfor (i = 0; i < STATE_BITS; i = i+1)\\n\\t\\t\\tif (state_tmp[i] === 1'bz)\\n\\t\\t\\t\\tstate_tmp[i] = 0;\\n\\t\\tstate <= state_tmp;\\n\\tend else begin\\n\\t\\tstate_tmp = next_state;\\n\\t\\tfor (i = 0; i < STATE_BITS; i = i+1)\\n\\t\\t\\tif (state_tmp[i] === 1'bz)\\n\\t\\t\\t\\tstate_tmp[i] = 0;\\n\\t\\tstate <= state_tmp;\\n\\tend\\nend\\n\\nalways @(state, CTRL_IN) begin\\n\\tnext_state <= STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];\\n\\tCTRL_OUT <= 'bx;\\n\\t// $display(\\\"---\\\");\\n\\t// $display(\\\"Q: %b %b\\\", state, CTRL_IN);\\n\\tfor (i = 0; i < TRANS_NUM; i = i+1) begin\\n\\t\\ttr_fetch(i);\\n\\t\\t// $display(\\\"T: %b %b -> %b %b [%d]\\\", tr_state_in, tr_ctrl_in, tr_state_out, tr_ctrl_out, i);\\n\\t\\tcasez ({state, CTRL_IN})\\n\\t\\t\\t{tr_state_in, tr_ctrl_in}: begin\\n\\t\\t\\t\\t// $display(\\\"-> %b %b <-   MATCH\\\", state, CTRL_IN);\\n\\t\\t\\t\\t{next_state, CTRL_OUT} <= {tr_state_out, tr_ctrl_out};\\n\\t\\t\\tend\\n\\t\\tendcase\\n\\tend\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n`ifndef SIMLIB_NOMEM\\n\\nmodule \\\\$memrd (CLK, EN, ADDR, DATA);\\n\\nparameter MEMID = \\\"\\\";\\nparameter ABITS = 8;\\nparameter WIDTH = 8;\\n\\nparameter CLK_ENABLE = 0;\\nparameter CLK_POLARITY = 0;\\nparameter TRANSPARENT = 0;\\n\\ninput CLK, EN;\\ninput [ABITS-1:0] ADDR;\\noutput [WIDTH-1:0] DATA;\\n\\ninitial begin\\n\\tif (MEMID != \\\"\\\") begin\\n\\t\\t$display(\\\"ERROR: Found non-simulatable instance of $memrd!\\\");\\n\\t\\t$finish;\\n\\tend\\nend\\n\\nendmodule\\n\\nmodule \\\\$memrd_v2 (CLK, EN, ARST, SRST, ADDR, DATA);\\n\\nparameter MEMID = \\\"\\\";\\nparameter ABITS = 8;\\nparameter WIDTH = 8;\\n\\nparameter CLK_ENABLE = 0;\\nparameter CLK_POLARITY = 0;\\nparameter TRANSPARENCY_MASK = 0;\\nparameter COLLISION_X_MASK = 0;\\nparameter ARST_VALUE = 0;\\nparameter SRST_VALUE = 0;\\nparameter INIT_VALUE = 0;\\nparameter CE_OVER_SRST = 0;\\n\\ninput CLK, EN, ARST, SRST;\\ninput [ABITS-1:0] ADDR;\\noutput [WIDTH-1:0] DATA;\\n\\ninitial begin\\n\\tif (MEMID != \\\"\\\") begin\\n\\t\\t$display(\\\"ERROR: Found non-simulatable instance of $memrd_v2!\\\");\\n\\t\\t$finish;\\n\\tend\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$memwr (CLK, EN, ADDR, DATA);\\n\\nparameter MEMID = \\\"\\\";\\nparameter ABITS = 8;\\nparameter WIDTH = 8;\\n\\nparameter CLK_ENABLE = 0;\\nparameter CLK_POLARITY = 0;\\nparameter PRIORITY = 0;\\n\\ninput CLK;\\ninput [WIDTH-1:0] EN;\\ninput [ABITS-1:0] ADDR;\\ninput [WIDTH-1:0] DATA;\\n\\ninitial begin\\n\\tif (MEMID != \\\"\\\") begin\\n\\t\\t$display(\\\"ERROR: Found non-simulatable instance of $memwr!\\\");\\n\\t\\t$finish;\\n\\tend\\nend\\n\\nendmodule\\n\\nmodule \\\\$memwr_v2 (CLK, EN, ADDR, DATA);\\n\\nparameter MEMID = \\\"\\\";\\nparameter ABITS = 8;\\nparameter WIDTH = 8;\\n\\nparameter CLK_ENABLE = 0;\\nparameter CLK_POLARITY = 0;\\nparameter PORTID = 0;\\nparameter PRIORITY_MASK = 0;\\n\\ninput CLK;\\ninput [WIDTH-1:0] EN;\\ninput [ABITS-1:0] ADDR;\\ninput [WIDTH-1:0] DATA;\\n\\ninitial begin\\n\\tif (MEMID != \\\"\\\") begin\\n\\t\\t$display(\\\"ERROR: Found non-simulatable instance of $memwr_v2!\\\");\\n\\t\\t$finish;\\n\\tend\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$meminit (ADDR, DATA);\\n\\nparameter MEMID = \\\"\\\";\\nparameter ABITS = 8;\\nparameter WIDTH = 8;\\nparameter WORDS = 1;\\n\\nparameter PRIORITY = 0;\\n\\ninput [ABITS-1:0] ADDR;\\ninput [WORDS*WIDTH-1:0] DATA;\\n\\ninitial begin\\n\\tif (MEMID != \\\"\\\") begin\\n\\t\\t$display(\\\"ERROR: Found non-simulatable instance of $meminit!\\\");\\n\\t\\t$finish;\\n\\tend\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$meminit_v2 (ADDR, DATA, EN);\\n\\nparameter MEMID = \\\"\\\";\\nparameter ABITS = 8;\\nparameter WIDTH = 8;\\nparameter WORDS = 1;\\n\\nparameter PRIORITY = 0;\\n\\ninput [ABITS-1:0] ADDR;\\ninput [WORDS*WIDTH-1:0] DATA;\\ninput [WIDTH-1:0] EN;\\n\\ninitial begin\\n\\tif (MEMID != \\\"\\\") begin\\n\\t\\t$display(\\\"ERROR: Found non-simulatable instance of $meminit_v2!\\\");\\n\\t\\t$finish;\\n\\tend\\nend\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$mem (RD_CLK, RD_EN, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);\\n\\nparameter MEMID = \\\"\\\";\\nparameter signed SIZE = 4;\\nparameter signed OFFSET = 0;\\nparameter signed ABITS = 2;\\nparameter signed WIDTH = 8;\\nparameter signed INIT = 1'bx;\\n\\nparameter signed RD_PORTS = 1;\\nparameter RD_CLK_ENABLE = 1'b1;\\nparameter RD_CLK_POLARITY = 1'b1;\\nparameter RD_TRANSPARENT = 1'b1;\\n\\nparameter signed WR_PORTS = 1;\\nparameter WR_CLK_ENABLE = 1'b1;\\nparameter WR_CLK_POLARITY = 1'b1;\\n\\ninput [RD_PORTS-1:0] RD_CLK;\\ninput [RD_PORTS-1:0] RD_EN;\\ninput [RD_PORTS*ABITS-1:0] RD_ADDR;\\noutput reg [RD_PORTS*WIDTH-1:0] RD_DATA;\\n\\ninput [WR_PORTS-1:0] WR_CLK;\\ninput [WR_PORTS*WIDTH-1:0] WR_EN;\\ninput [WR_PORTS*ABITS-1:0] WR_ADDR;\\ninput [WR_PORTS*WIDTH-1:0] WR_DATA;\\n\\nreg [WIDTH-1:0] memory [SIZE-1:0];\\n\\ninteger i, j;\\nreg [WR_PORTS-1:0] LAST_WR_CLK;\\nreg [RD_PORTS-1:0] LAST_RD_CLK;\\n\\nfunction port_active;\\n\\tinput clk_enable;\\n\\tinput clk_polarity;\\n\\tinput last_clk;\\n\\tinput this_clk;\\n\\tbegin\\n\\t\\tcasez ({clk_enable, clk_polarity, last_clk, this_clk})\\n\\t\\t\\t4'b0???: port_active = 1;\\n\\t\\t\\t4'b1101: port_active = 1;\\n\\t\\t\\t4'b1010: port_active = 1;\\n\\t\\t\\tdefault: port_active = 0;\\n\\t\\tendcase\\n\\tend\\nendfunction\\n\\ninitial begin\\n\\tfor (i = 0; i < SIZE; i = i+1)\\n\\t\\tmemory[i] = INIT >>> (i*WIDTH);\\nend\\n\\nalways @(RD_CLK, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin\\n`ifdef SIMLIB_MEMDELAY\\n\\t#`SIMLIB_MEMDELAY;\\n`endif\\n\\tfor (i = 0; i < RD_PORTS; i = i+1) begin\\n\\t\\tif (!RD_TRANSPARENT[i] && RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\\n\\t\\t\\t// $display(\\\"Read from %s: addr=%b data=%b\\\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\\n\\t\\t\\tRD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\\n\\t\\tend\\n\\tend\\n\\n\\tfor (i = 0; i < WR_PORTS; i = i+1) begin\\n\\t\\tif (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))\\n\\t\\t\\tfor (j = 0; j < WIDTH; j = j+1)\\n\\t\\t\\t\\tif (WR_EN[i*WIDTH+j]) begin\\n\\t\\t\\t\\t\\t// $display(\\\"Write to %s: addr=%b data=%b\\\", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);\\n\\t\\t\\t\\t\\tmemory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];\\n\\t\\t\\t\\tend\\n\\tend\\n\\n\\tfor (i = 0; i < RD_PORTS; i = i+1) begin\\n\\t\\tif ((RD_TRANSPARENT[i] || !RD_CLK_ENABLE[i]) && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\\n\\t\\t\\t// $display(\\\"Transparent read from %s: addr=%b data=%b\\\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\\n\\t\\t\\tRD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\\n\\t\\tend\\n\\tend\\n\\n\\tLAST_RD_CLK <= RD_CLK;\\n\\tLAST_WR_CLK <= WR_CLK;\\nend\\n\\nendmodule\\n\\nmodule \\\\$mem_v2 (RD_CLK, RD_EN, RD_ARST, RD_SRST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);\\n\\nparameter MEMID = \\\"\\\";\\nparameter signed SIZE = 4;\\nparameter signed OFFSET = 0;\\nparameter signed ABITS = 2;\\nparameter signed WIDTH = 8;\\nparameter signed INIT = 1'bx;\\n\\nparameter signed RD_PORTS = 1;\\nparameter RD_CLK_ENABLE = 1'b1;\\nparameter RD_CLK_POLARITY = 1'b1;\\nparameter RD_TRANSPARENCY_MASK = 1'b0;\\nparameter RD_COLLISION_X_MASK = 1'b0;\\nparameter RD_WIDE_CONTINUATION = 1'b0;\\nparameter RD_CE_OVER_SRST = 1'b0;\\nparameter RD_ARST_VALUE = 1'b0;\\nparameter RD_SRST_VALUE = 1'b0;\\nparameter RD_INIT_VALUE = 1'b0;\\n\\nparameter signed WR_PORTS = 1;\\nparameter WR_CLK_ENABLE = 1'b1;\\nparameter WR_CLK_POLARITY = 1'b1;\\nparameter WR_PRIORITY_MASK = 1'b0;\\nparameter WR_WIDE_CONTINUATION = 1'b0;\\n\\ninput [RD_PORTS-1:0] RD_CLK;\\ninput [RD_PORTS-1:0] RD_EN;\\ninput [RD_PORTS-1:0] RD_ARST;\\ninput [RD_PORTS-1:0] RD_SRST;\\ninput [RD_PORTS*ABITS-1:0] RD_ADDR;\\noutput reg [RD_PORTS*WIDTH-1:0] RD_DATA;\\n\\ninput [WR_PORTS-1:0] WR_CLK;\\ninput [WR_PORTS*WIDTH-1:0] WR_EN;\\ninput [WR_PORTS*ABITS-1:0] WR_ADDR;\\ninput [WR_PORTS*WIDTH-1:0] WR_DATA;\\n\\nreg [WIDTH-1:0] memory [SIZE-1:0];\\n\\ninteger i, j, k;\\nreg [WR_PORTS-1:0] LAST_WR_CLK;\\nreg [RD_PORTS-1:0] LAST_RD_CLK;\\n\\nfunction port_active;\\n\\tinput clk_enable;\\n\\tinput clk_polarity;\\n\\tinput last_clk;\\n\\tinput this_clk;\\n\\tbegin\\n\\t\\tcasez ({clk_enable, clk_polarity, last_clk, this_clk})\\n\\t\\t\\t4'b0???: port_active = 1;\\n\\t\\t\\t4'b1101: port_active = 1;\\n\\t\\t\\t4'b1010: port_active = 1;\\n\\t\\t\\tdefault: port_active = 0;\\n\\t\\tendcase\\n\\tend\\nendfunction\\n\\ninitial begin\\n\\tfor (i = 0; i < SIZE; i = i+1)\\n\\t\\tmemory[i] = INIT >>> (i*WIDTH);\\n\\tRD_DATA = RD_INIT_VALUE;\\nend\\n\\nalways @(RD_CLK, RD_ARST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin\\n`ifdef SIMLIB_MEMDELAY\\n\\t#`SIMLIB_MEMDELAY;\\n`endif\\n\\tfor (i = 0; i < RD_PORTS; i = i+1) begin\\n\\t\\tif (RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\\n\\t\\t\\t// $display(\\\"Read from %s: addr=%b data=%b\\\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\\n\\t\\t\\tRD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\\n\\n\\t\\t\\tfor (j = 0; j < WR_PORTS; j = j+1) begin\\n\\t\\t\\t\\tif (RD_TRANSPARENCY_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])\\n\\t\\t\\t\\t\\tfor (k = 0; k < WIDTH; k = k+1)\\n\\t\\t\\t\\t\\t\\tif (WR_EN[j*WIDTH+k])\\n\\t\\t\\t\\t\\t\\t\\tRD_DATA[i*WIDTH+k] <= WR_DATA[j*WIDTH+k];\\n\\t\\t\\t\\tif (RD_COLLISION_X_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])\\n\\t\\t\\t\\t\\tfor (k = 0; k < WIDTH; k = k+1)\\n\\t\\t\\t\\t\\t\\tif (WR_EN[j*WIDTH+k])\\n\\t\\t\\t\\t\\t\\t\\tRD_DATA[i*WIDTH+k] <= 1'bx;\\n\\t\\t\\tend\\n\\t\\tend\\n\\tend\\n\\n\\tfor (i = 0; i < WR_PORTS; i = i+1) begin\\n\\t\\tif (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))\\n\\t\\t\\tfor (j = 0; j < WIDTH; j = j+1)\\n\\t\\t\\t\\tif (WR_EN[i*WIDTH+j]) begin\\n\\t\\t\\t\\t\\t// $display(\\\"Write to %s: addr=%b data=%b\\\", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);\\n\\t\\t\\t\\t\\tmemory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];\\n\\t\\t\\t\\tend\\n\\tend\\n\\n\\tfor (i = 0; i < RD_PORTS; i = i+1) begin\\n\\t\\tif (!RD_CLK_ENABLE[i]) begin\\n\\t\\t\\t// $display(\\\"Combinatorial read from %s: addr=%b data=%b\\\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\\n\\t\\t\\tRD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\\n\\t\\tend\\n\\tend\\n\\n\\tfor (i = 0; i < RD_PORTS; i = i+1) begin\\n\\t\\tif (RD_SRST[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i]) && (RD_EN[i] || !RD_CE_OVER_SRST[i]))\\n\\t\\t\\tRD_DATA[i*WIDTH +: WIDTH] <= RD_SRST_VALUE[i*WIDTH +: WIDTH];\\n\\t\\tif (RD_ARST[i])\\n\\t\\t\\tRD_DATA[i*WIDTH +: WIDTH] <= RD_ARST_VALUE[i*WIDTH +: WIDTH];\\n\\tend\\n\\n\\tLAST_RD_CLK <= RD_CLK;\\n\\tLAST_WR_CLK <= WR_CLK;\\nend\\n\\nendmodule\\n\\n`endif\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$set_tag (A, SET, CLR, Y);\\n\\nparameter TAG = \\\"\\\";\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] A;\\ninput [WIDTH-1:0] SET;\\ninput [WIDTH-1:0] CLR;\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = A;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$get_tag (A, Y);\\n\\nparameter TAG = \\\"\\\";\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] A;\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = A;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$overwrite_tag (A, SET, CLR);\\n\\nparameter TAG = \\\"\\\";\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] A;\\ninput [WIDTH-1:0] SET;\\ninput [WIDTH-1:0] CLR;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$original_tag (A, Y);\\n\\nparameter TAG = \\\"\\\";\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] A;\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = A;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\nmodule \\\\$future_ff (A, Y);\\n\\nparameter WIDTH = 0;\\n\\ninput [WIDTH-1:0] A;\\noutput [WIDTH-1:0] Y;\\n\\nassign Y = A;\\n\\nendmodule\\n\\n// --------------------------------------------------------\\n\\n(* noblackbox *)\\nmodule \\\\$scopeinfo ();\\n\\nparameter TYPE = \\\"\\\";\\n\\nendmodule\\n\",\n        \"smtmap.v\": \"(* techmap_celltype = \\\"$pmux\\\" *)\\nmodule smt_pmux (A, B, S, Y);\\n\\tparameter WIDTH = 1;\\n\\tparameter S_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [WIDTH*S_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\tinput [S_WIDTH-1:0] S;\\n\\t(* force_downto *)\\n\\toutput [WIDTH-1:0] Y;\\n\\n\\t(* force_downto *)\\n\\twire [WIDTH-1:0] Y_B;\\n\\n\\tgenvar i, j;\\n\\tgenerate\\n\\t\\t(* force_downto *)\\n\\t\\twire [WIDTH*(S_WIDTH+1)-1:0] C;\\n\\n\\t\\tassign C[WIDTH-1:0] = A;\\n\\t\\tfor (i = 0; i < S_WIDTH; i = i + 1)\\n\\t\\t\\tassign C[WIDTH*(i+2)-1:WIDTH*(i+1)] = S[i] ? B[WIDTH*(i+1)-1:WIDTH*i] : C[WIDTH*(i+1)-1:WIDTH*i];\\n\\t\\tassign Y = C[WIDTH*(S_WIDTH+1)-1:WIDTH*S_WIDTH];\\n\\tendgenerate\\nendmodule\\n\",\n        \"techmap.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n *  ---\\n *\\n *  The internal logic cell technology mapper.\\n *\\n *  This Verilog library contains the mapping of internal cells (e.g. $not with\\n *  variable bit width) to the internal logic cells (such as the single bit $_NOT_\\n *  gate). Usually this logic network is then mapped to the actual technology\\n *  using e.g. the \\\"abc\\\" pass.\\n *\\n *  Note that this library does not map $mem cells. They must be mapped to logic\\n *  and $dff cells using the \\\"memory_map\\\" pass first. (Or map it to custom cells,\\n *  which is of course highly recommended for larger memories.)\\n *\\n */\\n\\n`define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))\\n`define MAX(_a, _b) ((_a) > (_b) ? (_a) : (_b))\\n\\n\\n// --------------------------------------------------------\\n// Use simplemap for trivial cell types\\n// --------------------------------------------------------\\n\\n(* techmap_simplemap *)\\n(* techmap_celltype = \\\"$not $and $or $xor $xnor\\\" *)\\nmodule _90_simplemap_bool_ops;\\nendmodule\\n\\n(* techmap_simplemap *)\\n(* techmap_celltype = \\\"$reduce_and $reduce_or $reduce_xor $reduce_xnor $reduce_bool\\\" *)\\nmodule _90_simplemap_reduce_ops;\\nendmodule\\n\\n(* techmap_simplemap *)\\n(* techmap_celltype = \\\"$logic_not $logic_and $logic_or\\\" *)\\nmodule _90_simplemap_logic_ops;\\nendmodule\\n\\n(* techmap_simplemap *)\\n(* techmap_celltype = \\\"$eq $eqx $ne $nex\\\" *)\\nmodule _90_simplemap_compare_ops;\\nendmodule\\n\\n(* techmap_simplemap *)\\n(* techmap_celltype = \\\"$pos $slice $concat $mux $tribuf $bmux $bwmux $bweqx\\\" *)\\nmodule _90_simplemap_various;\\nendmodule\\n\\n(* techmap_simplemap *)\\n(* techmap_celltype = \\\"$sr $ff $dff $dffe $adff $adffe $aldff $aldffe $sdff $sdffe $sdffce $dffsr $dffsre $dlatch $adlatch $dlatchsr\\\" *)\\nmodule _90_simplemap_registers;\\nendmodule\\n\\n\\n// --------------------------------------------------------\\n// Shift operators\\n// --------------------------------------------------------\\n\\n(* techmap_celltype = \\\"$shr $shl $sshl $sshr\\\" *)\\nmodule _90_shift_ops_shr_shl_sshl_sshr (A, B, Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\tparameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n\\tlocalparam shift_left = _TECHMAP_CELLTYPE_ == \\\"$shl\\\" || _TECHMAP_CELLTYPE_ == \\\"$sshl\\\";\\n\\tlocalparam sign_extend = A_SIGNED && _TECHMAP_CELLTYPE_ == \\\"$sshr\\\";\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\tlocalparam WIDTH = `MAX(A_WIDTH, Y_WIDTH);\\n\\tlocalparam BB_WIDTH = `MIN($clog2(shift_left ? Y_WIDTH : A_SIGNED ? WIDTH : A_WIDTH) + 1, B_WIDTH);\\n\\n\\twire [1023:0] _TECHMAP_DO_00_ = \\\"proc;;\\\";\\n\\twire [1023:0] _TECHMAP_DO_01_ = \\\"RECURSION; CONSTMAP; opt_muxtree; opt_expr -mux_undef -mux_bool -fine;;;\\\";\\n\\n\\tinteger i;\\n\\t(* force_downto *)\\n\\treg [WIDTH-1:0] buffer;\\n\\treg overflow;\\n\\n\\talways @* begin\\n\\t\\toverflow = B_WIDTH > BB_WIDTH ? |B[B_WIDTH-1:BB_WIDTH] : 1'b0;\\n\\t\\tbuffer = overflow ? {WIDTH{sign_extend ? A[A_WIDTH-1] : 1'b0}} : {{WIDTH-A_WIDTH{A_SIGNED ? A[A_WIDTH-1] : 1'b0}}, A};\\n\\n\\t\\tfor (i = 0; i < BB_WIDTH; i = i+1)\\n\\t\\t\\tif (B[i]) begin\\n\\t\\t\\t\\tif (shift_left)\\n\\t\\t\\t\\t\\tbuffer = {buffer, (2**i)'b0};\\n\\t\\t\\t\\telse if (2**i < WIDTH)\\n\\t\\t\\t\\t\\tbuffer = {{2**i{sign_extend ? buffer[WIDTH-1] : 1'b0}}, buffer[WIDTH-1 : 2**i]};\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuffer = {WIDTH{sign_extend ? buffer[WIDTH-1] : 1'b0}};\\n\\t\\t\\tend\\n\\tend\\n\\n\\tassign Y = buffer;\\nendmodule\\n\\n(* techmap_celltype = \\\"$shift $shiftx\\\" *)\\nmodule _90_shift_shiftx (A, B, Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\tparameter _TECHMAP_CELLTYPE_ = \\\"\\\";\\n\\tparameter [B_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;\\n\\tparameter [B_WIDTH-1:0] _TECHMAP_CONSTVAL_B_ = 0;\\n\\n\\tlocalparam extbit = _TECHMAP_CELLTYPE_ == \\\"$shift\\\" ? 1'b0 : 1'bx;\\n\\twire a_padding = _TECHMAP_CELLTYPE_ == \\\"$shiftx\\\" ? extbit : (A_SIGNED ? A[A_WIDTH-1] : 1'b0);\\n\\n\\tlocalparam BB_WIDTH = `MIN($clog2(`MAX(A_WIDTH, Y_WIDTH)) + (B_SIGNED ? 2 : 1), B_WIDTH);\\n\\tlocalparam WIDTH = `MAX(A_WIDTH, Y_WIDTH) + (B_SIGNED ? 2**(BB_WIDTH-1) : 0);\\n\\n\\twire [1023:0] _TECHMAP_DO_00_ = \\\"proc;;\\\";\\n\\twire [1023:0] _TECHMAP_DO_01_ = \\\"CONSTMAP; opt_muxtree; opt_expr -mux_undef -mux_bool -fine;;;\\\";\\n\\n\\tinteger i;\\n\\t(* force_downto *)\\n\\treg [WIDTH-1:0] buffer;\\n\\treg overflow;\\n\\n\\talways @* begin\\n\\t\\toverflow = 0;\\n\\t\\tbuffer = {WIDTH{extbit}};\\n\\t\\tbuffer[Y_WIDTH-1:0] = {Y_WIDTH{a_padding}};\\n\\t\\tbuffer[A_WIDTH-1:0] = A;\\n\\n\\t\\tif (B_WIDTH > BB_WIDTH) begin\\n\\t\\t\\tif (B_SIGNED) begin\\n\\t\\t\\t\\tfor (i = BB_WIDTH; i < B_WIDTH; i = i+1)\\n\\t\\t\\t\\t\\tif (B[i] != B[BB_WIDTH-1])\\n\\t\\t\\t\\t\\t\\toverflow = 1;\\n\\t\\t\\tend else\\n\\t\\t\\t\\toverflow = |B[B_WIDTH-1:BB_WIDTH];\\n\\t\\t\\tif (overflow)\\n\\t\\t\\t\\tbuffer = {WIDTH{extbit}};\\n\\t\\tend\\n\\n\\t\\tif (B_SIGNED && B[BB_WIDTH-1])\\n\\t\\t\\tbuffer = {buffer, {2**(BB_WIDTH-1){extbit}}};\\n\\n\\t\\tfor (i = 0; i < (B_SIGNED ? BB_WIDTH-1 : BB_WIDTH); i = i+1)\\n\\t\\t\\tif (B[i]) begin\\n\\t\\t\\t\\tif (2**i < WIDTH)\\n\\t\\t\\t\\t\\tbuffer = {{2**i{extbit}}, buffer[WIDTH-1 : 2**i]};\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuffer = {WIDTH{extbit}};\\n\\t\\t\\tend\\n\\tend\\n\\tassign Y = buffer;\\nendmodule\\n\\n\\n// --------------------------------------------------------\\n// Arithmetic operators\\n// --------------------------------------------------------\\n\\n(* techmap_celltype = \\\"$fa\\\" *)\\nmodule _90_fa (A, B, C, X, Y);\\n\\tparameter WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] A, B, C;\\n\\t(* force_downto *)\\n\\toutput [WIDTH-1:0] X, Y;\\n\\n\\t(* force_downto *)\\n\\twire [WIDTH-1:0] t1, t2, t3;\\n\\n\\tassign t1 = A ^ B, t2 = A & B, t3 = C & t1;\\n\\tassign Y = t1 ^ C, X = t2 | t3;\\nendmodule\\n\\n(* techmap_celltype = \\\"$lcu\\\" *)\\nmodule _90_lcu_brent_kung (P, G, CI, CO);\\n\\tparameter WIDTH = 2;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] P, G;\\n\\tinput CI;\\n\\n\\t(* force_downto *)\\n\\toutput [WIDTH-1:0] CO;\\n\\n\\tinteger i, j;\\n\\t(* force_downto *)\\n\\treg [WIDTH-1:0] p, g;\\n\\n\\twire [1023:0] _TECHMAP_DO_ = \\\"proc; opt -fast\\\";\\n\\n\\talways @* begin\\n\\t\\tp = P;\\n\\t\\tg = G;\\n\\n\\t\\t// in almost all cases CI will be constant zero\\n\\t\\tg[0] = g[0] | (p[0] & CI);\\n\\n\\t\\t// [[CITE]] Brent Kung Adder\\n\\t\\t// R. P. Brent and H. T. Kung, \\\"A Regular Layout for Parallel Adders\\\",\\n\\t\\t// IEEE Transaction on Computers, Vol. C-31, No. 3, p. 260-264, March, 1982\\n\\n\\t\\t// Main tree\\n\\t\\tfor (i = 1; i <= $clog2(WIDTH); i = i+1) begin\\n\\t\\t\\tfor (j = 2**i - 1; j < WIDTH; j = j + 2**i) begin\\n\\t\\t\\t\\tg[j] = g[j] | p[j] & g[j - 2**(i-1)];\\n\\t\\t\\t\\tp[j] = p[j] & p[j - 2**(i-1)];\\n\\t\\t\\tend\\n\\t\\tend\\n\\n\\t\\t// Inverse tree\\n\\t\\tfor (i = $clog2(WIDTH); i > 0; i = i-1) begin\\n\\t\\t\\tfor (j = 2**i + 2**(i-1) - 1; j < WIDTH; j = j + 2**i) begin\\n\\t\\t\\t\\tg[j] = g[j] | p[j] & g[j - 2**(i-1)];\\n\\t\\t\\t\\tp[j] = p[j] & p[j - 2**(i-1)];\\n\\t\\t\\tend\\n\\t\\tend\\n\\tend\\n\\n\\tassign CO = g;\\nendmodule\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _90_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\t\\\\$lcu #(.WIDTH(Y_WIDTH)) lcu (.P(X), .G(AA & BB), .CI(CI), .CO(CO));\\n\\n\\tassign X = AA ^ BB;\\n\\tassign Y = X ^ {CO, CI};\\nendmodule\\n\\n(* techmap_maccmap *)\\n(* techmap_celltype = \\\"$macc\\\" *)\\nmodule _90_macc;\\nendmodule\\n\\n(* techmap_wrap = \\\"alumacc\\\" *)\\n(* techmap_celltype = \\\"$lt $le $ge $gt $add $sub $neg $mul\\\" *)\\nmodule _90_alumacc;\\nendmodule\\n\\n\\n// --------------------------------------------------------\\n// Divide and Modulo\\n// --------------------------------------------------------\\n\\nmodule \\\\$__div_mod_u (A, B, Y, R);\\n\\tparameter WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] A, B;\\n\\t(* force_downto *)\\n\\toutput [WIDTH-1:0] Y, R;\\n\\n\\t(* force_downto *)\\n\\twire [WIDTH*WIDTH-1:0] chaindata;\\n\\tassign R = chaindata[WIDTH*WIDTH-1:WIDTH*(WIDTH-1)];\\n\\n\\tgenvar i;\\n\\tgenerate begin\\n\\t\\tfor (i = 0; i < WIDTH; i=i+1) begin:stage\\n\\t\\t\\t(* force_downto *)\\n\\t\\t\\twire [WIDTH-1:0] stage_in;\\n\\n\\t\\t\\tif (i == 0) begin:cp\\n\\t\\t\\t\\tassign stage_in = A;\\n\\t\\t\\tend else begin:cp\\n\\t\\t\\t\\tassign stage_in = chaindata[i*WIDTH-1:(i-1)*WIDTH];\\n\\t\\t\\tend\\n\\n\\t\\t\\tassign Y[WIDTH-(i+1)] = stage_in >= {B, {WIDTH-(i+1){1'b0}}};\\n\\t\\t\\tassign chaindata[(i+1)*WIDTH-1:i*WIDTH] = Y[WIDTH-(i+1)] ? stage_in - {B, {WIDTH-(i+1){1'b0}}} : stage_in;\\n\\t\\tend\\n\\tend endgenerate\\nendmodule\\n\\n// truncating signed division/modulo\\nmodule \\\\$__div_mod_trunc (A, B, Y, R);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\tlocalparam WIDTH =\\n\\t\\t\\tA_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :\\n\\t\\t\\tB_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y, R;\\n\\n\\t(* force_downto *)\\n\\twire [WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\t(* force_downto *)\\n\\twire [WIDTH-1:0] A_buf_u, B_buf_u, Y_u, R_u;\\n\\tassign A_buf_u = A_SIGNED && A_buf[WIDTH-1] ? -A_buf : A_buf;\\n\\tassign B_buf_u = B_SIGNED && B_buf[WIDTH-1] ? -B_buf : B_buf;\\n\\n\\t\\\\$__div_mod_u #(\\n\\t\\t.WIDTH(WIDTH)\\n\\t) div_mod_u (\\n\\t\\t.A(A_buf_u),\\n\\t\\t.B(B_buf_u),\\n\\t\\t.Y(Y_u),\\n\\t\\t.R(R_u)\\n\\t);\\n\\n\\tassign Y = A_SIGNED && B_SIGNED && (A_buf[WIDTH-1] != B_buf[WIDTH-1]) ? -Y_u : Y_u;\\n\\tassign R = A_SIGNED && B_SIGNED && A_buf[WIDTH-1] ? -R_u : R_u;\\nendmodule\\n\\n(* techmap_celltype = \\\"$div\\\" *)\\nmodule _90_div (A, B, Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\t\\\\$__div_mod_trunc #(\\n\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t.A_WIDTH(A_WIDTH),\\n\\t\\t.B_WIDTH(B_WIDTH),\\n\\t\\t.Y_WIDTH(Y_WIDTH)\\n\\t) div_mod (\\n\\t\\t.A(A),\\n\\t\\t.B(B),\\n\\t\\t.Y(Y)\\n\\t);\\nendmodule\\n\\n(* techmap_celltype = \\\"$mod\\\" *)\\nmodule _90_mod (A, B, Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\t\\\\$__div_mod_trunc #(\\n\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t.A_WIDTH(A_WIDTH),\\n\\t\\t.B_WIDTH(B_WIDTH),\\n\\t\\t.Y_WIDTH(Y_WIDTH)\\n\\t) div_mod (\\n\\t\\t.A(A),\\n\\t\\t.B(B),\\n\\t\\t.R(Y)\\n\\t);\\nendmodule\\n\\n// flooring signed division/modulo\\nmodule \\\\$__div_mod_floor (A, B, Y, R);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\tlocalparam WIDTH =\\n\\t\\t\\tA_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :\\n\\t\\t\\tB_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;\\n\\n\\tinput [A_WIDTH-1:0] A;\\n\\tinput [B_WIDTH-1:0] B;\\n\\toutput [Y_WIDTH-1:0] Y, R;\\n\\n\\twire [WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\twire [WIDTH-1:0] A_buf_u, B_buf_u, Y_u, R_u, R_s;\\n\\tassign A_buf_u = A_SIGNED && A_buf[WIDTH-1] ? -A_buf : A_buf;\\n\\tassign B_buf_u = B_SIGNED && B_buf[WIDTH-1] ? -B_buf : B_buf;\\n\\n\\t\\\\$__div_mod_u #(\\n\\t\\t.WIDTH(WIDTH)\\n\\t) div_mod_u (\\n\\t\\t.A(A_buf_u),\\n\\t\\t.B(B_buf_u),\\n\\t\\t.Y(Y_u),\\n\\t\\t.R(R_u)\\n\\t);\\n\\n\\t// For negative results, if there was a remainder, subtract one to turn\\n\\t// the round towards 0 into a round towards -inf\\n\\tassign Y = A_SIGNED && B_SIGNED && (A_buf[WIDTH-1] != B_buf[WIDTH-1]) ? (R_u == 0 ? -Y_u : -Y_u-1) : Y_u;\\n\\n\\t// truncating modulo\\n\\tassign R_s = A_SIGNED && B_SIGNED && A_buf[WIDTH-1] ? -R_u : R_u;\\n\\t// Flooring modulo differs from truncating modulo only if it is nonzero and\\n\\t// A and B have different signs - then `floor - trunc = B`\\n\\tassign R = (R_s != 0) && A_SIGNED && B_SIGNED && (A_buf[WIDTH-1] != B_buf[WIDTH-1]) ? $signed(B_buf) + $signed(R_s) : R_s;\\nendmodule\\n\\n(* techmap_celltype = \\\"$divfloor\\\" *)\\nmodule _90_divfloor (A, B, Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\t\\\\$__div_mod_floor #(\\n\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t.A_WIDTH(A_WIDTH),\\n\\t\\t.B_WIDTH(B_WIDTH),\\n\\t\\t.Y_WIDTH(Y_WIDTH)\\n\\t) div_mod (\\n\\t\\t.A(A),\\n\\t\\t.B(B),\\n\\t\\t.Y(Y)\\n\\t);\\nendmodule\\n\\n(* techmap_celltype = \\\"$modfloor\\\" *)\\nmodule _90_modfloor (A, B, Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\t\\\\$__div_mod_floor #(\\n\\t\\t.A_SIGNED(A_SIGNED),\\n\\t\\t.B_SIGNED(B_SIGNED),\\n\\t\\t.A_WIDTH(A_WIDTH),\\n\\t\\t.B_WIDTH(B_WIDTH),\\n\\t\\t.Y_WIDTH(Y_WIDTH)\\n\\t) div_mod (\\n\\t\\t.A(A),\\n\\t\\t.B(B),\\n\\t\\t.R(Y)\\n\\t);\\nendmodule\\n\\n\\n// --------------------------------------------------------\\n// Power\\n// --------------------------------------------------------\\n\\n(* techmap_celltype = \\\"$pow\\\" *)\\nmodule _90_pow (A, B, Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] Y;\\n\\n\\twire _TECHMAP_FAIL_ = 1;\\nendmodule\\n\\n\\n// --------------------------------------------------------\\n// Parallel Multiplexers\\n// --------------------------------------------------------\\n\\n(* techmap_celltype = \\\"$pmux\\\" *)\\nmodule _90_pmux (A, B, S, Y);\\n\\tparameter WIDTH = 1;\\n\\tparameter S_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [WIDTH*S_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\tinput [S_WIDTH-1:0] S;\\n\\t(* force_downto *)\\n\\toutput [WIDTH-1:0] Y;\\n\\n\\t(* force_downto *)\\n\\twire [WIDTH-1:0] Y_B;\\n\\n\\tgenvar i, j;\\n\\tgenerate\\n\\t\\t(* force_downto *)\\n\\t\\twire [WIDTH*S_WIDTH-1:0] B_AND_S;\\n\\t\\tfor (i = 0; i < S_WIDTH; i = i + 1) begin:B_AND\\n\\t\\t\\tassign B_AND_S[WIDTH*(i+1)-1:WIDTH*i] = B[WIDTH*(i+1)-1:WIDTH*i] & {WIDTH{S[i]}};\\n\\t\\tend:B_AND\\n\\t\\tfor (i = 0; i < WIDTH; i = i + 1) begin:B_OR\\n\\t\\t\\t(* force_downto *)\\n\\t\\t\\twire [S_WIDTH-1:0] B_AND_BITS;\\n\\t\\t\\tfor (j = 0; j < S_WIDTH; j = j + 1) begin:B_AND_BITS_COLLECT\\n\\t\\t\\t\\tassign B_AND_BITS[j] = B_AND_S[WIDTH*j+i];\\n\\t\\t\\tend:B_AND_BITS_COLLECT\\n\\t\\t\\tassign Y_B[i] = |B_AND_BITS;\\n\\t\\tend:B_OR\\n\\tendgenerate\\n\\n\\tassign Y = |S ? Y_B : A;\\nendmodule\\n\\n// --------------------------------------------------------\\n// Demultiplexers\\n// --------------------------------------------------------\\n\\n(* techmap_celltype = \\\"$demux\\\" *)\\nmodule _90_demux (A, S, Y);\\n\\tparameter WIDTH = 1;\\n\\tparameter S_WIDTH = 1;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [S_WIDTH-1:0] S;\\n\\t(* force_downto *)\\n\\toutput [(WIDTH << S_WIDTH)-1:0] Y;\\n\\n\\tgenerate\\n\\t\\tif (S_WIDTH == 0) begin\\n\\t\\t\\tassign Y = A;\\n\\t\\tend else if (S_WIDTH == 1) begin\\n\\t\\t\\tassign Y[0+:WIDTH] = S ? 0 : A;\\n\\t\\t\\tassign Y[WIDTH+:WIDTH] = S ? A : 0;\\n\\t\\tend else begin\\n\\t\\t\\tlocalparam SPLIT = S_WIDTH / 2;\\n\\t\\t\\twire [(1 << (S_WIDTH-SPLIT))-1:0] YH;\\n\\t\\t\\twire [(1 << SPLIT)-1:0] YL;\\n\\t\\t\\t$demux #(.WIDTH(1), .S_WIDTH(SPLIT)) lo (.A(1'b1), .S(S[SPLIT-1:0]), .Y(YL));\\n\\t\\t\\t$demux #(.WIDTH(1), .S_WIDTH(S_WIDTH-SPLIT)) hi (.A(1'b1), .S(S[S_WIDTH-1:SPLIT]), .Y(YH));\\n\\t\\t\\tgenvar i;\\n\\t\\t\\tfor (i = 0; i < (1 << S_WIDTH); i = i + 1) begin\\n\\t\\t\\t\\tlocalparam [S_WIDTH-1:0] IDX = i;\\n\\t\\t\\t\\tassign Y[i*WIDTH+:WIDTH] = (YL[IDX[SPLIT-1:0]] & YH[IDX[S_WIDTH-1:SPLIT]]) ? A : 0;\\n\\t\\t\\tend\\n\\t\\tend\\n\\tendgenerate\\nendmodule\\n\\n\\n// --------------------------------------------------------\\n// LUTs\\n// --------------------------------------------------------\\n\\n`ifndef NOLUT\\n(* techmap_simplemap *)\\n(* techmap_celltype = \\\"$lut $sop\\\" *)\\nmodule _90_lut;\\nendmodule\\n`endif\\n\\n\",\n        \"xilinx\": {\n            \"abc9_model.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *                2019  Eddie Hung    <eddie@fpgeh.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n// ============================================================================\\n\\n// Box containing MUXF7.[AB] + MUXF8,\\n//   Necessary to make these an atomic unit so that\\n//   ABC cannot optimise just one of the MUXF7 away\\n//   and expect to save on its delay\\n(* abc9_box, lib_whitebox *)\\nmodule \\\\$__XILINX_MUXF78 (output O, input I0, I1, I2, I3, S0, S1);\\n  assign O = S1 ? (S0 ? I3 : I2)\\n                : (S0 ? I1 : I0);\\n  specify\\n    (I0 => O) = 294;\\n    (I1 => O) = 297;\\n    (I2 => O) = 311;\\n    (I3 => O) = 317;\\n    (S0 => O) = 390;\\n    (S1 => O) = 273;\\n  endspecify\\nendmodule\\n\",\n            \"arith_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n// ============================================================================\\n// LCU\\n\\n(* techmap_celltype = \\\"$lcu\\\" *)\\nmodule _80_xilinx_lcu (P, G, CI, CO);\\n\\tparameter WIDTH = 2;\\n\\n\\t(* force_downto *)\\n\\tinput [WIDTH-1:0] P, G;\\n\\tinput CI;\\n\\n\\t(* force_downto *)\\n\\toutput [WIDTH-1:0] CO;\\n\\n\\twire _TECHMAP_FAIL_ = WIDTH <= 2;\\n\\n\\tgenvar i;\\n\\ngenerate if (`LUT_SIZE == 4) begin\\n\\n\\t(* force_downto *)\\n\\twire [WIDTH-1:0] C = {CO, CI};\\n\\t(* force_downto *)\\n\\twire [WIDTH-1:0] S = P & ~G;\\n\\n\\tgenerate for (i = 0; i < WIDTH; i = i + 1) begin:slice\\n\\t\\tMUXCY muxcy (\\n\\t\\t\\t.CI(C[i]),\\n\\t\\t\\t.DI(G[i]),\\n\\t\\t\\t.S(S[i]),\\n\\t\\t\\t.O(CO[i])\\n\\t\\t);\\n\\tend endgenerate\\n\\nend else begin\\n\\n\\tlocalparam CARRY4_COUNT = (WIDTH + 3) / 4;\\n\\tlocalparam MAX_WIDTH    = CARRY4_COUNT * 4;\\n\\tlocalparam PAD_WIDTH    = MAX_WIDTH - WIDTH;\\n\\n\\t(* force_downto *)\\n\\twire [MAX_WIDTH-1:0] S =  {{PAD_WIDTH{1'b0}}, P & ~G};\\n\\t(* force_downto *)\\n\\twire [MAX_WIDTH-1:0] GG = {{PAD_WIDTH{1'b0}}, G};\\n\\t(* force_downto *)\\n\\twire [MAX_WIDTH-1:0] C;\\n\\tassign CO = C;\\n\\n\\tgenerate for (i = 0; i < CARRY4_COUNT; i = i + 1) begin:slice\\n\\t\\tif (i == 0) begin\\n\\t\\t\\tCARRY4 carry4\\n\\t\\t\\t(\\n\\t\\t\\t.CYINIT(CI),\\n\\t\\t\\t.CI    (1'd0),\\n\\t\\t\\t.DI    (GG[i*4 +: 4]),\\n\\t\\t\\t.S     (S [i*4 +: 4]),\\n\\t\\t\\t.CO    (C [i*4 +: 4]),\\n\\t\\t\\t);\\n\\t\\tend else begin\\n\\t\\t\\tCARRY4 carry4\\n\\t\\t\\t(\\n\\t\\t\\t.CYINIT(1'd0),\\n\\t\\t\\t.CI    (C [i*4 - 1]),\\n\\t\\t\\t.DI    (GG[i*4 +: 4]),\\n\\t\\t\\t.S     (S [i*4 +: 4]),\\n\\t\\t\\t.CO    (C [i*4 +: 4]),\\n\\t\\t\\t);\\n\\t\\tend\\n\\tend endgenerate\\nend endgenerate\\n\\nendmodule\\n\\n\\n// ============================================================================\\n// ALU\\n\\n(* techmap_celltype = \\\"$alu\\\" *)\\nmodule _80_xilinx_alu (A, B, CI, BI, X, Y, CO);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 1;\\n\\tparameter B_WIDTH = 1;\\n\\tparameter Y_WIDTH = 1;\\n\\tparameter _TECHMAP_CONSTVAL_CI_ = 0;\\n\\tparameter _TECHMAP_CONSTMSK_CI_ = 0;\\n\\n\\t(* force_downto *)\\n\\tinput [A_WIDTH-1:0] A;\\n\\t(* force_downto *)\\n\\tinput [B_WIDTH-1:0] B;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] X, Y;\\n\\n\\tinput CI, BI;\\n\\t(* force_downto *)\\n\\toutput [Y_WIDTH-1:0] CO;\\n\\n\\twire _TECHMAP_FAIL_ = Y_WIDTH <= 2;\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] A_buf, B_buf;\\n\\t\\\\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\\n\\t\\\\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] AA = A_buf;\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\\n\\n\\tgenvar i;\\n\\ngenerate if (`LUT_SIZE == 4) begin\\n\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] C = {CO, CI};\\n\\t(* force_downto *)\\n\\twire [Y_WIDTH-1:0] S  = {AA ^ BB};\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < Y_WIDTH; i = i + 1) begin:slice\\n\\t\\tMUXCY muxcy (\\n\\t\\t\\t.CI(C[i]),\\n\\t\\t\\t.DI(AA[i]),\\n\\t\\t\\t.S(S[i]),\\n\\t\\t\\t.O(CO[i])\\n\\t\\t);\\n\\t\\tXORCY xorcy (\\n\\t\\t\\t.CI(C[i]),\\n\\t\\t\\t.LI(S[i]),\\n\\t\\t\\t.O(Y[i])\\n\\t\\t);\\n\\tend endgenerate\\n\\n\\tassign X = S;\\n\\nend else begin\\n\\n\\tlocalparam CARRY4_COUNT = (Y_WIDTH + 3) / 4;\\n\\tlocalparam MAX_WIDTH    = CARRY4_COUNT * 4;\\n\\tlocalparam PAD_WIDTH    = MAX_WIDTH - Y_WIDTH;\\n\\n\\t(* force_downto *)\\n\\twire [MAX_WIDTH-1:0] S  = {{PAD_WIDTH{1'b0}}, AA ^ BB};\\n\\t(* force_downto *)\\n\\twire [MAX_WIDTH-1:0] DI = {{PAD_WIDTH{1'b0}}, AA};\\n\\n\\t(* force_downto *)\\n\\twire [MAX_WIDTH-1:0] O;\\n\\t(* force_downto *)\\n\\twire [MAX_WIDTH-1:0] C;\\n\\tassign Y = O, CO = C;\\n\\n\\tgenvar i;\\n\\tgenerate for (i = 0; i < CARRY4_COUNT; i = i + 1) begin:slice\\n\\t\\tif (i == 0) begin\\n\\t\\t\\tCARRY4 carry4\\n\\t\\t\\t(\\n\\t\\t\\t.CYINIT(CI),\\n\\t\\t\\t.CI    (1'd0),\\n\\t\\t\\t.DI    (DI[i*4 +: 4]),\\n\\t\\t\\t.S     (S [i*4 +: 4]),\\n\\t\\t\\t.O     (O [i*4 +: 4]),\\n\\t\\t\\t.CO    (C [i*4 +: 4])\\n\\t\\t\\t);\\n\\t\\tend else begin\\n\\t\\t    CARRY4 carry4\\n\\t\\t    (\\n\\t\\t\\t.CYINIT(1'd0),\\n\\t\\t\\t.CI    (C [i*4 - 1]),\\n\\t\\t\\t.DI    (DI[i*4 +: 4]),\\n\\t\\t\\t.S     (S [i*4 +: 4]),\\n\\t\\t\\t.O     (O [i*4 +: 4]),\\n\\t\\t\\t.CO    (C [i*4 +: 4])\\n\\t\\t    );\\n\\t\\tend\\n\\tend endgenerate\\n\\n\\tassign X = S;\\n\\nend endgenerate\\nendmodule\\n\\n\",\n            \"brams_defs.vh\": \"`define PARAMS_INIT_9 \\\\\\n\\t.INIT_00(slice_init('h00)), \\\\\\n\\t.INIT_01(slice_init('h01)), \\\\\\n\\t.INIT_02(slice_init('h02)), \\\\\\n\\t.INIT_03(slice_init('h03)), \\\\\\n\\t.INIT_04(slice_init('h04)), \\\\\\n\\t.INIT_05(slice_init('h05)), \\\\\\n\\t.INIT_06(slice_init('h06)), \\\\\\n\\t.INIT_07(slice_init('h07)), \\\\\\n\\t.INIT_08(slice_init('h08)), \\\\\\n\\t.INIT_09(slice_init('h09)), \\\\\\n\\t.INIT_0A(slice_init('h0a)), \\\\\\n\\t.INIT_0B(slice_init('h0b)), \\\\\\n\\t.INIT_0C(slice_init('h0c)), \\\\\\n\\t.INIT_0D(slice_init('h0d)), \\\\\\n\\t.INIT_0E(slice_init('h0e)), \\\\\\n\\t.INIT_0F(slice_init('h0f)), \\\\\\n\\t.INIT_10(slice_init('h10)), \\\\\\n\\t.INIT_11(slice_init('h11)), \\\\\\n\\t.INIT_12(slice_init('h12)), \\\\\\n\\t.INIT_13(slice_init('h13)), \\\\\\n\\t.INIT_14(slice_init('h14)), \\\\\\n\\t.INIT_15(slice_init('h15)), \\\\\\n\\t.INIT_16(slice_init('h16)), \\\\\\n\\t.INIT_17(slice_init('h17)), \\\\\\n\\t.INIT_18(slice_init('h18)), \\\\\\n\\t.INIT_19(slice_init('h19)), \\\\\\n\\t.INIT_1A(slice_init('h1a)), \\\\\\n\\t.INIT_1B(slice_init('h1b)), \\\\\\n\\t.INIT_1C(slice_init('h1c)), \\\\\\n\\t.INIT_1D(slice_init('h1d)), \\\\\\n\\t.INIT_1E(slice_init('h1e)), \\\\\\n\\t.INIT_1F(slice_init('h1f)),\\n\\n`define PARAMS_INITP_9 \\\\\\n\\t.INITP_00(slice_initp('h00)), \\\\\\n\\t.INITP_01(slice_initp('h01)), \\\\\\n\\t.INITP_02(slice_initp('h02)), \\\\\\n\\t.INITP_03(slice_initp('h03)),\\n\\n`define PARAMS_INIT_18 \\\\\\n\\t.INIT_00(slice_init('h00)), \\\\\\n\\t.INIT_01(slice_init('h01)), \\\\\\n\\t.INIT_02(slice_init('h02)), \\\\\\n\\t.INIT_03(slice_init('h03)), \\\\\\n\\t.INIT_04(slice_init('h04)), \\\\\\n\\t.INIT_05(slice_init('h05)), \\\\\\n\\t.INIT_06(slice_init('h06)), \\\\\\n\\t.INIT_07(slice_init('h07)), \\\\\\n\\t.INIT_08(slice_init('h08)), \\\\\\n\\t.INIT_09(slice_init('h09)), \\\\\\n\\t.INIT_0A(slice_init('h0a)), \\\\\\n\\t.INIT_0B(slice_init('h0b)), \\\\\\n\\t.INIT_0C(slice_init('h0c)), \\\\\\n\\t.INIT_0D(slice_init('h0d)), \\\\\\n\\t.INIT_0E(slice_init('h0e)), \\\\\\n\\t.INIT_0F(slice_init('h0f)), \\\\\\n\\t.INIT_10(slice_init('h10)), \\\\\\n\\t.INIT_11(slice_init('h11)), \\\\\\n\\t.INIT_12(slice_init('h12)), \\\\\\n\\t.INIT_13(slice_init('h13)), \\\\\\n\\t.INIT_14(slice_init('h14)), \\\\\\n\\t.INIT_15(slice_init('h15)), \\\\\\n\\t.INIT_16(slice_init('h16)), \\\\\\n\\t.INIT_17(slice_init('h17)), \\\\\\n\\t.INIT_18(slice_init('h18)), \\\\\\n\\t.INIT_19(slice_init('h19)), \\\\\\n\\t.INIT_1A(slice_init('h1a)), \\\\\\n\\t.INIT_1B(slice_init('h1b)), \\\\\\n\\t.INIT_1C(slice_init('h1c)), \\\\\\n\\t.INIT_1D(slice_init('h1d)), \\\\\\n\\t.INIT_1E(slice_init('h1e)), \\\\\\n\\t.INIT_1F(slice_init('h1f)), \\\\\\n\\t.INIT_20(slice_init('h20)), \\\\\\n\\t.INIT_21(slice_init('h21)), \\\\\\n\\t.INIT_22(slice_init('h22)), \\\\\\n\\t.INIT_23(slice_init('h23)), \\\\\\n\\t.INIT_24(slice_init('h24)), \\\\\\n\\t.INIT_25(slice_init('h25)), \\\\\\n\\t.INIT_26(slice_init('h26)), \\\\\\n\\t.INIT_27(slice_init('h27)), \\\\\\n\\t.INIT_28(slice_init('h28)), \\\\\\n\\t.INIT_29(slice_init('h29)), \\\\\\n\\t.INIT_2A(slice_init('h2a)), \\\\\\n\\t.INIT_2B(slice_init('h2b)), \\\\\\n\\t.INIT_2C(slice_init('h2c)), \\\\\\n\\t.INIT_2D(slice_init('h2d)), \\\\\\n\\t.INIT_2E(slice_init('h2e)), \\\\\\n\\t.INIT_2F(slice_init('h2f)), \\\\\\n\\t.INIT_30(slice_init('h30)), \\\\\\n\\t.INIT_31(slice_init('h31)), \\\\\\n\\t.INIT_32(slice_init('h32)), \\\\\\n\\t.INIT_33(slice_init('h33)), \\\\\\n\\t.INIT_34(slice_init('h34)), \\\\\\n\\t.INIT_35(slice_init('h35)), \\\\\\n\\t.INIT_36(slice_init('h36)), \\\\\\n\\t.INIT_37(slice_init('h37)), \\\\\\n\\t.INIT_38(slice_init('h38)), \\\\\\n\\t.INIT_39(slice_init('h39)), \\\\\\n\\t.INIT_3A(slice_init('h3a)), \\\\\\n\\t.INIT_3B(slice_init('h3b)), \\\\\\n\\t.INIT_3C(slice_init('h3c)), \\\\\\n\\t.INIT_3D(slice_init('h3d)), \\\\\\n\\t.INIT_3E(slice_init('h3e)), \\\\\\n\\t.INIT_3F(slice_init('h3f)),\\n\\n`define PARAMS_INIT_18_U \\\\\\n\\t.INIT_00(slice_init('h40)), \\\\\\n\\t.INIT_01(slice_init('h41)), \\\\\\n\\t.INIT_02(slice_init('h42)), \\\\\\n\\t.INIT_03(slice_init('h43)), \\\\\\n\\t.INIT_04(slice_init('h44)), \\\\\\n\\t.INIT_05(slice_init('h45)), \\\\\\n\\t.INIT_06(slice_init('h46)), \\\\\\n\\t.INIT_07(slice_init('h47)), \\\\\\n\\t.INIT_08(slice_init('h48)), \\\\\\n\\t.INIT_09(slice_init('h49)), \\\\\\n\\t.INIT_0A(slice_init('h4a)), \\\\\\n\\t.INIT_0B(slice_init('h4b)), \\\\\\n\\t.INIT_0C(slice_init('h4c)), \\\\\\n\\t.INIT_0D(slice_init('h4d)), \\\\\\n\\t.INIT_0E(slice_init('h4e)), \\\\\\n\\t.INIT_0F(slice_init('h4f)), \\\\\\n\\t.INIT_10(slice_init('h50)), \\\\\\n\\t.INIT_11(slice_init('h51)), \\\\\\n\\t.INIT_12(slice_init('h52)), \\\\\\n\\t.INIT_13(slice_init('h53)), \\\\\\n\\t.INIT_14(slice_init('h54)), \\\\\\n\\t.INIT_15(slice_init('h55)), \\\\\\n\\t.INIT_16(slice_init('h56)), \\\\\\n\\t.INIT_17(slice_init('h57)), \\\\\\n\\t.INIT_18(slice_init('h58)), \\\\\\n\\t.INIT_19(slice_init('h59)), \\\\\\n\\t.INIT_1A(slice_init('h5a)), \\\\\\n\\t.INIT_1B(slice_init('h5b)), \\\\\\n\\t.INIT_1C(slice_init('h5c)), \\\\\\n\\t.INIT_1D(slice_init('h5d)), \\\\\\n\\t.INIT_1E(slice_init('h5e)), \\\\\\n\\t.INIT_1F(slice_init('h5f)), \\\\\\n\\t.INIT_20(slice_init('h60)), \\\\\\n\\t.INIT_21(slice_init('h61)), \\\\\\n\\t.INIT_22(slice_init('h62)), \\\\\\n\\t.INIT_23(slice_init('h63)), \\\\\\n\\t.INIT_24(slice_init('h64)), \\\\\\n\\t.INIT_25(slice_init('h65)), \\\\\\n\\t.INIT_26(slice_init('h66)), \\\\\\n\\t.INIT_27(slice_init('h67)), \\\\\\n\\t.INIT_28(slice_init('h68)), \\\\\\n\\t.INIT_29(slice_init('h69)), \\\\\\n\\t.INIT_2A(slice_init('h6a)), \\\\\\n\\t.INIT_2B(slice_init('h6b)), \\\\\\n\\t.INIT_2C(slice_init('h6c)), \\\\\\n\\t.INIT_2D(slice_init('h6d)), \\\\\\n\\t.INIT_2E(slice_init('h6e)), \\\\\\n\\t.INIT_2F(slice_init('h6f)), \\\\\\n\\t.INIT_30(slice_init('h70)), \\\\\\n\\t.INIT_31(slice_init('h71)), \\\\\\n\\t.INIT_32(slice_init('h72)), \\\\\\n\\t.INIT_33(slice_init('h73)), \\\\\\n\\t.INIT_34(slice_init('h74)), \\\\\\n\\t.INIT_35(slice_init('h75)), \\\\\\n\\t.INIT_36(slice_init('h76)), \\\\\\n\\t.INIT_37(slice_init('h77)), \\\\\\n\\t.INIT_38(slice_init('h78)), \\\\\\n\\t.INIT_39(slice_init('h79)), \\\\\\n\\t.INIT_3A(slice_init('h7a)), \\\\\\n\\t.INIT_3B(slice_init('h7b)), \\\\\\n\\t.INIT_3C(slice_init('h7c)), \\\\\\n\\t.INIT_3D(slice_init('h7d)), \\\\\\n\\t.INIT_3E(slice_init('h7e)), \\\\\\n\\t.INIT_3F(slice_init('h7f)),\\n\\n`define PARAMS_INITP_18 \\\\\\n\\t.INITP_00(slice_initp('h00)), \\\\\\n\\t.INITP_01(slice_initp('h01)), \\\\\\n\\t.INITP_02(slice_initp('h02)), \\\\\\n\\t.INITP_03(slice_initp('h03)), \\\\\\n\\t.INITP_04(slice_initp('h04)), \\\\\\n\\t.INITP_05(slice_initp('h05)), \\\\\\n\\t.INITP_06(slice_initp('h06)), \\\\\\n\\t.INITP_07(slice_initp('h07)),\\n\\n`define PARAMS_INIT_36 \\\\\\n\\t.INIT_00(slice_init('h00)), \\\\\\n\\t.INIT_01(slice_init('h01)), \\\\\\n\\t.INIT_02(slice_init('h02)), \\\\\\n\\t.INIT_03(slice_init('h03)), \\\\\\n\\t.INIT_04(slice_init('h04)), \\\\\\n\\t.INIT_05(slice_init('h05)), \\\\\\n\\t.INIT_06(slice_init('h06)), \\\\\\n\\t.INIT_07(slice_init('h07)), \\\\\\n\\t.INIT_08(slice_init('h08)), \\\\\\n\\t.INIT_09(slice_init('h09)), \\\\\\n\\t.INIT_0A(slice_init('h0a)), \\\\\\n\\t.INIT_0B(slice_init('h0b)), \\\\\\n\\t.INIT_0C(slice_init('h0c)), \\\\\\n\\t.INIT_0D(slice_init('h0d)), \\\\\\n\\t.INIT_0E(slice_init('h0e)), \\\\\\n\\t.INIT_0F(slice_init('h0f)), \\\\\\n\\t.INIT_10(slice_init('h10)), \\\\\\n\\t.INIT_11(slice_init('h11)), \\\\\\n\\t.INIT_12(slice_init('h12)), \\\\\\n\\t.INIT_13(slice_init('h13)), \\\\\\n\\t.INIT_14(slice_init('h14)), \\\\\\n\\t.INIT_15(slice_init('h15)), \\\\\\n\\t.INIT_16(slice_init('h16)), \\\\\\n\\t.INIT_17(slice_init('h17)), \\\\\\n\\t.INIT_18(slice_init('h18)), \\\\\\n\\t.INIT_19(slice_init('h19)), \\\\\\n\\t.INIT_1A(slice_init('h1a)), \\\\\\n\\t.INIT_1B(slice_init('h1b)), \\\\\\n\\t.INIT_1C(slice_init('h1c)), \\\\\\n\\t.INIT_1D(slice_init('h1d)), \\\\\\n\\t.INIT_1E(slice_init('h1e)), \\\\\\n\\t.INIT_1F(slice_init('h1f)), \\\\\\n\\t.INIT_20(slice_init('h20)), \\\\\\n\\t.INIT_21(slice_init('h21)), \\\\\\n\\t.INIT_22(slice_init('h22)), \\\\\\n\\t.INIT_23(slice_init('h23)), \\\\\\n\\t.INIT_24(slice_init('h24)), \\\\\\n\\t.INIT_25(slice_init('h25)), \\\\\\n\\t.INIT_26(slice_init('h26)), \\\\\\n\\t.INIT_27(slice_init('h27)), \\\\\\n\\t.INIT_28(slice_init('h28)), \\\\\\n\\t.INIT_29(slice_init('h29)), \\\\\\n\\t.INIT_2A(slice_init('h2a)), \\\\\\n\\t.INIT_2B(slice_init('h2b)), \\\\\\n\\t.INIT_2C(slice_init('h2c)), \\\\\\n\\t.INIT_2D(slice_init('h2d)), \\\\\\n\\t.INIT_2E(slice_init('h2e)), \\\\\\n\\t.INIT_2F(slice_init('h2f)), \\\\\\n\\t.INIT_30(slice_init('h30)), \\\\\\n\\t.INIT_31(slice_init('h31)), \\\\\\n\\t.INIT_32(slice_init('h32)), \\\\\\n\\t.INIT_33(slice_init('h33)), \\\\\\n\\t.INIT_34(slice_init('h34)), \\\\\\n\\t.INIT_35(slice_init('h35)), \\\\\\n\\t.INIT_36(slice_init('h36)), \\\\\\n\\t.INIT_37(slice_init('h37)), \\\\\\n\\t.INIT_38(slice_init('h38)), \\\\\\n\\t.INIT_39(slice_init('h39)), \\\\\\n\\t.INIT_3A(slice_init('h3a)), \\\\\\n\\t.INIT_3B(slice_init('h3b)), \\\\\\n\\t.INIT_3C(slice_init('h3c)), \\\\\\n\\t.INIT_3D(slice_init('h3d)), \\\\\\n\\t.INIT_3E(slice_init('h3e)), \\\\\\n\\t.INIT_3F(slice_init('h3f)), \\\\\\n\\t.INIT_40(slice_init('h40)), \\\\\\n\\t.INIT_41(slice_init('h41)), \\\\\\n\\t.INIT_42(slice_init('h42)), \\\\\\n\\t.INIT_43(slice_init('h43)), \\\\\\n\\t.INIT_44(slice_init('h44)), \\\\\\n\\t.INIT_45(slice_init('h45)), \\\\\\n\\t.INIT_46(slice_init('h46)), \\\\\\n\\t.INIT_47(slice_init('h47)), \\\\\\n\\t.INIT_48(slice_init('h48)), \\\\\\n\\t.INIT_49(slice_init('h49)), \\\\\\n\\t.INIT_4A(slice_init('h4a)), \\\\\\n\\t.INIT_4B(slice_init('h4b)), \\\\\\n\\t.INIT_4C(slice_init('h4c)), \\\\\\n\\t.INIT_4D(slice_init('h4d)), \\\\\\n\\t.INIT_4E(slice_init('h4e)), \\\\\\n\\t.INIT_4F(slice_init('h4f)), \\\\\\n\\t.INIT_50(slice_init('h50)), \\\\\\n\\t.INIT_51(slice_init('h51)), \\\\\\n\\t.INIT_52(slice_init('h52)), \\\\\\n\\t.INIT_53(slice_init('h53)), \\\\\\n\\t.INIT_54(slice_init('h54)), \\\\\\n\\t.INIT_55(slice_init('h55)), \\\\\\n\\t.INIT_56(slice_init('h56)), \\\\\\n\\t.INIT_57(slice_init('h57)), \\\\\\n\\t.INIT_58(slice_init('h58)), \\\\\\n\\t.INIT_59(slice_init('h59)), \\\\\\n\\t.INIT_5A(slice_init('h5a)), \\\\\\n\\t.INIT_5B(slice_init('h5b)), \\\\\\n\\t.INIT_5C(slice_init('h5c)), \\\\\\n\\t.INIT_5D(slice_init('h5d)), \\\\\\n\\t.INIT_5E(slice_init('h5e)), \\\\\\n\\t.INIT_5F(slice_init('h5f)), \\\\\\n\\t.INIT_60(slice_init('h60)), \\\\\\n\\t.INIT_61(slice_init('h61)), \\\\\\n\\t.INIT_62(slice_init('h62)), \\\\\\n\\t.INIT_63(slice_init('h63)), \\\\\\n\\t.INIT_64(slice_init('h64)), \\\\\\n\\t.INIT_65(slice_init('h65)), \\\\\\n\\t.INIT_66(slice_init('h66)), \\\\\\n\\t.INIT_67(slice_init('h67)), \\\\\\n\\t.INIT_68(slice_init('h68)), \\\\\\n\\t.INIT_69(slice_init('h69)), \\\\\\n\\t.INIT_6A(slice_init('h6a)), \\\\\\n\\t.INIT_6B(slice_init('h6b)), \\\\\\n\\t.INIT_6C(slice_init('h6c)), \\\\\\n\\t.INIT_6D(slice_init('h6d)), \\\\\\n\\t.INIT_6E(slice_init('h6e)), \\\\\\n\\t.INIT_6F(slice_init('h6f)), \\\\\\n\\t.INIT_70(slice_init('h70)), \\\\\\n\\t.INIT_71(slice_init('h71)), \\\\\\n\\t.INIT_72(slice_init('h72)), \\\\\\n\\t.INIT_73(slice_init('h73)), \\\\\\n\\t.INIT_74(slice_init('h74)), \\\\\\n\\t.INIT_75(slice_init('h75)), \\\\\\n\\t.INIT_76(slice_init('h76)), \\\\\\n\\t.INIT_77(slice_init('h77)), \\\\\\n\\t.INIT_78(slice_init('h78)), \\\\\\n\\t.INIT_79(slice_init('h79)), \\\\\\n\\t.INIT_7A(slice_init('h7a)), \\\\\\n\\t.INIT_7B(slice_init('h7b)), \\\\\\n\\t.INIT_7C(slice_init('h7c)), \\\\\\n\\t.INIT_7D(slice_init('h7d)), \\\\\\n\\t.INIT_7E(slice_init('h7e)), \\\\\\n\\t.INIT_7F(slice_init('h7f)),\\n\\n`define PARAMS_INIT_36_U \\\\\\n\\t.INIT_00(slice_init('h80)), \\\\\\n\\t.INIT_01(slice_init('h81)), \\\\\\n\\t.INIT_02(slice_init('h82)), \\\\\\n\\t.INIT_03(slice_init('h83)), \\\\\\n\\t.INIT_04(slice_init('h84)), \\\\\\n\\t.INIT_05(slice_init('h85)), \\\\\\n\\t.INIT_06(slice_init('h86)), \\\\\\n\\t.INIT_07(slice_init('h87)), \\\\\\n\\t.INIT_08(slice_init('h88)), \\\\\\n\\t.INIT_09(slice_init('h89)), \\\\\\n\\t.INIT_0A(slice_init('h8a)), \\\\\\n\\t.INIT_0B(slice_init('h8b)), \\\\\\n\\t.INIT_0C(slice_init('h8c)), \\\\\\n\\t.INIT_0D(slice_init('h8d)), \\\\\\n\\t.INIT_0E(slice_init('h8e)), \\\\\\n\\t.INIT_0F(slice_init('h8f)), \\\\\\n\\t.INIT_10(slice_init('h90)), \\\\\\n\\t.INIT_11(slice_init('h91)), \\\\\\n\\t.INIT_12(slice_init('h92)), \\\\\\n\\t.INIT_13(slice_init('h93)), \\\\\\n\\t.INIT_14(slice_init('h94)), \\\\\\n\\t.INIT_15(slice_init('h95)), \\\\\\n\\t.INIT_16(slice_init('h96)), \\\\\\n\\t.INIT_17(slice_init('h97)), \\\\\\n\\t.INIT_18(slice_init('h98)), \\\\\\n\\t.INIT_19(slice_init('h99)), \\\\\\n\\t.INIT_1A(slice_init('h9a)), \\\\\\n\\t.INIT_1B(slice_init('h9b)), \\\\\\n\\t.INIT_1C(slice_init('h9c)), \\\\\\n\\t.INIT_1D(slice_init('h9d)), \\\\\\n\\t.INIT_1E(slice_init('h9e)), \\\\\\n\\t.INIT_1F(slice_init('h9f)), \\\\\\n\\t.INIT_20(slice_init('ha0)), \\\\\\n\\t.INIT_21(slice_init('ha1)), \\\\\\n\\t.INIT_22(slice_init('ha2)), \\\\\\n\\t.INIT_23(slice_init('ha3)), \\\\\\n\\t.INIT_24(slice_init('ha4)), \\\\\\n\\t.INIT_25(slice_init('ha5)), \\\\\\n\\t.INIT_26(slice_init('ha6)), \\\\\\n\\t.INIT_27(slice_init('ha7)), \\\\\\n\\t.INIT_28(slice_init('ha8)), \\\\\\n\\t.INIT_29(slice_init('ha9)), \\\\\\n\\t.INIT_2A(slice_init('haa)), \\\\\\n\\t.INIT_2B(slice_init('hab)), \\\\\\n\\t.INIT_2C(slice_init('hac)), \\\\\\n\\t.INIT_2D(slice_init('had)), \\\\\\n\\t.INIT_2E(slice_init('hae)), \\\\\\n\\t.INIT_2F(slice_init('haf)), \\\\\\n\\t.INIT_30(slice_init('hb0)), \\\\\\n\\t.INIT_31(slice_init('hb1)), \\\\\\n\\t.INIT_32(slice_init('hb2)), \\\\\\n\\t.INIT_33(slice_init('hb3)), \\\\\\n\\t.INIT_34(slice_init('hb4)), \\\\\\n\\t.INIT_35(slice_init('hb5)), \\\\\\n\\t.INIT_36(slice_init('hb6)), \\\\\\n\\t.INIT_37(slice_init('hb7)), \\\\\\n\\t.INIT_38(slice_init('hb8)), \\\\\\n\\t.INIT_39(slice_init('hb9)), \\\\\\n\\t.INIT_3A(slice_init('hba)), \\\\\\n\\t.INIT_3B(slice_init('hbb)), \\\\\\n\\t.INIT_3C(slice_init('hbc)), \\\\\\n\\t.INIT_3D(slice_init('hbd)), \\\\\\n\\t.INIT_3E(slice_init('hbe)), \\\\\\n\\t.INIT_3F(slice_init('hbf)), \\\\\\n\\t.INIT_40(slice_init('hc0)), \\\\\\n\\t.INIT_41(slice_init('hc1)), \\\\\\n\\t.INIT_42(slice_init('hc2)), \\\\\\n\\t.INIT_43(slice_init('hc3)), \\\\\\n\\t.INIT_44(slice_init('hc4)), \\\\\\n\\t.INIT_45(slice_init('hc5)), \\\\\\n\\t.INIT_46(slice_init('hc6)), \\\\\\n\\t.INIT_47(slice_init('hc7)), \\\\\\n\\t.INIT_48(slice_init('hc8)), \\\\\\n\\t.INIT_49(slice_init('hc9)), \\\\\\n\\t.INIT_4A(slice_init('hca)), \\\\\\n\\t.INIT_4B(slice_init('hcb)), \\\\\\n\\t.INIT_4C(slice_init('hcc)), \\\\\\n\\t.INIT_4D(slice_init('hcd)), \\\\\\n\\t.INIT_4E(slice_init('hce)), \\\\\\n\\t.INIT_4F(slice_init('hcf)), \\\\\\n\\t.INIT_50(slice_init('hd0)), \\\\\\n\\t.INIT_51(slice_init('hd1)), \\\\\\n\\t.INIT_52(slice_init('hd2)), \\\\\\n\\t.INIT_53(slice_init('hd3)), \\\\\\n\\t.INIT_54(slice_init('hd4)), \\\\\\n\\t.INIT_55(slice_init('hd5)), \\\\\\n\\t.INIT_56(slice_init('hd6)), \\\\\\n\\t.INIT_57(slice_init('hd7)), \\\\\\n\\t.INIT_58(slice_init('hd8)), \\\\\\n\\t.INIT_59(slice_init('hd9)), \\\\\\n\\t.INIT_5A(slice_init('hda)), \\\\\\n\\t.INIT_5B(slice_init('hdb)), \\\\\\n\\t.INIT_5C(slice_init('hdc)), \\\\\\n\\t.INIT_5D(slice_init('hdd)), \\\\\\n\\t.INIT_5E(slice_init('hde)), \\\\\\n\\t.INIT_5F(slice_init('hdf)), \\\\\\n\\t.INIT_60(slice_init('he0)), \\\\\\n\\t.INIT_61(slice_init('he1)), \\\\\\n\\t.INIT_62(slice_init('he2)), \\\\\\n\\t.INIT_63(slice_init('he3)), \\\\\\n\\t.INIT_64(slice_init('he4)), \\\\\\n\\t.INIT_65(slice_init('he5)), \\\\\\n\\t.INIT_66(slice_init('he6)), \\\\\\n\\t.INIT_67(slice_init('he7)), \\\\\\n\\t.INIT_68(slice_init('he8)), \\\\\\n\\t.INIT_69(slice_init('he9)), \\\\\\n\\t.INIT_6A(slice_init('hea)), \\\\\\n\\t.INIT_6B(slice_init('heb)), \\\\\\n\\t.INIT_6C(slice_init('hec)), \\\\\\n\\t.INIT_6D(slice_init('hed)), \\\\\\n\\t.INIT_6E(slice_init('hee)), \\\\\\n\\t.INIT_6F(slice_init('hef)), \\\\\\n\\t.INIT_70(slice_init('hf0)), \\\\\\n\\t.INIT_71(slice_init('hf1)), \\\\\\n\\t.INIT_72(slice_init('hf2)), \\\\\\n\\t.INIT_73(slice_init('hf3)), \\\\\\n\\t.INIT_74(slice_init('hf4)), \\\\\\n\\t.INIT_75(slice_init('hf5)), \\\\\\n\\t.INIT_76(slice_init('hf6)), \\\\\\n\\t.INIT_77(slice_init('hf7)), \\\\\\n\\t.INIT_78(slice_init('hf8)), \\\\\\n\\t.INIT_79(slice_init('hf9)), \\\\\\n\\t.INIT_7A(slice_init('hfa)), \\\\\\n\\t.INIT_7B(slice_init('hfb)), \\\\\\n\\t.INIT_7C(slice_init('hfc)), \\\\\\n\\t.INIT_7D(slice_init('hfd)), \\\\\\n\\t.INIT_7E(slice_init('hfe)), \\\\\\n\\t.INIT_7F(slice_init('hff)),\\n\\n`define PARAMS_INITP_36 \\\\\\n\\t.INITP_00(slice_initp('h00)), \\\\\\n\\t.INITP_01(slice_initp('h01)), \\\\\\n\\t.INITP_02(slice_initp('h02)), \\\\\\n\\t.INITP_03(slice_initp('h03)), \\\\\\n\\t.INITP_04(slice_initp('h04)), \\\\\\n\\t.INITP_05(slice_initp('h05)), \\\\\\n\\t.INITP_06(slice_initp('h06)), \\\\\\n\\t.INITP_07(slice_initp('h07)), \\\\\\n\\t.INITP_08(slice_initp('h08)), \\\\\\n\\t.INITP_09(slice_initp('h09)), \\\\\\n\\t.INITP_0A(slice_initp('h0a)), \\\\\\n\\t.INITP_0B(slice_initp('h0b)), \\\\\\n\\t.INITP_0C(slice_initp('h0c)), \\\\\\n\\t.INITP_0D(slice_initp('h0d)), \\\\\\n\\t.INITP_0E(slice_initp('h0e)), \\\\\\n\\t.INITP_0F(slice_initp('h0f)),\\n\\n`define MAKE_DO(do, dop, rdata) \\\\\\n\\twire [63:0] do; \\\\\\n\\twire [7:0] dop; \\\\\\n\\tassign rdata = { \\\\\\n\\t\\tdop[7], \\\\\\n\\t\\tdo[63:56], \\\\\\n\\t\\tdop[6], \\\\\\n\\t\\tdo[55:48], \\\\\\n\\t\\tdop[5], \\\\\\n\\t\\tdo[47:40], \\\\\\n\\t\\tdop[4], \\\\\\n\\t\\tdo[39:32], \\\\\\n\\t\\tdop[3], \\\\\\n\\t\\tdo[31:24], \\\\\\n\\t\\tdop[2], \\\\\\n\\t\\tdo[23:16], \\\\\\n\\t\\tdop[1], \\\\\\n\\t\\tdo[15:8], \\\\\\n\\t\\tdop[0], \\\\\\n\\t\\tdo[7:0] \\\\\\n\\t};\\n\\n`define MAKE_DI(di, dip, wdata) \\\\\\n\\twire [63:0] di; \\\\\\n\\twire [7:0] dip; \\\\\\n\\tassign { \\\\\\n\\t\\tdip[7], \\\\\\n\\t\\tdi[63:56], \\\\\\n\\t\\tdip[6], \\\\\\n\\t\\tdi[55:48], \\\\\\n\\t\\tdip[5], \\\\\\n\\t\\tdi[47:40], \\\\\\n\\t\\tdip[4], \\\\\\n\\t\\tdi[39:32], \\\\\\n\\t\\tdip[3], \\\\\\n\\t\\tdi[31:24], \\\\\\n\\t\\tdip[2], \\\\\\n\\t\\tdi[23:16], \\\\\\n\\t\\tdip[1], \\\\\\n\\t\\tdi[15:8], \\\\\\n\\t\\tdip[0], \\\\\\n\\t\\tdi[7:0] \\\\\\n\\t} = wdata;\\n\\nfunction [71:0] ival;\\n\\tinput integer width;\\n\\tinput [71:0] val;\\n\\tif (width == 72)\\n\\t\\tival = {\\n\\t\\t\\tval[71],\\n\\t\\t\\tval[62],\\n\\t\\t\\tval[53],\\n\\t\\t\\tval[44],\\n\\t\\t\\tval[35],\\n\\t\\t\\tval[26],\\n\\t\\t\\tval[17],\\n\\t\\t\\tval[8],\\n\\t\\t\\tval[70:63],\\n\\t\\t\\tval[61:54],\\n\\t\\t\\tval[52:45],\\n\\t\\t\\tval[43:36],\\n\\t\\t\\tval[34:27],\\n\\t\\t\\tval[25:18],\\n\\t\\t\\tval[16:9],\\n\\t\\t\\tval[7:0]\\n\\t\\t};\\n\\telse if (width == 36)\\n\\t\\tival = {\\n\\t\\t\\tval[35],\\n\\t\\t\\tval[26],\\n\\t\\t\\tval[17],\\n\\t\\t\\tval[8],\\n\\t\\t\\tval[34:27],\\n\\t\\t\\tval[25:18],\\n\\t\\t\\tval[16:9],\\n\\t\\t\\tval[7:0]\\n\\t\\t};\\n\\telse if (width == 18)\\n\\t\\tival = {\\n\\t\\t\\tval[17],\\n\\t\\t\\tval[8],\\n\\t\\t\\tval[16:9],\\n\\t\\t\\tval[7:0]\\n\\t\\t};\\n\\telse\\n\\t\\tival = val;\\nendfunction\\n\\nfunction [255:0] slice_init;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < 32; i = i + 1)\\n\\t\\tslice_init[i*8+:8] = INIT[(idx * 32 + i)*9+:8];\\nendfunction\\n\\nfunction [255:0] slice_initp;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < 256; i = i + 1)\\n\\t\\tslice_initp[i] = INIT[(idx * 256 + i)*9+8];\\nendfunction\\n\",\n            \"brams_xc2v.txt\": \"# Block RAMs for Virtex 2, Spartan 3, Spartan 3E, Spartan 3A(N)\\n# The corresponding mapping file is brams_xc2v_map.v\\n\\nram block $__XILINX_BLOCKRAM_ {\\n\\tabits 14;\\n\\twidths 1 2 4 9 18 36 per_port;\\n\\tifdef HAS_BE {\\n\\t\\toption \\\"USE_BE\\\" 1 byte 9;\\n\\t}\\n\\tcost 129;\\n\\tinit any;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\toption \\\"USE_BE\\\" 0 width tied;\\n\\t\\tifdef HAS_BE {\\n\\t\\t\\toption \\\"USE_BE\\\" 1 width tied 9 18 36;\\n\\t\\t}\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t\\trdsrst any gated_clken;\\n\\t\\trdinit any;\\n\\t\\tportoption \\\"WRITE_MODE\\\" \\\"NO_CHANGE\\\" {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITE_MODE\\\" \\\"WRITE_FIRST\\\" {\\n\\t\\t\\trdwr new_only;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\trdwr old;\\n\\t\\t\\twrtrans all old;\\n\\t\\t}\\n\\t\\toptional;\\n\\t}\\n}\\n\",\n            \"brams_xc2v_map.v\": \"module $__XILINX_BLOCKRAM_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_USE_BE = 0;\\n\\nparameter PORT_A_WIDTH = 1;\\nparameter PORT_A_WR_EN_WIDTH = 1;\\nparameter PORT_A_USED = 1;\\nparameter PORT_A_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_A_RD_INIT_VALUE = 0;\\nparameter PORT_A_RD_SRST_VALUE = 0;\\n\\nparameter PORT_B_WIDTH = 1;\\nparameter PORT_B_WR_EN_WIDTH = 1;\\nparameter PORT_B_USED = 0;\\nparameter PORT_B_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_B_RD_INIT_VALUE = 0;\\nparameter PORT_B_RD_SRST_VALUE = 0;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput [13:0] PORT_A_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\ninput [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\ninput PORT_A_RD_SRST;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput [13:0] PORT_B_ADDR;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\ninput [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\ninput PORT_B_RD_SRST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\n`define PARAMS_DP \\\\\\n\\t`PARAMS_INIT_18 \\\\\\n\\t.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\\\\\n\\t.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\\\\\n\\t.SRVAL_A(SRVAL_A), \\\\\\n\\t.SRVAL_B(SRVAL_B), \\\\\\n\\t.INIT_A(INIT_A), \\\\\\n\\t.INIT_B(INIT_B),\\n\\n`define PARAMS_DP_SWAP \\\\\\n\\t`PARAMS_INIT_18 \\\\\\n\\t.WRITE_MODE_A(PORT_B_OPTION_WRITE_MODE), \\\\\\n\\t.WRITE_MODE_B(PORT_A_OPTION_WRITE_MODE), \\\\\\n\\t.SRVAL_A(SRVAL_B), \\\\\\n\\t.SRVAL_B(SRVAL_A), \\\\\\n\\t.INIT_A(INIT_B), \\\\\\n\\t.INIT_B(INIT_A),\\n\\n`define PARAMS_SP \\\\\\n\\t`PARAMS_INIT_18 \\\\\\n\\t.WRITE_MODE(PORT_A_OPTION_WRITE_MODE), \\\\\\n\\t.SRVAL(SRVAL_A), \\\\\\n\\t.INIT(INIT_A),\\n\\n`define PORTS_DP(addr_slice_a, addr_slice_b) \\\\\\n\\t.CLKA(PORT_A_CLK), \\\\\\n\\t.ENA(PORT_A_CLK_EN), \\\\\\n\\t.WEA(PORT_A_WR_EN), \\\\\\n\\t.SSRA(PORT_A_RD_SRST), \\\\\\n\\t.ADDRA(PORT_A_ADDR addr_slice_a), \\\\\\n\\t.DOA(DO_A), \\\\\\n\\t.DIA(DI_A), \\\\\\n\\t.CLKB(PORT_B_CLK), \\\\\\n\\t.ENB(PORT_B_CLK_EN), \\\\\\n\\t.WEB(PORT_B_WR_EN), \\\\\\n\\t.SSRB(PORT_B_RD_SRST), \\\\\\n\\t.ADDRB(PORT_B_ADDR addr_slice_b), \\\\\\n\\t.DOB(DO_B), \\\\\\n\\t.DIB(DI_B),\\n\\n`define PORTS_DP_SWAP(addr_slice_a, addr_slice_b) \\\\\\n\\t.CLKB(PORT_A_CLK), \\\\\\n\\t.ENB(PORT_A_CLK_EN), \\\\\\n\\t.WEB(PORT_A_WR_EN), \\\\\\n\\t.SSRB(PORT_A_RD_SRST), \\\\\\n\\t.ADDRB(PORT_A_ADDR addr_slice_a), \\\\\\n\\t.DOB(DO_A), \\\\\\n\\t.DIB(DI_A), \\\\\\n\\t.CLKA(PORT_B_CLK), \\\\\\n\\t.ENA(PORT_B_CLK_EN), \\\\\\n\\t.WEA(PORT_B_WR_EN), \\\\\\n\\t.SSRA(PORT_B_RD_SRST), \\\\\\n\\t.ADDRA(PORT_B_ADDR addr_slice_b), \\\\\\n\\t.DOA(DO_B), \\\\\\n\\t.DIA(DI_B),\\n\\n`define PORTS_SP(addr_slice) \\\\\\n\\t.CLK(PORT_A_CLK), \\\\\\n\\t.EN(PORT_A_CLK_EN), \\\\\\n\\t.WE(PORT_A_WR_EN), \\\\\\n\\t.SSR(PORT_A_RD_SRST), \\\\\\n\\t.ADDR(PORT_A_ADDR addr_slice), \\\\\\n\\t.DO(DO_A), \\\\\\n\\t.DI(DI_A),\\n\\nlocalparam [PORT_A_WIDTH-1:0] SRVAL_A = ival(PORT_A_WIDTH, PORT_A_RD_SRST_VALUE);\\nlocalparam [PORT_B_WIDTH-1:0] SRVAL_B = ival(PORT_B_WIDTH, PORT_B_RD_SRST_VALUE);\\nlocalparam [PORT_A_WIDTH-1:0] INIT_A = ival(PORT_A_WIDTH, PORT_A_RD_INIT_VALUE);\\nlocalparam [PORT_B_WIDTH-1:0] INIT_B = ival(PORT_B_WIDTH, PORT_B_RD_INIT_VALUE);\\n\\n`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)\\n`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)\\n`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)\\n`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)\\n\\ngenerate\\n\\nif (OPTION_USE_BE) begin\\n\\tif (!PORT_B_USED) begin\\n\\t\\tcase (PORT_A_WIDTH)\\n\\t\\t9: RAMB16_S9 #(\\n\\t\\t\\t`PARAMS_SP\\n\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_SP([13:3])\\n\\t\\t\\t.DIP(DIP_A),\\n\\t\\t\\t.DOP(DOP_A),\\n\\t\\t);\\n\\t\\t18: RAMB16BWE_S18 #(\\n\\t\\t\\t`PARAMS_SP\\n\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_SP([13:4])\\n\\t\\t\\t.DIP(DIP_A),\\n\\t\\t\\t.DOP(DOP_A),\\n\\t\\t);\\n\\t\\t36: RAMB16BWE_S36 #(\\n\\t\\t\\t`PARAMS_SP\\n\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_SP([13:5])\\n\\t\\t\\t.DIP(DIP_A),\\n\\t\\t\\t.DOP(DOP_A),\\n\\t\\t);\\n\\t\\tendcase\\n\\tend else begin\\n\\t\\tcase (PORT_A_WIDTH)\\n\\t\\t9:\\tcase(PORT_B_WIDTH)\\n\\t\\t\\t9: RAMB16_S9_S9 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:3], [13:3])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t18: RAMB16BWE_S9_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:3], [13:4])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t36: RAMB16BWE_S9_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:3], [13:5])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\tendcase\\n\\t\\t18:\\tcase(PORT_B_WIDTH)\\n\\t\\t\\t9: RAMB16BWE_S9_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:4], [13:3])\\n\\t\\t\\t\\t.DIPA(DIP_B), .DOPA(DOP_B),\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t18: RAMB16BWE_S18_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:4], [13:4])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t36: RAMB16BWE_S18_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:4], [13:5])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\tendcase\\n\\t\\t36:\\tcase(PORT_B_WIDTH)\\n\\t\\t\\t9: RAMB16BWE_S9_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:5], [13:3])\\n\\t\\t\\t\\t.DIPA(DIP_B), .DOPA(DOP_B),\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t18: RAMB16BWE_S18_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:5], [13:4])\\n\\t\\t\\t\\t.DIPA(DIP_B), .DOPA(DOP_B),\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t36: RAMB16BWE_S36_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:5], [13:5])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\tendcase\\n\\t\\tendcase\\n\\tend\\nend else begin\\n\\tif (!PORT_B_USED) begin\\n\\t\\tcase (PORT_A_WIDTH)\\n\\t\\t1: RAMB16_S1 #(\\n\\t\\t\\t`PARAMS_SP\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_SP([13:0])\\n\\t\\t);\\n\\t\\t2: RAMB16_S2 #(\\n\\t\\t\\t`PARAMS_SP\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_SP([13:1])\\n\\t\\t);\\n\\t\\t4: RAMB16_S4 #(\\n\\t\\t\\t`PARAMS_SP\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_SP([13:2])\\n\\t\\t);\\n\\t\\t9: RAMB16_S9 #(\\n\\t\\t\\t`PARAMS_SP\\n\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_SP([13:3])\\n\\t\\t\\t.DIP(DIP_A),\\n\\t\\t\\t.DOP(DOP_A),\\n\\t\\t);\\n\\t\\t18: RAMB16_S18 #(\\n\\t\\t\\t`PARAMS_SP\\n\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_SP([13:4])\\n\\t\\t\\t.DIP(DIP_A),\\n\\t\\t\\t.DOP(DOP_A),\\n\\t\\t);\\n\\t\\t36: RAMB16_S36 #(\\n\\t\\t\\t`PARAMS_SP\\n\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_SP([13:5])\\n\\t\\t\\t.DIP(DIP_A),\\n\\t\\t\\t.DOP(DOP_A),\\n\\t\\t);\\n\\t\\tendcase\\n\\tend else begin\\n\\t\\tcase (PORT_A_WIDTH)\\n\\t\\t1:\\tcase(PORT_B_WIDTH)\\n\\t\\t\\t1: RAMB16_S1_S1 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:0], [13:0])\\n\\t\\t\\t);\\n\\t\\t\\t2: RAMB16_S1_S2 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:0], [13:1])\\n\\t\\t\\t);\\n\\t\\t\\t4: RAMB16_S1_S4 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:0], [13:2])\\n\\t\\t\\t);\\n\\t\\t\\t9: RAMB16_S1_S9 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:0], [13:3])\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t18: RAMB16_S1_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:0], [13:4])\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t36: RAMB16_S1_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:0], [13:5])\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\tendcase\\n\\t\\t2:\\tcase(PORT_B_WIDTH)\\n\\t\\t\\t1: RAMB16_S1_S2 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:1], [13:0])\\n\\t\\t\\t);\\n\\t\\t\\t2: RAMB16_S2_S2 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:1], [13:1])\\n\\t\\t\\t);\\n\\t\\t\\t4: RAMB16_S2_S4 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:1], [13:2])\\n\\t\\t\\t);\\n\\t\\t\\t9: RAMB16_S2_S9 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:1], [13:3])\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t18: RAMB16_S2_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:1], [13:4])\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t36: RAMB16_S2_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:1], [13:5])\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\tendcase\\n\\t\\t4:\\tcase(PORT_B_WIDTH)\\n\\t\\t\\t1: RAMB16_S1_S4 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:2], [13:0])\\n\\t\\t\\t);\\n\\t\\t\\t2: RAMB16_S2_S4 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:2], [13:1])\\n\\t\\t\\t);\\n\\t\\t\\t4: RAMB16_S4_S4 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:2], [13:2])\\n\\t\\t\\t);\\n\\t\\t\\t9: RAMB16_S4_S9 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:2], [13:3])\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t18: RAMB16_S4_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:2], [13:4])\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t36: RAMB16_S4_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:2], [13:5])\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\tendcase\\n\\t\\t9:\\tcase(PORT_B_WIDTH)\\n\\t\\t\\t1: RAMB16_S1_S9 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:3], [13:0])\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t2: RAMB16_S2_S9 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:3], [13:1])\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t4: RAMB16_S4_S9 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:3], [13:2])\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t9: RAMB16_S9_S9 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:3], [13:3])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t18: RAMB16_S9_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:3], [13:4])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t36: RAMB16_S9_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:3], [13:5])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\tendcase\\n\\t\\t18:\\tcase(PORT_B_WIDTH)\\n\\t\\t\\t1: RAMB16_S1_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:4], [13:0])\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t2: RAMB16_S2_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:4], [13:1])\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t4: RAMB16_S4_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:4], [13:2])\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t9: RAMB16_S9_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:4], [13:3])\\n\\t\\t\\t\\t.DIPA(DIP_B), .DOPA(DOP_B),\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t18: RAMB16_S18_S18 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:4], [13:4])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\t36: RAMB16_S18_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:4], [13:5])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\tendcase\\n\\t\\t36:\\tcase(PORT_B_WIDTH)\\n\\t\\t\\t1: RAMB16_S1_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:5], [13:0])\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t2: RAMB16_S2_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:5], [13:1])\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t4: RAMB16_S4_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:5], [13:2])\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t9: RAMB16_S9_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:5], [13:3])\\n\\t\\t\\t\\t.DIPA(DIP_B), .DOPA(DOP_B),\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t18: RAMB16_S18_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP_SWAP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP_SWAP([13:5], [13:4])\\n\\t\\t\\t\\t.DIPA(DIP_B), .DOPA(DOP_B),\\n\\t\\t\\t\\t.DIPB(DIP_A), .DOPB(DOP_A),\\n\\t\\t\\t);\\n\\t\\t\\t36: RAMB16_S36_S36 #(\\n\\t\\t\\t\\t`PARAMS_DP\\n\\t\\t\\t\\t`PARAMS_INITP_18\\n\\t\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t\\t`PORTS_DP([13:5], [13:5])\\n\\t\\t\\t\\t.DIPA(DIP_A), .DOPA(DOP_A),\\n\\t\\t\\t\\t.DIPB(DIP_B), .DOPB(DOP_B),\\n\\t\\t\\t);\\n\\t\\t\\tendcase\\n\\t\\tendcase\\n\\tend\\nend\\n\\nendgenerate\\n\\n\\nendmodule\\n\",\n            \"brams_xc3sda.txt\": \"# Block RAMs for Spartan 3A DSP and Spartan 6.\\n# The corresponding mapping file is brams_xc3sda_map.v\\n\\nram block $__XILINX_BLOCKRAM_TDP_ {\\n\\tbyte 9;\\n\\tifdef IS_SPARTAN6 {\\n\\t\\toption \\\"MODE\\\" \\\"HALF\\\" {\\n\\t\\t\\tabits 13;\\n\\t\\t\\twidths 1 2 4 9 18 per_port;\\n\\t\\t\\tcost 65;\\n\\t\\t}\\n\\t}\\n\\toption \\\"MODE\\\" \\\"FULL\\\" {\\n\\t\\tabits 14;\\n\\t\\twidths 1 2 4 9 18 36 per_port;\\n\\t\\tcost 129;\\n\\t}\\n\\tinit any;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\t# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.\\n\\t\\tifdef IS_SPARTAN6 {\\n\\t\\t\\toption \\\"HAS_RDFIRST\\\" 1 {\\n\\t\\t\\t\\tclock posedge \\\"C\\\";\\n\\t\\t\\t}\\n\\t\\t\\toption \\\"HAS_RDFIRST\\\" 0 {\\n\\t\\t\\t\\tclock posedge;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tclock posedge;\\n\\t\\t}\\n\\t\\tclken;\\n\\t\\toption \\\"RSTTYPE\\\" \\\"SYNC\\\" {\\n\\t\\t\\tportoption \\\"RST_PRIORITY\\\" \\\"CE\\\" {\\n\\t\\t\\t\\trdsrst any gated_clken;\\n\\t\\t\\t}\\n\\t\\t\\tifdef IS_SPARTAN6 {\\n\\t\\t\\t\\tportoption \\\"RST_PRIORITY\\\" \\\"SR\\\" {\\n\\t\\t\\t\\t\\trdsrst any ungated;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tifdef IS_SPARTAN6 {\\n\\t\\t\\toption \\\"RSTTYPE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\t\\tportoption \\\"RST_PRIORITY\\\" \\\"SR\\\" {\\n\\t\\t\\t\\t\\trdarst any;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\trdinit any;\\n\\t\\tportoption \\\"WRITE_MODE\\\" \\\"NO_CHANGE\\\" {\\n\\t\\t\\trdwr no_change;\\n\\t\\t}\\n\\t\\tportoption \\\"WRITE_MODE\\\" \\\"WRITE_FIRST\\\" {\\n\\t\\t\\trdwr new;\\n\\t\\t}\\n\\t\\tifdef IS_SPARTAN6 {\\n\\t\\t\\toption \\\"HAS_RDFIRST\\\" 1 {\\n\\t\\t\\t\\tportoption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\t\\t\\trdwr old;\\n\\t\\t\\t\\t\\twrtrans all old;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tportoption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\t\\trdwr old;\\n\\t\\t\\t\\twrtrans all old;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\toptional;\\n\\t}\\n}\\n\\nifdef IS_SPARTAN6 {\\n\\tram block $__XILINX_BLOCKRAM_SDP_ {\\n\\t\\tbyte 9;\\n\\t\\tabits 13;\\n\\t\\twidths 1 2 4 9 18 36 per_port;\\n\\t\\tcost 65;\\n\\t\\tinit any;\\n\\t\\tport sw \\\"W\\\" {\\n\\t\\t\\twidth 36;\\n\\t\\t\\t# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.\\n\\t\\t\\toption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\t\\tclock posedge \\\"C\\\";\\n\\t\\t\\t\\twrtrans all old;\\n\\t\\t\\t}\\n\\t\\t\\toption \\\"WRITE_MODE\\\" \\\"WRITE_FIRST\\\" {\\n\\t\\t\\t\\tclock posedge;\\n\\t\\t\\t}\\n\\t\\t\\tclken;\\n\\t\\t\\toptional;\\n\\t\\t}\\n\\t\\tport sr \\\"R\\\" {\\n\\t\\t\\twidth 36;\\n\\t\\t\\t# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.\\n\\t\\t\\toption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\t\\tclock posedge \\\"C\\\";\\n\\t\\t\\t}\\n\\t\\t\\toption \\\"WRITE_MODE\\\" \\\"WRITE_FIRST\\\" {\\n\\t\\t\\t\\tclock posedge;\\n\\t\\t\\t}\\n\\t\\t\\tclken;\\n\\t\\t\\toption \\\"RSTTYPE\\\" \\\"SYNC\\\" {\\n\\t\\t\\t\\tportoption \\\"RST_PRIORITY\\\" \\\"CE\\\" {\\n\\t\\t\\t\\t\\trdsrst any gated_clken;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tportoption \\\"RST_PRIORITY\\\" \\\"SR\\\" {\\n\\t\\t\\t\\t\\trdsrst any ungated;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\toption \\\"RSTTYPE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\t\\tportoption \\\"RST_PRIORITY\\\" \\\"SR\\\" {\\n\\t\\t\\t\\t\\trdarst any;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\trdinit any;\\n\\t\\t\\toptional;\\n\\t\\t}\\n\\t}\\n}\\n\",\n            \"brams_xc3sda_map.v\": \"module $__XILINX_BLOCKRAM_TDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_MODE = \\\"FULL\\\";\\nparameter OPTION_RSTTYPE = \\\"SYNC\\\";\\nparameter OPTION_HAS_RDFIRST = 0;\\n\\nparameter PORT_A_WIDTH = 1;\\nparameter PORT_A_WR_EN_WIDTH = 1;\\nparameter PORT_A_USED = 1;\\nparameter PORT_A_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_A_RD_INIT_VALUE = 0;\\nparameter PORT_A_RD_SRST_VALUE = 0;\\nparameter PORT_A_RD_ARST_VALUE = 0;\\nparameter PORT_A_OPTION_RST_PRIORITY = \\\"CE\\\";\\n\\nparameter PORT_B_WIDTH = 1;\\nparameter PORT_B_WR_EN_WIDTH = 1;\\nparameter PORT_B_USED = 0;\\nparameter PORT_B_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_B_RD_INIT_VALUE = 0;\\nparameter PORT_B_RD_SRST_VALUE = 0;\\nparameter PORT_B_RD_ARST_VALUE = 0;\\nparameter PORT_B_OPTION_RST_PRIORITY = \\\"CE\\\";\\n\\ninput CLK_C;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput [13:0] PORT_A_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\ninput [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\ninput PORT_A_RD_SRST;\\ninput PORT_A_RD_ARST;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput [13:0] PORT_B_ADDR;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\ninput [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\ninput PORT_B_RD_SRST;\\ninput PORT_B_RD_ARST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\n`define PARAMS_COMMON \\\\\\n\\t.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\\\\\n\\t.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\\\\\n\\t.DATA_WIDTH_A(PORT_A_USED ? PORT_A_WIDTH : 0), \\\\\\n\\t.DATA_WIDTH_B(PORT_B_USED ? PORT_B_WIDTH : 0), \\\\\\n\\t.EN_RSTRAM_A(\\\"TRUE\\\"), \\\\\\n\\t.EN_RSTRAM_B(\\\"TRUE\\\"), \\\\\\n\\t.DOA_REG(0), \\\\\\n\\t.DOB_REG(0), \\\\\\n\\t.RST_PRIORITY_A(PORT_A_OPTION_RST_PRIORITY), \\\\\\n\\t.RST_PRIORITY_B(PORT_B_OPTION_RST_PRIORITY), \\\\\\n\\t.RSTTYPE(OPTION_RSTTYPE), \\\\\\n\\t.INIT_A(ival(PORT_A_WIDTH, PORT_A_RD_INIT_VALUE)), \\\\\\n\\t.INIT_B(ival(PORT_B_WIDTH, PORT_B_RD_INIT_VALUE)), \\\\\\n\\t.SRVAL_A(ival(PORT_A_WIDTH, OPTION_RSTTYPE == \\\"SYNC\\\" ? PORT_A_RD_SRST_VALUE : PORT_A_RD_ARST_VALUE)), \\\\\\n\\t.SRVAL_B(ival(PORT_B_WIDTH, OPTION_RSTTYPE == \\\"SYNC\\\" ? PORT_B_RD_SRST_VALUE : PORT_B_RD_ARST_VALUE)),\\n\\nwire RST_A = OPTION_RSTTYPE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST;\\nwire RST_B = OPTION_RSTTYPE == \\\"SYNC\\\" ? PORT_B_RD_SRST : PORT_B_RD_ARST;\\n\\n`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)\\n`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)\\n`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)\\n`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)\\n\\ngenerate\\n\\nif (OPTION_MODE == \\\"FULL\\\") begin\\n\\twire [3:0] WE_A = {4{PORT_A_WR_EN}};\\n\\twire [3:0] WE_B = {4{PORT_B_WR_EN}};\\n\\tRAMB16BWER #(\\n\\t\\t`PARAMS_INIT_18\\n\\t\\t`PARAMS_INITP_18\\n\\t\\t`PARAMS_COMMON\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.DOA(DO_A),\\n\\t\\t.DOPA(DOP_A),\\n\\t\\t.DIA(DI_A),\\n\\t\\t.DIPA(DIP_A),\\n\\t\\t.DOB(DO_B),\\n\\t\\t.DOPB(DOP_B),\\n\\t\\t.DIB(DI_B),\\n\\t\\t.DIPB(DIP_B),\\n\\t\\t.ADDRA(PORT_A_ADDR),\\n\\t\\t.ADDRB(PORT_B_ADDR),\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.ENA(PORT_A_CLK_EN),\\n\\t\\t.ENB(PORT_B_CLK_EN),\\n\\t\\t.REGCEA(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.RSTA(RST_A),\\n\\t\\t.RSTB(RST_B),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEB(WE_B),\\n\\t);\\nend else begin\\n\\twire [1:0] WE_A = {2{PORT_A_WR_EN}};\\n\\twire [1:0] WE_B = {2{PORT_B_WR_EN}};\\n\\tRAMB8BWER #(\\n\\t\\t`PARAMS_INIT_9\\n\\t\\t`PARAMS_INITP_9\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_MODE(\\\"TDP\\\"),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.DOADO(DO_A),\\n\\t\\t.DOPADOP(DOP_A),\\n\\t\\t.DIADI(DI_A),\\n\\t\\t.DIPADIP(DIP_A),\\n\\t\\t.DOBDO(DO_B),\\n\\t\\t.DOPBDOP(DOP_B),\\n\\t\\t.DIBDI(DI_B),\\n\\t\\t.DIPBDIP(DIP_B),\\n\\t\\t.ADDRAWRADDR(PORT_A_ADDR),\\n\\t\\t.ADDRBRDADDR(PORT_B_ADDR),\\n\\t\\t.CLKAWRCLK(PORT_A_CLK),\\n\\t\\t.CLKBRDCLK(PORT_B_CLK),\\n\\t\\t.ENAWREN(PORT_A_CLK_EN),\\n\\t\\t.ENBRDEN(PORT_B_CLK_EN),\\n\\t\\t.REGCEA(1'b0),\\n\\t\\t.REGCEBREGCE(1'b0),\\n\\t\\t.RSTA(RST_A),\\n\\t\\t.RSTBRST(RST_B),\\n\\t\\t.WEAWEL(WE_A),\\n\\t\\t.WEBWEU(WE_B),\\n\\t);\\nend\\n\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__XILINX_BLOCKRAM_SDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_RSTTYPE = \\\"SYNC\\\";\\nparameter OPTION_WRITE_MODE = \\\"READ_FIRST\\\";\\n\\nparameter PORT_W_WIDTH = 1;\\nparameter PORT_W_WR_EN_WIDTH = 1;\\nparameter PORT_W_USED = 1;\\n\\nparameter PORT_R_WIDTH = 1;\\nparameter PORT_R_USED = 0;\\nparameter PORT_R_RD_INIT_VALUE = 0;\\nparameter PORT_R_RD_SRST_VALUE = 0;\\nparameter PORT_R_RD_ARST_VALUE = 0;\\nparameter PORT_R_OPTION_RST_PRIORITY = \\\"CE\\\";\\n\\ninput CLK_C;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput [13:0] PORT_W_ADDR;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\ninput [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput [13:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\ninput PORT_R_RD_SRST;\\ninput PORT_R_RD_ARST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\nwire RST = OPTION_RSTTYPE == \\\"SYNC\\\" ? PORT_R_RD_SRST : PORT_R_RD_ARST;\\n\\n`MAKE_DI(DI, DIP, PORT_W_WR_DATA)\\n`MAKE_DO(DO, DOP, PORT_R_RD_DATA)\\n\\nlocalparam [35:0] RST_VALUE = OPTION_RSTTYPE == \\\"SYNC\\\" ? PORT_R_RD_SRST_VALUE : PORT_R_RD_ARST_VALUE;\\n\\nRAMB8BWER #(\\n\\t`PARAMS_INIT_9\\n\\t`PARAMS_INITP_9\\n\\t.WRITE_MODE_A(OPTION_WRITE_MODE),\\n\\t.WRITE_MODE_B(OPTION_WRITE_MODE),\\n\\t.DATA_WIDTH_A(PORT_W_USED ? PORT_W_WIDTH : 0),\\n\\t.DATA_WIDTH_B(PORT_R_USED ? PORT_R_WIDTH : 0),\\n\\t.EN_RSTRAM_A(\\\"TRUE\\\"),\\n\\t.EN_RSTRAM_B(\\\"TRUE\\\"),\\n\\t.DOA_REG(0),\\n\\t.DOB_REG(0),\\n\\t.RST_PRIORITY_A(\\\"CE\\\"),\\n\\t.RST_PRIORITY_B(PORT_R_OPTION_RST_PRIORITY),\\n\\t.RSTTYPE(OPTION_RSTTYPE),\\n\\t.INIT_A(ival(18, PORT_R_RD_INIT_VALUE[17:0])),\\n\\t.INIT_B(ival(18, PORT_R_RD_INIT_VALUE[35:18])),\\n\\t.SRVAL_A(ival(18, RST_VALUE[17:0])),\\n\\t.SRVAL_B(ival(18, RST_VALUE[35:18])),\\n\\t.RAM_MODE(\\\"SDP\\\"),\\n) _TECHMAP_REPLACE_ (\\n\\t.DOADO(DO[15:0]),\\n\\t.DOPADOP(DOP[1:0]),\\n\\t.DIADI(DI[15:0]),\\n\\t.DIPADIP(DIP[1:0]),\\n\\t.DOBDO(DO[31:16]),\\n\\t.DOPBDOP(DOP[3:2]),\\n\\t.DIBDI(DI[31:16]),\\n\\t.DIPBDIP(DIP[3:2]),\\n\\t.ADDRAWRADDR(PORT_W_ADDR),\\n\\t.ADDRBRDADDR(PORT_R_ADDR),\\n\\t.CLKAWRCLK(PORT_W_CLK),\\n\\t.CLKBRDCLK(PORT_R_CLK),\\n\\t.ENAWREN(PORT_W_CLK_EN),\\n\\t.ENBRDEN(PORT_R_CLK_EN),\\n\\t.REGCEA(1'b0),\\n\\t.REGCEBREGCE(1'b0),\\n\\t.RSTA(1'b0),\\n\\t.RSTBRST(RST),\\n\\t.WEAWEL(PORT_W_WR_EN[1:0]),\\n\\t.WEBWEU(PORT_W_WR_EN[3:2]),\\n);\\n\\nendmodule\\n\",\n            \"brams_xc4v.txt\": \"# Block RAMs for Virtex 4+.\\n# The corresponding mapping files are:\\n# - brams_xc3sda_map.v: Spartan 3A DSP, Spartan 6\\n# - brams_xc4v_map.v: Virtex 4\\n# - brams_xc5v_map.v: Virtex 5\\n# - brams_xc6v_map.v: Virtex 6, Series 7\\n# - brams_xcu_map.v: Ultrascale\\n\\nram block $__XILINX_BLOCKRAM_TDP_ {\\n\\tbyte 9;\\n\\tifdef HAS_SIZE_36 {\\n\\t\\toption \\\"MODE\\\" \\\"HALF\\\" {\\n\\t\\t\\tabits 14;\\n\\t\\t\\twidths 1 2 4 9 18 per_port;\\n\\t\\t\\tcost 129;\\n\\t\\t}\\n\\t\\toption \\\"MODE\\\" \\\"FULL\\\" {\\n\\t\\t\\tabits 15;\\n\\t\\t\\twidths 1 2 4 9 18 36 per_port;\\n\\t\\t\\tcost 257;\\n\\t\\t}\\n\\t\\tifdef HAS_CASCADE {\\n\\t\\t\\toption \\\"MODE\\\" \\\"CASCADE\\\" {\\n\\t\\t\\t\\tabits 16;\\n\\t\\t\\t\\t# hack to enforce same INIT layout as in the other modes\\n\\t\\t\\t\\twidths 1 2 4 9 per_port;\\n\\t\\t\\t\\tcost 513;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\toption \\\"MODE\\\" \\\"FULL\\\" {\\n\\t\\t\\tabits 14;\\n\\t\\t\\twidths 1 2 4 9 18 36 per_port;\\n\\t\\t\\tcost 129;\\n\\t\\t}\\n\\t\\tifdef HAS_CASCADE {\\n\\t\\t\\toption \\\"MODE\\\" \\\"CASCADE\\\" {\\n\\t\\t\\t\\tabits 15;\\n\\t\\t\\t\\twidths 1 2 4 9 per_port;\\n\\t\\t\\t\\tcost 257;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tinit any;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\toption \\\"MODE\\\" \\\"HALF\\\" {\\n\\t\\t\\twidth mix;\\n\\t\\t}\\n\\t\\toption \\\"MODE\\\" \\\"FULL\\\" {\\n\\t\\t\\twidth mix;\\n\\t\\t}\\n\\t\\toption \\\"MODE\\\" \\\"CASCADE\\\" {\\n\\t\\t\\twidth mix 1;\\n\\t\\t}\\n\\t\\tifdef HAS_ADDRCE {\\n\\t\\t\\t# TODO\\n\\t\\t\\t# addrce;\\n\\t\\t}\\n\\t\\t# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.\\n\\t\\tifdef HAS_CONFLICT_BUG {\\n\\t\\t\\toption \\\"HAS_RDFIRST\\\" 1 {\\n\\t\\t\\t\\tclock posedge \\\"C\\\";\\n\\t\\t\\t}\\n\\t\\t\\toption \\\"HAS_RDFIRST\\\" 0 {\\n\\t\\t\\t\\tclock posedge;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tclock posedge;\\n\\t\\t}\\n\\t\\tclken;\\n\\t\\trdsrst any gated_clken;\\n\\t\\trdinit any;\\n\\t\\tportoption \\\"WRITE_MODE\\\" \\\"NO_CHANGE\\\" {\\n\\t\\t\\trdwr no_change;\\n\\t\\t\\toption \\\"MODE\\\" \\\"CASCADE\\\" {\\n\\t\\t\\t\\tforbid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tportoption \\\"WRITE_MODE\\\" \\\"WRITE_FIRST\\\" {\\n\\t\\t\\tifdef HAS_SIZE_36 {\\n\\t\\t\\t\\trdwr new;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trdwr new_only;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tifdef HAS_CONFLICT_BUG {\\n\\t\\t\\toption \\\"HAS_RDFIRST\\\" 1 {\\n\\t\\t\\t\\tportoption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\t\\t\\trdwr old;\\n\\t\\t\\t\\t\\twrtrans all old;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tportoption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\t\\trdwr old;\\n\\t\\t\\t\\twrtrans all old;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\toptional_rw;\\n\\t}\\n}\\n\\nifdef HAS_SIZE_36 {\\n\\tram block $__XILINX_BLOCKRAM_SDP_ {\\n\\t\\tbyte 9;\\n\\t\\toption \\\"MODE\\\" \\\"HALF\\\" {\\n\\t\\t\\tabits 14;\\n\\t\\t\\twidths 1 2 4 9 18 36 per_port;\\n\\t\\t\\tcost 129;\\n\\t\\t}\\n\\t\\toption \\\"MODE\\\" \\\"FULL\\\" {\\n\\t\\t\\tabits 15;\\n\\t\\t\\twidths 1 2 4 9 18 36 72 per_port;\\n\\t\\t\\tcost 257;\\n\\t\\t}\\n\\t\\tinit any;\\n\\t\\tport sw \\\"W\\\" {\\n\\t\\t\\tifndef HAS_MIXWIDTH_SDP {\\n\\t\\t\\t\\toption \\\"MODE\\\" \\\"HALF\\\" width 36;\\n\\t\\t\\t\\toption \\\"MODE\\\" \\\"FULL\\\" width 72;\\n\\t\\t\\t}\\n\\t\\t\\tifdef HAS_ADDRCE {\\n\\t\\t\\t\\t# TODO\\n\\t\\t\\t\\t# addrce;\\n\\t\\t\\t}\\n\\t\\t\\t# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.\\n\\t\\t\\tifdef HAS_CONFLICT_BUG {\\n\\t\\t\\t\\toption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\t\\t\\tclock posedge \\\"C\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toption \\\"WRITE_MODE\\\" \\\"WRITE_FIRST\\\" {\\n\\t\\t\\t\\t\\tclock posedge;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tclock posedge;\\n\\t\\t\\t}\\n\\t\\t\\tclken;\\n\\t\\t\\toption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\t\\twrtrans all old;\\n\\t\\t\\t}\\n\\t\\t\\toptional;\\n\\t\\t}\\n\\t\\tport sr \\\"R\\\" {\\n\\t\\t\\tifndef HAS_MIXWIDTH_SDP {\\n\\t\\t\\t\\toption \\\"MODE\\\" \\\"HALF\\\" width 36;\\n\\t\\t\\t\\toption \\\"MODE\\\" \\\"FULL\\\" width 72;\\n\\t\\t\\t}\\n\\t\\t\\tifdef HAS_ADDRCE {\\n\\t\\t\\t\\t# TODO\\n\\t\\t\\t\\t# addrce;\\n\\t\\t\\t}\\n\\t\\t\\t# Spartan 6 and Virtex 6 have a bug where READ_FIRST is not usable with asynchronous clocks.\\n\\t\\t\\tifdef HAS_CONFLICT_BUG {\\n\\t\\t\\t\\toption \\\"WRITE_MODE\\\" \\\"READ_FIRST\\\" {\\n\\t\\t\\t\\t\\tclock posedge \\\"C\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toption \\\"WRITE_MODE\\\" \\\"WRITE_FIRST\\\" {\\n\\t\\t\\t\\t\\tclock posedge;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tclock posedge;\\n\\t\\t\\t}\\n\\t\\t\\tclken;\\n\\t\\t\\trdsrst any gated_clken;\\n\\t\\t\\trdinit any;\\n\\t\\t\\toptional;\\n\\t\\t}\\n\\t}\\n}\\n\",\n            \"brams_xc4v_map.v\": \"module $__XILINX_BLOCKRAM_TDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_MODE = \\\"FULL\\\";\\n\\nparameter PORT_A_RD_WIDTH = 1;\\nparameter PORT_A_WR_WIDTH = 1;\\nparameter PORT_A_WR_EN_WIDTH = 1;\\nparameter PORT_A_RD_USED = 1;\\nparameter PORT_A_WR_USED = 1;\\nparameter PORT_A_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_A_RD_INIT_VALUE = 0;\\nparameter PORT_A_RD_SRST_VALUE = 0;\\n\\nparameter PORT_B_RD_WIDTH = 1;\\nparameter PORT_B_WR_WIDTH = 1;\\nparameter PORT_B_WR_EN_WIDTH = 1;\\nparameter PORT_B_RD_USED = 0;\\nparameter PORT_B_WR_USED = 0;\\nparameter PORT_B_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_B_RD_INIT_VALUE = 0;\\nparameter PORT_B_RD_SRST_VALUE = 0;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput [14:0] PORT_A_ADDR;\\ninput [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;\\ninput [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;\\noutput [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;\\ninput PORT_A_RD_SRST;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput [14:0] PORT_B_ADDR;\\ninput [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;\\ninput [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;\\noutput [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;\\ninput PORT_B_RD_SRST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\n`define PARAMS_COMMON \\\\\\n\\t.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\\\\\n\\t.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\\\\\n\\t.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\\\\\n\\t.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\\\\\n\\t.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\\\\\n\\t.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\\\\\n\\t.DOA_REG(0), \\\\\\n\\t.DOB_REG(0), \\\\\\n\\t.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\\\\\n\\t.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\\\\\n\\t.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\\\\\n\\t.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)),\\n\\n`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)\\n`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)\\n`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)\\n`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)\\n\\nwire [3:0] WE_A = {4{PORT_A_WR_EN}};\\nwire [3:0] WE_B = {4{PORT_B_WR_EN}};\\n\\ngenerate\\n\\nif (OPTION_MODE == \\\"FULL\\\") begin\\n\\tRAMB16 #(\\n\\t\\t`PARAMS_INIT_18\\n\\t\\t`PARAMS_INITP_18\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_EXTENSION_A(\\\"NONE\\\"),\\n\\t\\t.RAM_EXTENSION_B(\\\"NONE\\\"),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.DOA(DO_A),\\n\\t\\t.DOPA(DOP_A),\\n\\t\\t.DIA(DI_A),\\n\\t\\t.DIPA(DIP_A),\\n\\t\\t.DOB(DO_B),\\n\\t\\t.DOPB(DOP_B),\\n\\t\\t.DIB(DI_B),\\n\\t\\t.DIPB(DIP_B),\\n\\t\\t.ADDRA({1'b1, PORT_A_ADDR[13:0]}),\\n\\t\\t.ADDRB({1'b1, PORT_B_ADDR[13:0]}),\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.ENA(PORT_A_CLK_EN),\\n\\t\\t.ENB(PORT_B_CLK_EN),\\n\\t\\t.REGCEA(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.SSRA(PORT_A_RD_SRST),\\n\\t\\t.SSRB(PORT_B_RD_SRST),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEB(WE_B),\\n\\t);\\nend else begin\\n\\twire CAS_A, CAS_B;\\n\\tRAMB16 #(\\n\\t\\t`PARAMS_INIT_18\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_EXTENSION_A(\\\"LOWER\\\"),\\n\\t\\t.RAM_EXTENSION_B(\\\"LOWER\\\"),\\n\\t) lower (\\n\\t\\t.DIA(DI_A),\\n\\t\\t.DIB(DI_B),\\n\\t\\t.ADDRA(PORT_A_ADDR),\\n\\t\\t.ADDRB(PORT_B_ADDR),\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.ENA(PORT_A_CLK_EN),\\n\\t\\t.ENB(PORT_B_CLK_EN),\\n\\t\\t.REGCEA(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.SSRA(PORT_A_RD_SRST),\\n\\t\\t.SSRB(PORT_B_RD_SRST),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEB(WE_B),\\n\\t\\t.CASCADEOUTA(CAS_A),\\n\\t\\t.CASCADEOUTB(CAS_B),\\n\\t);\\n\\tRAMB16 #(\\n\\t\\t`PARAMS_INIT_18_U\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_EXTENSION_A(\\\"UPPER\\\"),\\n\\t\\t.RAM_EXTENSION_B(\\\"UPPER\\\"),\\n\\t) upper (\\n\\t\\t.DOA(DO_A),\\n\\t\\t.DIA(DI_A),\\n\\t\\t.DOB(DO_B),\\n\\t\\t.DIB(DI_B),\\n\\t\\t.ADDRA(PORT_A_ADDR),\\n\\t\\t.ADDRB(PORT_B_ADDR),\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.ENA(PORT_A_CLK_EN),\\n\\t\\t.ENB(PORT_B_CLK_EN),\\n\\t\\t.REGCEA(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.SSRA(PORT_A_RD_SRST),\\n\\t\\t.SSRB(PORT_B_RD_SRST),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEB(WE_B),\\n\\t\\t.CASCADEINA(CAS_A),\\n\\t\\t.CASCADEINB(CAS_B),\\n\\t);\\nend\\n\\nendgenerate\\n\\nendmodule\\n\",\n            \"brams_xc5v_map.v\": \"module $__XILINX_BLOCKRAM_TDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_MODE = \\\"FULL\\\";\\n\\nparameter PORT_A_RD_WIDTH = 1;\\nparameter PORT_A_WR_WIDTH = 1;\\nparameter PORT_A_WR_EN_WIDTH = 1;\\nparameter PORT_A_RD_USED = 1;\\nparameter PORT_A_WR_USED = 1;\\nparameter PORT_A_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_A_RD_INIT_VALUE = 0;\\nparameter PORT_A_RD_SRST_VALUE = 0;\\n\\nparameter PORT_B_RD_WIDTH = 1;\\nparameter PORT_B_WR_WIDTH = 1;\\nparameter PORT_B_WR_EN_WIDTH = 1;\\nparameter PORT_B_RD_USED = 0;\\nparameter PORT_B_WR_USED = 0;\\nparameter PORT_B_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_B_RD_INIT_VALUE = 0;\\nparameter PORT_B_RD_SRST_VALUE = 0;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput [15:0] PORT_A_ADDR;\\ninput [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;\\ninput [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;\\noutput [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;\\ninput PORT_A_RD_SRST;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput [15:0] PORT_B_ADDR;\\ninput [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;\\ninput [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;\\noutput [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;\\ninput PORT_B_RD_SRST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\n`define PARAMS_COMMON \\\\\\n\\t.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\\\\\n\\t.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\\\\\n\\t.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\\\\\n\\t.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\\\\\n\\t.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\\\\\n\\t.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\\\\\n\\t.DOA_REG(0), \\\\\\n\\t.DOB_REG(0), \\\\\\n\\t.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\\\\\n\\t.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\\\\\n\\t.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\\\\\n\\t.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)),\\n\\n`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)\\n`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)\\n`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)\\n`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)\\n\\nwire [3:0] WE_A = {4{PORT_A_WR_EN}};\\nwire [3:0] WE_B = {4{PORT_B_WR_EN}};\\n\\ngenerate\\n\\nif (OPTION_MODE == \\\"HALF\\\") begin\\n\\tRAMB18 #(\\n\\t\\t`PARAMS_INIT_18\\n\\t\\t`PARAMS_INITP_18\\n\\t\\t`PARAMS_COMMON\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.DOA(DO_A),\\n\\t\\t.DOPA(DOP_A),\\n\\t\\t.DIA(DI_A),\\n\\t\\t.DIPA(DIP_A),\\n\\t\\t.DOB(DO_B),\\n\\t\\t.DOPB(DOP_B),\\n\\t\\t.DIB(DI_B),\\n\\t\\t.DIPB(DIP_B),\\n\\t\\t.ADDRA(PORT_A_ADDR[13:0]),\\n\\t\\t.ADDRB(PORT_B_ADDR[13:0]),\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.ENA(PORT_A_CLK_EN),\\n\\t\\t.ENB(PORT_B_CLK_EN),\\n\\t\\t.REGCEA(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.SSRA(PORT_A_RD_SRST),\\n\\t\\t.SSRB(PORT_B_RD_SRST),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEB(WE_B),\\n\\t);\\nend else if (OPTION_MODE == \\\"FULL\\\") begin\\n\\tRAMB36 #(\\n\\t\\t`PARAMS_INIT_36\\n\\t\\t`PARAMS_INITP_36\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_EXTENSION_A(\\\"NONE\\\"),\\n\\t\\t.RAM_EXTENSION_B(\\\"NONE\\\"),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.DOA(DO_A),\\n\\t\\t.DOPA(DOP_A),\\n\\t\\t.DIA(DI_A),\\n\\t\\t.DIPA(DIP_A),\\n\\t\\t.DOB(DO_B),\\n\\t\\t.DOPB(DOP_B),\\n\\t\\t.DIB(DI_B),\\n\\t\\t.DIPB(DIP_B),\\n\\t\\t.ADDRA({1'b1, PORT_A_ADDR[14:0]}),\\n\\t\\t.ADDRB({1'b1, PORT_B_ADDR[14:0]}),\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.ENA(PORT_A_CLK_EN),\\n\\t\\t.ENB(PORT_B_CLK_EN),\\n\\t\\t.REGCEA(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.SSRA(PORT_A_RD_SRST),\\n\\t\\t.SSRB(PORT_B_RD_SRST),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEB(WE_B),\\n\\t);\\nend else begin\\n\\twire CAS_A, CAS_B;\\n\\tRAMB36 #(\\n\\t\\t`PARAMS_INIT_36\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_EXTENSION_A(\\\"LOWER\\\"),\\n\\t\\t.RAM_EXTENSION_B(\\\"LOWER\\\"),\\n\\t) lower (\\n\\t\\t.DIA(DI_A),\\n\\t\\t.DIB(DI_B),\\n\\t\\t.ADDRA(PORT_A_ADDR),\\n\\t\\t.ADDRB(PORT_B_ADDR),\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.ENA(PORT_A_CLK_EN),\\n\\t\\t.ENB(PORT_B_CLK_EN),\\n\\t\\t.REGCEA(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.SSRA(PORT_A_RD_SRST),\\n\\t\\t.SSRB(PORT_B_RD_SRST),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEB(WE_B),\\n\\t\\t.CASCADEOUTLATA(CAS_A),\\n\\t\\t.CASCADEOUTLATB(CAS_B),\\n\\t);\\n\\tRAMB36 #(\\n\\t\\t`PARAMS_INIT_36_U\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_EXTENSION_A(\\\"UPPER\\\"),\\n\\t\\t.RAM_EXTENSION_B(\\\"UPPER\\\"),\\n\\t) upper (\\n\\t\\t.DOA(DO_A),\\n\\t\\t.DIA(DI_A),\\n\\t\\t.DOB(DO_B),\\n\\t\\t.DIB(DI_B),\\n\\t\\t.ADDRA(PORT_A_ADDR),\\n\\t\\t.ADDRB(PORT_B_ADDR),\\n\\t\\t.CLKA(PORT_A_CLK),\\n\\t\\t.CLKB(PORT_B_CLK),\\n\\t\\t.ENA(PORT_A_CLK_EN),\\n\\t\\t.ENB(PORT_B_CLK_EN),\\n\\t\\t.REGCEA(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.SSRA(PORT_A_RD_SRST),\\n\\t\\t.SSRB(PORT_B_RD_SRST),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEB(WE_B),\\n\\t\\t.CASCADEINLATA(CAS_A),\\n\\t\\t.CASCADEINLATB(CAS_B),\\n\\t);\\nend\\n\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__XILINX_BLOCKRAM_SDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_MODE = \\\"FULL\\\";\\nparameter OPTION_WRITE_MODE = \\\"READ_FIRST\\\";\\n\\nparameter PORT_W_WIDTH = 1;\\nparameter PORT_W_WR_EN_WIDTH = 1;\\nparameter PORT_W_USED = 1;\\n\\nparameter PORT_R_WIDTH = 1;\\nparameter PORT_R_USED = 0;\\nparameter PORT_R_RD_INIT_VALUE = 0;\\nparameter PORT_R_RD_SRST_VALUE = 0;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput [15:0] PORT_W_ADDR;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\ninput [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput [15:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\ninput PORT_R_RD_SRST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\n`define PARAMS_COMMON \\\\\\n\\t.DO_REG(0), \\\\\\n\\t.INIT(ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)), \\\\\\n\\t.SRVAL(ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),\\n\\n`define PORTS_COMMON \\\\\\n\\t.DO(DO), \\\\\\n\\t.DOP(DOP), \\\\\\n\\t.DI(DI), \\\\\\n\\t.DIP(DIP), \\\\\\n\\t.WRCLK(PORT_W_CLK), \\\\\\n\\t.RDCLK(PORT_R_CLK), \\\\\\n\\t.WREN(PORT_W_CLK_EN), \\\\\\n\\t.RDEN(PORT_R_CLK_EN), \\\\\\n\\t.REGCE(1'b0), \\\\\\n\\t.SSR(PORT_R_RD_SRST), \\\\\\n\\t.WE(PORT_W_WR_EN),\\n\\n`MAKE_DI(DI, DIP, PORT_W_WR_DATA)\\n`MAKE_DO(DO, DOP, PORT_R_RD_DATA)\\n\\ngenerate\\n\\nif (OPTION_MODE == \\\"HALF\\\") begin\\n\\tRAMB18SDP #(\\n\\t\\t`PARAMS_INIT_18\\n\\t\\t`PARAMS_INITP_18\\n\\t\\t`PARAMS_COMMON\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t\\t.WRADDR(PORT_W_ADDR[13:5]),\\n\\t\\t.RDADDR(PORT_R_ADDR[13:5]),\\n\\t);\\nend else if (OPTION_MODE == \\\"FULL\\\") begin\\n\\tRAMB36SDP #(\\n\\t\\t`PARAMS_INIT_36\\n\\t\\t`PARAMS_INITP_36\\n\\t\\t`PARAMS_COMMON\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t\\t.WRADDR(PORT_W_ADDR[14:6]),\\n\\t\\t.RDADDR(PORT_R_ADDR[14:6]),\\n\\t);\\nend\\n\\nendgenerate\\n\\nendmodule\\n\",\n            \"brams_xc6v_map.v\": \"module $__XILINX_BLOCKRAM_TDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_MODE = \\\"FULL\\\";\\nparameter OPTION_HAS_RDFIRST = 0;\\n\\nparameter PORT_A_RD_WIDTH = 1;\\nparameter PORT_A_WR_WIDTH = 1;\\nparameter PORT_A_WR_EN_WIDTH = 1;\\nparameter PORT_A_RD_USED = 1;\\nparameter PORT_A_WR_USED = 1;\\nparameter PORT_A_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_A_RD_INIT_VALUE = 0;\\nparameter PORT_A_RD_SRST_VALUE = 1;\\n\\nparameter PORT_B_RD_WIDTH = 1;\\nparameter PORT_B_WR_WIDTH = 1;\\nparameter PORT_B_WR_EN_WIDTH = 1;\\nparameter PORT_B_RD_USED = 0;\\nparameter PORT_B_WR_USED = 0;\\nparameter PORT_B_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_B_RD_INIT_VALUE = 0;\\nparameter PORT_B_RD_SRST_VALUE = 0;\\n\\ninput CLK_C;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput [15:0] PORT_A_ADDR;\\ninput [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;\\ninput [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;\\noutput [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;\\ninput PORT_A_RD_SRST;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput [15:0] PORT_B_ADDR;\\ninput [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;\\ninput [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;\\noutput [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;\\ninput PORT_B_RD_SRST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\n`define PARAMS_COMMON \\\\\\n\\t.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\\\\\n\\t.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\\\\\n\\t.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\\\\\n\\t.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\\\\\n\\t.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\\\\\n\\t.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\\\\\n\\t.DOA_REG(0), \\\\\\n\\t.DOB_REG(0), \\\\\\n\\t.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\\\\\n\\t.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\\\\\n\\t.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\\\\\n\\t.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)), \\\\\\n\\t.RAM_MODE(\\\"TDP\\\"),\\n\\n`define PORTS_COMMON \\\\\\n\\t.DOADO(DO_A), \\\\\\n\\t.DOPADOP(DOP_A), \\\\\\n\\t.DIADI(DI_A), \\\\\\n\\t.DIPADIP(DIP_A), \\\\\\n\\t.DOBDO(DO_B), \\\\\\n\\t.DOPBDOP(DOP_B), \\\\\\n\\t.DIBDI(DI_B), \\\\\\n\\t.DIPBDIP(DIP_B), \\\\\\n\\t.CLKARDCLK(PORT_A_CLK), \\\\\\n\\t.CLKBWRCLK(PORT_B_CLK), \\\\\\n\\t.ENARDEN(PORT_A_CLK_EN), \\\\\\n\\t.ENBWREN(PORT_B_CLK_EN), \\\\\\n\\t.REGCEAREGCE(1'b0), \\\\\\n\\t.REGCEB(1'b0), \\\\\\n\\t.RSTRAMARSTRAM(PORT_A_RD_SRST), \\\\\\n\\t.RSTRAMB(PORT_B_RD_SRST), \\\\\\n\\t.RSTREGARSTREG(1'b0), \\\\\\n\\t.RSTREGB(1'b0), \\\\\\n\\t.WEA(WE_A), \\\\\\n\\t.WEBWE(WE_B),\\n\\n`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)\\n`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)\\n`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)\\n`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)\\n\\nwire [3:0] WE_A = {4{PORT_A_WR_EN}};\\nwire [3:0] WE_B = {4{PORT_B_WR_EN}};\\n\\ngenerate\\n\\nif (OPTION_MODE == \\\"HALF\\\") begin\\n\\tRAMB18E1 #(\\n\\t\\t`PARAMS_INIT_18\\n\\t\\t`PARAMS_INITP_18\\n\\t\\t`PARAMS_COMMON\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t\\t.ADDRARDADDR(PORT_A_ADDR[13:0]),\\n\\t\\t.ADDRBWRADDR(PORT_B_ADDR[13:0]),\\n\\t);\\nend else if (OPTION_MODE == \\\"FULL\\\") begin\\n\\tRAMB36E1 #(\\n\\t\\t`PARAMS_INIT_36\\n\\t\\t`PARAMS_INITP_36\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_EXTENSION_A(\\\"NONE\\\"),\\n\\t\\t.RAM_EXTENSION_B(\\\"NONE\\\"),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t\\t.ADDRARDADDR({1'b1, PORT_A_ADDR[14:0]}),\\n\\t\\t.ADDRBWRADDR({1'b1, PORT_B_ADDR[14:0]}),\\n\\t);\\nend else begin\\n\\twire CAS_A, CAS_B;\\n\\tRAMB36E1 #(\\n\\t\\t`PARAMS_INIT_36\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_EXTENSION_A(\\\"LOWER\\\"),\\n\\t\\t.RAM_EXTENSION_B(\\\"LOWER\\\"),\\n\\t) lower (\\n\\t\\t.DIADI(DI_A),\\n\\t\\t.DIBDI(DI_B),\\n\\t\\t.CLKARDCLK(PORT_A_CLK),\\n\\t\\t.CLKBWRCLK(PORT_B_CLK),\\n\\t\\t.ENARDEN(PORT_A_CLK_EN),\\n\\t\\t.ENBWREN(PORT_B_CLK_EN),\\n\\t\\t.REGCEAREGCE(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.RSTRAMARSTRAM(PORT_A_RD_SRST),\\n\\t\\t.RSTRAMB(PORT_B_RD_SRST),\\n\\t\\t.RSTREGARSTREG(1'b0),\\n\\t\\t.RSTREGB(1'b0),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEBWE(WE_B),\\n\\t\\t.ADDRARDADDR(PORT_A_ADDR),\\n\\t\\t.ADDRBWRADDR(PORT_B_ADDR),\\n\\t\\t.CASCADEOUTA(CAS_A),\\n\\t\\t.CASCADEOUTB(CAS_B),\\n\\t);\\n\\tRAMB36E1 #(\\n\\t\\t`PARAMS_INIT_36_U\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.RAM_EXTENSION_A(\\\"UPPER\\\"),\\n\\t\\t.RAM_EXTENSION_B(\\\"UPPER\\\"),\\n\\t) upper (\\n\\t\\t.DOADO(DO_A),\\n\\t\\t.DIADI(DI_A),\\n\\t\\t.DOBDO(DO_B),\\n\\t\\t.DIBDI(DI_B),\\n\\t\\t.CLKARDCLK(PORT_A_CLK),\\n\\t\\t.CLKBWRCLK(PORT_B_CLK),\\n\\t\\t.ENARDEN(PORT_A_CLK_EN),\\n\\t\\t.ENBWREN(PORT_B_CLK_EN),\\n\\t\\t.REGCEAREGCE(1'b0),\\n\\t\\t.REGCEB(1'b0),\\n\\t\\t.RSTRAMARSTRAM(PORT_A_RD_SRST),\\n\\t\\t.RSTRAMB(PORT_B_RD_SRST),\\n\\t\\t.RSTREGARSTREG(1'b0),\\n\\t\\t.RSTREGB(1'b0),\\n\\t\\t.WEA(WE_A),\\n\\t\\t.WEBWE(WE_B),\\n\\t\\t.ADDRARDADDR(PORT_A_ADDR),\\n\\t\\t.ADDRBWRADDR(PORT_B_ADDR),\\n\\t\\t.CASCADEINA(CAS_A),\\n\\t\\t.CASCADEINB(CAS_B),\\n\\t);\\nend\\n\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__XILINX_BLOCKRAM_SDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_MODE = \\\"FULL\\\";\\nparameter OPTION_WRITE_MODE = \\\"READ_FIRST\\\";\\n\\nparameter PORT_W_WIDTH = 1;\\nparameter PORT_W_WR_EN_WIDTH = 1;\\nparameter PORT_W_USED = 1;\\n\\nparameter PORT_R_WIDTH = 1;\\nparameter PORT_R_USED = 0;\\nparameter PORT_R_RD_INIT_VALUE = 0;\\nparameter PORT_R_RD_SRST_VALUE = 0;\\n\\ninput CLK_C;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput [15:0] PORT_W_ADDR;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\ninput [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput [15:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\ninput PORT_R_RD_SRST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\n`define PARAMS_COMMON \\\\\\n\\t.WRITE_MODE_A(OPTION_WRITE_MODE), \\\\\\n\\t.WRITE_MODE_B(OPTION_WRITE_MODE), \\\\\\n\\t.READ_WIDTH_A(PORT_R_USED ? PORT_R_WIDTH : 0), \\\\\\n\\t.READ_WIDTH_B(0), \\\\\\n\\t.WRITE_WIDTH_A(0), \\\\\\n\\t.WRITE_WIDTH_B(PORT_W_USED ? PORT_W_WIDTH : 0), \\\\\\n\\t.DOA_REG(0), \\\\\\n\\t.DOB_REG(0), \\\\\\n\\t.RAM_MODE(\\\"SDP\\\"),\\n\\n`define PORTS_COMMON \\\\\\n\\t.CLKBWRCLK(PORT_W_CLK), \\\\\\n\\t.CLKARDCLK(PORT_R_CLK), \\\\\\n\\t.ENBWREN(PORT_W_CLK_EN), \\\\\\n\\t.ENARDEN(PORT_R_CLK_EN), \\\\\\n\\t.REGCEAREGCE(1'b0), \\\\\\n\\t.REGCEB(1'b0), \\\\\\n\\t.RSTRAMARSTRAM(PORT_R_RD_SRST), \\\\\\n\\t.RSTRAMB(1'b0), \\\\\\n\\t.RSTREGARSTREG(1'b0), \\\\\\n\\t.RSTREGB(1'b0), \\\\\\n\\t.WEA(0), \\\\\\n\\t.WEBWE(PORT_W_WR_EN),\\n\\n`MAKE_DI(DI, DIP, PORT_W_WR_DATA)\\n`MAKE_DO(DO, DOP, PORT_R_RD_DATA)\\n\\ngenerate\\n\\nif (OPTION_MODE == \\\"HALF\\\") begin\\n\\tRAMB18E1 #(\\n\\t\\t`PARAMS_INIT_18\\n\\t\\t`PARAMS_INITP_18\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.INIT_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),\\n\\t\\t.INIT_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[35:18]) : 0),\\n\\t\\t.SRVAL_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),\\n\\t\\t.SRVAL_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[35:18]) : 0),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t\\t.ADDRARDADDR(PORT_R_ADDR[13:0]),\\n\\t\\t.ADDRBWRADDR(PORT_W_ADDR[13:0]),\\n\\t\\t.DOADO(DO[15:0]),\\n\\t\\t.DOBDO(DO[31:16]),\\n\\t\\t.DOPADOP(DOP[1:0]),\\n\\t\\t.DOPBDOP(DOP[3:2]),\\n\\t\\t.DIADI(DI[15:0]),\\n\\t\\t.DIBDI(PORT_W_WIDTH == 36 ? DI[31:16] : DI[15:0]),\\n\\t\\t.DIPADIP(DIP[1:0]),\\n\\t\\t.DIPBDIP(PORT_W_WIDTH == 36 ? DIP[3:2] : DIP[1:0]),\\n\\t);\\nend else if (OPTION_MODE == \\\"FULL\\\") begin\\n\\tRAMB36E1 #(\\n\\t\\t`PARAMS_INIT_36\\n\\t\\t`PARAMS_INITP_36\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.INIT_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),\\n\\t\\t.INIT_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[71:36]) : 0),\\n\\t\\t.SRVAL_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),\\n\\t\\t.SRVAL_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[71:36]) : 0),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t\\t.ADDRARDADDR({1'b1, PORT_R_ADDR}),\\n\\t\\t.ADDRBWRADDR({1'b1, PORT_W_ADDR}),\\n\\t\\t.DOADO(DO[31:0]),\\n\\t\\t.DOBDO(DO[63:32]),\\n\\t\\t.DOPADOP(DOP[3:0]),\\n\\t\\t.DOPBDOP(DOP[7:4]),\\n\\t\\t.DIADI(DI[31:0]),\\n\\t\\t.DIBDI(PORT_W_WIDTH == 72 ? DI[63:32] : DI[31:0]),\\n\\t\\t.DIPADIP(DIP[3:0]),\\n\\t\\t.DIPBDIP(PORT_W_WIDTH == 71 ? DIP[7:4] : DIP[3:0]),\\n\\t);\\nend\\n\\nendgenerate\\n\\nendmodule\\n\",\n            \"brams_xcu_map.v\": \"module $__XILINX_BLOCKRAM_TDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_MODE = \\\"FULL\\\";\\nparameter OPTION_HAS_RDFIRST = 0;\\n\\nparameter PORT_A_RD_WIDTH = 1;\\nparameter PORT_A_WR_WIDTH = 1;\\nparameter PORT_A_WR_EN_WIDTH = 1;\\nparameter PORT_A_RD_USED = 1;\\nparameter PORT_A_WR_USED = 1;\\nparameter PORT_A_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_A_RD_INIT_VALUE = 0;\\nparameter PORT_A_RD_SRST_VALUE = 1;\\n\\nparameter PORT_B_RD_WIDTH = 1;\\nparameter PORT_B_WR_WIDTH = 1;\\nparameter PORT_B_WR_EN_WIDTH = 1;\\nparameter PORT_B_RD_USED = 0;\\nparameter PORT_B_WR_USED = 0;\\nparameter PORT_B_OPTION_WRITE_MODE = \\\"NO_CHANGE\\\";\\nparameter PORT_B_RD_INIT_VALUE = 0;\\nparameter PORT_B_RD_SRST_VALUE = 0;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput [15:0] PORT_A_ADDR;\\ninput [PORT_A_WR_WIDTH-1:0] PORT_A_WR_DATA;\\ninput [PORT_A_WR_EN_WIDTH-1:0] PORT_A_WR_EN;\\noutput [PORT_A_RD_WIDTH-1:0] PORT_A_RD_DATA;\\ninput PORT_A_RD_SRST;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput [15:0] PORT_B_ADDR;\\ninput [PORT_B_WR_WIDTH-1:0] PORT_B_WR_DATA;\\ninput [PORT_B_WR_EN_WIDTH-1:0] PORT_B_WR_EN;\\noutput [PORT_B_RD_WIDTH-1:0] PORT_B_RD_DATA;\\ninput PORT_B_RD_SRST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\n`define PARAMS_COMMON \\\\\\n\\t.WRITE_MODE_A(PORT_A_OPTION_WRITE_MODE), \\\\\\n\\t.WRITE_MODE_B(PORT_B_OPTION_WRITE_MODE), \\\\\\n\\t.READ_WIDTH_A(PORT_A_RD_USED ? PORT_A_RD_WIDTH : 0), \\\\\\n\\t.READ_WIDTH_B(PORT_B_RD_USED ? PORT_B_RD_WIDTH : 0), \\\\\\n\\t.WRITE_WIDTH_A(PORT_A_WR_USED ? PORT_A_WR_WIDTH : 0), \\\\\\n\\t.WRITE_WIDTH_B(PORT_B_WR_USED ? PORT_B_WR_WIDTH : 0), \\\\\\n\\t.DOA_REG(0), \\\\\\n\\t.DOB_REG(0), \\\\\\n\\t.INIT_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_INIT_VALUE)), \\\\\\n\\t.INIT_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_INIT_VALUE)), \\\\\\n\\t.SRVAL_A(ival(PORT_A_RD_WIDTH, PORT_A_RD_SRST_VALUE)), \\\\\\n\\t.SRVAL_B(ival(PORT_B_RD_WIDTH, PORT_B_RD_SRST_VALUE)),\\n\\n`define PORTS_COMMON \\\\\\n\\t.DOUTADOUT(DO_A), \\\\\\n\\t.DOUTPADOUTP(DOP_A), \\\\\\n\\t.DINADIN(DI_A), \\\\\\n\\t.DINPADINP(DIP_A), \\\\\\n\\t.DOUTBDOUT(DO_B), \\\\\\n\\t.DOUTPBDOUTP(DOP_B), \\\\\\n\\t.DINBDIN(DI_B), \\\\\\n\\t.DINPBDINP(DIP_B), \\\\\\n\\t.CLKARDCLK(PORT_A_CLK), \\\\\\n\\t.CLKBWRCLK(PORT_B_CLK), \\\\\\n\\t.ENARDEN(PORT_A_CLK_EN), \\\\\\n\\t.ENBWREN(PORT_B_CLK_EN), \\\\\\n\\t.REGCEAREGCE(1'b0), \\\\\\n\\t.REGCEB(1'b0), \\\\\\n\\t.ADDRENA(1'b1), \\\\\\n\\t.ADDRENB(1'b1), \\\\\\n\\t.RSTRAMARSTRAM(PORT_A_RD_SRST), \\\\\\n\\t.RSTRAMB(PORT_B_RD_SRST), \\\\\\n\\t.RSTREGARSTREG(1'b0), \\\\\\n\\t.RSTREGB(1'b0), \\\\\\n\\t.WEA(WE_A), \\\\\\n\\t.WEBWE(WE_B), \\\\\\n\\t.ADDRARDADDR(PORT_A_ADDR), \\\\\\n\\t.ADDRBWRADDR(PORT_B_ADDR), \\\\\\n\\t.SLEEP(1'b0),\\n\\n`MAKE_DI(DI_A, DIP_A, PORT_A_WR_DATA)\\n`MAKE_DI(DI_B, DIP_B, PORT_B_WR_DATA)\\n`MAKE_DO(DO_A, DOP_A, PORT_A_RD_DATA)\\n`MAKE_DO(DO_B, DOP_B, PORT_B_RD_DATA)\\n\\nwire [3:0] WE_A = {4{PORT_A_WR_EN}};\\nwire [3:0] WE_B = {4{PORT_B_WR_EN}};\\n\\ngenerate\\n\\nif (OPTION_MODE == \\\"HALF\\\") begin\\n\\tRAMB18E2 #(\\n\\t\\t`PARAMS_INIT_18\\n\\t\\t`PARAMS_INITP_18\\n\\t\\t`PARAMS_COMMON\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t);\\nend else if (OPTION_MODE == \\\"FULL\\\") begin\\n\\tRAMB36E2 #(\\n\\t\\t`PARAMS_INIT_36\\n\\t\\t`PARAMS_INITP_36\\n\\t\\t`PARAMS_COMMON\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t);\\nend\\n\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__XILINX_BLOCKRAM_SDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_MODE = \\\"FULL\\\";\\nparameter OPTION_WRITE_MODE = \\\"READ_FIRST\\\";\\n\\nparameter PORT_W_WIDTH = 1;\\nparameter PORT_W_WR_EN_WIDTH = 1;\\nparameter PORT_W_USED = 1;\\n\\nparameter PORT_R_WIDTH = 1;\\nparameter PORT_R_USED = 0;\\nparameter PORT_R_RD_INIT_VALUE = 0;\\nparameter PORT_R_RD_SRST_VALUE = 0;\\n\\ninput PORT_W_CLK;\\ninput PORT_W_CLK_EN;\\ninput [15:0] PORT_W_ADDR;\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\ninput [PORT_W_WR_EN_WIDTH-1:0] PORT_W_WR_EN;\\n\\ninput PORT_R_CLK;\\ninput PORT_R_CLK_EN;\\ninput [15:0] PORT_R_ADDR;\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\ninput PORT_R_RD_SRST;\\n\\n`include \\\"brams_defs.vh\\\"\\n\\n`define PARAMS_COMMON \\\\\\n\\t.WRITE_MODE_A(OPTION_WRITE_MODE), \\\\\\n\\t.WRITE_MODE_B(OPTION_WRITE_MODE), \\\\\\n\\t.READ_WIDTH_A(PORT_R_USED ? PORT_R_WIDTH : 0), \\\\\\n\\t.READ_WIDTH_B(0), \\\\\\n\\t.WRITE_WIDTH_A(0), \\\\\\n\\t.WRITE_WIDTH_B(PORT_W_USED ? PORT_W_WIDTH : 0), \\\\\\n\\t.DOA_REG(0), \\\\\\n\\t.DOB_REG(0),\\n\\n`define PORTS_COMMON \\\\\\n\\t.CLKBWRCLK(PORT_W_CLK), \\\\\\n\\t.CLKARDCLK(PORT_R_CLK), \\\\\\n\\t.ENBWREN(PORT_W_CLK_EN), \\\\\\n\\t.ENARDEN(PORT_R_CLK_EN), \\\\\\n\\t.REGCEAREGCE(1'b0), \\\\\\n\\t.REGCEB(1'b0), \\\\\\n\\t.ADDRENA(1'b1), \\\\\\n\\t.ADDRENB(1'b1), \\\\\\n\\t.RSTRAMARSTRAM(PORT_R_RD_SRST), \\\\\\n\\t.RSTRAMB(1'b0), \\\\\\n\\t.RSTREGARSTREG(1'b0), \\\\\\n\\t.RSTREGB(1'b0), \\\\\\n\\t.WEA(0), \\\\\\n\\t.WEBWE(PORT_W_WR_EN), \\\\\\n\\t.ADDRARDADDR(PORT_R_ADDR), \\\\\\n\\t.ADDRBWRADDR(PORT_W_ADDR), \\\\\\n\\t.SLEEP(1'b0),\\n\\n`MAKE_DI(DI, DIP, PORT_W_WR_DATA)\\n`MAKE_DO(DO, DOP, PORT_R_RD_DATA)\\n\\ngenerate\\n\\nif (OPTION_MODE == \\\"HALF\\\") begin\\n\\tRAMB18E2 #(\\n\\t\\t`PARAMS_INIT_18\\n\\t\\t`PARAMS_INITP_18\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.INIT_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),\\n\\t\\t.INIT_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_INIT_VALUE[35:18]) : 0),\\n\\t\\t.SRVAL_A(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[17:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),\\n\\t\\t.SRVAL_B(PORT_R_WIDTH == 36 ? ival(18, PORT_R_RD_SRST_VALUE[35:18]) : 0),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t\\t.DOUTADOUT(DO[15:0]),\\n\\t\\t.DOUTBDOUT(DO[31:16]),\\n\\t\\t.DOUTPADOUTP(DOP[1:0]),\\n\\t\\t.DOUTPBDOUTP(DOP[3:2]),\\n\\t\\t.DINADIN(DI[15:0]),\\n\\t\\t.DINBDIN(PORT_W_WIDTH == 36 ? DI[31:16] : DI[15:0]),\\n\\t\\t.DINPADINP(DIP[1:0]),\\n\\t\\t.DINPBDINP(PORT_W_WIDTH == 36 ? DIP[3:2] : DIP[1:0]),\\n\\t);\\nend else if (OPTION_MODE == \\\"FULL\\\") begin\\n\\tRAMB36E2 #(\\n\\t\\t`PARAMS_INIT_36\\n\\t\\t`PARAMS_INITP_36\\n\\t\\t`PARAMS_COMMON\\n\\t\\t.INIT_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_INIT_VALUE)),\\n\\t\\t.INIT_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_INIT_VALUE[71:36]) : 0),\\n\\t\\t.SRVAL_A(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[35:0]) : ival(PORT_R_WIDTH, PORT_R_RD_SRST_VALUE)),\\n\\t\\t.SRVAL_B(PORT_R_WIDTH == 72 ? ival(36, PORT_R_RD_SRST_VALUE[71:36]) : 0),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_COMMON\\n\\t\\t.DOUTADOUT(DO[31:0]),\\n\\t\\t.DOUTBDOUT(DO[63:32]),\\n\\t\\t.DOUTPADOUTP(DOP[3:0]),\\n\\t\\t.DOUTPBDOUTP(DOP[7:4]),\\n\\t\\t.DINADIN(DI[31:0]),\\n\\t\\t.DINBDIN(PORT_W_WIDTH == 72 ? DI[63:32] : DI[31:0]),\\n\\t\\t.DINPADINP(DIP[3:0]),\\n\\t\\t.DINPBDINP(PORT_W_WIDTH == 71 ? DIP[7:4] : DIP[3:0]),\\n\\t);\\nend\\n\\nendgenerate\\n\\nendmodule\\n\\n\",\n            \"brams_xcv.txt\": \"# Block RAMs for the original Virtex.\\n# The corresponding mapping file is brams_xcv_map.v\\n\\nram block $__XILINX_BLOCKRAM_ {\\n\\tabits 12;\\n\\twidths 1 2 4 8 16 per_port;\\n\\tcost 32;\\n\\tinit any;\\n\\tport srsw \\\"A\\\" \\\"B\\\" {\\n\\t\\tclock posedge;\\n\\t\\tclken;\\n\\t\\trdwr new;\\n\\t\\trdinit zero;\\n\\t\\trdsrst zero gated_clken;\\n\\t\\toptional;\\n\\t}\\n}\\n\",\n            \"brams_xcv_map.v\": \"module $__XILINX_BLOCKRAM_ (...);\\n\\nparameter INIT = 0;\\n\\nparameter PORT_A_WIDTH = 1;\\nparameter PORT_B_WIDTH = 1;\\nparameter PORT_A_USED = 1;\\nparameter PORT_B_USED = 0;\\n\\ninput PORT_A_CLK;\\ninput PORT_A_CLK_EN;\\ninput [11:0] PORT_A_ADDR;\\ninput [PORT_A_WIDTH-1:0] PORT_A_WR_DATA;\\ninput PORT_A_WR_EN;\\noutput [PORT_A_WIDTH-1:0] PORT_A_RD_DATA;\\ninput PORT_A_RD_SRST;\\n\\ninput PORT_B_CLK;\\ninput PORT_B_CLK_EN;\\ninput [11:0] PORT_B_ADDR;\\ninput [PORT_B_WIDTH-1:0] PORT_B_WR_DATA;\\ninput PORT_B_WR_EN;\\noutput [PORT_B_WIDTH-1:0] PORT_B_RD_DATA;\\ninput PORT_B_RD_SRST;\\n\\n`define PARAMS_INIT \\\\\\n\\t.INIT_00(INIT[0*256+:256]), \\\\\\n\\t.INIT_01(INIT[1*256+:256]), \\\\\\n\\t.INIT_02(INIT[2*256+:256]), \\\\\\n\\t.INIT_03(INIT[3*256+:256]), \\\\\\n\\t.INIT_04(INIT[4*256+:256]), \\\\\\n\\t.INIT_05(INIT[5*256+:256]), \\\\\\n\\t.INIT_06(INIT[6*256+:256]), \\\\\\n\\t.INIT_07(INIT[7*256+:256]), \\\\\\n\\t.INIT_08(INIT[8*256+:256]), \\\\\\n\\t.INIT_09(INIT[9*256+:256]), \\\\\\n\\t.INIT_0A(INIT[10*256+:256]), \\\\\\n\\t.INIT_0B(INIT[11*256+:256]), \\\\\\n\\t.INIT_0C(INIT[12*256+:256]), \\\\\\n\\t.INIT_0D(INIT[13*256+:256]), \\\\\\n\\t.INIT_0E(INIT[14*256+:256]), \\\\\\n\\t.INIT_0F(INIT[15*256+:256]),\\n\\n`define PORTS_DP(addr_slice_a, addr_slice_b) \\\\\\n\\t.CLKA(PORT_A_CLK), \\\\\\n\\t.ENA(PORT_A_CLK_EN), \\\\\\n\\t.WEA(PORT_A_WR_EN), \\\\\\n\\t.RSTA(PORT_A_RD_SRST), \\\\\\n\\t.ADDRA(PORT_A_ADDR addr_slice_a), \\\\\\n\\t.DOA(PORT_A_RD_DATA), \\\\\\n\\t.DIA(PORT_A_WR_DATA), \\\\\\n\\t.CLKB(PORT_B_CLK), \\\\\\n\\t.ENB(PORT_B_CLK_EN), \\\\\\n\\t.WEB(PORT_B_WR_EN), \\\\\\n\\t.RSTB(PORT_B_RD_SRST), \\\\\\n\\t.ADDRB(PORT_B_ADDR addr_slice_b), \\\\\\n\\t.DOB(PORT_B_RD_DATA), \\\\\\n\\t.DIB(PORT_B_WR_DATA),\\n\\n`define PORTS_DP_SWAP(addr_slice_a, addr_slice_b) \\\\\\n\\t.CLKB(PORT_A_CLK), \\\\\\n\\t.ENB(PORT_A_CLK_EN), \\\\\\n\\t.WEB(PORT_A_WR_EN), \\\\\\n\\t.RSTB(PORT_A_RD_SRST), \\\\\\n\\t.ADDRB(PORT_A_ADDR addr_slice_a), \\\\\\n\\t.DOB(PORT_A_RD_DATA), \\\\\\n\\t.DIB(PORT_A_WR_DATA), \\\\\\n\\t.CLKA(PORT_B_CLK), \\\\\\n\\t.ENA(PORT_B_CLK_EN), \\\\\\n\\t.WEA(PORT_B_WR_EN), \\\\\\n\\t.RSTA(PORT_B_RD_SRST), \\\\\\n\\t.ADDRA(PORT_B_ADDR addr_slice_b), \\\\\\n\\t.DOA(PORT_B_RD_DATA), \\\\\\n\\t.DIA(PORT_B_WR_DATA),\\n\\n`define PORTS_SP(addr_slice) \\\\\\n\\t.CLK(PORT_A_CLK), \\\\\\n\\t.EN(PORT_A_CLK_EN), \\\\\\n\\t.WE(PORT_A_WR_EN), \\\\\\n\\t.RST(PORT_A_RD_SRST), \\\\\\n\\t.ADDR(PORT_A_ADDR addr_slice), \\\\\\n\\t.DO(PORT_A_RD_DATA), \\\\\\n\\t.DI(PORT_A_WR_DATA),\\n\\ngenerate\\n\\nif (!PORT_B_USED) begin\\n\\tcase (PORT_A_WIDTH)\\n\\t1: RAMB4_S1 #(\\n\\t\\t`PARAMS_INIT\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_SP([11:0])\\n\\t);\\n\\t2: RAMB4_S2 #(\\n\\t\\t`PARAMS_INIT\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_SP([11:1])\\n\\t);\\n\\t4: RAMB4_S4 #(\\n\\t\\t`PARAMS_INIT\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_SP([11:2])\\n\\t);\\n\\t8: RAMB4_S8 #(\\n\\t\\t`PARAMS_INIT\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_SP([11:3])\\n\\t);\\n\\t16: RAMB4_S16 #(\\n\\t\\t`PARAMS_INIT\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t`PORTS_SP([11:4])\\n\\t);\\n\\tendcase\\nend else begin\\n\\tcase (PORT_A_WIDTH)\\n\\t1:\\tcase(PORT_B_WIDTH)\\n\\t\\t1: RAMB4_S1_S1 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:0], [11:0])\\n\\t\\t);\\n\\t\\t2: RAMB4_S1_S2 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:0], [11:1])\\n\\t\\t);\\n\\t\\t4: RAMB4_S1_S4 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:0], [11:2])\\n\\t\\t);\\n\\t\\t8: RAMB4_S1_S8 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:0], [11:3])\\n\\t\\t);\\n\\t\\t16: RAMB4_S1_S16 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:0], [11:4])\\n\\t\\t);\\n\\t\\tendcase\\n\\t2:\\tcase(PORT_B_WIDTH)\\n\\t\\t1: RAMB4_S1_S2 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:1], [11:0])\\n\\t\\t);\\n\\t\\t2: RAMB4_S2_S2 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:1], [11:1])\\n\\t\\t);\\n\\t\\t4: RAMB4_S2_S4 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:1], [11:2])\\n\\t\\t);\\n\\t\\t8: RAMB4_S2_S8 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:1], [11:3])\\n\\t\\t);\\n\\t\\t16: RAMB4_S2_S16 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:1], [11:4])\\n\\t\\t);\\n\\t\\tendcase\\n\\t4:\\tcase(PORT_B_WIDTH)\\n\\t\\t1: RAMB4_S1_S4 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:2], [11:0])\\n\\t\\t);\\n\\t\\t2: RAMB4_S2_S4 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:2], [11:1])\\n\\t\\t);\\n\\t\\t4: RAMB4_S4_S4 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:2], [11:2])\\n\\t\\t);\\n\\t\\t8: RAMB4_S4_S8 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:2], [11:3])\\n\\t\\t);\\n\\t\\t16: RAMB4_S4_S16 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:2], [11:4])\\n\\t\\t);\\n\\t\\tendcase\\n\\t8:\\tcase(PORT_B_WIDTH)\\n\\t\\t1: RAMB4_S1_S8 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:3], [11:0])\\n\\t\\t);\\n\\t\\t2: RAMB4_S2_S8 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:3], [11:1])\\n\\t\\t);\\n\\t\\t4: RAMB4_S4_S8 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:3], [11:2])\\n\\t\\t);\\n\\t\\t8: RAMB4_S8_S8 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:3], [11:3])\\n\\t\\t);\\n\\t\\t16: RAMB4_S8_S16 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:3], [11:4])\\n\\t\\t);\\n\\t\\tendcase\\n\\t16:\\tcase(PORT_B_WIDTH)\\n\\t\\t1: RAMB4_S1_S16 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:4], [11:0])\\n\\t\\t);\\n\\t\\t2: RAMB4_S2_S16 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:4], [11:1])\\n\\t\\t);\\n\\t\\t4: RAMB4_S4_S16 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:4], [11:2])\\n\\t\\t);\\n\\t\\t8: RAMB4_S8_S16 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP_SWAP([11:4], [11:3])\\n\\t\\t);\\n\\t\\t16: RAMB4_S16_S16 #(\\n\\t\\t\\t`PARAMS_INIT\\n\\t\\t) _TECHMAP_REPLACE_ (\\n\\t\\t\\t`PORTS_DP([11:4], [11:4])\\n\\t\\t);\\n\\t\\tendcase\\n\\tendcase\\nend\\n\\nendgenerate\\n\\nendmodule\\n\",\n            \"cells_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *                2019  Eddie Hung    <eddie@fpgeh.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\nmodule \\\\$__SHREG_ (input C, input D, input E, output Q);\\n  parameter DEPTH = 0;\\n  parameter [DEPTH-1:0] INIT = 0;\\n  parameter CLKPOL = 1;\\n  parameter ENPOL = 2;\\n\\n  \\\\$__XILINX_SHREG_ #(.DEPTH(DEPTH), .INIT(INIT), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) _TECHMAP_REPLACE_ (.C(C), .D(D), .L(DEPTH-1), .E(E), .Q(Q));\\nendmodule\\n\\nmodule \\\\$__XILINX_SHREG_ (input C, input D, input [31:0] L, input E, output Q, output SO);\\n  parameter DEPTH = 0;\\n  parameter [DEPTH-1:0] INIT = 0;\\n  parameter CLKPOL = 1;\\n  parameter ENPOL = 2;\\n\\n  // shregmap's INIT parameter shifts out LSB first;\\n  // however Xilinx expects MSB first\\n  function [DEPTH-1:0] brev;\\n    input [DEPTH-1:0] din;\\n    integer i;\\n    begin\\n      for (i = 0; i < DEPTH; i=i+1)\\n        brev[i] = din[DEPTH-1-i];\\n    end\\n  endfunction\\n  localparam [DEPTH-1:0] INIT_R = brev(INIT);\\n\\n  parameter _TECHMAP_CONSTMSK_L_ = 0;\\n\\n  wire CE;\\n  generate\\n    if (ENPOL == 0)\\n      assign CE = ~E;\\n    else if (ENPOL == 1)\\n      assign CE = E;\\n    else\\n      assign CE = 1'b1;\\n    if (DEPTH == 1) begin\\n      if (CLKPOL)\\n          FDRE #(.INIT(INIT_R)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(CE), .R(1'b0));\\n      else\\n          FDRE_1 #(.INIT(INIT_R)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(CE), .R(1'b0));\\n    end else\\n    if (DEPTH <= 16) begin\\n      SRL16E #(.INIT(INIT_R), .IS_CLK_INVERTED(~CLKPOL[0])) _TECHMAP_REPLACE_ (.A0(L[0]), .A1(L[1]), .A2(L[2]), .A3(L[3]), .CE(CE), .CLK(C), .D(D), .Q(Q));\\n    end else\\n    if (DEPTH > 17 && DEPTH <= 32) begin\\n      SRLC32E #(.INIT(INIT_R), .IS_CLK_INVERTED(~CLKPOL[0])) _TECHMAP_REPLACE_ (.A(L[4:0]), .CE(CE), .CLK(C), .D(D), .Q(Q));\\n    end else\\n    if (DEPTH > 33 && DEPTH <= 64) begin\\n      wire T0, T1, T2;\\n      SRLC32E #(.INIT(INIT_R[32-1:0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D(D), .Q(T0), .Q31(T1));\\n      \\\\$__XILINX_SHREG_ #(.DEPTH(DEPTH-32), .INIT(INIT[DEPTH-32-1:0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_1 (.C(C), .D(T1), .L(L), .E(E), .Q(T2));\\n      if (&_TECHMAP_CONSTMSK_L_)\\n        assign Q = T2;\\n      else\\n        MUXF7 fpga_mux_0 (.O(Q), .I0(T0), .I1(T2), .S(L[5]));\\n    end else\\n    if (DEPTH > 65 && DEPTH <= 96) begin\\n      wire T0, T1, T2, T3, T4, T5, T6;\\n      SRLC32E #(.INIT(INIT_R[32-1: 0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D( D), .Q(T0), .Q31(T1));\\n      SRLC32E #(.INIT(INIT_R[64-1:32]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_1 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T1), .Q(T2), .Q31(T3));\\n      \\\\$__XILINX_SHREG_ #(.DEPTH(DEPTH-64), .INIT(INIT[DEPTH-64-1:0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_2 (.C(C), .D(T3), .L(L[4:0]), .E(E), .Q(T4));\\n      if (&_TECHMAP_CONSTMSK_L_)\\n        assign Q = T4;\\n      else\\n        \\\\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T4), .I3(1'bx), .S0(L[5]), .S1(L[6]), .O(Q));\\n    end else\\n    if (DEPTH > 97 && DEPTH < 128) begin\\n      wire T0, T1, T2, T3, T4, T5, T6, T7, T8;\\n      SRLC32E #(.INIT(INIT_R[32-1: 0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D( D), .Q(T0), .Q31(T1));\\n      SRLC32E #(.INIT(INIT_R[64-1:32]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_1 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T1), .Q(T2), .Q31(T3));\\n      SRLC32E #(.INIT(INIT_R[96-1:64]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_2 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T3), .Q(T4), .Q31(T5));\\n      \\\\$__XILINX_SHREG_ #(.DEPTH(DEPTH-96), .INIT(INIT[DEPTH-96-1:0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_3 (.C(C), .D(T5), .L(L[4:0]), .E(E), .Q(T6));\\n      if (&_TECHMAP_CONSTMSK_L_)\\n        assign Q = T6;\\n      else\\n        \\\\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T4), .I3(T6), .S0(L[5]), .S1(L[6]), .O(Q));\\n    end\\n    else if (DEPTH == 128) begin\\n      wire T0, T1, T2, T3, T4, T5, T6;\\n      SRLC32E #(.INIT(INIT_R[ 32-1: 0]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_0 (.A(L[4:0]), .CE(CE), .CLK(C), .D( D), .Q(T0), .Q31(T1));\\n      SRLC32E #(.INIT(INIT_R[ 64-1:32]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_1 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T1), .Q(T2), .Q31(T3));\\n      SRLC32E #(.INIT(INIT_R[ 96-1:64]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_2 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T3), .Q(T4), .Q31(T5));\\n      SRLC32E #(.INIT(INIT_R[128-1:96]), .IS_CLK_INVERTED(~CLKPOL[0])) fpga_srl_3 (.A(L[4:0]), .CE(CE), .CLK(C), .D(T5), .Q(T6), .Q31(SO));\\n      if (&_TECHMAP_CONSTMSK_L_)\\n        assign Q = T6;\\n      else\\n        \\\\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T4), .I3(T6), .S0(L[5]), .S1(L[6]), .O(Q));\\n    end\\n    // For fixed length, if just 1 over a convenient value, decompose\\n    else if (DEPTH <= 129 && &_TECHMAP_CONSTMSK_L_) begin\\n      wire T;\\n      \\\\$__XILINX_SHREG_ #(.DEPTH(DEPTH-1), .INIT(INIT[DEPTH-1:1]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl      (.C(C), .D(D), .L({32{1'b1}}), .E(E), .Q(T));\\n      \\\\$__XILINX_SHREG_ #(.DEPTH(1),       .INIT(INIT[0]),         .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_last (.C(C), .D(T), .L(L), .E(E), .Q(Q));\\n    end\\n    // For variable length, if just 1 over a convenient value, then bump up one more\\n    else if (DEPTH < 129 && ~&_TECHMAP_CONSTMSK_L_)\\n      \\\\$__XILINX_SHREG_ #(.DEPTH(DEPTH+1), .INIT({INIT,1'b0}), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) _TECHMAP_REPLACE_ (.C(C), .D(D), .L(L), .E(E), .Q(Q));\\n    else begin\\n      localparam depth0 = 128;\\n      localparam num_srl128 = DEPTH / depth0;\\n      localparam depthN = DEPTH % depth0;\\n      wire [num_srl128 + (depthN > 0 ? 1 : 0) - 1:0] T;\\n      wire [num_srl128 + (depthN > 0 ? 1 : 0) :0] S;\\n      assign S[0] = D;\\n      genvar i;\\n      for (i = 0; i < num_srl128; i++)\\n        \\\\$__XILINX_SHREG_ #(.DEPTH(depth0), .INIT(INIT[DEPTH-1-i*depth0-:depth0]), .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl      (.C(C), .D(S[i]),          .L(L[$clog2(depth0)-1:0]), .E(E), .Q(T[i]), .SO(S[i+1]));\\n\\n      if (depthN > 0)\\n        \\\\$__XILINX_SHREG_ #(.DEPTH(depthN), .INIT(INIT[depthN-1:0]),               .CLKPOL(CLKPOL), .ENPOL(ENPOL)) fpga_srl_last (.C(C), .D(S[num_srl128]), .L(L[$clog2(depth0)-1:0]), .E(E), .Q(T[num_srl128]));\\n\\n      if (&_TECHMAP_CONSTMSK_L_)\\n        assign Q = T[num_srl128 + (depthN > 0 ? 1 : 0) - 1];\\n      else\\n        assign Q = T[L[DEPTH-1:$clog2(depth0)]];\\n    end\\n  endgenerate\\nendmodule\\n\\n`ifdef MIN_MUX_INPUTS\\nmodule \\\\$__XILINX_SHIFTX (A, B, Y);\\n  parameter A_SIGNED = 0;\\n  parameter B_SIGNED = 0;\\n  parameter A_WIDTH = 1;\\n  parameter B_WIDTH = 1;\\n  parameter Y_WIDTH = 1;\\n\\n  (* force_downto *)\\n  input [A_WIDTH-1:0] A;\\n  (* force_downto *)\\n  input [B_WIDTH-1:0] B;\\n  (* force_downto *)\\n  output [Y_WIDTH-1:0] Y;\\n\\n  parameter [A_WIDTH-1:0] _TECHMAP_CONSTMSK_A_ = 0;\\n  parameter [A_WIDTH-1:0] _TECHMAP_CONSTVAL_A_ = 0;\\n  parameter [B_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;\\n  parameter [B_WIDTH-1:0] _TECHMAP_CONSTVAL_B_ = 0;\\n\\n  function integer A_WIDTH_trimmed;\\n    input integer start;\\n  begin\\n    A_WIDTH_trimmed = start;\\n    while (A_WIDTH_trimmed > 0 && _TECHMAP_CONSTMSK_A_[A_WIDTH_trimmed-1] && _TECHMAP_CONSTVAL_A_[A_WIDTH_trimmed-1] === 1'bx)\\n      A_WIDTH_trimmed = A_WIDTH_trimmed - 1;\\n  end\\n  endfunction\\n\\n  generate\\n    genvar i, j;\\n    // Bit-blast\\n    if (Y_WIDTH > 1) begin\\n      for (i = 0; i < Y_WIDTH; i++)\\n        \\\\$__XILINX_SHIFTX  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH-Y_WIDTH+1), .B_WIDTH(B_WIDTH), .Y_WIDTH(1'd1)) bitblast (.A(A[A_WIDTH-Y_WIDTH+i:i]), .B(B), .Y(Y[i]));\\n    end\\n    // If the LSB of B is constant zero (and Y_WIDTH is 1) then\\n    //   we can optimise by removing every other entry from A\\n    //   and popping the constant zero from B\\n    else if (_TECHMAP_CONSTMSK_B_[0] && !_TECHMAP_CONSTVAL_B_[0]) begin\\n      wire [(A_WIDTH+1)/2-1:0] A_i;\\n      for (i = 0; i < (A_WIDTH+1)/2; i++)\\n        assign A_i[i] = A[i*2];\\n      \\\\$__XILINX_SHIFTX  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH((A_WIDTH+1'd1)/2'd2), .B_WIDTH(B_WIDTH-1'd1), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A_i), .B(B[B_WIDTH-1:1]), .Y(Y));\\n    end\\n    // Trim off any leading 1'bx -es in A\\n    else if (_TECHMAP_CONSTMSK_A_[A_WIDTH-1] && _TECHMAP_CONSTVAL_A_[A_WIDTH-1] === 1'bx) begin\\n      localparam A_WIDTH_new = A_WIDTH_trimmed(A_WIDTH-1);\\n      \\\\$__XILINX_SHIFTX  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH_new), .B_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A[A_WIDTH_new-1:0]), .B(B), .Y(Y));\\n    end\\n    else if (A_WIDTH < `MIN_MUX_INPUTS) begin\\n      wire _TECHMAP_FAIL_ = 1;\\n    end\\n    else if (A_WIDTH == 2) begin\\n      MUXF7 fpga_hard_mux (.I0(A[0]), .I1(A[1]), .S(B[0]), .O(Y));\\n    end\\n    else if (A_WIDTH <= 4) begin\\n      wire [4-1:0] Ax;\\n      if (A_WIDTH == 4)\\n        assign Ax = A;\\n      else\\n        // Rather than extend with 1'bx which gets flattened to 1'b0\\n        // causing the \\\"don't care\\\" status to get lost, extend with\\n        // the same driver of F7B.I0 so that we can optimise F7B away\\n        // later\\n        assign Ax = {A[1], A};\\n      \\\\$__XILINX_MUXF78 fpga_hard_mux (.I0(Ax[0]), .I1(Ax[2]), .I2(Ax[1]), .I3(Ax[3]), .S0(B[1]), .S1(B[0]), .O(Y));\\n    end\\n    // Note that the following decompositions are 'backwards' in that\\n    // the LSBs are placed on the hard resources, and the soft resources\\n    // are used for MSBs.\\n    // This has the effect of more effectively utilising the hard mux;\\n    // take for example a 5:1 multiplexer, currently this would map as:\\n    //\\n    //     A[0] \\\\___  __                             A[0] \\\\__  __\\n    //     A[4] /   \\\\|  \\\\       whereas the more     A[1] /  \\\\|  \\\\\\n    //     A[1] _____|   |      obvious mapping      A[2] \\\\___|   |\\n    //     A[2] _____|   |--    of MSBs to hard      A[3] /   |   |__\\n    //     A[3]______|   |      resources would      A[4] ____|   |\\n    //               |__/       lead to:             1'bx ____|   |\\n    //                ||                                      |__/\\n    //                ||                                       ||\\n    //              B[1:0]                                   B[1:2]\\n    //\\n    // Expectation would be that the 'forward' mapping (right) is more\\n    // area efficient (consider a 9:1 multiplexer using 2x4:1 multiplexers\\n    // on its I0 and I1 inputs, and A[8] and 1'bx on its I2 and I3 inputs)\\n    // but that the 'backwards' mapping (left) is more delay efficient\\n    // since smaller LUTs are faster than wider ones.\\n    else if (A_WIDTH <= 8) begin\\n      wire [8-1:0] Ax = {{{8-A_WIDTH}{1'bx}}, A};\\n      wire T0 = B[2] ? Ax[4] : Ax[0];\\n      wire T1 = B[2] ? Ax[5] : Ax[1];\\n      wire T2 = B[2] ? Ax[6] : Ax[2];\\n      wire T3 = B[2] ? Ax[7] : Ax[3];\\n      \\\\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T1), .I3(T3), .S0(B[1]), .S1(B[0]), .O(Y));\\n    end\\n    else if (A_WIDTH <= 16) begin\\n      wire [16-1:0] Ax = {{{16-A_WIDTH}{1'bx}}, A};\\n      wire T0 = B[2] ? B[3] ? Ax[12] : Ax[4]\\n                     : B[3] ? Ax[ 8] : Ax[0];\\n      wire T1 = B[2] ? B[3] ? Ax[13] : Ax[5]\\n                     : B[3] ? Ax[ 9] : Ax[1];\\n      wire T2 = B[2] ? B[3] ? Ax[14] : Ax[6]\\n                     : B[3] ? Ax[10] : Ax[2];\\n      wire T3 = B[2] ? B[3] ? Ax[15] : Ax[7]\\n                     : B[3] ? Ax[11] : Ax[3];\\n      \\\\$__XILINX_MUXF78 fpga_hard_mux (.I0(T0), .I1(T2), .I2(T1), .I3(T3), .S0(B[1]), .S1(B[0]), .O(Y));\\n    end\\n    else begin\\n      localparam num_mux16 = (A_WIDTH+15) / 16;\\n      localparam clog2_num_mux16 = $clog2(num_mux16);\\n      wire [num_mux16-1:0] T;\\n      wire [num_mux16*16-1:0] Ax = {{(num_mux16*16-A_WIDTH){1'bx}}, A};\\n      for (i = 0; i < num_mux16; i++)\\n        \\\\$__XILINX_SHIFTX  #(\\n          .A_SIGNED(A_SIGNED),\\n          .B_SIGNED(B_SIGNED),\\n          .A_WIDTH(16),\\n          .B_WIDTH(4),\\n          .Y_WIDTH(Y_WIDTH)\\n        ) fpga_mux (\\n          .A(Ax[i*16+:16]),\\n          .B(B[3:0]),\\n          .Y(T[i])\\n        );\\n      \\\\$__XILINX_SHIFTX  #(\\n          .A_SIGNED(A_SIGNED),\\n          .B_SIGNED(B_SIGNED),\\n          .A_WIDTH(num_mux16),\\n          .B_WIDTH(clog2_num_mux16),\\n          .Y_WIDTH(Y_WIDTH)\\n      ) _TECHMAP_REPLACE_ (\\n          .A(T),\\n          .B(B[B_WIDTH-1-:clog2_num_mux16]),\\n          .Y(Y));\\n    end\\n  endgenerate\\nendmodule\\n\\n(* techmap_celltype = \\\"$__XILINX_SHIFTX\\\" *)\\nmodule _90__XILINX_SHIFTX (A, B, Y);\\n  parameter A_SIGNED = 0;\\n  parameter B_SIGNED = 0;\\n  parameter A_WIDTH = 1;\\n  parameter B_WIDTH = 1;\\n  parameter Y_WIDTH = 1;\\n\\n  (* force_downto *)\\n  input [A_WIDTH-1:0] A;\\n  (* force_downto *)\\n  input [B_WIDTH-1:0] B;\\n  (* force_downto *)\\n  output [Y_WIDTH-1:0] Y;\\n\\n  \\\\$shiftx  #(.A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A), .B(B), .Y(Y));\\nendmodule\\n\\nmodule \\\\$_MUX_ (A, B, S, Y);\\n  input A, B, S;\\n  output Y;\\n  generate\\n    if (`MIN_MUX_INPUTS == 2)\\n      \\\\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(2), .B_WIDTH(1), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({B,A}), .B(S), .Y(Y));\\n    else\\n      wire _TECHMAP_FAIL_ = 1;\\n  endgenerate\\nendmodule\\n\\nmodule \\\\$_MUX4_ (A, B, C, D, S, T, Y);\\n  input A, B, C, D, S, T;\\n  output Y;\\n  \\\\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(4), .B_WIDTH(2), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({D,C,B,A}), .B({T,S}), .Y(Y));\\nendmodule\\n\\nmodule \\\\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);\\n  input A, B, C, D, E, F, G, H, S, T, U;\\n  output Y;\\n  \\\\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(8), .B_WIDTH(3), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({H,G,F,E,D,C,B,A}), .B({U,T,S}), .Y(Y));\\nendmodule\\n\\nmodule \\\\$_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y);\\n  input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V;\\n  output Y;\\n  \\\\$__XILINX_SHIFTX  #(.A_SIGNED(0), .B_SIGNED(0), .A_WIDTH(16), .B_WIDTH(4), .Y_WIDTH(1)) _TECHMAP_REPLACE_ (.A({P,O,N,M,L,K,J,I,H,G,F,E,D,C,B,A}), .B({V,U,T,S}), .Y(Y));\\nendmodule\\n`endif\\n\\nmodule \\\\$__XILINX_MUXF78 (O, I0, I1, I2, I3, S0, S1);\\n  output O;\\n  input I0, I1, I2, I3, S0, S1;\\n  wire T0, T1;\\n  parameter _TECHMAP_BITS_CONNMAP_ = 0;\\n  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I0_ = 0;\\n  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I1_ = 0;\\n  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I2_ = 0;\\n  parameter [_TECHMAP_BITS_CONNMAP_-1:0] _TECHMAP_CONNMAP_I3_ = 0;\\n  parameter _TECHMAP_CONSTMSK_S0_ = 0;\\n  parameter _TECHMAP_CONSTVAL_S0_ = 0;\\n  parameter _TECHMAP_CONSTMSK_S1_ = 0;\\n  parameter _TECHMAP_CONSTVAL_S1_ = 0;\\n  if (_TECHMAP_CONSTMSK_S0_ && _TECHMAP_CONSTVAL_S0_ === 1'b1)\\n    assign T0 = I1;\\n  else if (_TECHMAP_CONSTMSK_S0_ || _TECHMAP_CONNMAP_I0_ === _TECHMAP_CONNMAP_I1_)\\n    assign T0 = I0;\\n  else\\n    MUXF7 mux7a (.I0(I0), .I1(I1), .S(S0), .O(T0));\\n  if (_TECHMAP_CONSTMSK_S0_ && _TECHMAP_CONSTVAL_S0_ === 1'b1)\\n    assign T1 = I3;\\n  else if (_TECHMAP_CONSTMSK_S0_ || _TECHMAP_CONNMAP_I2_ === _TECHMAP_CONNMAP_I3_)\\n    assign T1 = I2;\\n  else\\n    MUXF7 mux7b (.I0(I2), .I1(I3), .S(S0), .O(T1));\\n  if (_TECHMAP_CONSTMSK_S1_ && _TECHMAP_CONSTVAL_S1_ === 1'b1)\\n    assign O = T1;\\n  else if (_TECHMAP_CONSTMSK_S1_ || (_TECHMAP_CONNMAP_I0_ === _TECHMAP_CONNMAP_I1_ && _TECHMAP_CONNMAP_I1_ === _TECHMAP_CONNMAP_I2_ && _TECHMAP_CONNMAP_I2_ === _TECHMAP_CONNMAP_I3_))\\n    assign O = T0;\\n  else\\n    MUXF8 mux8 (.I0(T0), .I1(T1), .S(S1), .O(O));\\nendmodule\\n\",\n            \"cells_sim.v\": new URL(/* asset import */ __webpack_require__(/*! ./share/xilinx/cells_sim.v */ \"./node_modules/@yowasp/yosys/gen/share/xilinx/cells_sim.v\"), __webpack_require__.b),\n            \"cells_xtra.v\": new URL(/* asset import */ __webpack_require__(/*! ./share/xilinx/cells_xtra.v */ \"./node_modules/@yowasp/yosys/gen/share/xilinx/cells_xtra.v\"), __webpack_require__.b),\n            \"ff_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n`ifndef _NO_FFS\\n\\n// Async reset, enable.\\n\\nmodule  \\\\$_DFFE_NP0P_ (input D, C, E, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDCE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\nmodule  \\\\$_DFFE_PP0P_ (input D, C, E, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDCE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\nmodule  \\\\$_DFFE_NP1P_ (input D, C, E, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDPE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .PRE(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\nmodule  \\\\$_DFFE_PP1P_ (input D, C, E, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .PRE(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// Async set and reset, enable.\\n\\nmodule  \\\\$_DFFSRE_NPPP_ (input D, C, E, S, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDCPE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_C_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R), .PRE(S));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\nmodule  \\\\$_DFFSRE_PPPP_ (input D, C, E, S, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDCPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .CLR(R), .PRE(S));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// Sync reset, enable.\\n\\nmodule  \\\\$_SDFFE_NP0P_ (input D, C, E, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDRE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .R(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\nmodule  \\\\$_SDFFE_PP0P_ (input D, C, E, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDRE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .R(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\nmodule  \\\\$_SDFFE_NP1P_ (input D, C, E, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDSE_1 #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .S(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\nmodule  \\\\$_SDFFE_PP1P_ (input D, C, E, R, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  FDSE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .C(C), .CE(E), .S(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// Latches with reset.\\n\\nmodule  \\\\$_DLATCH_NP0_ (input E, R, D, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  LDCE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_G_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\nmodule  \\\\$_DLATCH_PP0_ (input E, R, D, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  LDCE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\nmodule  \\\\$_DLATCH_NP1_ (input E, R, D, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  LDPE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_G_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .PRE(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\nmodule  \\\\$_DLATCH_PP1_ (input E, R, D, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  LDPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .PRE(R));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n// Latches with set and reset.\\n\\nmodule  \\\\$_DLATCH_NPP_ (input E, S, R, D, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  LDCPE #(.INIT(_TECHMAP_WIREINIT_Q_), .IS_G_INVERTED(1'b1)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R), .PRE(S));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\nmodule  \\\\$_DLATCH_PPP_ (input E, S, R, D, output Q);\\n  parameter _TECHMAP_WIREINIT_Q_ = 1'bx;\\n  LDCPE   #(.INIT(_TECHMAP_WIREINIT_Q_)) _TECHMAP_REPLACE_ (.D(D), .Q(Q), .G(E), .GE(1'b1), .CLR(R), .PRE(S));\\n  wire _TECHMAP_REMOVEINIT_Q_ = 1;\\nendmodule\\n\\n`endif\\n\\n\",\n            \"lut_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n// ============================================================================\\n// LUT mapping\\n\\n`ifndef _NO_LUTS\\n\\nmodule \\\\$lut (A, Y);\\n  parameter WIDTH = 0;\\n  parameter LUT = 0;\\n\\n  (* force_downto *)\\n  input [WIDTH-1:0] A;\\n  output Y;\\n\\n  generate\\n    if (WIDTH == 1) begin\\n      if (LUT == 2'b01) begin\\n        INV _TECHMAP_REPLACE_ (.O(Y), .I(A[0]));\\n      end else begin\\n        LUT1 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),\\n          .I0(A[0]));\\n      end\\n    end else\\n    if (WIDTH == 2) begin\\n      LUT2 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),\\n        .I0(A[0]), .I1(A[1]));\\n    end else\\n    if (WIDTH == 3) begin\\n      LUT3 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),\\n        .I0(A[0]), .I1(A[1]), .I2(A[2]));\\n    end else\\n    if (WIDTH == 4) begin\\n      LUT4 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),\\n        .I0(A[0]), .I1(A[1]), .I2(A[2]),\\n        .I3(A[3]));\\n    end else\\n    if (WIDTH == 5 && WIDTH <= `LUT_WIDTH) begin\\n      LUT5 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),\\n        .I0(A[0]), .I1(A[1]), .I2(A[2]),\\n        .I3(A[3]), .I4(A[4]));\\n    end else\\n    if (WIDTH == 6 && WIDTH <= `LUT_WIDTH) begin\\n      LUT6 #(.INIT(LUT)) _TECHMAP_REPLACE_ (.O(Y),\\n        .I0(A[0]), .I1(A[1]), .I2(A[2]),\\n        .I3(A[3]), .I4(A[4]), .I5(A[5]));\\n    end else\\n    if (WIDTH == 5 && WIDTH > `LUT_WIDTH) begin\\n      wire f0, f1;\\n      \\\\$lut #(.LUT(LUT[15: 0]), .WIDTH(4)) lut0 (.A(A[3:0]), .Y(f0));\\n      \\\\$lut #(.LUT(LUT[31:16]), .WIDTH(4)) lut1 (.A(A[3:0]), .Y(f1));\\n      MUXF5 mux5(.I0(f0), .I1(f1), .S(A[4]), .O(Y));\\n    end else\\n    if (WIDTH == 6 && WIDTH > `LUT_WIDTH) begin\\n      wire f0, f1;\\n      \\\\$lut #(.LUT(LUT[31: 0]), .WIDTH(5)) lut0 (.A(A[4:0]), .Y(f0));\\n      \\\\$lut #(.LUT(LUT[63:32]), .WIDTH(5)) lut1 (.A(A[4:0]), .Y(f1));\\n      MUXF6 mux6(.I0(f0), .I1(f1), .S(A[5]), .O(Y));\\n    end else\\n    if (WIDTH == 7) begin\\n      wire f0, f1;\\n      \\\\$lut #(.LUT(LUT[ 63: 0]), .WIDTH(6)) lut0 (.A(A[5:0]), .Y(f0));\\n      \\\\$lut #(.LUT(LUT[127:64]), .WIDTH(6)) lut1 (.A(A[5:0]), .Y(f1));\\n      MUXF7 mux7(.I0(f0), .I1(f1), .S(A[6]), .O(Y));\\n    end else\\n    if (WIDTH == 8) begin\\n      wire f0, f1;\\n      \\\\$lut #(.LUT(LUT[127:  0]), .WIDTH(7)) lut0 (.A(A[6:0]), .Y(f0));\\n      \\\\$lut #(.LUT(LUT[255:128]), .WIDTH(7)) lut1 (.A(A[6:0]), .Y(f1));\\n      MUXF8 mux8(.I0(f0), .I1(f1), .S(A[7]), .O(Y));\\n    end else\\n    if (WIDTH == 9) begin\\n      wire f0, f1;\\n      \\\\$lut #(.LUT(LUT[255:  0]), .WIDTH(8)) lut0 (.A(A[7:0]), .Y(f0));\\n      \\\\$lut #(.LUT(LUT[511:256]), .WIDTH(8)) lut1 (.A(A[7:0]), .Y(f1));\\n      MUXF9 mux9(.I0(f0), .I1(f1), .S(A[8]), .O(Y));\\n    end else begin\\n      wire _TECHMAP_FAIL_ = 1;\\n    end\\n  endgenerate\\nendmodule\\n\\n`endif\\n\\n\",\n            \"lutrams_xc5v.txt\": \"# LUT RAMs for Virtex 5, Virtex 6, Spartan 6, Series 7.\\n# The corresponding mapping file is lutrams_xc5v_map.v\\n\\n# Single-port RAMs.\\n\\nram distributed $__XILINX_LUTRAM_SP_ {\\n\\tcost 8;\\n\\twidthscale;\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\twidths 8 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 6 {\\n\\t\\tabits 6;\\n\\t\\twidths 4 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 7 {\\n\\t\\tabits 7;\\n\\t\\twidths 2 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 8 {\\n\\t\\tabits 8;\\n\\t\\twidths 1 global;\\n\\t}\\n\\tinit no_undef;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n}\\n\\n# Dual-port RAMs.\\n\\nram distributed $__XILINX_LUTRAM_DP_ {\\n\\tcost 8;\\n\\twidthscale;\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\twidths 4 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 6 {\\n\\t\\tabits 6;\\n\\t\\twidths 2 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 7 {\\n\\t\\tabits 7;\\n\\t\\twidths 1 global;\\n\\t}\\n\\tinit no_undef;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\\n# Quad-port RAMs.\\n\\nram distributed $__XILINX_LUTRAM_QP_ {\\n\\tcost 7;\\n\\twidthscale;\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\twidths 2 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 6 {\\n\\t\\tabits 6;\\n\\t\\twidths 1 global;\\n\\t}\\n\\tinit no_undef;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R0\\\" \\\"R1\\\" \\\"R2\\\" {\\n\\t}\\n}\\n\\n# Simple dual port RAMs.\\n\\nram distributed $__XILINX_LUTRAM_SDP_ {\\n\\tcost 8;\\n\\twidthscale 7;\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\twidths 6 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 6 {\\n\\t\\tabits 6;\\n\\t\\twidths 3 global;\\n\\t}\\n\\tinit no_undef;\\n\\tprune_rom;\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\",\n            \"lutrams_xc5v_map.v\": \"// LUT RAMs for Virtex 5, Virtex 6, Spartan 6, Series 7, Ultrascale.\\n// The definitions are in lutrams_xc5v.txt (everything but Ultrascale)\\n// and lutrams_xcu.txt (Ultrascale).\\n\\n\\nmodule $__XILINX_LUTRAM_SP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_ABITS = 5;\\nparameter WIDTH = 8;\\nparameter BITS_USED = 0;\\n\\noutput [WIDTH-1:0] PORT_RW_RD_DATA;\\ninput [WIDTH-1:0] PORT_RW_WR_DATA;\\ninput [OPTION_ABITS-1:0] PORT_RW_ADDR;\\ninput PORT_RW_WR_EN;\\ninput PORT_RW_CLK;\\n\\nfunction [(1 << OPTION_ABITS)-1:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < (1 << OPTION_ABITS); i = i + 1)\\n\\t\\tinit_slice[i] = INIT[i * WIDTH + idx];\\nendfunction\\n\\nfunction [(2 << OPTION_ABITS)-1:0] init_slice2;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < (1 << OPTION_ABITS); i = i + 1)\\n\\t\\tinit_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];\\nendfunction\\n\\ngenerate\\ncase(OPTION_ABITS)\\n5: if (WIDTH == 8)\\n\\tRAM32M\\n\\t#(\\n\\t\\t.INIT_D(init_slice2(0)),\\n\\t\\t.INIT_C(init_slice2(1)),\\n\\t\\t.INIT_B(init_slice2(2)),\\n\\t\\t.INIT_A(init_slice2(3)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_RW_RD_DATA[7:6]),\\n\\t\\t.DOB(PORT_RW_RD_DATA[5:4]),\\n\\t\\t.DOC(PORT_RW_RD_DATA[3:2]),\\n\\t\\t.DOD(PORT_RW_RD_DATA[1:0]),\\n\\t\\t.DIA(PORT_RW_WR_DATA[7:6]),\\n\\t\\t.DIB(PORT_RW_WR_DATA[5:4]),\\n\\t\\t.DIC(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DID(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.ADDRA(PORT_RW_ADDR),\\n\\t\\t.ADDRB(PORT_RW_ADDR),\\n\\t\\t.ADDRC(PORT_RW_ADDR),\\n\\t\\t.ADDRD(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\nelse\\n\\tRAM32M16\\n\\t#(\\n\\t\\t.INIT_H(init_slice2(0)),\\n\\t\\t.INIT_G(init_slice2(1)),\\n\\t\\t.INIT_F(init_slice2(2)),\\n\\t\\t.INIT_E(init_slice2(3)),\\n\\t\\t.INIT_D(init_slice2(4)),\\n\\t\\t.INIT_C(init_slice2(5)),\\n\\t\\t.INIT_B(init_slice2(6)),\\n\\t\\t.INIT_A(init_slice2(7)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_RW_RD_DATA[15:14]),\\n\\t\\t.DOB(PORT_RW_RD_DATA[13:12]),\\n\\t\\t.DOC(PORT_RW_RD_DATA[11:10]),\\n\\t\\t.DOD(PORT_RW_RD_DATA[9:8]),\\n\\t\\t.DOE(PORT_RW_RD_DATA[7:6]),\\n\\t\\t.DOF(PORT_RW_RD_DATA[5:4]),\\n\\t\\t.DOG(PORT_RW_RD_DATA[3:2]),\\n\\t\\t.DOH(PORT_RW_RD_DATA[1:0]),\\n\\t\\t.DIA(PORT_RW_WR_DATA[15:14]),\\n\\t\\t.DIB(PORT_RW_WR_DATA[13:12]),\\n\\t\\t.DIC(PORT_RW_WR_DATA[11:10]),\\n\\t\\t.DID(PORT_RW_WR_DATA[9:8]),\\n\\t\\t.DIE(PORT_RW_WR_DATA[7:6]),\\n\\t\\t.DIF(PORT_RW_WR_DATA[5:4]),\\n\\t\\t.DIG(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DIH(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.ADDRA(PORT_RW_ADDR),\\n\\t\\t.ADDRB(PORT_RW_ADDR),\\n\\t\\t.ADDRC(PORT_RW_ADDR),\\n\\t\\t.ADDRD(PORT_RW_ADDR),\\n\\t\\t.ADDRE(PORT_RW_ADDR),\\n\\t\\t.ADDRF(PORT_RW_ADDR),\\n\\t\\t.ADDRG(PORT_RW_ADDR),\\n\\t\\t.ADDRH(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\n6: begin\\n\\tgenvar i;\\n\\tfor (i = 0; i < WIDTH; i = i + 1)\\n\\t\\tif (BITS_USED[i])\\n\\t\\t\\tRAM64X1S\\n\\t\\t\\t#(\\n\\t\\t\\t\\t.INIT(init_slice(i)),\\n\\t\\t\\t)\\n\\t\\t\\tslice\\n\\t\\t\\t(\\n\\t\\t\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t\\t\\t.A4(PORT_RW_ADDR[4]),\\n\\t\\t\\t\\t.A5(PORT_RW_ADDR[5]),\\n\\t\\t\\t\\t.D(PORT_RW_WR_DATA[i]),\\n\\t\\t\\t\\t.O(PORT_RW_RD_DATA[i]),\\n\\t\\t\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t\\t);\\nend\\n7: begin\\n\\tgenvar i;\\n\\tfor (i = 0; i < WIDTH; i = i + 1)\\n\\t\\tif (BITS_USED[i])\\n\\t\\t\\tRAM128X1S\\n\\t\\t\\t#(\\n\\t\\t\\t\\t.INIT(init_slice(i)),\\n\\t\\t\\t)\\n\\t\\t\\tslice\\n\\t\\t\\t(\\n\\t\\t\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t\\t\\t.A4(PORT_RW_ADDR[4]),\\n\\t\\t\\t\\t.A5(PORT_RW_ADDR[5]),\\n\\t\\t\\t\\t.A6(PORT_RW_ADDR[6]),\\n\\t\\t\\t\\t.D(PORT_RW_WR_DATA[i]),\\n\\t\\t\\t\\t.O(PORT_RW_RD_DATA[i]),\\n\\t\\t\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t\\t);\\nend\\n8: begin\\n\\tgenvar i;\\n\\tfor (i = 0; i < WIDTH; i = i + 1)\\n\\t\\tif (BITS_USED[i])\\n\\t\\t\\tRAM256X1S\\n\\t\\t\\t#(\\n\\t\\t\\t\\t.INIT(init_slice(i)),\\n\\t\\t\\t)\\n\\t\\t\\tslice\\n\\t\\t\\t(\\n\\t\\t\\t\\t.A(PORT_RW_ADDR),\\n\\t\\t\\t\\t.D(PORT_RW_WR_DATA[i]),\\n\\t\\t\\t\\t.O(PORT_RW_RD_DATA[i]),\\n\\t\\t\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t\\t);\\nend\\n9: begin\\n\\tgenvar i;\\n\\tfor (i = 0; i < WIDTH; i = i + 1)\\n\\t\\tif (BITS_USED[i])\\n\\t\\t\\tRAM512X1S\\n\\t\\t\\t#(\\n\\t\\t\\t\\t.INIT(init_slice(i)),\\n\\t\\t\\t)\\n\\t\\t\\tslice\\n\\t\\t\\t(\\n\\t\\t\\t\\t.A(PORT_RW_ADDR),\\n\\t\\t\\t\\t.D(PORT_RW_WR_DATA[i]),\\n\\t\\t\\t\\t.O(PORT_RW_RD_DATA[i]),\\n\\t\\t\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t\\t);\\nend\\ndefault:\\n\\t$error(\\\"invalid OPTION_ABITS/WIDTH combination\\\");\\nendcase\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__XILINX_LUTRAM_DP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_ABITS = 5;\\nparameter WIDTH = 4;\\nparameter BITS_USED = 0;\\n\\noutput [WIDTH-1:0] PORT_RW_RD_DATA;\\ninput [WIDTH-1:0] PORT_RW_WR_DATA;\\ninput [OPTION_ABITS-1:0] PORT_RW_ADDR;\\ninput PORT_RW_WR_EN;\\ninput PORT_RW_CLK;\\n\\noutput [WIDTH-1:0] PORT_R_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R_ADDR;\\n\\nfunction [(1 << OPTION_ABITS)-1:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < (1 << OPTION_ABITS); i = i + 1)\\n\\t\\tinit_slice[i] = INIT[i * WIDTH + idx];\\nendfunction\\n\\nfunction [(2 << OPTION_ABITS)-1:0] init_slice2;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < (1 << OPTION_ABITS); i = i + 1)\\n\\t\\tinit_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];\\nendfunction\\n\\ngenerate\\ncase (OPTION_ABITS)\\n5: if (WIDTH == 4)\\n\\tRAM32M\\n\\t#(\\n\\t\\t.INIT_D(init_slice2(0)),\\n\\t\\t.INIT_C(init_slice2(0)),\\n\\t\\t.INIT_B(init_slice2(1)),\\n\\t\\t.INIT_A(init_slice2(1)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R_RD_DATA[3:2]),\\n\\t\\t.DOB(PORT_RW_RD_DATA[3:2]),\\n\\t\\t.DOC(PORT_R_RD_DATA[1:0]),\\n\\t\\t.DOD(PORT_RW_RD_DATA[1:0]),\\n\\t\\t.DIA(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DIB(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DIC(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.DID(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.ADDRA(PORT_R_ADDR),\\n\\t\\t.ADDRB(PORT_RW_ADDR),\\n\\t\\t.ADDRC(PORT_R_ADDR),\\n\\t\\t.ADDRD(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\nelse\\n\\tRAM32M16\\n\\t#(\\n\\t\\t.INIT_H(init_slice2(0)),\\n\\t\\t.INIT_G(init_slice2(0)),\\n\\t\\t.INIT_F(init_slice2(1)),\\n\\t\\t.INIT_E(init_slice2(1)),\\n\\t\\t.INIT_D(init_slice2(2)),\\n\\t\\t.INIT_C(init_slice2(2)),\\n\\t\\t.INIT_B(init_slice2(3)),\\n\\t\\t.INIT_A(init_slice2(3)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R_RD_DATA[7:6]),\\n\\t\\t.DOB(PORT_RW_RD_DATA[7:6]),\\n\\t\\t.DOC(PORT_R_RD_DATA[5:4]),\\n\\t\\t.DOD(PORT_RW_RD_DATA[5:4]),\\n\\t\\t.DOE(PORT_R_RD_DATA[3:2]),\\n\\t\\t.DOF(PORT_RW_RD_DATA[3:2]),\\n\\t\\t.DOG(PORT_R_RD_DATA[1:0]),\\n\\t\\t.DOH(PORT_RW_RD_DATA[1:0]),\\n\\t\\t.DIA(PORT_RW_WR_DATA[7:6]),\\n\\t\\t.DIB(PORT_RW_WR_DATA[7:6]),\\n\\t\\t.DIC(PORT_RW_WR_DATA[5:4]),\\n\\t\\t.DID(PORT_RW_WR_DATA[5:4]),\\n\\t\\t.DIE(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DIF(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DIG(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.DIH(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.ADDRA(PORT_R_ADDR),\\n\\t\\t.ADDRB(PORT_RW_ADDR),\\n\\t\\t.ADDRC(PORT_R_ADDR),\\n\\t\\t.ADDRD(PORT_RW_ADDR),\\n\\t\\t.ADDRE(PORT_R_ADDR),\\n\\t\\t.ADDRF(PORT_RW_ADDR),\\n\\t\\t.ADDRG(PORT_R_ADDR),\\n\\t\\t.ADDRH(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\n6: begin\\n\\tgenvar i;\\n\\tfor (i = 0; i < WIDTH; i = i + 1)\\n\\t\\tif (BITS_USED[i])\\n\\t\\t\\tRAM64X1D\\n\\t\\t\\t#(\\n\\t\\t\\t\\t.INIT(init_slice(i)),\\n\\t\\t\\t)\\n\\t\\t\\tslice\\n\\t\\t\\t(\\n\\t\\t\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t\\t\\t.A4(PORT_RW_ADDR[4]),\\n\\t\\t\\t\\t.A5(PORT_RW_ADDR[5]),\\n\\t\\t\\t\\t.D(PORT_RW_WR_DATA[i]),\\n\\t\\t\\t\\t.SPO(PORT_RW_RD_DATA[i]),\\n\\t\\t\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t\\t\\t.DPRA0(PORT_R_ADDR[0]),\\n\\t\\t\\t\\t.DPRA1(PORT_R_ADDR[1]),\\n\\t\\t\\t\\t.DPRA2(PORT_R_ADDR[2]),\\n\\t\\t\\t\\t.DPRA3(PORT_R_ADDR[3]),\\n\\t\\t\\t\\t.DPRA4(PORT_R_ADDR[4]),\\n\\t\\t\\t\\t.DPRA5(PORT_R_ADDR[5]),\\n\\t\\t\\t\\t.DPO(PORT_R_RD_DATA[i]),\\n\\t\\t\\t);\\nend\\n7: begin\\n\\tgenvar i;\\n\\tfor (i = 0; i < WIDTH; i = i + 1)\\n\\t\\tif (BITS_USED[i])\\n\\t\\t\\tRAM128X1D\\n\\t\\t\\t#(\\n\\t\\t\\t\\t.INIT(init_slice(i)),\\n\\t\\t\\t)\\n\\t\\t\\tslice\\n\\t\\t\\t(\\n\\t\\t\\t\\t.A(PORT_RW_ADDR),\\n\\t\\t\\t\\t.D(PORT_RW_WR_DATA[i]),\\n\\t\\t\\t\\t.SPO(PORT_RW_RD_DATA[i]),\\n\\t\\t\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t\\t\\t.DPRA(PORT_R_ADDR),\\n\\t\\t\\t\\t.DPO(PORT_R_RD_DATA[i]),\\n\\t\\t\\t);\\nend\\n8: begin\\n\\tgenvar i;\\n\\tfor (i = 0; i < WIDTH; i = i + 1)\\n\\t\\tif (BITS_USED[i])\\n\\t\\t\\tRAM256X1D\\n\\t\\t\\t#(\\n\\t\\t\\t\\t.INIT(init_slice(i)),\\n\\t\\t\\t)\\n\\t\\t\\tslice\\n\\t\\t\\t(\\n\\t\\t\\t\\t.A(PORT_RW_ADDR),\\n\\t\\t\\t\\t.D(PORT_RW_WR_DATA[i]),\\n\\t\\t\\t\\t.SPO(PORT_RW_RD_DATA[i]),\\n\\t\\t\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t\\t\\t.DPRA(PORT_R_ADDR),\\n\\t\\t\\t\\t.DPO(PORT_R_RD_DATA[i]),\\n\\t\\t\\t);\\nend\\ndefault:\\n\\t$error(\\\"invalid OPTION_ABITS/WIDTH combination\\\");\\nendcase\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__XILINX_LUTRAM_QP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_ABITS = 5;\\nparameter WIDTH = 2;\\nparameter BITS_USED = 0;\\n\\noutput [WIDTH-1:0] PORT_RW_RD_DATA;\\ninput [WIDTH-1:0] PORT_RW_WR_DATA;\\ninput [OPTION_ABITS-1:0] PORT_RW_ADDR;\\ninput PORT_RW_WR_EN;\\ninput PORT_RW_CLK;\\n\\noutput [WIDTH-1:0] PORT_R0_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R0_ADDR;\\noutput [WIDTH-1:0] PORT_R1_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R1_ADDR;\\noutput [WIDTH-1:0] PORT_R2_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R2_ADDR;\\n\\nfunction [(1 << OPTION_ABITS)-1:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < (1 << OPTION_ABITS); i = i + 1)\\n\\t\\tinit_slice[i] = INIT[i * WIDTH + idx];\\nendfunction\\n\\nfunction [(2 << OPTION_ABITS)-1:0] init_slice2;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < (1 << OPTION_ABITS); i = i + 1)\\n\\t\\tinit_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];\\nendfunction\\n\\ngenerate\\ncase (OPTION_ABITS)\\n5: if (WIDTH == 2)\\n\\tRAM32M\\n\\t#(\\n\\t\\t.INIT_D(init_slice2(0)),\\n\\t\\t.INIT_C(init_slice2(0)),\\n\\t\\t.INIT_B(init_slice2(0)),\\n\\t\\t.INIT_A(init_slice2(0)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R2_RD_DATA[1:0]),\\n\\t\\t.DOB(PORT_R1_RD_DATA[1:0]),\\n\\t\\t.DOC(PORT_R0_RD_DATA[1:0]),\\n\\t\\t.DOD(PORT_RW_RD_DATA[1:0]),\\n\\t\\t.DIA(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.DIB(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.DIC(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.DID(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.ADDRA(PORT_R2_ADDR),\\n\\t\\t.ADDRB(PORT_R1_ADDR),\\n\\t\\t.ADDRC(PORT_R0_ADDR),\\n\\t\\t.ADDRD(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\nelse\\n\\tRAM32M16\\n\\t#(\\n\\t\\t.INIT_H(init_slice2(0)),\\n\\t\\t.INIT_G(init_slice2(0)),\\n\\t\\t.INIT_F(init_slice2(0)),\\n\\t\\t.INIT_E(init_slice2(0)),\\n\\t\\t.INIT_D(init_slice2(1)),\\n\\t\\t.INIT_C(init_slice2(1)),\\n\\t\\t.INIT_B(init_slice2(1)),\\n\\t\\t.INIT_A(init_slice2(1)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R2_RD_DATA[3:2]),\\n\\t\\t.DOB(PORT_R1_RD_DATA[3:2]),\\n\\t\\t.DOC(PORT_R0_RD_DATA[3:2]),\\n\\t\\t.DOD(PORT_RW_RD_DATA[3:2]),\\n\\t\\t.DOE(PORT_R2_RD_DATA[1:0]),\\n\\t\\t.DOF(PORT_R1_RD_DATA[1:0]),\\n\\t\\t.DOG(PORT_R0_RD_DATA[1:0]),\\n\\t\\t.DOH(PORT_RW_RD_DATA[1:0]),\\n\\t\\t.DIA(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DIB(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DIC(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DID(PORT_RW_WR_DATA[3:2]),\\n\\t\\t.DIE(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.DIF(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.DIG(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.DIH(PORT_RW_WR_DATA[1:0]),\\n\\t\\t.ADDRA(PORT_R2_ADDR),\\n\\t\\t.ADDRB(PORT_R1_ADDR),\\n\\t\\t.ADDRC(PORT_R0_ADDR),\\n\\t\\t.ADDRD(PORT_RW_ADDR),\\n\\t\\t.ADDRE(PORT_R2_ADDR),\\n\\t\\t.ADDRF(PORT_R1_ADDR),\\n\\t\\t.ADDRG(PORT_R0_ADDR),\\n\\t\\t.ADDRH(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\n6: if (WIDTH == 1)\\n\\tRAM64M\\n\\t#(\\n\\t\\t.INIT_D(init_slice(0)),\\n\\t\\t.INIT_C(init_slice(0)),\\n\\t\\t.INIT_B(init_slice(0)),\\n\\t\\t.INIT_A(init_slice(0)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R2_RD_DATA[0]),\\n\\t\\t.DOB(PORT_R1_RD_DATA[0]),\\n\\t\\t.DOC(PORT_R0_RD_DATA[0]),\\n\\t\\t.DOD(PORT_RW_RD_DATA[0]),\\n\\t\\t.DIA(PORT_RW_WR_DATA[0]),\\n\\t\\t.DIB(PORT_RW_WR_DATA[0]),\\n\\t\\t.DIC(PORT_RW_WR_DATA[0]),\\n\\t\\t.DID(PORT_RW_WR_DATA[0]),\\n\\t\\t.ADDRA(PORT_R2_ADDR),\\n\\t\\t.ADDRB(PORT_R1_ADDR),\\n\\t\\t.ADDRC(PORT_R0_ADDR),\\n\\t\\t.ADDRD(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\nelse\\n\\tRAM64M8\\n\\t#(\\n\\t\\t.INIT_H(init_slice(0)),\\n\\t\\t.INIT_G(init_slice(0)),\\n\\t\\t.INIT_F(init_slice(0)),\\n\\t\\t.INIT_E(init_slice(0)),\\n\\t\\t.INIT_D(init_slice(1)),\\n\\t\\t.INIT_C(init_slice(1)),\\n\\t\\t.INIT_B(init_slice(1)),\\n\\t\\t.INIT_A(init_slice(1)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R2_RD_DATA[1]),\\n\\t\\t.DOB(PORT_R1_RD_DATA[1]),\\n\\t\\t.DOC(PORT_R0_RD_DATA[1]),\\n\\t\\t.DOD(PORT_RW_RD_DATA[1]),\\n\\t\\t.DOE(PORT_R2_RD_DATA[0]),\\n\\t\\t.DOF(PORT_R1_RD_DATA[0]),\\n\\t\\t.DOG(PORT_R0_RD_DATA[0]),\\n\\t\\t.DOH(PORT_RW_RD_DATA[0]),\\n\\t\\t.DIA(PORT_RW_WR_DATA[1]),\\n\\t\\t.DIB(PORT_RW_WR_DATA[1]),\\n\\t\\t.DIC(PORT_RW_WR_DATA[1]),\\n\\t\\t.DID(PORT_RW_WR_DATA[1]),\\n\\t\\t.DIE(PORT_RW_WR_DATA[0]),\\n\\t\\t.DIF(PORT_RW_WR_DATA[0]),\\n\\t\\t.DIG(PORT_RW_WR_DATA[0]),\\n\\t\\t.DIH(PORT_RW_WR_DATA[0]),\\n\\t\\t.ADDRA(PORT_R2_ADDR),\\n\\t\\t.ADDRB(PORT_R1_ADDR),\\n\\t\\t.ADDRC(PORT_R0_ADDR),\\n\\t\\t.ADDRD(PORT_RW_ADDR),\\n\\t\\t.ADDRE(PORT_R2_ADDR),\\n\\t\\t.ADDRF(PORT_R1_ADDR),\\n\\t\\t.ADDRG(PORT_R0_ADDR),\\n\\t\\t.ADDRH(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\ndefault:\\n\\t$error(\\\"invalid OPTION_ABITS/WIDTH combination\\\");\\nendcase\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__XILINX_LUTRAM_OP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_ABITS = 5;\\nparameter WIDTH = 2;\\nparameter BITS_USED = 0;\\n\\noutput [WIDTH-1:0] PORT_RW_RD_DATA;\\ninput [WIDTH-1:0] PORT_RW_WR_DATA;\\ninput [OPTION_ABITS-1:0] PORT_RW_ADDR;\\ninput PORT_RW_WR_EN;\\ninput PORT_RW_CLK;\\n\\noutput [WIDTH-1:0] PORT_R0_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R0_ADDR;\\noutput [WIDTH-1:0] PORT_R1_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R1_ADDR;\\noutput [WIDTH-1:0] PORT_R2_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R2_ADDR;\\noutput [WIDTH-1:0] PORT_R3_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R3_ADDR;\\noutput [WIDTH-1:0] PORT_R4_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R4_ADDR;\\noutput [WIDTH-1:0] PORT_R5_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R5_ADDR;\\noutput [WIDTH-1:0] PORT_R6_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R6_ADDR;\\n\\ngenerate\\ncase (OPTION_ABITS)\\n5:\\tRAM32M16\\n\\t#(\\n\\t\\t.INIT_H(INIT),\\n\\t\\t.INIT_G(INIT),\\n\\t\\t.INIT_F(INIT),\\n\\t\\t.INIT_E(INIT),\\n\\t\\t.INIT_D(INIT),\\n\\t\\t.INIT_C(INIT),\\n\\t\\t.INIT_B(INIT),\\n\\t\\t.INIT_A(INIT),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R6_RD_DATA),\\n\\t\\t.DOB(PORT_R5_RD_DATA),\\n\\t\\t.DOC(PORT_R4_RD_DATA),\\n\\t\\t.DOD(PORT_R3_RD_DATA),\\n\\t\\t.DOE(PORT_R2_RD_DATA),\\n\\t\\t.DOF(PORT_R1_RD_DATA),\\n\\t\\t.DOG(PORT_R0_RD_DATA),\\n\\t\\t.DOH(PORT_RW_RD_DATA),\\n\\t\\t.DIA(PORT_RW_WR_DATA),\\n\\t\\t.DIB(PORT_RW_WR_DATA),\\n\\t\\t.DIC(PORT_RW_WR_DATA),\\n\\t\\t.DID(PORT_RW_WR_DATA),\\n\\t\\t.DIE(PORT_RW_WR_DATA),\\n\\t\\t.DIF(PORT_RW_WR_DATA),\\n\\t\\t.DIG(PORT_RW_WR_DATA),\\n\\t\\t.DIH(PORT_RW_WR_DATA),\\n\\t\\t.ADDRA(PORT_R6_ADDR),\\n\\t\\t.ADDRB(PORT_R5_ADDR),\\n\\t\\t.ADDRC(PORT_R4_ADDR),\\n\\t\\t.ADDRD(PORT_R3_ADDR),\\n\\t\\t.ADDRE(PORT_R2_ADDR),\\n\\t\\t.ADDRF(PORT_R1_ADDR),\\n\\t\\t.ADDRG(PORT_R0_ADDR),\\n\\t\\t.ADDRH(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\n6:\\tRAM64M8\\n\\t#(\\n\\t\\t.INIT_H(INIT),\\n\\t\\t.INIT_G(INIT),\\n\\t\\t.INIT_F(INIT),\\n\\t\\t.INIT_E(INIT),\\n\\t\\t.INIT_D(INIT),\\n\\t\\t.INIT_C(INIT),\\n\\t\\t.INIT_B(INIT),\\n\\t\\t.INIT_A(INIT),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R6_RD_DATA),\\n\\t\\t.DOB(PORT_R5_RD_DATA),\\n\\t\\t.DOC(PORT_R4_RD_DATA),\\n\\t\\t.DOD(PORT_R3_RD_DATA),\\n\\t\\t.DOE(PORT_R2_RD_DATA),\\n\\t\\t.DOF(PORT_R1_RD_DATA),\\n\\t\\t.DOG(PORT_R0_RD_DATA),\\n\\t\\t.DOH(PORT_RW_RD_DATA),\\n\\t\\t.DIA(PORT_RW_WR_DATA),\\n\\t\\t.DIB(PORT_RW_WR_DATA),\\n\\t\\t.DIC(PORT_RW_WR_DATA),\\n\\t\\t.DID(PORT_RW_WR_DATA),\\n\\t\\t.DIE(PORT_RW_WR_DATA),\\n\\t\\t.DIF(PORT_RW_WR_DATA),\\n\\t\\t.DIG(PORT_RW_WR_DATA),\\n\\t\\t.DIH(PORT_RW_WR_DATA),\\n\\t\\t.ADDRA(PORT_R6_ADDR),\\n\\t\\t.ADDRB(PORT_R5_ADDR),\\n\\t\\t.ADDRC(PORT_R4_ADDR),\\n\\t\\t.ADDRD(PORT_R3_ADDR),\\n\\t\\t.ADDRE(PORT_R2_ADDR),\\n\\t\\t.ADDRF(PORT_R1_ADDR),\\n\\t\\t.ADDRG(PORT_R0_ADDR),\\n\\t\\t.ADDRH(PORT_RW_ADDR),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\ndefault:\\n\\t$error(\\\"invalid OPTION_ABITS/WIDTH combination\\\");\\nendcase\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__XILINX_LUTRAM_SDP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_ABITS = 5;\\nparameter WIDTH = 6;\\nparameter BITS_USED = 0;\\n\\ninput [WIDTH-1:0] PORT_W_WR_DATA;\\ninput [OPTION_ABITS-1:0] PORT_W_ADDR;\\ninput PORT_W_WR_EN;\\ninput PORT_W_CLK;\\n\\noutput [WIDTH-1:0] PORT_R_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R_ADDR;\\n\\nfunction [(1 << OPTION_ABITS)-1:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < (1 << OPTION_ABITS); i = i + 1)\\n\\t\\tinit_slice[i] = INIT[i * WIDTH + idx];\\nendfunction\\n\\nfunction [(2 << OPTION_ABITS)-1:0] init_slice2;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < (1 << OPTION_ABITS); i = i + 1)\\n\\t\\tinit_slice2[2 * i +: 2] = INIT[i * WIDTH + idx * 2 +: 2];\\nendfunction\\n\\ngenerate\\ncase (OPTION_ABITS)\\n5: if (WIDTH == 6)\\n\\tRAM32M\\n\\t#(\\n\\t\\t.INIT_C(init_slice2(0)),\\n\\t\\t.INIT_B(init_slice2(1)),\\n\\t\\t.INIT_A(init_slice2(2)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R_RD_DATA[5:4]),\\n\\t\\t.DOB(PORT_R_RD_DATA[3:2]),\\n\\t\\t.DOC(PORT_R_RD_DATA[1:0]),\\n\\t\\t.DIA(PORT_W_WR_DATA[5:4]),\\n\\t\\t.DIB(PORT_W_WR_DATA[3:2]),\\n\\t\\t.DIC(PORT_W_WR_DATA[1:0]),\\n\\t\\t.ADDRA(PORT_R_ADDR),\\n\\t\\t.ADDRB(PORT_R_ADDR),\\n\\t\\t.ADDRC(PORT_R_ADDR),\\n\\t\\t.ADDRD(PORT_W_ADDR),\\n\\t\\t.WE(PORT_W_WR_EN),\\n\\t\\t.WCLK(PORT_W_CLK),\\n\\t);\\nelse\\n\\tRAM32M16\\n\\t#(\\n\\t\\t.INIT_G(init_slice2(0)),\\n\\t\\t.INIT_F(init_slice2(1)),\\n\\t\\t.INIT_E(init_slice2(2)),\\n\\t\\t.INIT_D(init_slice2(3)),\\n\\t\\t.INIT_C(init_slice2(4)),\\n\\t\\t.INIT_B(init_slice2(5)),\\n\\t\\t.INIT_A(init_slice2(6)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R_RD_DATA[13:12]),\\n\\t\\t.DOB(PORT_R_RD_DATA[11:10]),\\n\\t\\t.DOC(PORT_R_RD_DATA[9:8]),\\n\\t\\t.DOD(PORT_R_RD_DATA[7:6]),\\n\\t\\t.DOE(PORT_R_RD_DATA[5:4]),\\n\\t\\t.DOF(PORT_R_RD_DATA[3:2]),\\n\\t\\t.DOG(PORT_R_RD_DATA[1:0]),\\n\\t\\t.DIA(PORT_W_WR_DATA[13:12]),\\n\\t\\t.DIB(PORT_W_WR_DATA[11:10]),\\n\\t\\t.DIC(PORT_W_WR_DATA[9:8]),\\n\\t\\t.DID(PORT_W_WR_DATA[7:6]),\\n\\t\\t.DIE(PORT_W_WR_DATA[5:4]),\\n\\t\\t.DIF(PORT_W_WR_DATA[3:2]),\\n\\t\\t.DIG(PORT_W_WR_DATA[1:0]),\\n\\t\\t.ADDRA(PORT_R_ADDR),\\n\\t\\t.ADDRB(PORT_R_ADDR),\\n\\t\\t.ADDRC(PORT_R_ADDR),\\n\\t\\t.ADDRD(PORT_R_ADDR),\\n\\t\\t.ADDRE(PORT_R_ADDR),\\n\\t\\t.ADDRF(PORT_R_ADDR),\\n\\t\\t.ADDRG(PORT_R_ADDR),\\n\\t\\t.ADDRH(PORT_W_ADDR),\\n\\t\\t.WE(PORT_W_WR_EN),\\n\\t\\t.WCLK(PORT_W_CLK),\\n\\t);\\n6: if (WIDTH == 3)\\n\\tRAM64M\\n\\t#(\\n\\t\\t.INIT_C(init_slice(0)),\\n\\t\\t.INIT_B(init_slice(1)),\\n\\t\\t.INIT_A(init_slice(2)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R_RD_DATA[2]),\\n\\t\\t.DOB(PORT_R_RD_DATA[1]),\\n\\t\\t.DOC(PORT_R_RD_DATA[0]),\\n\\t\\t.DIA(PORT_W_WR_DATA[2]),\\n\\t\\t.DIB(PORT_W_WR_DATA[1]),\\n\\t\\t.DIC(PORT_W_WR_DATA[0]),\\n\\t\\t.ADDRA(PORT_R_ADDR),\\n\\t\\t.ADDRB(PORT_R_ADDR),\\n\\t\\t.ADDRC(PORT_R_ADDR),\\n\\t\\t.ADDRD(PORT_W_ADDR),\\n\\t\\t.WE(PORT_W_WR_EN),\\n\\t\\t.WCLK(PORT_W_CLK),\\n\\t);\\nelse\\n\\tRAM64M8\\n\\t#(\\n\\t\\t.INIT_G(init_slice(0)),\\n\\t\\t.INIT_F(init_slice(1)),\\n\\t\\t.INIT_E(init_slice(2)),\\n\\t\\t.INIT_D(init_slice(3)),\\n\\t\\t.INIT_C(init_slice(4)),\\n\\t\\t.INIT_B(init_slice(5)),\\n\\t\\t.INIT_A(init_slice(6)),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.DOA(PORT_R_RD_DATA[6]),\\n\\t\\t.DOB(PORT_R_RD_DATA[5]),\\n\\t\\t.DOC(PORT_R_RD_DATA[4]),\\n\\t\\t.DOD(PORT_R_RD_DATA[3]),\\n\\t\\t.DOE(PORT_R_RD_DATA[2]),\\n\\t\\t.DOF(PORT_R_RD_DATA[1]),\\n\\t\\t.DOG(PORT_R_RD_DATA[0]),\\n\\t\\t.DIA(PORT_W_WR_DATA[6]),\\n\\t\\t.DIB(PORT_W_WR_DATA[5]),\\n\\t\\t.DIC(PORT_W_WR_DATA[4]),\\n\\t\\t.DID(PORT_W_WR_DATA[3]),\\n\\t\\t.DIE(PORT_W_WR_DATA[2]),\\n\\t\\t.DIF(PORT_W_WR_DATA[1]),\\n\\t\\t.DIG(PORT_W_WR_DATA[0]),\\n\\t\\t.ADDRA(PORT_R_ADDR),\\n\\t\\t.ADDRB(PORT_R_ADDR),\\n\\t\\t.ADDRC(PORT_R_ADDR),\\n\\t\\t.ADDRD(PORT_R_ADDR),\\n\\t\\t.ADDRE(PORT_R_ADDR),\\n\\t\\t.ADDRF(PORT_R_ADDR),\\n\\t\\t.ADDRG(PORT_R_ADDR),\\n\\t\\t.ADDRH(PORT_W_ADDR),\\n\\t\\t.WE(PORT_W_WR_EN),\\n\\t\\t.WCLK(PORT_W_CLK),\\n\\t);\\ndefault:\\n\\t$error(\\\"invalid OPTION_ABITS/WIDTH combination\\\");\\nendcase\\nendgenerate\\n\\nendmodule\\n\\n\\nmodule $__XILINX_LUTRAM_64X8SW_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_ABITS = 9;\\nparameter PORT_RW_WR_WIDTH = 1;\\nparameter PORT_RW_RD_WIDTH = 8;\\n\\noutput [PORT_RW_RD_WIDTH-1:0] PORT_RW_RD_DATA;\\ninput [PORT_RW_WR_WIDTH-1:0] PORT_RW_WR_DATA;\\ninput [OPTION_ABITS-1:0] PORT_RW_ADDR;\\ninput PORT_RW_WR_EN;\\ninput PORT_RW_CLK;\\n\\nfunction [63:0] init_slice;\\n\\tinput integer idx;\\n\\tinteger i;\\n\\tfor (i = 0; i < 64; i = i + 1)\\n\\t\\tinit_slice[i] = INIT[i * 8 + idx];\\nendfunction\\n\\nRAM64X8SW\\n#(\\n\\t.INIT_A(init_slice(7)),\\n\\t.INIT_B(init_slice(6)),\\n\\t.INIT_C(init_slice(5)),\\n\\t.INIT_D(init_slice(4)),\\n\\t.INIT_E(init_slice(3)),\\n\\t.INIT_F(init_slice(2)),\\n\\t.INIT_G(init_slice(1)),\\n\\t.INIT_H(init_slice(0)),\\n)\\n_TECHMAP_REPLACE_\\n(\\n\\t.A(PORT_RW_ADDR[8:3]),\\n\\t.WSEL(PORT_RW_ADDR[2:0]),\\n\\t.D(PORT_RW_WR_DATA),\\n\\t.O(PORT_RW_RD_DATA),\\n\\t.WE(PORT_RW_WR_EN),\\n\\t.WCLK(PORT_RW_CLK),\\n);\\n\\nendmodule\\n\\n\\nmodule $__XILINX_LUTRAM_32X16DR8_ (...);\\n\\nparameter OPTION_ABITS = 6;\\nparameter BITS_USED = 0;\\nparameter PORT_W_WIDTH = 14;\\nparameter PORT_R_WIDTH = 7;\\n\\ninput [PORT_W_WIDTH-1:0] PORT_W_WR_DATA;\\ninput [OPTION_ABITS-1:0] PORT_W_ADDR;\\ninput PORT_W_WR_EN;\\ninput PORT_W_CLK;\\n\\noutput [PORT_R_WIDTH-1:0] PORT_R_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R_ADDR;\\n\\nRAM32X16DR8 _TECHMAP_REPLACE_\\n(\\n\\t.DOA(PORT_R_RD_DATA[6]),\\n\\t.DOB(PORT_R_RD_DATA[5]),\\n\\t.DOC(PORT_R_RD_DATA[4]),\\n\\t.DOD(PORT_R_RD_DATA[3]),\\n\\t.DOE(PORT_R_RD_DATA[2]),\\n\\t.DOF(PORT_R_RD_DATA[1]),\\n\\t.DOG(PORT_R_RD_DATA[0]),\\n\\t.DIA({PORT_W_WR_DATA[13], PORT_W_WR_DATA[6]}),\\n\\t.DIB({PORT_W_WR_DATA[12], PORT_W_WR_DATA[5]}),\\n\\t.DIC({PORT_W_WR_DATA[11], PORT_W_WR_DATA[4]}),\\n\\t.DID({PORT_W_WR_DATA[10], PORT_W_WR_DATA[3]}),\\n\\t.DIE({PORT_W_WR_DATA[9], PORT_W_WR_DATA[2]}),\\n\\t.DIF({PORT_W_WR_DATA[8], PORT_W_WR_DATA[1]}),\\n\\t.DIG({PORT_W_WR_DATA[7], PORT_W_WR_DATA[0]}),\\n\\t.ADDRA(PORT_R_ADDR),\\n\\t.ADDRB(PORT_R_ADDR),\\n\\t.ADDRC(PORT_R_ADDR),\\n\\t.ADDRD(PORT_R_ADDR),\\n\\t.ADDRE(PORT_R_ADDR),\\n\\t.ADDRF(PORT_R_ADDR),\\n\\t.ADDRG(PORT_R_ADDR),\\n\\t.ADDRH(PORT_W_ADDR[5:1]),\\n\\t.WE(PORT_W_WR_EN),\\n\\t.WCLK(PORT_W_CLK),\\n);\\n\\nendmodule\\n\",\n            \"lutrams_xcu.txt\": \"# LUT RAMs for Ultrascale.\\n# The corresponding mapping file is lutrams_xc5v_map.v\\n\\n# Single-port RAMs.\\n\\nram distributed $__XILINX_LUTRAM_SP_ {\\n\\tcost 16;\\n\\twidthscale;\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\twidths 16 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 6 {\\n\\t\\tabits 6;\\n\\t\\twidths 8 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 7 {\\n\\t\\tabits 7;\\n\\t\\twidths 4 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 8 {\\n\\t\\tabits 8;\\n\\t\\twidths 2 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 16 {\\n\\t\\tabits 16;\\n\\t\\twidths 1 global;\\n\\t}\\n\\tinit any;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n}\\n\\n# Dual-port RAMs.\\n\\nram distributed $__XILINX_LUTRAM_DP_ {\\n\\tcost 16;\\n\\twidthscale;\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\twidths 8 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 6 {\\n\\t\\tabits 6;\\n\\t\\twidths 4 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 7 {\\n\\t\\tabits 7;\\n\\t\\twidths 2 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 8 {\\n\\t\\tabits 8;\\n\\t\\twidths 1 global;\\n\\t}\\n\\tinit any;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\\n# Quad-port RAMs.\\n\\nram distributed $__XILINX_LUTRAM_QP_ {\\n\\tcost 16;\\n\\twidthscale;\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\twidths 4 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 6 {\\n\\t\\tabits 6;\\n\\t\\twidths 2 global;\\n\\t}\\n\\tinit any;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R0\\\" \\\"R1\\\" \\\"R2\\\" {\\n\\t}\\n}\\n\\n# Octal-port RAMs.\\n\\nram distributed $__XILINX_LUTRAM_OP_ {\\n\\tcost 16;\\n\\twidthscale;\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\twidths 2 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 6 {\\n\\t\\tabits 6;\\n\\t\\twidths 1 global;\\n\\t}\\n\\tinit any;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R0\\\" \\\"R1\\\" \\\"R2\\\" \\\"R3\\\" \\\"R4\\\" \\\"R5\\\" \\\"R6\\\" {\\n\\t}\\n}\\n\\n# Simple dual port RAMs.\\n\\nram distributed $__XILINX_LUTRAM_SDP_ {\\n\\tcost 16;\\n\\twidthscale;\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\twidths 14 global;\\n\\t}\\n\\toption \\\"ABITS\\\" 6 {\\n\\t\\tabits 6;\\n\\t\\twidths 7 global;\\n\\t}\\n\\tinit any;\\n\\tprune_rom;\\n\\tport sw \\\"W\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\\n# Wide-read RAM.\\n\\nram distributed $__XILINX_LUTRAM_64X8SW_ {\\n\\tcost 16;\\n\\tabits 9;\\n\\twidths 1 2 4 8 per_port;\\n\\tinit any;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\twidth rd 8 wr 1;\\n\\t\\tclock posedge;\\n\\t}\\n}\\n\\n# Wide-write RAM.\\n\\nram distributed $__XILINX_LUTRAM_32X16DR8_ {\\n\\tcost 16;\\n\\twidthscale;\\n\\tabits 6;\\n\\twidths 7 14 per_port;\\n\\t# Yes, no initialization capability.\\n\\tprune_rom;\\n\\tport sw \\\"W\\\" {\\n\\t\\twidth 14;\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t\\twidth 7;\\n\\t}\\n}\\n\",\n            \"lutrams_xcv.txt\": \"# LUT RAMs for Virtex, Virtex 2, Spartan 3, Virtex 4.\\n# The corresponding mapping file is lutrams_xcv_map.v\\n\\nram distributed $__XILINX_LUTRAM_SP_ {\\n\\twidth 1;\\n\\toption \\\"ABITS\\\" 4 {\\n\\t\\tabits 4;\\n\\t\\tcost 3;\\n\\t}\\n\\toption \\\"ABITS\\\" 5 {\\n\\t\\tabits 5;\\n\\t\\tcost 5;\\n\\t}\\n\\tifndef IS_VIRTEX {\\n\\t\\toption \\\"ABITS\\\" 6 {\\n\\t\\t\\tabits 6;\\n\\t\\t\\tcost 9;\\n\\t\\t}\\n\\t}\\n\\tifdef IS_VIRTEX2 {\\n\\t\\t# RAM128X1S\\n\\t\\toption \\\"ABITS\\\" 7 {\\n\\t\\t\\tabits 7;\\n\\t\\t\\tcost 17;\\n\\t\\t}\\n\\t}\\n\\tinit no_undef;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n}\\n\\nram distributed $__XILINX_LUTRAM_DP_ {\\n\\twidth 1;\\n\\toption \\\"ABITS\\\" 4 {\\n\\t\\tabits 4;\\n\\t\\tcost 5;\\n\\t}\\n\\tifdef IS_VIRTEX2 {\\n\\t\\t# RAM32X1D\\n\\t\\toption \\\"ABITS\\\" 5 {\\n\\t\\t\\tabits 5;\\n\\t\\t\\tcost 9;\\n\\t\\t}\\n\\t\\t# RAM64X1D\\n\\t\\toption \\\"ABITS\\\" 6 {\\n\\t\\t\\tabits 6;\\n\\t\\t\\tcost 17;\\n\\t\\t}\\n\\t}\\n\\tinit no_undef;\\n\\tprune_rom;\\n\\tport arsw \\\"RW\\\" {\\n\\t\\tclock posedge;\\n\\t}\\n\\tport ar \\\"R\\\" {\\n\\t}\\n}\\n\",\n            \"lutrams_xcv_map.v\": \"// LUT RAMs for Virtex, Virtex 2, Spartan 3, Virtex 4.\\n// The corresponding definition file is lutrams_xcv.txt\\n\\nmodule $__XILINX_LUTRAM_SP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_ABITS = 4;\\n\\noutput PORT_RW_RD_DATA;\\ninput PORT_RW_WR_DATA;\\ninput [OPTION_ABITS-1:0] PORT_RW_ADDR;\\ninput PORT_RW_WR_EN;\\ninput PORT_RW_CLK;\\n\\ngenerate\\ncase(OPTION_ABITS)\\n4: RAM16X1S\\n\\t#(\\n\\t\\t.INIT(INIT),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t.D(PORT_RW_WR_DATA),\\n\\t\\t.O(PORT_RW_RD_DATA),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\n5: RAM32X1S\\n\\t#(\\n\\t\\t.INIT(INIT),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t.A4(PORT_RW_ADDR[4]),\\n\\t\\t.D(PORT_RW_WR_DATA),\\n\\t\\t.O(PORT_RW_RD_DATA),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\n6: RAM64X1S\\n\\t#(\\n\\t\\t.INIT(INIT),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t.A4(PORT_RW_ADDR[4]),\\n\\t\\t.A5(PORT_RW_ADDR[5]),\\n\\t\\t.D(PORT_RW_WR_DATA),\\n\\t\\t.O(PORT_RW_RD_DATA),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\n7: RAM128X1S\\n\\t#(\\n\\t\\t.INIT(INIT),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t.A4(PORT_RW_ADDR[4]),\\n\\t\\t.A5(PORT_RW_ADDR[5]),\\n\\t\\t.A6(PORT_RW_ADDR[6]),\\n\\t\\t.D(PORT_RW_WR_DATA),\\n\\t\\t.O(PORT_RW_RD_DATA),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t);\\ndefault:\\n\\t$error(\\\"invalid OPTION_ABITS\\\");\\nendcase\\nendgenerate\\n\\nendmodule\\n\\nmodule $__XILINX_LUTRAM_DP_ (...);\\n\\nparameter INIT = 0;\\nparameter OPTION_ABITS = 4;\\n\\noutput PORT_RW_RD_DATA;\\ninput PORT_RW_WR_DATA;\\ninput [OPTION_ABITS-1:0] PORT_RW_ADDR;\\ninput PORT_RW_WR_EN;\\ninput PORT_RW_CLK;\\n\\noutput PORT_R_RD_DATA;\\ninput [OPTION_ABITS-1:0] PORT_R_ADDR;\\n\\ngenerate\\ncase (OPTION_ABITS)\\n4: RAM16X1D\\n\\t#(\\n\\t\\t.INIT(INIT),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t.D(PORT_RW_WR_DATA),\\n\\t\\t.SPO(PORT_RW_RD_DATA),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t.DPRA0(PORT_R_ADDR[0]),\\n\\t\\t.DPRA1(PORT_R_ADDR[1]),\\n\\t\\t.DPRA2(PORT_R_ADDR[2]),\\n\\t\\t.DPRA3(PORT_R_ADDR[3]),\\n\\t\\t.DPO(PORT_R_RD_DATA),\\n\\t);\\n5: RAM32X1D\\n\\t#(\\n\\t\\t.INIT(INIT),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t.A4(PORT_RW_ADDR[4]),\\n\\t\\t.D(PORT_RW_WR_DATA),\\n\\t\\t.SPO(PORT_RW_RD_DATA),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t.DPRA0(PORT_R_ADDR[0]),\\n\\t\\t.DPRA1(PORT_R_ADDR[1]),\\n\\t\\t.DPRA2(PORT_R_ADDR[2]),\\n\\t\\t.DPRA3(PORT_R_ADDR[3]),\\n\\t\\t.DPRA4(PORT_R_ADDR[4]),\\n\\t\\t.DPO(PORT_R_RD_DATA),\\n\\t);\\n6: RAM64X1D\\n\\t#(\\n\\t\\t.INIT(INIT),\\n\\t)\\n\\t_TECHMAP_REPLACE_\\n\\t(\\n\\t\\t.A0(PORT_RW_ADDR[0]),\\n\\t\\t.A1(PORT_RW_ADDR[1]),\\n\\t\\t.A2(PORT_RW_ADDR[2]),\\n\\t\\t.A3(PORT_RW_ADDR[3]),\\n\\t\\t.A4(PORT_RW_ADDR[4]),\\n\\t\\t.A5(PORT_RW_ADDR[5]),\\n\\t\\t.D(PORT_RW_WR_DATA),\\n\\t\\t.SPO(PORT_RW_RD_DATA),\\n\\t\\t.WE(PORT_RW_WR_EN),\\n\\t\\t.WCLK(PORT_RW_CLK),\\n\\t\\t.DPRA0(PORT_R_ADDR[0]),\\n\\t\\t.DPRA1(PORT_R_ADDR[1]),\\n\\t\\t.DPRA2(PORT_R_ADDR[2]),\\n\\t\\t.DPRA3(PORT_R_ADDR[3]),\\n\\t\\t.DPRA4(PORT_R_ADDR[4]),\\n\\t\\t.DPRA5(PORT_R_ADDR[5]),\\n\\t\\t.DPO(PORT_R_RD_DATA),\\n\\t);\\ndefault:\\n\\t$error(\\\"invalid OPTION_ABITS\\\");\\nendcase\\nendgenerate\\n\\nendmodule\\n\",\n            \"mux_map.v\": \"/*\\n *  yosys -- Yosys Open SYnthesis Suite\\n *\\n *  Copyright (C) 2012  Claire Xenia Wolf <claire@yosyshq.com>\\n *                2019  Eddie Hung    <eddie@fpgeh.com>\\n *\\n *  Permission to use, copy, modify, and/or distribute this software for any\\n *  purpose with or without fee is hereby granted, provided that the above\\n *  copyright notice and this permission notice appear in all copies.\\n *\\n *  THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n *\\n */\\n\\n// The purpose of these mapping rules is to allow preserve all (sufficiently\\n// wide) $shiftx cells during 'techmap' so that they can be mapped to hard\\n// resources, rather than being bit-blasted to gates during 'techmap'\\n// execution\\n\\nmodule \\\\$shiftx (A, B, Y);\\n  parameter A_SIGNED = 0;\\n  parameter B_SIGNED = 0;\\n  parameter A_WIDTH = 1;\\n  parameter B_WIDTH = 1;\\n  parameter Y_WIDTH = 1;\\n\\n  (* force_downto *)\\n  input [A_WIDTH-1:0] A;\\n  (* force_downto *)\\n  input [B_WIDTH-1:0] B;\\n  (* force_downto *)\\n  output [Y_WIDTH-1:0] Y;\\n\\n  parameter [B_WIDTH-1:0] _TECHMAP_CONSTMSK_B_ = 0;\\n  parameter [B_WIDTH-1:0] _TECHMAP_CONSTVAL_B_ = 0;\\n\\n  generate\\n    if (B_SIGNED) begin\\n      if (_TECHMAP_CONSTMSK_B_[B_WIDTH-1] && (_TECHMAP_CONSTVAL_B_[B_WIDTH-1] == 1'b0 || _TECHMAP_CONSTVAL_B_[B_WIDTH-1] === 1'bx))\\n        // Optimisation to remove B_SIGNED if sign bit of B is constant-0\\n        \\\\$shiftx #(\\n          .A_SIGNED(A_SIGNED),\\n          .B_SIGNED(0),\\n          .A_WIDTH(A_WIDTH),\\n          .B_WIDTH(B_WIDTH-1'd1),\\n          .Y_WIDTH(Y_WIDTH)\\n        ) _TECHMAP_REPLACE_ (\\n          .A(A), .B(B[B_WIDTH-2:0]), .Y(Y)\\n        );\\n      else\\n        wire _TECHMAP_FAIL_ = 1;\\n    end\\n    else begin\\n      if (((A_WIDTH + Y_WIDTH - 1) / Y_WIDTH) < `MIN_MUX_INPUTS)\\n        wire _TECHMAP_FAIL_ = 1;\\n      else\\n        \\\\$__XILINX_SHIFTX #(\\n          .A_SIGNED(A_SIGNED),\\n          .B_SIGNED(B_SIGNED),\\n          .A_WIDTH(A_WIDTH),\\n          .B_WIDTH(B_WIDTH),\\n          .Y_WIDTH(Y_WIDTH)\\n        ) _TECHMAP_REPLACE_ (\\n          .A(A), .B(B), .Y(Y)\\n        );\\n    end\\n  endgenerate\\nendmodule\\n\",\n            \"urams.txt\": \"ram huge $__XILINX_URAM_ {\\n\\tabits 12;\\n\\twidth 72;\\n\\tcost 1024;\\n\\toption \\\"BYTEWIDTH\\\" 8 byte 8;\\n\\toption \\\"BYTEWIDTH\\\" 9 byte 9;\\n\\tinit zero;\\n\\tport srsw \\\"A\\\" {\\n\\t\\tclock anyedge \\\"C\\\";\\n\\t\\tclken;\\n\\t\\trdwr no_change;\\n\\t\\trdinit zero;\\n\\t\\tportoption \\\"RST_MODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated;\\n\\t\\t}\\n\\t\\tportoption \\\"RST_MODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\twrtrans all new;\\n\\t\\twrbe_separate;\\n\\t}\\n\\tport srsw \\\"B\\\" {\\n\\t\\tclock anyedge \\\"C\\\";\\n\\t\\tclken;\\n\\t\\trdwr no_change;\\n\\t\\trdinit zero;\\n\\t\\tportoption \\\"RST_MODE\\\" \\\"SYNC\\\" {\\n\\t\\t\\trdsrst zero ungated;\\n\\t\\t}\\n\\t\\tportoption \\\"RST_MODE\\\" \\\"ASYNC\\\" {\\n\\t\\t\\trdarst zero;\\n\\t\\t}\\n\\t\\twrtrans all old;\\n\\t\\twrprio \\\"A\\\";\\n\\t\\twrbe_separate;\\n\\t}\\n}\\n\",\n            \"urams_map.v\": \"module $__XILINX_URAM_ (...);\\n\\tparameter OPTION_BYTEWIDTH = 8;\\n\\tlocalparam WR_BE_WIDTH = 72 / OPTION_BYTEWIDTH;\\n\\n\\tparameter CLK_C_POL = 1;\\n\\tparameter PORT_A_CLK_POL = 1;\\n\\tparameter PORT_A_OPTION_RST_MODE = \\\"SYNC\\\";\\n\\tparameter PORT_B_CLK_POL = 1;\\n\\tparameter PORT_B_OPTION_RST_MODE = \\\"SYNC\\\";\\n\\n\\tinput CLK_C;\\n\\n\\tinput PORT_A_CLK;\\n\\tinput PORT_A_CLK_EN;\\n\\tinput PORT_A_RD_SRST;\\n\\tinput PORT_A_RD_ARST;\\n\\tinput PORT_A_WR_EN;\\n\\tinput [WR_BE_WIDTH-1:0] PORT_A_WR_BE;\\n\\tinput [11:0] PORT_A_ADDR;\\n\\tinput [71:0] PORT_A_WR_DATA;\\n\\toutput [71:0] PORT_A_RD_DATA;\\n\\n\\tinput PORT_B_CLK;\\n\\tinput PORT_B_CLK_EN;\\n\\tinput PORT_B_RD_SRST;\\n\\tinput PORT_B_RD_ARST;\\n\\tinput PORT_B_WR_EN;\\n\\tinput [WR_BE_WIDTH-1:0] PORT_B_WR_BE;\\n\\tinput [11:0] PORT_B_ADDR;\\n\\tinput [71:0] PORT_B_WR_DATA;\\n\\toutput [71:0] PORT_B_RD_DATA;\\n\\n\\twire [71:0] DIN_A, DIN_B, DOUT_A, DOUT_B;\\n\\n\\tgenerate\\n\\t\\tif (OPTION_BYTEWIDTH == 8) begin\\n\\t\\t\\tassign DIN_A = PORT_A_WR_DATA;\\n\\t\\t\\tassign DIN_B = PORT_B_WR_DATA;\\n\\t\\t\\tassign PORT_A_RD_DATA = DOUT_A;\\n\\t\\t\\tassign PORT_B_RD_DATA = DOUT_B;\\n\\t\\tend else begin\\n\\t\\t\\tassign DIN_A = {\\n\\t\\t\\t\\tPORT_A_WR_DATA[71],\\n\\t\\t\\t\\tPORT_A_WR_DATA[62],\\n\\t\\t\\t\\tPORT_A_WR_DATA[53],\\n\\t\\t\\t\\tPORT_A_WR_DATA[44],\\n\\t\\t\\t\\tPORT_A_WR_DATA[35],\\n\\t\\t\\t\\tPORT_A_WR_DATA[26],\\n\\t\\t\\t\\tPORT_A_WR_DATA[17],\\n\\t\\t\\t\\tPORT_A_WR_DATA[8],\\n\\t\\t\\t\\tPORT_A_WR_DATA[70:63],\\n\\t\\t\\t\\tPORT_A_WR_DATA[61:54],\\n\\t\\t\\t\\tPORT_A_WR_DATA[52:45],\\n\\t\\t\\t\\tPORT_A_WR_DATA[43:36],\\n\\t\\t\\t\\tPORT_A_WR_DATA[34:27],\\n\\t\\t\\t\\tPORT_A_WR_DATA[25:18],\\n\\t\\t\\t\\tPORT_A_WR_DATA[16:9],\\n\\t\\t\\t\\tPORT_A_WR_DATA[7:0]\\n\\t\\t\\t};\\n\\t\\t\\tassign DIN_B = {\\n\\t\\t\\t\\tPORT_B_WR_DATA[71],\\n\\t\\t\\t\\tPORT_B_WR_DATA[62],\\n\\t\\t\\t\\tPORT_B_WR_DATA[53],\\n\\t\\t\\t\\tPORT_B_WR_DATA[44],\\n\\t\\t\\t\\tPORT_B_WR_DATA[35],\\n\\t\\t\\t\\tPORT_B_WR_DATA[26],\\n\\t\\t\\t\\tPORT_B_WR_DATA[17],\\n\\t\\t\\t\\tPORT_B_WR_DATA[8],\\n\\t\\t\\t\\tPORT_B_WR_DATA[70:63],\\n\\t\\t\\t\\tPORT_B_WR_DATA[61:54],\\n\\t\\t\\t\\tPORT_B_WR_DATA[52:45],\\n\\t\\t\\t\\tPORT_B_WR_DATA[43:36],\\n\\t\\t\\t\\tPORT_B_WR_DATA[34:27],\\n\\t\\t\\t\\tPORT_B_WR_DATA[25:18],\\n\\t\\t\\t\\tPORT_B_WR_DATA[16:9],\\n\\t\\t\\t\\tPORT_B_WR_DATA[7:0]\\n\\t\\t\\t};\\n\\t\\t\\tassign PORT_A_RD_DATA = {\\n\\t\\t\\t\\tDOUT_A[71],\\n\\t\\t\\t\\tDOUT_A[63:56],\\n\\t\\t\\t\\tDOUT_A[70],\\n\\t\\t\\t\\tDOUT_A[55:48],\\n\\t\\t\\t\\tDOUT_A[69],\\n\\t\\t\\t\\tDOUT_A[47:40],\\n\\t\\t\\t\\tDOUT_A[68],\\n\\t\\t\\t\\tDOUT_A[39:32],\\n\\t\\t\\t\\tDOUT_A[67],\\n\\t\\t\\t\\tDOUT_A[31:24],\\n\\t\\t\\t\\tDOUT_A[66],\\n\\t\\t\\t\\tDOUT_A[23:16],\\n\\t\\t\\t\\tDOUT_A[65],\\n\\t\\t\\t\\tDOUT_A[15:8],\\n\\t\\t\\t\\tDOUT_A[64],\\n\\t\\t\\t\\tDOUT_A[7:0]\\n\\t\\t\\t};\\n\\t\\t\\tassign PORT_B_RD_DATA = {\\n\\t\\t\\t\\tDOUT_B[71],\\n\\t\\t\\t\\tDOUT_B[63:56],\\n\\t\\t\\t\\tDOUT_B[70],\\n\\t\\t\\t\\tDOUT_B[55:48],\\n\\t\\t\\t\\tDOUT_B[69],\\n\\t\\t\\t\\tDOUT_B[47:40],\\n\\t\\t\\t\\tDOUT_B[68],\\n\\t\\t\\t\\tDOUT_B[39:32],\\n\\t\\t\\t\\tDOUT_B[67],\\n\\t\\t\\t\\tDOUT_B[31:24],\\n\\t\\t\\t\\tDOUT_B[66],\\n\\t\\t\\t\\tDOUT_B[23:16],\\n\\t\\t\\t\\tDOUT_B[65],\\n\\t\\t\\t\\tDOUT_B[15:8],\\n\\t\\t\\t\\tDOUT_B[64],\\n\\t\\t\\t\\tDOUT_B[7:0]\\n\\t\\t\\t};\\n\\t\\tend\\n\\tendgenerate\\n\\n\\tURAM288 #(\\n\\t\\t.BWE_MODE_A(OPTION_BYTEWIDTH == 8 ? \\\"PARITY_INDEPENDENT\\\" : \\\"PARITY_INTERLEAVED\\\"),\\n\\t\\t.BWE_MODE_B(OPTION_BYTEWIDTH == 8 ? \\\"PARITY_INDEPENDENT\\\" : \\\"PARITY_INTERLEAVED\\\"),\\n\\t\\t.EN_AUTO_SLEEP_MODE(\\\"FALSE\\\"),\\n\\t\\t.IREG_PRE_A(\\\"FALSE\\\"),\\n\\t\\t.IREG_PRE_B(\\\"FALSE\\\"),\\n\\t\\t.IS_CLK_INVERTED(!CLK_C_POL),\\n\\t\\t.OREG_A(\\\"FALSE\\\"),\\n\\t\\t.OREG_B(\\\"FALSE\\\"),\\n\\t\\t.RST_MODE_A(PORT_A_OPTION_RST_MODE),\\n\\t\\t.RST_MODE_B(PORT_B_OPTION_RST_MODE),\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t.ADDR_A({11'b0, PORT_A_ADDR}),\\n\\t\\t.BWE_A(PORT_A_WR_BE),\\n\\t\\t.EN_A(PORT_A_CLK_EN),\\n\\t\\t.RDB_WR_A(PORT_A_WR_EN),\\n\\t\\t.INJECT_DBITERR_A(1'b0),\\n\\t\\t.INJECT_SBITERR_A(1'b0),\\n\\t\\t.RST_A(PORT_A_OPTION_RST_MODE == \\\"SYNC\\\" ? PORT_A_RD_SRST : PORT_A_RD_ARST),\\n\\t\\t.DIN_A(DIN_A),\\n\\t\\t.DOUT_A(DOUT_A),\\n\\n\\t\\t.ADDR_B({11'b0, PORT_B_ADDR}),\\n\\t\\t.BWE_B(PORT_B_WR_BE),\\n\\t\\t.EN_B(PORT_B_CLK_EN),\\n\\t\\t.RDB_WR_B(PORT_B_WR_EN),\\n\\t\\t.INJECT_DBITERR_B(1'b0),\\n\\t\\t.INJECT_SBITERR_B(1'b0),\\n\\t\\t.RST_B(PORT_B_OPTION_RST_MODE == \\\"SYNC\\\" ? PORT_B_RD_SRST : PORT_B_RD_ARST),\\n\\t\\t.DIN_B(DIN_B),\\n\\t\\t.DOUT_B(DOUT_B),\\n\\n\\t\\t.CLK(CLK_C),\\n\\t\\t.SLEEP(1'b0)\\n\\t);\\nendmodule\\n\",\n            \"xc3s_mult_map.v\": \"module \\\\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 0;\\n\\tparameter B_WIDTH = 0;\\n\\tparameter Y_WIDTH = 0;\\n\\n\\tMULT18X18 _TECHMAP_REPLACE_ (\\n\\t\\t.A(A),\\n\\t\\t.B(B),\\n\\t\\t.P(Y)\\n\\t);\\nendmodule\\n\\n\",\n            \"xc3sda_dsp_map.v\": \"module \\\\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 0;\\n\\tparameter B_WIDTH = 0;\\n\\tparameter Y_WIDTH = 0;\\n\\n\\twire [47:0] P_48;\\n\\tDSP48A #(\\n\\t\\t// Disable all registers\\n\\t\\t.A0REG(0),\\n\\t\\t.A1REG(0),\\n\\t\\t.B0REG(0),\\n\\t\\t.B1REG(0),\\n\\t\\t.CARRYINREG(0),\\n\\t\\t.CARRYINSEL(\\\"OPMODE5\\\"),\\n\\t\\t.CREG(0),\\n\\t\\t.DREG(0),\\n\\t\\t.MREG(0),\\n\\t\\t.OPMODEREG(0),\\n\\t\\t.PREG(0)\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t//Data path\\n\\t\\t.A(A),\\n\\t\\t.B(B),\\n\\t\\t.C(48'b0),\\n\\t\\t.D(18'b0),\\n\\t\\t.P(P_48),\\n\\n\\t\\t.OPMODE(8'b0000001)\\n\\t);\\n\\tassign Y = P_48;\\nendmodule\\n\\n\",\n            \"xc4v_dsp_map.v\": \"module \\\\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 0;\\n\\tparameter B_WIDTH = 0;\\n\\tparameter Y_WIDTH = 0;\\n\\n\\twire [47:0] P_48;\\n\\tDSP48 #(\\n\\t\\t// Disable all registers\\n\\t\\t.AREG(0),\\n\\t\\t.BREG(0),\\n\\t\\t.B_INPUT(\\\"DIRECT\\\"),\\n\\t\\t.CARRYINREG(0),\\n\\t\\t.CARRYINSELREG(0),\\n\\t\\t.CREG(0),\\n\\t\\t.MREG(0),\\n\\t\\t.OPMODEREG(0),\\n\\t\\t.PREG(0),\\n\\t\\t.SUBTRACTREG(0),\\n\\t\\t.LEGACY_MODE(\\\"MULT18X18\\\")\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t//Data path\\n\\t\\t.A(A),\\n\\t\\t.B(B),\\n\\t\\t.C(48'b0),\\n\\t\\t.P(P_48),\\n\\n\\t\\t.SUBTRACT(1'b0),\\n\\t\\t.OPMODE(7'b000101),\\n\\t\\t.CARRYINSEL(2'b00),\\n\\n\\t\\t.BCIN(18'b0),\\n\\t\\t.PCIN(48'b0),\\n\\t\\t.CARRYIN(1'b0)\\n\\t);\\n\\tassign Y = P_48;\\nendmodule\\n\",\n            \"xc5v_dsp_map.v\": \"module \\\\$__MUL25X18 (input [24:0] A, input [17:0] B, output [42:0] Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 0;\\n\\tparameter B_WIDTH = 0;\\n\\tparameter Y_WIDTH = 0;\\n\\n\\twire [47:0] P_48;\\n\\tDSP48E #(\\n\\t\\t// Disable all registers\\n\\t\\t.ACASCREG(0),\\n\\t\\t.A_INPUT(\\\"DIRECT\\\"),\\n\\t\\t.ALUMODEREG(0),\\n\\t\\t.AREG(0),\\n\\t\\t.BCASCREG(0),\\n\\t\\t.B_INPUT(\\\"DIRECT\\\"),\\n\\t\\t.BREG(0),\\n\\t\\t.MULTCARRYINREG(0),\\n\\t\\t.CARRYINREG(0),\\n\\t\\t.CARRYINSELREG(0),\\n\\t\\t.CREG(0),\\n\\t\\t.MREG(0),\\n\\t\\t.OPMODEREG(0),\\n\\t\\t.PREG(0),\\n\\t\\t.USE_MULT(\\\"MULT\\\"),\\n\\t\\t.USE_SIMD(\\\"ONE48\\\")\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t//Data path\\n\\t\\t.A({{5{A[24]}}, A}),\\n\\t\\t.B(B),\\n\\t\\t.C(48'b0),\\n\\t\\t.P(P_48),\\n\\n\\t\\t.ALUMODE(4'b0000),\\n\\t\\t.OPMODE(7'b000101),\\n\\t\\t.CARRYINSEL(3'b000),\\n\\n\\t\\t.ACIN(30'b0),\\n\\t\\t.BCIN(18'b0),\\n\\t\\t.PCIN(48'b0),\\n\\t\\t.CARRYIN(1'b0)\\n\\t);\\n\\tassign Y = P_48;\\nendmodule\\n\\n\",\n            \"xc6s_dsp_map.v\": \"module \\\\$__MUL18X18 (input [17:0] A, input [17:0] B, output [35:0] Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 0;\\n\\tparameter B_WIDTH = 0;\\n\\tparameter Y_WIDTH = 0;\\n\\n\\twire [47:0] P_48;\\n\\tDSP48A1 #(\\n\\t\\t// Disable all registers\\n\\t\\t.A0REG(0),\\n\\t\\t.A1REG(0),\\n\\t\\t.B0REG(0),\\n\\t\\t.B1REG(0),\\n\\t\\t.CARRYINREG(0),\\n\\t\\t.CARRYINSEL(\\\"OPMODE5\\\"),\\n\\t\\t.CREG(0),\\n\\t\\t.DREG(0),\\n\\t\\t.MREG(0),\\n\\t\\t.OPMODEREG(0),\\n\\t\\t.PREG(0)\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t//Data path\\n\\t\\t.A(A),\\n\\t\\t.B(B),\\n\\t\\t.C(48'b0),\\n\\t\\t.D(18'b0),\\n\\t\\t.P(P_48),\\n\\n\\t\\t.OPMODE(8'b0000001)\\n\\t);\\n\\tassign Y = P_48;\\nendmodule\\n\\n\\n\",\n            \"xc7_dsp_map.v\": \"module \\\\$__MUL25X18 (input [24:0] A, input [17:0] B, output [42:0] Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 0;\\n\\tparameter B_WIDTH = 0;\\n\\tparameter Y_WIDTH = 0;\\n\\n\\twire [47:0] P_48;\\n\\tDSP48E1 #(\\n\\t\\t// Disable all registers\\n\\t\\t.ACASCREG(0),\\n\\t\\t.ADREG(0),\\n\\t\\t.A_INPUT(\\\"DIRECT\\\"),\\n\\t\\t.ALUMODEREG(0),\\n\\t\\t.AREG(0),\\n\\t\\t.BCASCREG(0),\\n\\t\\t.B_INPUT(\\\"DIRECT\\\"),\\n\\t\\t.BREG(0),\\n\\t\\t.CARRYINREG(0),\\n\\t\\t.CARRYINSELREG(0),\\n\\t\\t.CREG(0),\\n\\t\\t.DREG(0),\\n\\t\\t.INMODEREG(0),\\n\\t\\t.MREG(0),\\n\\t\\t.OPMODEREG(0),\\n\\t\\t.PREG(0),\\n\\t\\t.USE_MULT(\\\"MULTIPLY\\\"),\\n\\t\\t.USE_SIMD(\\\"ONE48\\\"),\\n\\t\\t.USE_DPORT(\\\"FALSE\\\")\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t//Data path\\n\\t\\t.A({{5{A[24]}}, A}),\\n\\t\\t.B(B),\\n\\t\\t.C(48'b0),\\n\\t\\t.D(25'b0),\\n\\t\\t.CARRYIN(1'b0),\\n\\t\\t.P(P_48),\\n\\n\\t\\t.INMODE(5'b00000),\\n\\t\\t.ALUMODE(4'b0000),\\n\\t\\t.OPMODE(7'b000101),\\n\\t\\t.CARRYINSEL(3'b000),\\n\\n\\t\\t.ACIN(30'b0),\\n\\t\\t.BCIN(18'b0),\\n\\t\\t.PCIN(48'b0),\\n\\t\\t.CARRYIN(1'b0)\\n\\t);\\n\\tassign Y = P_48;\\nendmodule\\n\",\n            \"xcu_dsp_map.v\": \"module \\\\$__MUL27X18 (input [26:0] A, input [17:0] B, output [44:0] Y);\\n\\tparameter A_SIGNED = 0;\\n\\tparameter B_SIGNED = 0;\\n\\tparameter A_WIDTH = 0;\\n\\tparameter B_WIDTH = 0;\\n\\tparameter Y_WIDTH = 0;\\n\\n\\twire [47:0] P_48;\\n\\tDSP48E2 #(\\n\\t\\t// Disable all registers\\n\\t\\t.ACASCREG(0),\\n\\t\\t.ADREG(0),\\n\\t\\t.A_INPUT(\\\"DIRECT\\\"),\\n\\t\\t.ALUMODEREG(0),\\n\\t\\t.AREG(0),\\n\\t\\t.BCASCREG(0),\\n\\t\\t.B_INPUT(\\\"DIRECT\\\"),\\n\\t\\t.BREG(0),\\n\\t\\t.CARRYINREG(0),\\n\\t\\t.CARRYINSELREG(0),\\n\\t\\t.CREG(0),\\n\\t\\t.DREG(0),\\n\\t\\t.INMODEREG(0),\\n\\t\\t.MREG(0),\\n\\t\\t.OPMODEREG(0),\\n\\t\\t.PREG(0),\\n\\t\\t.USE_MULT(\\\"MULTIPLY\\\"),\\n\\t\\t.USE_SIMD(\\\"ONE48\\\"),\\n\\t\\t.AMULTSEL(\\\"A\\\"),\\n\\t\\t.BMULTSEL(\\\"B\\\")\\n\\t) _TECHMAP_REPLACE_ (\\n\\t\\t//Data path\\n\\t\\t.A({{3{A[26]}}, A}),\\n\\t\\t.B(B),\\n\\t\\t.C(48'b0),\\n\\t\\t.D(27'b0),\\n\\t\\t.P(P_48),\\n\\n\\t\\t.INMODE(5'b00000),\\n\\t\\t.ALUMODE(4'b0000),\\n\\t\\t.OPMODE(9'b00000101),\\n\\t\\t.CARRYINSEL(3'b000),\\n\\n\\t\\t.ACIN(30'b0),\\n\\t\\t.BCIN(18'b0),\\n\\t\\t.PCIN(48'b0),\\n\\t\\t.CARRYIN(1'b0)\\n\\t);\\n\\tassign Y = P_48;\\nendmodule\\n\\n\",\n        },\n    }\n};\n\n\n//# sourceURL=webpack://churchroad/./node_modules/@yowasp/yosys/gen/resources-yosys.js?");

/***/ })

}]);