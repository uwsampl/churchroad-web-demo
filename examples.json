{
  "antiunify": "(datatype Expr\n  (Num i64)\n  (Var String)\n  (Add Expr Expr))\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n\n;; antiunificaiton returns an expression that could unify with either\n;; of the input expressions\n;; (AU x y) can be considered a placeholder variable\n(function AU (Expr Expr) Expr)\n\n(rewrite (AU x x) x)\n(rewrite\n (AU (Add a b) (Add c d))\n (Add (AU a c) (AU b d)))\n\n(let e1 (Add (Var \"x\") (Add (Num 1) (Num 2))))\n(let e2 (Add (Num 3) (Var \"y\")))\n\n(let au12 (AU e1 e2))\n\n(run 4)\n(check (= au12 (Add (Num 3) (AU (Var \"x\") (Var \"y\")))))\n(query-extract au12)\n",
  "array": "; Smtlib theory of arrays\n; https://smtlib.cs.uiowa.edu/theories-ArraysEx.shtml\n; http://smtlib.cs.uiowa.edu/version1/theories/Arrays.smt\n\n(datatype Math\n  (Num i64)\n  (Var String)\n)\n\n\n(datatype Array\n  (Const i64)\n  (AVar String)\n)\n\n(function add (Math Math) Math)\n(function select (Array Math) Math)\n(function store (Array Math Math) Array)\n\n(relation neq (Math Math))\n\n(rule ((neq x y))\n      ((neq y x)))\n\n(rule ((neq x x))\n      ((panic \"query (neq x x) found something equal to itself\")))\n\n\n; injectivity rules take not equal to not equal.\n(rule  ((neq x y) (= (add x z) e))\n       ((neq (add x z) (add y z))))\n(rule  ((= (add x (Num i)) e) (!= i 0))\n       ((neq e x)))\n\n\n(rule ((= (Num a) n1) (= (Num b) n2) (!= a b))\n      ((neq n1 n2)))\n\n; select gets from store\n(rewrite (select (store mem i e) i) e)\n; select passes through wrong index\n(rule ((= (select (store mem i1 e) i2) e1) (neq i1 i2))\n      ((union (select mem i2) e1)))\n; aliasing writes destroy old value\n(rewrite (store (store mem i e1) i e2) (store mem i e2))\n; non-aliasing writes commutes\n(rule ((= (store (store mem i2 e2) i1 e1) mem1) (neq i1 i2))\n      ((union (store (store mem i1 e1) i2 e2) mem1)))\n\n; typical math rules\n(rewrite (add x y) (add y x))\n(rewrite (add (add x y) z) (add x (add y z)))\n(rewrite (add (Num x) (Num y)) (Num (+ x y)))\n(rewrite (add x (Num 0)) x)\n\n(push)\n(let r1 (Var \"r1\"))\n(let r2 (Var \"r2\"))\n(let r3 (Var \"r3\"))\n(let mem1 (AVar \"mem1\"))\n\n(neq r1 r2)\n(neq r2 r3)\n(neq r1 r3)\n(let test1 (select (store mem1 r1 (Num 42)) r1))\n(let test2 (select (store mem1 r1 (Num 42)) (add r1 (Num 17))))\n(let test3 (select (store (store mem1 (add r1 r2) (Num 1)) (add r2 r1) (Num 2)) (add r1 r3)))\n(let test4 (add (Num 1) (add (add (Num 1) (add (Num 1) r1)) (Num -3))))\n\n(run 5)\n(check (= test1 (Num 42)))\n(check (neq r1 r2))\n(check (neq r1 (add r1 (Num 17))))\n(check (= test2 (select mem1 (add r1 (Num 17)))))\n(check (= test3 (select mem1 (add r1 r3))))\n(check (= test4 r1))\n(pop)\n",
  "bdd": "; Binary Decision Diagrams are if-then-else trees/ compressed tries that hash cons their leaves\n; This is easily expressible in the facilities provided. Everything in egglog is automatcally shared\n; and Compression is easily expressible as a rule.\n\n; They are a notion of first class set useful for certain classes of uniformly describable sets.\n; https://en.wikipedia.org/wiki/Binary_decision_diagram\n; https://www.lri.fr/~filliatr/ftp/publis/hash-consing2.pdf Type-Safe Modular Hash-Consing - Section 3.3\n\n(datatype BDD\n    (ITE i64 BDD BDD) ; variables labelled by number\n)\n(declare True BDD)\n(declare False BDD)\n\n; compress unneeded nodes\n(rewrite (ITE n a a) a)\n\n(function bddand (BDD BDD) BDD)\n(rewrite (bddand x y) (bddand y x))\n(rewrite (bddand False n) False)\n(rewrite (bddand True x) x)\n\n; We use an order where low variables are higher in tree\n; Could go the other way.\n(rewrite (bddand (ITE n a1 a2) (ITE m b1 b2))\n    (ITE n (bddand a1 (ITE m b1 b2)) (bddand a2 (ITE m b1 b2)))\n    :when ((< n m))\n)\n(rewrite (bddand (ITE n a1 a2) (ITE n b1 b2))\n    (ITE n (bddand a1 b1) (bddand a2 b2))\n)\n\n(function bddor (BDD BDD) BDD)\n(rewrite (bddor x y) (bddor y x))\n(rewrite (bddor True n) True)\n(rewrite (bddor False x) x)\n(rewrite (bddor (ITE n a1 a2) (ITE m b1 b2))\n    (ITE n (bddor a1 (ITE m b1 b2)) (bddor a2 (ITE m b1 b2)))\n    :when ((< n m))\n)\n(rewrite (bddor (ITE n a1 a2) (ITE n b1 b2))\n    (ITE n (bddor a1 b1) (bddor a2 b2))\n)\n\n(function bddnot (BDD) BDD)\n(rewrite (bddnot True) False)\n(rewrite (bddnot False) True)\n(rewrite (bddnot (ITE n a1 a2)) (ITE n (bddnot a1) (bddnot a2)))\n\n\n(function bddxor (BDD BDD) BDD)\n(rewrite (bddxor x y) (bddxor y x))\n(rewrite (bddxor True n) (bddnot n))\n(rewrite (bddxor False x) x)\n\n(rewrite (bddxor (ITE n a1 a2) (ITE m b1 b2))\n    (ITE n (bddxor a1 (ITE m b1 b2)) (bddxor a2 (ITE m b1 b2)))\n    :when ((< n m))\n)\n(rewrite (bddxor (ITE n a1 a2) (ITE n b1 b2))\n    (ITE n (bddxor a1 b1) (bddxor a2 b2))\n)\n\n(push)\n;;; Tests\n\n(let v0 (ITE 0 True False))\n(let v1 (ITE 1 True False))\n(let v2 (ITE 2 True False))\n\n(let t0 (bddnot (bddnot v0)))\n(let t1 (bddor v0 (bddnot v0)))\n(let t2 (bddand v0 (bddnot v0)))\n(let t3 (bddand v0 v0))\n(let t4 (bddor v0 v0))\n(let t5 (bddxor (bddnot v0) v0))\n(let t6 (bddand (bddor v1 v2) v2))\n\n(let t7a (bddxor (bddnot v0) v1))\n(let t7b (bddxor v0 (bddnot v1)))\n(let t7c (bddnot (bddxor v0 v1)))\n\n(let t8 (bddand v1 v2))\n\n(let t9 (bddand (bddnot v1) (bddand (bddnot v0) (bddxor v0 v1))))\n(let t10 (bddor (bddnot v1) (bddor (bddnot v0) (bddxor  v0 (bddnot v1)))))\n\n(run 30)\n\n(check (= t0 v0)) ; bddnot cancels\n(check (= t1 True))\n(check (= t2 False))\n(check (= t3 v0))\n(check (= t4 v0))\n(check (= t5 True))\n(check (= t6 v2))\n\n(check (= t7a t7b))\n(check (= t7a t7c))\n\n(check (= t8 (ITE 1 (ITE 2 True False) False)))\n\n(check (= t9 False))\n(check (= t10 True))\n(pop)\n",
  "before-proofs": "(set-option enable_proofs 1)\n\n(datatype Math\n    (Add Math Math)\n    (Sub Math Math)\n    (Const Rational)\n    (Var String))\n\n(rewrite (Add a b) (Add (Add a b) (Const (rational 0 1))))\n\n(rewrite (Add a b) (Add b a))\n\n\n(rewrite (Add a (Add b c))\n      (Add (Add a b) c))\n\n(let two (rational 2 1))\n(let start1 (Add (Var \"x\") (Const two)))\n;; add original proofs\n\n(run 3)\n\n\n(check (!= (Var \"x\") (Const two)))\n(check (= (Add (Var \"x\") (Const two))\n          (Add (Const two) (Var \"x\"))))\n\n(let zero (Const (rational 0 1)))\n(let addx2 (Add (Var \"x\") (Const two)))\n(let addx20 (Add addx2 zero))\n(let addzerofront (Add (Add zero (Var \"x\")) (Const two)))\n\n(check (= addx2\n          addx20))\n",
  "birewrite": "(datatype Math (Add Math Math) (Lit i64))\n\n(birewrite (Add (Add x y) z) (Add x (Add y z)))\n\n(let a (Lit 1))\n(let b (Lit 2))\n(let c (Lit 3))\n\n(let d (Lit 4))\n(let e (Lit 5))\n(let f (Lit 6))\n\n(let ex1 (Add (Add a b) c))\n(let ex2 (Add d (Add e f)))\n\n(run 10)\n(check (= ex1 (Add a (Add b c))))\n(check (= ex2 (Add (Add d e) f)))\n",
  "bitwise": "(check (= 0 (& 10 0)))\n(check (= 8 (& 8 10)))\n(check (= 10 (| 8 10)))\n(check (= 2 (^ 8 10)))\n(check (= 8 (<< 1 3)))\n(check (= 1 (>> 8 3)))\n(check (= 2 (% 8 3)))\n(check (= 2 (/ 8 3)))\n(check (= -1 (not-i64 0)))\n\n; bitsets\n;(function bs-union (i64 i64) i64)\n;(rewrite (bs-union a b) (| a b))\n\n;(function bs-inter (i64 i64) i64)\n;(rewrite (bs-inter a b) (& a b))\n\n;(function bs-comp (i64) i64)\n;(rewrite (bs-comp a) (bvnot a))\n\n; singleton set\n;(function bs-sing (i64) i64)\n;(rewrite (bs-sing a) (1 << a))\n\n;(function bs-insert (i64 i64) i64)\n;(rewrite (bs-insert s x) (| s (1 << a))\n\n;(function bs-diff (i64 i64) i64)\n;(rewrite (bs-diff a b) (^ a (bs-inter a b))\n\n;(let bs-empty 0)\n\n;(let bs-subset (i64 i64) bool)\n;(rewrite (bs-subset x y) (is-zero (bs-diff x y)))\n\n;(let bs-is-elem (i64 i64) bool)\n;(rewrite (bs-is-elem s x) (not (is-zero (bs-inter s (sing x)))))\n",
  "bool": "\n(check (= (and true true) true))\n(check (= (and true false) false))\n(check (= (or true false) true))\n(check (!= (or true false) false))\n\n(check (= (bool-= 1 1) true))\n(check (= (bool-= -5 -5) true))\n(check (= (bool-= 1 3) false))\n(check (= (bool-= 3 1) false))\n\n(check (= (bool-< 1 2) true))\n(check (= (bool-< 2 1) false))\n(check (= (bool-< 1 1) false))\n\n(check (= (bool-<= 1 2) true))\n(check (= (bool-<= 2 1) false))\n(check (= (bool-<= 1 1) true))\n\n(check (= (bool-> 1 2) false))\n(check (= (bool-> 2 1) true))\n(check (= (bool-> 1 1) false))\n\n(check (= (bool->= 1 2) false))\n(check (= (bool->= 2 1) true))\n(check (= (bool->= 1 1) true))\n\n; Test bool's tag\n(relation R (i64))\n(function F (i64) bool)\n\n(rule\n    ((R i))\n    ((set (F i) true))\n)\n\n(R 0)\n\n(run 3)\n",
  "calc": "(datatype G)\n(declare I G)\n(declare A G)\n(declare B G)\n(function g* (G G) G)\n(function inv (G) G)\n(birewrite (g* (g* a b) c) (g* a (g* b c))) ; assoc\n(rewrite (g* I a) a) ; idl\n(rewrite (g* a I) a) ; idr\n(rewrite (g* (inv a) a) I) ; invl\n(rewrite (g* a (inv a)) I) ; invr\n\n; A is cyclic of period 4\n(rewrite (g* A (g* A (g* A A))) I)\n\n(let A2 (g* A A))\n(let A4 (g* A2 A2))\n(let A8 (g* A4 A4))\n\n\n(calc ()\n    (g* A4 A4)\n    (g* (g* A2 A2) (g* A2 A2))\n    (g* A2 (g* A2 (g* A2 A2)))\n)\n\n; Note that (calc ((I G) (b G)) ...) will fail because names must be unused\n(calc ((a G) (b G))\n    (g* (g* b (g* (inv a) a)) (inv b))\n    (g* b (inv b))\n    I\n)\n",
  "combinators": "; Substitution in lambda-calculus via S/K/I combinators. Extremely slow, as\n; abstraction elimination does not pay attention to whether variables are free\n; in an expression before introducing 'S'.\n;\n; Provides an example of how to implement substitution by embedding in a\n; 'richer' data-type and then mapping back to syntax.\n\n(datatype Expr\n    (Var String :cost 100)\n    (Abs String Expr)\n    (If Expr Expr Expr)\n    (N i64)\n    (Add Expr Expr)\n    (App Expr Expr))\n(declare T Expr)\n(declare F Expr)\n\n\n; (\\x. (if x then 0 else 1) + 2) false\n(let test\n    (App \n        (Abs \"x\" (Add (If (Var \"x\") (N 0) (N 1)) (N 2))) F))\n\n(datatype CExpr\n    (CVar String :cost 10000) ; (variables that haven't been eliminated yet)\n    (CAbs String CExpr :cost 10000) ; (abstractions that haven't been eliminated yet)\n    (CN i64)\n    (CApp CExpr CExpr))\n(declare CT CExpr)\n(declare CF CExpr)\n(declare CIf CExpr)\n(declare CAdd CExpr)\n(declare S CExpr)\n(declare K CExpr)\n(declare I CExpr)\n\n;;;; Conversion functions\n(function Comb (Expr) CExpr :cost 1000000)\n(function Uncomb (CExpr) Expr)    \n(rewrite (Comb (Uncomb cx)) cx)\n(rewrite (Uncomb (Comb x)) x)\n\n; Mechanical mappings back and forth.\n; Note: we avoid resugaring S/K/I\n(rule ((= x (N n))) ((union (Comb x) (CN n))))\n(rule ((= cx (CN n))) ((union (Uncomb cx) (N n))))\n(rule ((= x T)) ((union (Comb x) CT)))\n(rule ((= cx CT)) ((union (Uncomb cx) T)))\n(rule ((= x F)) ((union (Comb x) CF)))\n(rule ((= cx CF)) ((union (Uncomb cx) F)))\n\n(rule ((= x (If c t f)))\n    ((union (Comb x) (CApp (CApp (CApp CIf (Comb c)) (Comb t)) (Comb f)))))\n(rule ((= cx (CApp (CApp (CApp CIf cc) ct) cf)))\n    ((union (Uncomb cx) (If (Uncomb cc) (Uncomb ct) (Uncomb cf)))))\n\n(rule ((= x (Add l r)))\n    ((union (Comb x) (CApp (CApp CAdd (Comb l)) (Comb r)))))\n(rule ((= cx (CApp (CApp CAdd cl) cr)))\n    ((union (Uncomb cx) (Add (Uncomb cl) (Uncomb cr)))))\n(rule ((= x (App f a))) ((union (Comb x) (CApp (Comb f) (Comb a)))))\n\n(rule ((= x (Var v))) ((union (Comb x) (CVar v))))\n(rule ((= x (Abs v body))) ((union (Comb x) (CAbs v (Comb body)))))\n\n;;;; Abstraction Elimination \n(rewrite (CAbs v (CVar v)) I)\n; Hacks, could be replaced by !free computation.\n(rewrite (CAbs v1 (CVar v2)) (CApp K (CVar v2)) \n    :when ((!= v1 v2)))\n(rewrite (CAbs v (CN n)) (CApp K (CN n)))\n(rewrite (CAbs v CT) (CApp K CT))\n(rewrite (CAbs v CF) (CApp K CF))\n(rewrite (CAbs v CIf) (CApp K CIf))\n(rewrite (CAbs v CAdd) (CApp K CAdd))\n(rewrite (CAbs v (CApp x y)) (CApp (CApp S (CAbs v x)) (CAbs v y)))\n; May be needed for multiple nested variables\n(rewrite (CAbs v (CApp K (CVar v))) K)\n\n;;;; Primitive Evaluation rules (letd on \"surface syntax\")\n(rewrite (If T t f) t)\n(rewrite (If F t f) f)\n(rewrite (Add (N n) (N m)) (N (+ n m)))\n\n;;;; Substitution Rules (letd on the combinator representation)\n(rewrite (CApp I cx) cx)\n(rewrite (CApp (CApp K cx) cy) cx)\n; Without demand, this can cause an explosion in DB size.\n(rewrite (CApp (CApp (CApp S cx) cy) cz) (CApp (CApp cx cz) (CApp cy cz)))\n\n(run 11)\n(query-extract (Comb test))\n(check (= test (N 3)))",
  "combined-nested": "(relation number (i64))\n\n\n(ruleset myrules1)\n(rule ()\n      ((number 1))\n      :ruleset myrules1)\n(ruleset myrules2)\n(rule ()\n      ((number 2))\n      :ruleset myrules2)\n\n(unstable-combined-ruleset rules1and2\n    myrules1 myrules2)\n\n;; allowed to add to myrules2 and the change is reflected\n(rule ()\n      ((number 3))\n      :ruleset myrules2)\n\n;; not allowed to add to combined ruleset\n(fail\n (rule ()\n    ((number 4))\n    :ruleset myrules1and2))\n\n\n(fail\n  (rule ()\n    ((number 4))\n    :ruleset unboundruleset))\n\n(ruleset myrules5)\n(rule ()\n      ((number 5))\n      :ruleset myrules5)\n\n(unstable-combined-ruleset rules1and2and5\n     rules1and2 myrules5)\n\n(run-schedule\n  rules1and2and5)\n\n(check (number 1))\n(check (number 2))\n(check (number 3))\n(check (number 5))\n(fail (check (number 4)))\n",
  "container-rebuild": "(push)\n(datatype Math\n  (Num i64))\n\n(sort MathVec (Vec Math))\n\n(let v1 (vec-of (Num 1) (Num 2)))\n(let v2 (vec-of (Num 2) (Num 2)))\n\n(union (Num 1) (Num 2))\n\n(check (= v1 v2))\n\n(function MyVec (MathVec) Math)\n\n(MyVec v1)\n\n(check (MyVec v2))\n\n(check (= (MyVec v1) (MyVec v2)))\n\n(let v3 (vec-of (Num 4) (Num 5)))\n\n(union (Num 4) (Num 6))\n(union (Num 5) (Num 7))\n\n;; We don't have any (MyVec v3) yet\n(fail (check (= (MyVec v3) (MyVec (vec-of (Num 6) (Num 7))))))\n\n(MyVec v3)\n(check (= (MyVec v3) (MyVec (vec-of (Num 6) (Num 7)))))\n\n(pop)\n\n(push)\n\n(datatype Math\n  (Num i64))\n\n(sort MathVec (Vec Math))\n\n\n(let v1 (vec-of (Num 1) (Num 2)))\n(let v2 (vec-of (Num 2) (Num 2)))\n\n(union (Num 1) (Num 2))\n\n(function MyVec (MathVec) Math)\n\n;; make a reference to v1\n(MyVec v1)\n\n(extract (MyVec v1))\n\n;; rebuilding creates (MyVec v2)\n(check (= (MyVec v1) (MyVec v2)))\n(pop)\n\n(push)\n(datatype Math\n  (Add i64 i64)\n  (Expensive :cost 100))\n\n(sort MathVec (Vec Math))\n\n(let myvec (vec-of (Expensive)))\n(let cheapvec (vec-of (Add 1 2)))\n\n(function VecContainer (MathVec) Math)\n\n(let myvecontainer (VecContainer cheapvec))\n\n\n(union myvecontainer (Expensive))\n\n;; (vec-push (vec-empty) (VecContainer (vec-push (vec-empty) (Add 1 2))))\n;; should have cost 4\n(extract myvec 0)\n\n(pop)",
  "cyk": "(datatype term (Term String))\n(datatype nonterm (NonTerm String))\n(datatype tree (NT String tree tree)\n                  (T String String))\n\n(function getString (i64) String)\n\n(relation Prod (nonterm nonterm nonterm))\n(relation End (nonterm String))\n\n\n\n(relation P (i64 i64 nonterm))\n(function B (i64 i64 nonterm) tree :cost 1000)\n\n(rule ((End (NonTerm a) s)\n       (= s (getString pos)))\n      ((P 1 pos (NonTerm a))\n       (union (B 1 pos (NonTerm a)) (T a s)))) \n\n(rule ((Prod (NonTerm a) (NonTerm b) (NonTerm c)) ;; a -> bc\n       (P p1 s (NonTerm b))\n       (P p2 (+ s p1) (NonTerm c)))\n      ((P (+ p1 p2) s (NonTerm a))))\n\n\n(rule ((Prod (NonTerm a) (NonTerm b) (NonTerm c))\n       (= f1 (B p1 s (NonTerm b)))\n       (= f2 (B p2 (+ s p1) (NonTerm c))))\n      ((union (B (+ p1 p2) s (NonTerm a)) \n       (NT a f1 f2))))\n\n(push)\n\n\n(set (getString 1) \"she\")\n(set (getString 2) \"eats\")\n(set (getString 3) \"a\")\n(set (getString 4) \"fish\")\n(set (getString 5) \"with\")\n(set (getString 6) \"a\")\n(set (getString 7) \"fork\")\n\n\n(Prod (NonTerm \"S\") (NonTerm \"NP\") (NonTerm \"VP\"))\n(Prod (NonTerm \"VP\") (NonTerm \"VP\") (NonTerm \"PP\"))\n(Prod (NonTerm \"VP\") (NonTerm \"V\") (NonTerm \"NP\"))\n(End (NonTerm \"VP\")  \"eats\")\n(Prod (NonTerm \"PP\") (NonTerm \"P\") (NonTerm \"NP\"))\n(Prod (NonTerm \"NP\") (NonTerm \"DET\") (NonTerm \"N\"))\n(End (NonTerm \"NP\") \"she\")\n(End (NonTerm \"V\") \"eats\")\n(End (NonTerm \"P\") \"with\")\n(End (NonTerm \"N\") \"fish\")\n(End (NonTerm \"N\") \"fork\")\n(End (NonTerm \"DET\") \"a\")\n\n\n(let test1 (B 7 1 (NonTerm \"S\")))\n\n(run 100)\n\n(check (P 7 1 (NonTerm \"S\")))\n(fail (check (P 7 1 (NonTerm \"VP\"))))\n(fail (check (P 7 1 (NonTerm \"\"))))\n\n(query-extract test1)\n\n(pop)\n\n(push)\n\n(Prod (NonTerm \"S\") (NonTerm \"A\") (NonTerm \"B\"))\n(Prod (NonTerm \"S\") (NonTerm \"B\") (NonTerm \"C\"))\n(Prod (NonTerm \"A\") (NonTerm \"B\") (NonTerm \"A\"))\n(End (NonTerm \"A\") \"a\")\n(Prod (NonTerm \"B\") (NonTerm \"C\") (NonTerm \"C\"))\n(End (NonTerm \"B\") \"b\")\n(Prod (NonTerm \"C\") (NonTerm \"A\") (NonTerm \"B\"))\n(End (NonTerm \"C\") \"a\")\n\n(push)\n\n(set (getString 1) \"a\")\n(set (getString 2) \"b\")\n(set (getString 3) \"a\")\n(set (getString 4) \"a\")\n(set (getString 5) \"b\")\n\n(run 100)\n(check (P 5 1 (NonTerm \"S\")))\n(fail (check (P 5 1 (NonTerm \"B\"))))\n(let test2 (B 5 1 (NonTerm \"S\")))\n(query-extract:variants 10  test2)\n\n(pop)\n\n(push)\n\n(set (getString 1) \"a\")\n(set (getString 2) \"a\")\n(set (getString 3) \"a\")\n(set (getString 4) \"a\")\n(set (getString 5) \"a\")\n\n(run 100)\n(check (P 5 1 (NonTerm \"S\")))\n(check (P 5 1 (NonTerm \"A\")))\n(fail (check (P 5 1 (NonTerm \"B\"))))\n(fail (check (P 5 1 (NonTerm \"\"))))\n(fail (check (P 5 1 (NonTerm \"unrelated\"))))\n(let test3 (B 5 1 (NonTerm \"S\")))\n(query-extract :variants 10 test3)\n\n(pop)",
  "cykjson": "(datatype tree (NT String tree tree)\n                  (T String String))\n\n(function getString (i64) String)\n\n(relation Prod (String String String))\n(relation End (String String))\n\n\n(relation P (i64 i64 String))\n(function B (i64 i64 String) tree :cost 100000)\n\n(rule ((End a s)\n       (= s (getString pos)))\n      ((P 1 pos a)\n       (union (B 1 pos a) (T a s)))) \n\n(rule ((Prod a b c) ;; a -> bc\n       (P p1 s b)\n       (P p2 (+ s p1) c))\n      ((P (+ p1 p2) s a)))\n\n\n(rule ((Prod a b c)\n       (= f1 (B p1 s b))\n       (= f2 (B p2 (+ s p1) c)))\n      ((union (B (+ p1 p2) s a) \n       (NT a f1 f2))))\n\n\n(input Prod \"./tests/cykjson_Prod.csv\")\n(input End \"./tests/cykjson_End.csv\")\n\n; small size 801\n(input getString \"./tests/cykjson_small_token.csv\")\n\n; medium size 7821 but runs for 2 min.\n;(input getString \"./tests/cykjson_medium_token.csv\")\n\n(let test1 (B 801 1 \"VAL\"))\n\n(run 10000)\n\n(check (P 801 1 \"VAL\"))",
  "delete": "(function foo (i64) i64)\n(set (foo 1) 7)\n(check (= (foo 1) 7))\n(delete (foo 1))\n(rule ((= x (foo 1))) ((panic \"foo 1 was there!\")))\n(run 1)",
  "eggcc-extraction": "\n(datatype Literal)\n(datatype Expr)\n(datatype Operand)\n(datatype Body)\n\n(sort VecOperandBase (Vec Operand))\n(datatype VecOperand (VO VecOperandBase))\n\n(sort VecVecOperandBase (Vec VecOperand))\n(datatype VecVecOperand (VVO VecVecOperandBase))\n\n;; Type\n(datatype Type\n    (IntT)\n    (BoolT)\n    (FloatT)\n    (CharT)\n    (PointerT Type))\n(datatype EffectType\n    (Bril Type)\n    (PrintState))\n(sort FuncSigs (Vec EffectType))\n(datatype OptionType\n    (SomeType Type)\n    (NoneType))\n;; Literal\n(function Num (i64) Literal)\n(function Float (f64) Literal)\n(function Char (String) Literal)\n(function Bool (bool) Literal)\n\n;; Expr\n(datatype ConstOps (const))\n(function Const (Type ConstOps Literal) Expr)\n;; Call may return multiple values but at most one of them\n;; is a value type, which is stored in OptionType.\n;; The last fields denotes how many return values it have\n;; Finally, we assume if call ever returns a value, \n;; it has to be the first one.\n(function Call (OptionType String VecOperand i64) Expr :cost 1000) ; TODO: fix cost model\n(function badd (Type Operand Operand) Expr)\n(function bsub (Type Operand Operand) Expr)\n(function bmul (Type Operand Operand) Expr)\n(function bfmul (Type Operand Operand) Expr)\n(function bdiv (Type Operand Operand) Expr)\n(function beq (Type Operand Operand) Expr)\n(function blt (Type Operand Operand) Expr)\n(function bgt (Type Operand Operand) Expr)\n(function ble (Type Operand Operand) Expr)\n(function bge (Type Operand Operand) Expr)\n(function bnot (Type Operand Operand) Expr)\n(function band (Type Operand Operand) Expr)\n(function bor (Type Operand Operand) Expr)\n(function PRINT (Operand Operand) Expr)\n\n;; Operand\n(function Arg (i64) Operand)\n(function Node (Body) Operand)\n(function Project (i64 Body) Operand)\n\n;; Body\n(function PureOp (Expr) Body)\n;; branching\n;; predicate (outside switch), inputs (outside switch),\n;; and for each branch a vector of outputs\n(function Gamma (Operand VecOperand VecVecOperand) Body)\n;; loops\n;; predicate (inside loop), inputs (outside loop), outputs (inside loop)\n(function Theta (Operand VecOperand VecOperand) Body)\n;; A body can also just be a VecOperand for convenience\n;; This has no corresponding node in rust, it can be\n;; removed during translation\n(function OperandGroup (VecOperand) Body)\n\n(datatype Function\n    ;;    name   input types    output types    body\n    (Func String FuncSigs       FuncSigs        VecOperand))\n\n\n;; procedure f(n):\n;;   i = 0\n;;   ans = 0\n;;   do:\n;;     ans += i*5;\n;;     i += 1\n;;   while(i < n);\n;;   return ansm\n\n;; ;; inputs: [n]\n; (Project 0\n;     (Theta\n;        ;     i       n\n;         (lt (Arg 1) (Arg 2)) ;; pred\n;         (vec-of ;; inputs\n;             (Node (PureOp (Const 0))) ;; accumulator\n;             (Node (PureOp (Const 0))) ;; loop var\n;             (Arg 0) ;; n\n;             )\n;         (vec-of ;; outputs\n;             (Node (PureOp (add (Arg 0) ;; ans\n;                 (Node (PureOp (mul \n;                     (Arg 1) ;; i\n;                     (Node (PureOp (Const 5))))))))) ;; ans = i*5\n;             (Node (PureOp (add (Arg 1) (Node (PureOp (Const 1)))))) ;; i += 1\n;             (Arg 2) ;; n\n;         ))\n; )\n\n\n\n(ruleset fast-analyses)\n\n          (function VecOperand-get (VecOperand i64) Operand)\n          (rule ((VO x) (> (vec-length x) 0))\n                ((union (VecOperand-get (VO x) 0) (vec-get x 0)))\n                :ruleset fast-analyses)\n          (rule ((VecOperand-get (VO x) j)\n                 (= i (+ j 1)) (< i (vec-length x)))\n                ((union (VecOperand-get (VO x) i) (vec-get x i)))\n                :ruleset fast-analyses)\n\n            (function VecOperand-length (VecOperand) i64)\n            (rule ((VO x))\n                  ((set (VecOperand-length (VO x)) (vec-length x)))\n                  :ruleset fast-analyses)\n        \n\n          (function VecVecOperand-get (VecVecOperand i64) VecOperand)\n          (rule ((VVO x) (> (vec-length x) 0))\n                ((union (VecVecOperand-get (VVO x) 0) (vec-get x 0)))\n                :ruleset fast-analyses)\n          (rule ((VecVecOperand-get (VVO x) j)\n                 (= i (+ j 1)) (< i (vec-length x)))\n                ((union (VecVecOperand-get (VVO x) i) (vec-get x i)))\n                :ruleset fast-analyses)\n\n            (function VecVecOperand-length (VecVecOperand) i64)\n            (rule ((VVO x))\n                  ((set (VecVecOperand-length (VVO x)) (vec-length x)))\n                  :ruleset fast-analyses)\n        \n\n        (relation Expr-is-pure (Expr))\n        (relation Operand-is-pure (Operand))\n        (relation Body-is-pure (Body))\n        (relation VecOperand-is-pure (VecOperand))\n        (function VecOperand-pure-prefix (VecOperand) i64 :merge (max old new))\n        (relation VecVecOperand-is-pure (VecVecOperand))\n        (function VecVecOperand-pure-prefix (VecVecOperand) i64 :merge (max old new))\n        (relation Function-is-pure (Function))\n    \n\n        (rule ((= f (Const ty ops lit)))\n              ((Expr-is-pure f))\n              :ruleset fast-analyses)\n\n        (rule ((= f (Call ty name args n-outs))\n               (Function-is-pure (Func name input-types output-types body)))\n              ((Expr-is-pure f))\n              :ruleset fast-analyses)\n    \n\n                (rule ((= f (badd type e1 e2))\n                       (Operand-is-pure e1)\n                       (Operand-is-pure e2))\n                      ((Expr-is-pure f))\n                      :ruleset fast-analyses)\n                \n\n                (rule ((= f (bsub type e1 e2))\n                       (Operand-is-pure e1)\n                       (Operand-is-pure e2))\n                      ((Expr-is-pure f))\n                      :ruleset fast-analyses)\n                \n\n                (rule ((= f (bmul type e1 e2))\n                       (Operand-is-pure e1)\n                       (Operand-is-pure e2))\n                      ((Expr-is-pure f))\n                      :ruleset fast-analyses)\n                \n\n                (rule ((= f (bdiv type e1 e2))\n                       (Operand-is-pure e1)\n                       (Operand-is-pure e2))\n                      ((Expr-is-pure f))\n                      :ruleset fast-analyses)\n                \n\n                (rule ((= f (blt type e1 e2))\n                       (Operand-is-pure e1)\n                       (Operand-is-pure e2))\n                      ((Expr-is-pure f))\n                      :ruleset fast-analyses)\n                \n\n        (rule ((= f (Arg x)))\n              ((Operand-is-pure f))\n              :ruleset fast-analyses)\n        (rule ((= f (Node body))\n               (Body-is-pure body))\n              ((Operand-is-pure f))\n              :ruleset fast-analyses)\n        (rule ((= f (Project i body))\n               (Body-is-pure body))\n              ((Operand-is-pure f))\n              :ruleset fast-analyses)\n    \n\n        (rule ((= f (PureOp e))\n               (Expr-is-pure e))\n              ((Body-is-pure f))\n              :ruleset fast-analyses)\n        (rule ((= f (Gamma pred inputs outputs))\n               (Operand-is-pure pred)\n               (VecOperand-is-pure inputs)\n               (VecVecOperand-is-pure outputs))\n              ((Body-is-pure f))\n              :ruleset fast-analyses)\n        (rule ((= f (Theta pred inputs outputs))\n               (Operand-is-pure pred)\n               (VecOperand-is-pure inputs)\n               (VecOperand-is-pure outputs))\n              ((Body-is-pure f))\n              :ruleset fast-analyses)\n        (rule ((= f (OperandGroup vec))\n               (VecOperand-is-pure vec))\n              ((Body-is-pure f))\n              :ruleset fast-analyses)\n    \n\n            (rule ((= f (VO vec)))\n                  ((set (VecOperand-pure-prefix f) 0))\n                  :ruleset fast-analyses)\n            (rule ((= i (VecOperand-pure-prefix f))\n                   (< i (VecOperand-length f))\n                   (Operand-is-pure (VecOperand-get f i)))\n                  ((set (VecOperand-pure-prefix f) (+ i 1)))\n                  :ruleset fast-analyses)\n            (rule ((= (VecOperand-length f) (VecOperand-pure-prefix f)))\n                  ((VecOperand-is-pure f))\n                  :ruleset fast-analyses)\n        \n\n            (rule ((= f (VVO vec)))\n                  ((set (VecVecOperand-pure-prefix f) 0))\n                  :ruleset fast-analyses)\n            (rule ((= i (VecVecOperand-pure-prefix f))\n                   (< i (VecVecOperand-length f))\n                   (VecOperand-is-pure (VecVecOperand-get f i)))\n                  ((set (VecVecOperand-pure-prefix f) (+ i 1)))\n                  :ruleset fast-analyses)\n            (rule ((= (VecVecOperand-length f) (VecVecOperand-pure-prefix f)))\n                  ((VecVecOperand-is-pure f))\n                  :ruleset fast-analyses)\n        \n\n        (rule ((= f (Func name input-types output-types body))\n               (VecOperand-is-pure body))\n              ((Function-is-pure f))\n              :ruleset fast-analyses)\n    \n\n        (relation Body-contains-Expr (Body i64 Expr))\n        (relation Body-contains-Operand (Body i64 Operand))\n        (relation Body-contains-Body (Body i64 Body))\n    \n\n        (rule ((= f (PureOp e)))\n              ((Body-contains-Expr f 0 e))\n              :ruleset fast-analyses)\n        ; A Gamma only contains its outputs\n        (rule ((= f (Gamma pred inputs outputs))\n               (= outputs-i (VecVecOperand-get outputs i))\n               (= x (VecOperand-get outputs-i j)))\n              ((Body-contains-Operand f i x))\n              :ruleset fast-analyses)\n        ; A Theta contains its pred and outputs\n        (rule ((= f (Theta pred inputs outputs)))\n              ((Body-contains-Operand f -1 pred))\n              :ruleset fast-analyses)\n        (rule ((= f (Theta pred inputs outputs))\n               (= x (VecOperand-get outputs i)))\n              ((Body-contains-Operand f i x))\n              :ruleset fast-analyses)\n        (rule ((= f (OperandGroup vec))\n               (= x (VecOperand-get vec i)))\n              ((Body-contains-Operand f i x))\n              :ruleset fast-analyses)\n    \n\n        (rule ((Body-contains-Body f i (PureOp e)))\n              ((Body-contains-Expr f i e))\n              :ruleset fast-analyses)\n        ; A Gamma's pred and inputs are in the outer context\n        (rule ((Body-contains-Body f i (Gamma pred inputs outputs)))\n              ((Body-contains-Operand f i pred))\n              :ruleset fast-analyses)\n        (rule ((Body-contains-Body f i (Gamma pred inputs outputs))\n               (= x (VecOperand-get inputs any)))\n              ((Body-contains-Operand f i x))\n              :ruleset fast-analyses)\n        ; A Theta's inputs are in the outer context\n        (rule ((Body-contains-Body f i (Theta pred inputs outputs))\n                (= x (VecOperand-get inputs any)))\n              ((Body-contains-Operand f i x))\n              :ruleset fast-analyses)\n        (rule ((Body-contains-Body f i (OperandGroup vec))\n               (= x (VecOperand-get vec any)))\n              ((Body-contains-Operand f i x))\n              :ruleset fast-analyses)\n    \n\n        (rule ((Body-contains-Expr f i (Call ty name args n-outs))\n               (= x (VecOperand-get args any)))\n              ((Body-contains-Operand f i x))\n              :ruleset fast-analyses)\n        (rule ((Body-contains-Expr f i (PRINT e1 e2)))\n              ((Body-contains-Operand f i e1)\n               (Body-contains-Operand f i e2))\n              :ruleset fast-analyses)\n    \n\n                (rule ((Body-contains-Expr f i (badd type e1 e2)))\n                      ((Body-contains-Operand f i e1)\n                       (Body-contains-Operand f i e2))\n                      :ruleset fast-analyses)\n                \n\n                (rule ((Body-contains-Expr f i (bsub type e1 e2)))\n                      ((Body-contains-Operand f i e1)\n                       (Body-contains-Operand f i e2))\n                      :ruleset fast-analyses)\n                \n\n                (rule ((Body-contains-Expr f i (bmul type e1 e2)))\n                      ((Body-contains-Operand f i e1)\n                       (Body-contains-Operand f i e2))\n                      :ruleset fast-analyses)\n                \n\n                (rule ((Body-contains-Expr f i (bdiv type e1 e2)))\n                      ((Body-contains-Operand f i e1)\n                       (Body-contains-Operand f i e2))\n                      :ruleset fast-analyses)\n                \n\n                (rule ((Body-contains-Expr f i (blt type e1 e2)))\n                      ((Body-contains-Operand f i e1)\n                       (Body-contains-Operand f i e2))\n                      :ruleset fast-analyses)\n                \n\n        (rule ((Body-contains-Operand f i (Node body)))\n              ((Body-contains-Body f i body))\n              :ruleset fast-analyses)\n        (rule ((Body-contains-Operand f i (Project i body)))\n              ((Body-contains-Body f i body))\n              :ruleset fast-analyses)\n    \n(ruleset subst) (ruleset shift)\n\n        (relation can-subst-Expr-beneath (Body Expr Expr))\n        (relation can-subst-Operand-beneath (Body Operand Operand))\n        (relation can-subst-Body-beneath (Body Body Body))\n        (relation can-subst-VecVecOperand-beneath (Body VecVecOperand VecVecOperand))\n        (relation can-subst-VecOperand-beneath (Body VecOperand VecOperand))\n\n        ;; Base case 'do the substitution' rules\n        (rule ((can-subst-Operand-beneath above from to)\n               (= above     (Theta from inputs outputs)))\n              ((union above (Theta to   inputs outputs)))\n              :ruleset subst)\n        (rule ((can-subst-VecOperand-beneath above from to)\n               (= above     (Theta pred inputs from)))\n              ((union above (Theta pred inputs to)))\n              :ruleset subst)\n        (rule ((can-subst-Operand-beneath above pred-from pred-to)\n               (can-subst-VecOperand-beneath above outputs-from outputs-to)\n               (= above     (Theta pred-from inputs outputs-from)))\n              ((union above (Theta pred-from inputs outputs-to)))\n              :ruleset subst)\n        (rule ((can-subst-VecVecOperand-beneath above from to)\n               (= above     (Gamma pred inputs from)))\n              ((union above (Gamma pred inputs to)))\n              :ruleset subst)\n        (rule ((can-subst-VecOperand-beneath above from to)\n               (= above     (OperandGroup from)))\n              ((union above (OperandGroup to)))\n              :ruleset subst)\n\n        ;; Learn can-subst-Operand-beneath\n        (rule ((can-subst-Body-beneath above from to)\n               (= new-from (Node from)))\n              ((can-subst-Operand-beneath above new-from (Node to)))\n              :ruleset subst)\n        (rule ((can-subst-Body-beneath above from to)\n               (= new-from (Project i from)))\n              ((can-subst-Operand-beneath above new-from (Project i to)))\n              :ruleset subst)\n\n        ;; Learn can-subst-body-beneath\n        (rule ((can-subst-Expr-beneath above from to)\n               (= new-from (PureOp from)))\n              ((can-subst-Body-beneath above new-from (PureOp to)))\n              :ruleset subst)\n        ;; Propagates up same context (Gamma: pred & inputs, Theta: inputs)\n        ;; rtjoa: Is it sound to propagate up outputs if we renumber args?\n        (rule ((can-subst-Operand-beneath above from to)\n               (= new-from (Gamma from inputs outputs)))\n              ((can-subst-Body-beneath above new-from (Gamma to inputs outputs)))\n              :ruleset subst)\n        (rule ((can-subst-VecOperand-beneath above from to)\n               (= new-from (Gamma pred from outputs)))\n              ((can-subst-Body-beneath above new-from (Gamma pred to outputs)))\n              :ruleset subst)\n        (rule ((can-subst-VecOperand-beneath above from to)\n               (= new-from (Theta pred from outputs)))\n              ((can-subst-Body-beneath above new-from (Theta pred to outputs)))\n              :ruleset subst)\n        (rule ((can-subst-VecOperand-beneath above from to)\n               (= new-from (OperandGroup from)))\n              ((can-subst-Body-beneath above new-from (OperandGroup to)))\n              :ruleset subst)\n        \n\n      (rule ((can-subst-VecOperand-beneath above from to)\n              (= new-from (Call ty f from n-outs)))\n             ((can-subst-Expr-beneath above new-from (Call ty f to n-outs)))\n            :ruleset subst)\n\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (badd type from e2)))\n                     ((can-subst-Expr-beneath above new-from (badd type to e2)))\n                    :ruleset subst)\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (badd type e1 from)))\n                     ((can-subst-Expr-beneath above new-from (badd type e1 to)))\n                    :ruleset subst)\n                     \n\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (bsub type from e2)))\n                     ((can-subst-Expr-beneath above new-from (bsub type to e2)))\n                    :ruleset subst)\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (bsub type e1 from)))\n                     ((can-subst-Expr-beneath above new-from (bsub type e1 to)))\n                    :ruleset subst)\n                     \n\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (bmul type from e2)))\n                     ((can-subst-Expr-beneath above new-from (bmul type to e2)))\n                    :ruleset subst)\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (bmul type e1 from)))\n                     ((can-subst-Expr-beneath above new-from (bmul type e1 to)))\n                    :ruleset subst)\n                     \n\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (bdiv type from e2)))\n                     ((can-subst-Expr-beneath above new-from (bdiv type to e2)))\n                    :ruleset subst)\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (bdiv type e1 from)))\n                     ((can-subst-Expr-beneath above new-from (bdiv type e1 to)))\n                    :ruleset subst)\n                     \n\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (blt type from e2)))\n                     ((can-subst-Expr-beneath above new-from (blt type to e2)))\n                    :ruleset subst)\n              (rule ((can-subst-Operand-beneath above from to)\n                      (= new-from (blt type e1 from)))\n                     ((can-subst-Expr-beneath above new-from (blt type e1 to)))\n                    :ruleset subst)\n                     \n\n          (rule ((can-subst-Operand-beneath above from to)\n                 (= from (VecOperand-get (VO vec) i)))\n                ((can-subst-VecOperand-beneath\n                    above\n                    (VO vec)\n                    (VO (vec-set vec i to))))\n                :ruleset subst)\n\n          (rule ((can-subst-VecOperand-beneath above from to)\n                 (= from (VecVecOperand-get (VVO vec) i)))\n                ((can-subst-VecVecOperand-beneath\n                    above\n                    (VVO vec)\n                    (VVO (vec-set vec i to))))\n                :ruleset subst)\n(function SubstExpr (Expr i64 Operand) Expr :unextractable)\n(function SubstOperand (Operand i64 Operand) Operand :unextractable)\n(function SubstBody (Body i64 Operand) Body :unextractable)\n(function SubstVecOperand (VecOperand i64 Operand) VecOperand :unextractable)\n(function SubstVecVecOperand (VecVecOperand i64 Operand) VecVecOperand :unextractable)\n\n                (rewrite\n                    (SubstExpr (badd ty a b) x0 x1)\n                    (badd\n                        ty\n                        (SubstOperand a x0 x1)\n                        (SubstOperand b x0 x1))\n                    :ruleset subst)\n                     \n\n                (rewrite\n                    (SubstExpr (bsub ty a b) x0 x1)\n                    (bsub\n                        ty\n                        (SubstOperand a x0 x1)\n                        (SubstOperand b x0 x1))\n                    :ruleset subst)\n                     \n\n                (rewrite\n                    (SubstExpr (bmul ty a b) x0 x1)\n                    (bmul\n                        ty\n                        (SubstOperand a x0 x1)\n                        (SubstOperand b x0 x1))\n                    :ruleset subst)\n                     \n\n                (rewrite\n                    (SubstExpr (bdiv ty a b) x0 x1)\n                    (bdiv\n                        ty\n                        (SubstOperand a x0 x1)\n                        (SubstOperand b x0 x1))\n                    :ruleset subst)\n                     \n\n                (rewrite\n                    (SubstExpr (blt ty a b) x0 x1)\n                    (blt\n                        ty\n                        (SubstOperand a x0 x1)\n                        (SubstOperand b x0 x1))\n                    :ruleset subst)\n                     \n\n        (rewrite\n            (SubstExpr (Const ty ops lit) x0 x1)\n            (Const ty ops lit)\n            :ruleset subst)\n        (rewrite\n            (SubstExpr (Call ty f args n-outs) x0 x1)\n            (Call ty f (SubstVecOperand args x0 x1) n-outs)\n            :ruleset subst)\n        (rewrite\n            (SubstExpr (PRINT a b) x0 x1)\n            (PRINT (SubstOperand a x0 x1) (SubstOperand b x0 x1))\n            :ruleset subst)\n\n        (rewrite (SubstOperand (Arg x) x v) v :ruleset subst)\n        (rule ((= f (SubstOperand (Arg y) x v)) (!= y x))\n              ((union f (Arg y))) :ruleset subst)\n\n        (rewrite\n            (SubstOperand (Node b) x0 x1)\n            (Node (SubstBody b x0 x1))\n            :ruleset subst)\n        (rewrite\n            (SubstOperand (Project i b) x0 x1)\n            (Project i (SubstBody b x0 x1))\n            :ruleset subst)\n\n        (rewrite\n            (SubstBody (PureOp e) x0 x1)\n            (PureOp (SubstExpr e x0 x1))\n            :ruleset subst)\n        ;; Don't cross regions, so so we shift into the inputs but not outputs\n        ;; A Gamma's pred is on the outside, so it's affected, but not a Theta's\n        (rewrite\n            (SubstBody (Gamma pred inputs outputs) x0 x1)\n            (Gamma\n                (SubstOperand pred x0 x1)\n                (SubstVecOperand inputs x0 x1)\n                outputs)\n            :ruleset subst)\n        (rewrite\n            (SubstBody (Theta pred inputs outputs) x0 x1)\n            (Theta pred (SubstVecOperand inputs x0 x1) outputs)\n            :ruleset subst)\n\n            (function SubstVecOperand-helper (VecOperand i64 Operand i64) VecOperand)\n            (rewrite\n                (SubstVecOperand vec x0 x1)\n                (SubstVecOperand-helper vec x0 x1 0)\n                :ruleset subst)\n            (rule\n                ((= f (SubstVecOperand-helper (VO vec) x0 x1 i))\n                 (< i (vec-length vec)))\n                ((union\n                    (SubstVecOperand-helper (VO vec) x0 x1 i)\n                    (SubstVecOperand-helper\n                        (VO (vec-set vec i (SubstOperand (vec-get vec i) x0 x1)))\n                        x0 x1 (+ i 1))))\n                :ruleset subst)\n            (rule\n                ((= f (SubstVecOperand-helper (VO vec) x0 x1 i))\n                 (= i (vec-length vec)))\n                ((union\n                    (SubstVecOperand-helper (VO vec) x0 x1 i)\n                    (VO vec)))\n                :ruleset subst)\n\n            (function SubstVecVecOperand-helper (VecVecOperand i64 Operand i64) VecVecOperand)\n            (rewrite\n                (SubstVecVecOperand vec x0 x1)\n                (SubstVecVecOperand-helper vec x0 x1 0)\n                :ruleset subst)\n            (rule\n                ((= f (SubstVecVecOperand-helper (VVO vec) x0 x1 i))\n                 (< i (vec-length vec)))\n                ((union\n                    (SubstVecVecOperand-helper (VVO vec) x0 x1 i)\n                    (SubstVecVecOperand-helper\n                        (VVO (vec-set vec i (SubstVecOperand (vec-get vec i) x0 x1)))\n                        x0 x1 (+ i 1))))\n                :ruleset subst)\n            (rule\n                ((= f (SubstVecVecOperand-helper (VVO vec) x0 x1 i))\n                 (= i (vec-length vec)))\n                ((union\n                    (SubstVecVecOperand-helper (VVO vec) x0 x1 i)\n                    (VVO vec)))\n                :ruleset subst)\n(function SubstExprAll (Expr VecOperand) Expr :unextractable)\n(function SubstOperandAll (Operand VecOperand) Operand :unextractable)\n(function SubstBodyAll (Body VecOperand) Body :unextractable)\n(function SubstVecOperandAll (VecOperand VecOperand) VecOperand :unextractable)\n(function SubstVecVecOperandAll (VecVecOperand VecOperand) VecVecOperand :unextractable)\n\n                (rewrite\n                    (SubstExprAll (badd ty a b) x0)\n                    (badd\n                        ty\n                        (SubstOperandAll a x0)\n                        (SubstOperandAll b x0))\n                    :ruleset subst)\n                     \n\n                (rewrite\n                    (SubstExprAll (bsub ty a b) x0)\n                    (bsub\n                        ty\n                        (SubstOperandAll a x0)\n                        (SubstOperandAll b x0))\n                    :ruleset subst)\n                     \n\n                (rewrite\n                    (SubstExprAll (bmul ty a b) x0)\n                    (bmul\n                        ty\n                        (SubstOperandAll a x0)\n                        (SubstOperandAll b x0))\n                    :ruleset subst)\n                     \n\n                (rewrite\n                    (SubstExprAll (bdiv ty a b) x0)\n                    (bdiv\n                        ty\n                        (SubstOperandAll a x0)\n                        (SubstOperandAll b x0))\n                    :ruleset subst)\n                     \n\n                (rewrite\n                    (SubstExprAll (blt ty a b) x0)\n                    (blt\n                        ty\n                        (SubstOperandAll a x0)\n                        (SubstOperandAll b x0))\n                    :ruleset subst)\n                     \n\n        (rewrite\n            (SubstExprAll (Const ty ops lit) x0)\n            (Const ty ops lit)\n            :ruleset subst)\n        (rewrite\n            (SubstExprAll (Call ty f args n-outs) x0)\n            (Call ty f (SubstVecOperandAll args x0) n-outs)\n            :ruleset subst)\n        (rewrite\n            (SubstExprAll (PRINT a b) x0)\n            (PRINT (SubstOperandAll a x0) (SubstOperandAll b x0))\n            :ruleset subst)\n\n        (rule ((= f (SubstOperandAll (Arg x) (VO ops)))\n               (< x (vec-length ops)))\n              ((union f (vec-get ops x))) :ruleset subst)\n\n        (rewrite\n            (SubstOperandAll (Node b) x0)\n            (Node (SubstBodyAll b x0))\n            :ruleset subst)\n        (rewrite\n            (SubstOperandAll (Project i b) x0)\n            (Project i (SubstBodyAll b x0))\n            :ruleset subst)\n\n        (rewrite\n            (SubstBodyAll (PureOp e) x0)\n            (PureOp (SubstExprAll e x0))\n            :ruleset subst)\n        ;; Don't cross regions, so so we shift into the inputs but not outputs\n        ;; A Gamma's pred is on the outside, so it's affected, but not a Theta's\n        (rewrite\n            (SubstBodyAll (Gamma pred inputs outputs) x0)\n            (Gamma\n                (SubstOperandAll pred x0)\n                (SubstVecOperandAll inputs x0)\n                outputs)\n            :ruleset subst)\n        (rewrite\n            (SubstBodyAll (Theta pred inputs outputs) x0)\n            (Theta pred (SubstVecOperandAll inputs x0) outputs)\n            :ruleset subst)\n\n            (function SubstVecOperandAll-helper (VecOperand VecOperand i64) VecOperand)\n            (rewrite\n                (SubstVecOperandAll vec x0)\n                (SubstVecOperandAll-helper vec x0 0)\n                :ruleset subst)\n            (rule\n                ((= f (SubstVecOperandAll-helper (VO vec) x0 i))\n                 (< i (vec-length vec)))\n                ((union\n                    (SubstVecOperandAll-helper (VO vec) x0 i)\n                    (SubstVecOperandAll-helper\n                        (VO (vec-set vec i (SubstOperandAll (vec-get vec i) x0)))\n                        x0 (+ i 1))))\n                :ruleset subst)\n            (rule\n                ((= f (SubstVecOperandAll-helper (VO vec) x0 i))\n                 (= i (vec-length vec)))\n                ((union\n                    (SubstVecOperandAll-helper (VO vec) x0 i)\n                    (VO vec)))\n                :ruleset subst)\n\n            (function SubstVecVecOperandAll-helper (VecVecOperand VecOperand i64) VecVecOperand)\n            (rewrite\n                (SubstVecVecOperandAll vec x0)\n                (SubstVecVecOperandAll-helper vec x0 0)\n                :ruleset subst)\n            (rule\n                ((= f (SubstVecVecOperandAll-helper (VVO vec) x0 i))\n                 (< i (vec-length vec)))\n                ((union\n                    (SubstVecVecOperandAll-helper (VVO vec) x0 i)\n                    (SubstVecVecOperandAll-helper\n                        (VVO (vec-set vec i (SubstVecOperandAll (vec-get vec i) x0)))\n                        x0 (+ i 1))))\n                :ruleset subst)\n            (rule\n                ((= f (SubstVecVecOperandAll-helper (VVO vec) x0 i))\n                 (= i (vec-length vec)))\n                ((union\n                    (SubstVecVecOperandAll-helper (VVO vec) x0 i)\n                    (VVO vec)))\n                :ruleset subst)\n(function ShiftExpr (Expr i64 i64) Expr :unextractable)\n(function ShiftOperand (Operand i64 i64) Operand :unextractable)\n(function ShiftBody (Body i64 i64) Body :unextractable)\n(function ShiftVecOperand (VecOperand i64 i64) VecOperand :unextractable)\n(function ShiftVecVecOperand (VecVecOperand i64 i64) VecVecOperand :unextractable)\n\n                (rewrite\n                    (ShiftExpr (badd ty a b) x0 x1)\n                    (badd\n                        ty\n                        (ShiftOperand a x0 x1)\n                        (ShiftOperand b x0 x1))\n                    :ruleset shift)\n                     \n\n                (rewrite\n                    (ShiftExpr (bsub ty a b) x0 x1)\n                    (bsub\n                        ty\n                        (ShiftOperand a x0 x1)\n                        (ShiftOperand b x0 x1))\n                    :ruleset shift)\n                     \n\n                (rewrite\n                    (ShiftExpr (bmul ty a b) x0 x1)\n                    (bmul\n                        ty\n                        (ShiftOperand a x0 x1)\n                        (ShiftOperand b x0 x1))\n                    :ruleset shift)\n                     \n\n                (rewrite\n                    (ShiftExpr (bdiv ty a b) x0 x1)\n                    (bdiv\n                        ty\n                        (ShiftOperand a x0 x1)\n                        (ShiftOperand b x0 x1))\n                    :ruleset shift)\n                     \n\n                (rewrite\n                    (ShiftExpr (blt ty a b) x0 x1)\n                    (blt\n                        ty\n                        (ShiftOperand a x0 x1)\n                        (ShiftOperand b x0 x1))\n                    :ruleset shift)\n                     \n\n        (rewrite\n            (ShiftExpr (Const ty ops lit) x0 x1)\n            (Const ty ops lit)\n            :ruleset shift)\n        (rewrite\n            (ShiftExpr (Call ty f args n-outs) x0 x1)\n            (Call ty f (ShiftVecOperand args x0 x1) n-outs)\n            :ruleset shift)\n        (rewrite\n            (ShiftExpr (PRINT a b) x0 x1)\n            (PRINT (ShiftOperand a x0 x1) (ShiftOperand b x0 x1))\n            :ruleset shift)\n\n        (rule ((= f (ShiftOperand (Arg x) last-unshifted amt)) (<= x last-unshifted))\n              ((union f (Arg x))) :ruleset shift)\n        (rule ((= f (ShiftOperand (Arg x) last-unshifted amt)) (> x last-unshifted))\n              ((union f (Arg (+ x amt)))) :ruleset shift)\n\n        (rewrite\n            (ShiftOperand (Node b) x0 x1)\n            (Node (ShiftBody b x0 x1))\n            :ruleset shift)\n        (rewrite\n            (ShiftOperand (Project i b) x0 x1)\n            (Project i (ShiftBody b x0 x1))\n            :ruleset shift)\n\n        (rewrite\n            (ShiftBody (PureOp e) x0 x1)\n            (PureOp (ShiftExpr e x0 x1))\n            :ruleset shift)\n        ;; Don't cross regions, so so we shift into the inputs but not outputs\n        ;; A Gamma's pred is on the outside, so it's affected, but not a Theta's\n        (rewrite\n            (ShiftBody (Gamma pred inputs outputs) x0 x1)\n            (Gamma\n                (ShiftOperand pred x0 x1)\n                (ShiftVecOperand inputs x0 x1)\n                outputs)\n            :ruleset shift)\n        (rewrite\n            (ShiftBody (Theta pred inputs outputs) x0 x1)\n            (Theta pred (ShiftVecOperand inputs x0 x1) outputs)\n            :ruleset shift)\n\n            (function ShiftVecOperand-helper (VecOperand i64 i64 i64) VecOperand)\n            (rewrite\n                (ShiftVecOperand vec x0 x1)\n                (ShiftVecOperand-helper vec x0 x1 0)\n                :ruleset shift)\n            (rule\n                ((= f (ShiftVecOperand-helper (VO vec) x0 x1 i))\n                 (< i (vec-length vec)))\n                ((union\n                    (ShiftVecOperand-helper (VO vec) x0 x1 i)\n                    (ShiftVecOperand-helper\n                        (VO (vec-set vec i (ShiftOperand (vec-get vec i) x0 x1)))\n                        x0 x1 (+ i 1))))\n                :ruleset shift)\n            (rule\n                ((= f (ShiftVecOperand-helper (VO vec) x0 x1 i))\n                 (= i (vec-length vec)))\n                ((union\n                    (ShiftVecOperand-helper (VO vec) x0 x1 i)\n                    (VO vec)))\n                :ruleset shift)\n\n            (function ShiftVecVecOperand-helper (VecVecOperand i64 i64 i64) VecVecOperand)\n            (rewrite\n                (ShiftVecVecOperand vec x0 x1)\n                (ShiftVecVecOperand-helper vec x0 x1 0)\n                :ruleset shift)\n            (rule\n                ((= f (ShiftVecVecOperand-helper (VVO vec) x0 x1 i))\n                 (< i (vec-length vec)))\n                ((union\n                    (ShiftVecVecOperand-helper (VVO vec) x0 x1 i)\n                    (ShiftVecVecOperand-helper\n                        (VVO (vec-set vec i (ShiftVecOperand (vec-get vec i) x0 x1)))\n                        x0 x1 (+ i 1))))\n                :ruleset shift)\n            (rule\n                ((= f (ShiftVecVecOperand-helper (VVO vec) x0 x1 i))\n                 (= i (vec-length vec)))\n                ((union\n                    (ShiftVecVecOperand-helper (VVO vec) x0 x1 i)\n                    (VVO vec)))\n                :ruleset shift)\n;; ####################################\n;; implementation of PassThroughArguments\n;; Creates a vec of arguments\n;; (vec-of (Arg 0) (Arg 1) ...) with length i\n(function PassThroughArguments (i64) VecOperand :unextractable)\n\n\n\n;; (how many arguments to generate, vector so far)\n(function PassThroughArgumentsHelper (i64 VecOperand) VecOperand :unextractable)\n\n(rewrite (PassThroughArguments i)\n  (PassThroughArgumentsHelper i (VO (vec-of)))\n  :ruleset subst)\n\n(rule ((= lhs (PassThroughArgumentsHelper i (VO rest)))\n       (< (vec-length rest) i))\n      ((union lhs\n        (PassThroughArgumentsHelper i\n            (VO (vec-push rest (Arg (vec-length rest)))))))\n      :ruleset subst)\n\n(rule ((= lhs (PassThroughArgumentsHelper i (VO rest)))\n       (= (vec-length rest) i))\n      ((union lhs (VO rest)))\n      :ruleset subst)\n\n\n\n;; Project each argument out of a body\n(function BodyToVecOperand (i64 Body) VecOperand :unextractable)\n;; current index, body length, body, and vector so far\n(function BodyToVecOperandHelper (i64 i64 Body VecOperandBase) VecOperand :unextractable)\n\n(rewrite (BodyToVecOperand body-len body)\n         (BodyToVecOperandHelper 0 body-len body (vec-of)))\n(rule\n  ((= helper (BodyToVecOperandHelper index body-len body so-far))\n   (< index body-len))\n  ((union helper\n          (BodyToVecOperandHelper (+ index 1) body-len body\n                                  (vec-push so-far \n                                   (Project index body)))))\n  :ruleset subst)\n\n(rule\n  ((= helper (BodyToVecOperandHelper index body-len body so-far))\n   (= index body-len))\n  ((union helper (VO so-far)))\n  :ruleset subst)\n\n\n\n;; constant_fold.rs adds most constant folding operations\n;; this file is for special cases\n\n\n;; eliminate gamma nodes for true and false cases\n(rule ((= gamma\n          ;; gamma predicate is true\n          (Gamma (Node (PureOp (Const (BoolT) (const) (Bool true))))\n                 inputs\n                 (VVO outputs))))\n      (\n        ;; replace use of the gamma with\n        ;; the true case\n        (union\n          gamma\n          (OperandGroup\n              (SubstVecOperandAll\n                (vec-get outputs 1)\n                inputs)))))\n\n\n\n(rule ((= gamma\n          ;; gamma predicate is false\n          (Gamma (Node (PureOp (Const (BoolT) (const) (Bool false))))\n                 inputs\n                 (VVO outputs))))\n      (\n        ;; replace use of the gamma with\n        ;; the false case\n        (union\n          gamma\n          (OperandGroup\n              (SubstVecOperandAll (vec-get outputs 0) inputs)))))\n\n;; Eliminate theta\n;; Unroll one layer and get rid of loop\n(rule ((= theta\n          ;; gamma predicate is false\n          (Theta (Node (PureOp (Const (BoolT) (const) (Bool false))))\n                 (VO inputs)\n                 (VO outputs))))\n      ((let after-one-iter (SubstVecOperandAll (VO outputs) (VO inputs)))\n       (union theta\n          (OperandGroup after-one-iter))))\n\n\n\n\n\n(rewrite (badd output_type\n                    (Node (PureOp (Const ty2 (const) (Num n1))))\n                    (Node (PureOp (Const ty3 (const) (Num n2)))))\n                  (Const output_type (const) (Num (+ n1 n2))))\n(rewrite (bsub output_type\n                    (Node (PureOp (Const ty2 (const) (Num n1))))\n                    (Node (PureOp (Const ty3 (const) (Num n2)))))\n                  (Const output_type (const) (Num (- n1 n2))))\n(rewrite (bmul output_type\n                    (Node (PureOp (Const ty2 (const) (Num n1))))\n                    (Node (PureOp (Const ty3 (const) (Num n2)))))\n                  (Const output_type (const) (Num (* n1 n2))))\n(rewrite (bdiv output_type\n                    (Node (PureOp (Const ty2 (const) (Num n1))))\n                    (Node (PureOp (Const ty3 (const) (Num n2)))))\n                  (Const output_type (const) (Num (/ n1 n2))))\n(rewrite (blt output_type\n                  (Node (PureOp (Const ty2 (const) (Num n1))))\n                  (Node (PureOp (Const ty3 (const) (Num n2)))))\n                (Const output_type (const) (Bool (bool-< n1 n2))))\n(sort TermAndCost)\n(function Smaller (TermAndCost TermAndCost) TermAndCost)\n\n;; manual, bottom-up extraction of terms using this function\n(function ExtractedExpr (Expr) TermAndCost\n            :merge (Smaller old new))\n;; Store a term and its cost for this type\n(function ExprAndCost (Expr i64) TermAndCost)\n\n;; Perform smaller using the next two rules\n(rule ((= lhs (Smaller (ExprAndCost t1 cost1)\n                       (ExprAndCost t2 cost2)))\n       (<= cost1 cost2))\n      ((union lhs (ExprAndCost t1 cost1)))\n       :ruleset fast-analyses)\n  \n(rule ((= lhs (Smaller (ExprAndCost t1 cost1)\n                       (ExprAndCost t2 cost2)))\n       (> cost1 cost2))\n      ((union lhs (ExprAndCost t2 cost2)))\n       :ruleset fast-analyses)\n\n\n;; manual, bottom-up extraction of terms using this function\n(function ExtractedOperand (Operand) TermAndCost\n            :merge (Smaller old new))\n;; Store a term and its cost for this type\n(function OperandAndCost (Operand i64) TermAndCost)\n\n;; Perform smaller using the next two rules\n(rule ((= lhs (Smaller (OperandAndCost t1 cost1)\n                       (OperandAndCost t2 cost2)))\n       (<= cost1 cost2))\n      ((union lhs (OperandAndCost t1 cost1)))\n       :ruleset fast-analyses)\n  \n(rule ((= lhs (Smaller (OperandAndCost t1 cost1)\n                       (OperandAndCost t2 cost2)))\n       (> cost1 cost2))\n      ((union lhs (OperandAndCost t2 cost2)))\n       :ruleset fast-analyses)\n\n\n;; manual, bottom-up extraction of terms using this function\n(function ExtractedBody (Body) TermAndCost\n            :merge (Smaller old new))\n;; Store a term and its cost for this type\n(function BodyAndCost (Body i64) TermAndCost)\n\n;; Perform smaller using the next two rules\n(rule ((= lhs (Smaller (BodyAndCost t1 cost1)\n                       (BodyAndCost t2 cost2)))\n       (<= cost1 cost2))\n      ((union lhs (BodyAndCost t1 cost1)))\n       :ruleset fast-analyses)\n  \n(rule ((= lhs (Smaller (BodyAndCost t1 cost1)\n                       (BodyAndCost t2 cost2)))\n       (> cost1 cost2))\n      ((union lhs (BodyAndCost t2 cost2)))\n       :ruleset fast-analyses)\n\n\n;; manual, bottom-up extraction of terms using this function\n(function ExtractedVecOperand (VecOperand) TermAndCost\n            :merge (Smaller old new))\n;; Store a term and its cost for this type\n(function VecOperandAndCost (VecOperand i64) TermAndCost)\n\n;; Perform smaller using the next two rules\n(rule ((= lhs (Smaller (VecOperandAndCost t1 cost1)\n                       (VecOperandAndCost t2 cost2)))\n       (<= cost1 cost2))\n      ((union lhs (VecOperandAndCost t1 cost1)))\n       :ruleset fast-analyses)\n  \n(rule ((= lhs (Smaller (VecOperandAndCost t1 cost1)\n                       (VecOperandAndCost t2 cost2)))\n       (> cost1 cost2))\n      ((union lhs (VecOperandAndCost t2 cost2)))\n       :ruleset fast-analyses)\n\n\n;; manual, bottom-up extraction of terms using this function\n(function ExtractedVecVecOperand (VecVecOperand) TermAndCost\n            :merge (Smaller old new))\n;; Store a term and its cost for this type\n(function VecVecOperandAndCost (VecVecOperand i64) TermAndCost)\n\n;; Perform smaller using the next two rules\n(rule ((= lhs (Smaller (VecVecOperandAndCost t1 cost1)\n                       (VecVecOperandAndCost t2 cost2)))\n       (<= cost1 cost2))\n      ((union lhs (VecVecOperandAndCost t1 cost1)))\n       :ruleset fast-analyses)\n  \n(rule ((= lhs (Smaller (VecVecOperandAndCost t1 cost1)\n                       (VecVecOperandAndCost t2 cost2)))\n       (> cost1 cost2))\n      ((union lhs (VecVecOperandAndCost t2 cost2)))\n       :ruleset fast-analyses)\n\n\n(rule ((= lhs (badd ty a b))\n       (= (OperandAndCost expr1 cost1) (ExtractedOperand a))\n       (= (OperandAndCost expr2 cost2) (ExtractedOperand b)))\n      ((set (ExtractedExpr lhs)\n            (ExprAndCost (badd ty expr1 expr2)\n                         (+ 1 (+ cost1 cost2)))))\n        :ruleset fast-analyses)\n\n\n(rule ((= lhs (bsub ty a b))\n       (= (OperandAndCost expr1 cost1) (ExtractedOperand a))\n       (= (OperandAndCost expr2 cost2) (ExtractedOperand b)))\n      ((set (ExtractedExpr lhs)\n            (ExprAndCost (bsub ty expr1 expr2)\n                         (+ 1 (+ cost1 cost2)))))\n        :ruleset fast-analyses)\n\n\n(rule ((= lhs (bmul ty a b))\n       (= (OperandAndCost expr1 cost1) (ExtractedOperand a))\n       (= (OperandAndCost expr2 cost2) (ExtractedOperand b)))\n      ((set (ExtractedExpr lhs)\n            (ExprAndCost (bmul ty expr1 expr2)\n                         (+ 1 (+ cost1 cost2)))))\n        :ruleset fast-analyses)\n\n\n(rule ((= lhs (bdiv ty a b))\n       (= (OperandAndCost expr1 cost1) (ExtractedOperand a))\n       (= (OperandAndCost expr2 cost2) (ExtractedOperand b)))\n      ((set (ExtractedExpr lhs)\n            (ExprAndCost (bdiv ty expr1 expr2)\n                         (+ 1 (+ cost1 cost2)))))\n        :ruleset fast-analyses)\n\n\n(rule ((= lhs (blt ty a b))\n       (= (OperandAndCost expr1 cost1) (ExtractedOperand a))\n       (= (OperandAndCost expr2 cost2) (ExtractedOperand b)))\n      ((set (ExtractedExpr lhs)\n            (ExprAndCost (blt ty expr1 expr2)\n                         (+ 1 (+ cost1 cost2)))))\n        :ruleset fast-analyses)\n\n\n(rule ((= lhs (PRINT a b))\n        (= (OperandAndCost expr1 cost1) (ExtractedOperand a))\n        (= (OperandAndCost expr2 cost2) (ExtractedOperand b)))\n      ((set (ExtractedExpr lhs)\n            (ExprAndCost (PRINT expr1 expr2)\n                         (+ 1 (+ cost1 cost2)))))\n      :ruleset fast-analyses)\n\n;; TODO fix this HACK\n;; this is how we get an empty vector of vectors in egglog because of\n;; typechecking bug in egglog https://github.com/egraphs-good/egglog/issues/113\n(let empty-vvo \n  (vec-pop (vec-of (VO (vec-of)))))\n\n\n(function ExtractedVecOperandHelper (VecOperand i64) TermAndCost :merge (Smaller old new))\n\n;; base case: extract nothing\n(rule\n   ((VO vec))\n   ((set (ExtractedVecOperandHelper (VO vec) 0)\n         (VecOperandAndCost (VO (vec-of)) 0)))\n    :ruleset fast-analyses)\n\n;; extract one more thing\n(rule\n   ((= (VecOperandAndCost (VO current) current-cost)\n       (ExtractedVecOperandHelper (VO vec) index))\n    (< index (vec-length vec))\n    (= (ExtractedOperand (VecOperand-get (VO vec) index)) (OperandAndCost expr expr-cost)))\n   ((set (ExtractedVecOperandHelper (VO vec) (+ index 1))\n         (VecOperandAndCost\n             (VO (vec-push current expr))\n             (+ current-cost expr-cost))))\n    :ruleset fast-analyses)\n    \n\n            \n;; finished extracting, create result\n(rule\n  ((= result\n      (ExtractedVecOperandHelper (VO vec) index))\n   ;; at the end\n   (= index (vec-length vec)))\n  ((set (ExtractedVecOperand (VO vec))\n        result))\n  :ruleset fast-analyses)\n      \n\n(function ExtractedVecVecOperandHelper (VecVecOperand i64) TermAndCost :merge (Smaller old new))\n\n;; base case: extract nothing\n(rule\n   ((VVO vec))\n   ((set (ExtractedVecVecOperandHelper (VVO vec) 0)\n         (VecVecOperandAndCost (VVO empty-vvo) 0)))\n    :ruleset fast-analyses)\n\n;; extract one more thing\n(rule\n   ((= (VecVecOperandAndCost (VVO current) current-cost)\n       (ExtractedVecVecOperandHelper (VVO vec) index))\n    (< index (vec-length vec))\n    (= (ExtractedVecOperand (VecVecOperand-get (VVO vec) index)) (VecOperandAndCost expr expr-cost)))\n   ((set (ExtractedVecVecOperandHelper (VVO vec) (+ index 1))\n         (VecVecOperandAndCost\n             (VVO (vec-push current expr))\n             (+ current-cost expr-cost))))\n    :ruleset fast-analyses)\n    \n\n            \n;; finished extracting, create result\n(rule\n  ((= result\n      (ExtractedVecVecOperandHelper (VVO vec) index))\n   ;; at the end\n   (= index (vec-length vec)))\n  ((set (ExtractedVecVecOperand (VVO vec))\n        result))\n  :ruleset fast-analyses)\n      \n\n;; Constant gets cost of 1\n(rule\n  ((= lhs (Const ty ops lit)))\n  ((set (ExtractedExpr lhs) (ExprAndCost lhs 1)))\n  :ruleset fast-analyses)\n\n;; arg gets cost of 1\n(rule\n  ((= lhs (Arg index)))\n  ((set (ExtractedOperand lhs) (OperandAndCost lhs 1)))\n  :ruleset fast-analyses)\n\n\n;; PureOp doesn't add cost\n(rule\n  ((= lhs (PureOp expr))\n   (= (ExprAndCost expr-extracted expr-cost)\n      (ExtractedExpr expr)))\n   ((set (ExtractedBody lhs) (BodyAndCost (PureOp expr-extracted) expr-cost)))\n    :ruleset fast-analyses)\n\n;; Nor does Node\n(rule\n  ((= lhs (Node body))\n   (= (BodyAndCost body-extracted body-cost)\n      (ExtractedBody body)))\n   ((set (ExtractedOperand lhs) (OperandAndCost (Node body-extracted) body-cost)))\n    :ruleset fast-analyses)\n\n;; Theta gets a cost of 1 for now\n(rule\n  ((= lhs (Theta pred inputs outputs))\n   (= (OperandAndCost pred-extracted pred-cost)\n      (ExtractedOperand pred))\n   (= (VecOperandAndCost inputs-extracted inputs-cost)\n      (ExtractedVecOperand inputs))\n   (= (VecOperandAndCost outputs-extracted outputs-cost)\n      (ExtractedVecOperand outputs)))\n   ((set (ExtractedBody lhs)\n         (BodyAndCost\n            (Theta pred-extracted inputs-extracted outputs-extracted)\n            (+ 1 (+ pred-cost (+ inputs-cost outputs-cost))))))\n    :ruleset fast-analyses)\n\n;; Gamma gets a cost of 1 for now\n(rule\n  ((= lhs (Gamma pred inputs outputs))\n   (= (OperandAndCost pred-extracted pred-cost)\n      (ExtractedOperand pred))\n   (= (VecOperandAndCost inputs-extracted inputs-cost)\n      (ExtractedVecOperand inputs))\n   (= (VecVecOperandAndCost outputs-extracted outputs-cost)\n      (ExtractedVecVecOperand outputs)))\n  ((set (ExtractedBody lhs)\n        (BodyAndCost\n          (Gamma pred-extracted inputs-extracted outputs-extracted)\n          (+ 1 (+ pred-cost (+ inputs-cost outputs-cost))))))\n    :ruleset fast-analyses)\n\n\n;; Project is also free\n(rule ((= lhs (Project index body))\n       (= (BodyAndCost body-extracted body-cost)\n          (ExtractedBody body)))\n      ((set (ExtractedOperand lhs)\n            (OperandAndCost (Project index body-extracted) body-cost)))\n      :ruleset fast-analyses)\n        \n\n\n;; If a theta passes along argument,\n;; can extract the input instead.\n(rule ((= lhs (Project index loop))\n        (= loop (Theta pred inputs outputs))\n        (= (VecOperand-get outputs index) (Arg index))\n        (= passedthrough (ExtractedOperand (VecOperand-get inputs index)))\n      )\n      ((set (ExtractedOperand lhs) passedthrough))\n      :ruleset fast-analyses)\n\n;; If a gamma passes along an argument in both branches,\n;; extract the input instead.\n(rule ((= lhs (Project index loop))\n       (= loop (Gamma pred inputs outputs))\n       (= outputs (VVO outputs-inner))\n       (= 2 (vec-length outputs-inner))\n       (= outputs0 (VecVecOperand-get outputs 0))\n       (= outputs1 (VecVecOperand-get outputs 1))\n       (= (VecOperand-get outputs0 index) (Arg index))\n       (= (VecOperand-get outputs1 index) (Arg index))\n       (= passedthrough (ExtractedOperand (VecOperand-get inputs index))))\n      ((set (ExtractedOperand lhs) passedthrough))\n      :ruleset fast-analyses)\n\n\n;; if we reach a new context, union\n(rule ((= theta (Theta pred inputs outputs))\n       (= (BodyAndCost extracted cost)\n          (ExtractedBody theta)))\n      ((union theta extracted))\n      :ruleset fast-analyses)\n(rule ((= gamma (Gamma pred inputs outputs))\n       (= (BodyAndCost extracted cost)\n          (ExtractedBody gamma)))\n      ((union gamma extracted))\n      :ruleset fast-analyses)\n\n\n;; if we reach the function at the top level, union\n(rule ((= func (Func name intypes outtypes body))\n       (= (VecOperandAndCost extracted cost)\n          (ExtractedVecOperand body)))\n      ((union func\n              (Func name intypes outtypes extracted)))\n      :ruleset fast-analyses)\n        \n;;\tif a && b:\n;;\t\tA\n;;\telse:\n;;\t\tB\n;; ----------\n;;\tif a:\n;;\t\tif b:\n;;\t\t\tA\n;;\t\telse:\n;;\t\t\tB\n;;\telse:\n;;\t\tB\n(rule ((= gamma (Gamma (Node (PureOp (band BoolT a b))) (VO inputs) (VVO outputs)))\n       (= (vec-length outputs) 2)\n       (= (vec-get outputs 1) (VO A))\n       (= (vec-get outputs 0) (VO B))\n       (= args (vec-length inputs))\n       (= rets (vec-length B)))\n      ((let inner (Gamma (Arg args) ; we pass b as an extra argument to the outer gamma\n                         (PassThroughArguments args)\n                         (VVO (vec-of (VO B)\n                                      (VO A)))))\n       (union gamma (Gamma a\n                           (VO (vec-push inputs b)) ; pass b as an extra argument\n                           (VVO (vec-of (VO B)\n                                        (BodyToVecOperand rets inner)))))))\n\n;;\tif a || b:\n;;\t\tA\n;;\telse:\n;;\t\tB\n;; -----------\n;;\tif a:\n;;\t\tA\n;;\telse:\n;;\t\tif b:\n;;\t\t\tA\n;;\t\telse:\n;;\t\t\tB\n(rule ((= gamma (Gamma (Node (PureOp (bor BoolT a b))) (VO inputs) (VVO outputs)))\n       (= (vec-length outputs) 2)\n       (= (vec-get outputs 1) (VO A))\n       (= (vec-get outputs 0) (VO B))\n       (= args (vec-length inputs))\n       (= rets (vec-length B)))\n      ((let inner (Gamma (Arg args) ; we pass b as an extra argument to the outer gamma\n                         (PassThroughArguments args)\n                         (VVO (vec-of (VO B)\n                                      (VO A)))))\n       (union gamma (Gamma a\n                           (VO (vec-push inputs b)) ; pass b as an extra argument\n                           (VVO (vec-of (BodyToVecOperand rets inner)\n                                        (VO A)))))))\n\n;;\tif a:\n;;\t\tA\n;;\telse:\n;;\t\tA\n;; ------\n;;\tA\n(rule ((= gamma (Gamma condition inputs (VVO outputs)))\n       (= (vec-length outputs) 2)\n       (= (vec-get outputs 0) (vec-get outputs 1)))\n      ((union gamma (OperandGroup (SubstVecOperandAll (vec-get outputs 0) inputs)))))\n\n\n;; unroll loops\n(rule ((= theta (Theta pred (VO inputs) (VO outputs))))\n                          ;;            arguments body\n      ((let after-one-iter\n         (SubstVecOperandAll (VO outputs) (VO inputs)))\n       ;; (vec-of (Arg 0) (Arg 1) ...)\n       (let pass-through (PassThroughArguments (vec-length outputs)))\n       (union theta\n          (Gamma\n            (SubstOperandAll pred after-one-iter)\n            after-one-iter\n            (VVO\n              (vec-of\n                ;; in the false case, we are done\n                pass-through\n                ;; otherwise do the rest of the loop\n                (BodyToVecOperand\n                (vec-length outputs)\n                (Theta pred pass-through\n                            (VO outputs)))))))))\n\n\n\n(datatype Interval\n  (BoolI bool bool)\n  (IntI i64 i64)\n  (interval-intersect Interval Interval)\n  (interval-union Interval Interval))\n\n\n(rewrite (interval-intersect (IntI la ha) (IntI lb hb))\n      (IntI (max la lb) (min ha hb)))\n(rewrite (interval-union (IntI la ha) (IntI lb hb))\n      (IntI (min la lb) (max ha hb)))\n\n(rewrite (interval-intersect (BoolI la ha) (BoolI lb hb))\n      (BoolI (or la lb) (and ha hb)))\n(rewrite (interval-union (BoolI la ha) (BoolI lb hb))\n      (BoolI (and la lb) (or ha hb)))\n\n(function ival (Operand) Interval\n  :merge (interval-intersect old new))\n\n; context-specific intervals (because Args need to have interval analysis but are not globally unique)\n(function context-ival (Operand Body) Interval\n  :merge (interval-intersect old new))\n\n(rule ((= lhs (Node (PureOp (Const (BoolT) (const) (Bool b))))))\n      ((set (ival lhs) (BoolI b b))))\n\n(rule ((= lhs (Node (PureOp (Const (IntT) (const) (Num n))))))\n      ((set (ival lhs) (IntI n n))))\n\n\n; < a b interval (< ha lb) (< la hb)\n(rule ((= lhs (Node (PureOp (blt (BoolT) a b))))\n       (= (IntI la ha) (ival a))\n       (= (IntI lb hb) (ival b)))\n      ((set (ival lhs) (BoolI (bool-< ha lb) (bool-< la hb)))))\n\n; Rule that unions intervals for a gamma\n(rule (\n        (= lhs (Project i (Gamma pred ins (VVO outs))))\n        (= (VO thens) (vec-get outs 1))\n        (= (VO elses) (vec-get outs 0))\n        (= thenival (ival (vec-get thens i)))\n        (= elseival (ival (vec-get elses i)))\n      )\n      (\n        (set (ival lhs) (interval-union thenival elseival))\n      )\n)\n\n; Eliminate gamma with interval analysis\n(rule (\n        (= gamma (Gamma pred inputs (VVO outputs)))\n        (= (BoolI true true) (ival pred))\n      )\n      (\n        (union gamma (OperandGroup (SubstVecOperandAll (vec-get outputs 1) inputs)))\n      )\n)\n(rule (\n        (= gamma (Gamma pred inputs (VVO outputs)))\n        (= (BoolI false false) (ival pred))\n      )\n      (\n        (union gamma (OperandGroup (SubstVecOperandAll (vec-get outputs 0) inputs)))\n      )\n)\n\n(rule  \n    (\n        ; Match on PureOp because all exprs are converted to bodies\n        ; Will refactor Call in the future\n        (= return (PureOp (Call ty name args num)) )\n        (Func name input-types output-types body)\n    )\n    ((\n        union \n        return\n        (OperandGroup (SubstVecOperandAll body args))\n    ))\n)\n\n     (rule\n      ((= num (Node (PureOp (Const (IntT) (const) (Num n1)))))\n       (= lhs (badd (IntT) other num)))\n      ((union lhs (badd (IntT) num other))))\n\n     (rule\n      ((= num (Node (PureOp (Const (IntT) (const) (Num n1)))))\n       (= lhs (bmul (IntT) other num)))\n      ((union lhs (bmul (IntT) num other))))\n\n      (rule\n        ((= lhs (badd (IntT)\n                      (Node (PureOp (badd (IntT) a b)))\n                      c)))\n        ((union lhs\n                (badd (IntT)\n                      a\n                      (Node (PureOp (badd (IntT) b c)))))))\n      \n\n        (rule\n          ((= lhs (badd (IntT)\n                        a\n                        (Node (PureOp (badd (IntT) b c)))))\n           (= b (Node (PureOp (Const (IntT) (const) (Num n1)))))            \n          )\n          ((union lhs\n             (badd (IntT)\n                   b\n                   (Node (PureOp (badd (IntT) a c))))))               \n        )\n      \n\n      (rule\n        ((= lhs (badd (IntT)\n                      a\n                      (Node (PureOp (badd (IntT) b c)))))\n         (= a (Node (PureOp (Const (IntT) (const) (Num n1)))))\n         (= b (Node (PureOp (Const (IntT) (const) (Num n2))))))\n\n        ((union lhs\n          (badd (IntT)\n            (Node (PureOp (Const (IntT) (const) (Num (+ n1 n2)))))\n            c))))      \n\n\n(let v0 \"main\")\n(let v1 (IntT))\n(let v2 (Bril v1))\n(let v3 (PrintState))\n(let v4 (vec-of v2 v2 v3))\n(let v5 (vec-of v3))\n(let v6 1)\n(let v7 2)\n(let v8 (BoolT))\n(let v9 (Arg v6))\n(let v10 4)\n(let v11 (Arg v10))\n(let v12 (blt v8 v9 v11))\n(let v13 (PureOp v12))\n(let v14 (Node v13))\n(let v15 0)\n(let v16 (Arg v15))\n(let v17 (Arg v7))\n(let v18 3)\n(let v19 (Arg v18))\n(let v20 (vec-of v16 v9 v17 v19 v11))\n(let v21 (VO v20))\n(let v22 (const))\n(let v23 (Num v15))\n(let v24 (Const v1 v22 v23))\n(let v25 (PureOp v24))\n(let v26 (Node v25))\n(let v27 (vec-of v16 v9 v26 v17 v19 v11))\n(let v28 (VO v27))\n(let v29 (blt v8 v19 v11))\n(let v30 (PureOp v29))\n(let v31 (Node v30))\n(let v32 5)\n(let v33 (Arg v32))\n(let v34 (vec-of v16 v9 v17 v19 v11 v33))\n(let v35 (VO v34))\n(let v36 (vec-of v16 v9 v17 v26 v19 v11 v33))\n(let v37 (VO v36))\n(let v38 (bmul v1 v9 v11))\n(let v39 (PureOp v38))\n(let v40 (Node v39))\n(let v41 (badd v1 v40 v19))\n(let v42 (PureOp v41))\n(let v43 (Node v42))\n(let v44 (PRINT v43 v16))\n(let v45 (PureOp v44))\n(let v46 (Node v45))\n(let v47 (Num v6))\n(let v48 (Const v1 v22 v47))\n(let v49 (PureOp v48))\n(let v50 (Node v49))\n(let v51 (badd v1 v19 v17))\n(let v52 (PureOp v51))\n(let v53 (Node v52))\n(let v54 (vec-of v46 v9 v17 v50 v53 v11 v33))\n(let v55 (VO v54))\n(let v56 (vec-of v37 v55))\n(let v57 (VVO v56))\n(let v58 (Gamma v31 v35 v57))\n(let v59 (Project v18 v58))\n(let v60 (vec-of v16 v9 v17 v26 v19 v11))\n(let v61 (VO v60))\n(let v62 (Project v15 v58))\n(let v63 (Project v6 v58))\n(let v64 (Project v7 v58))\n(let v65 (Project v10 v58))\n(let v66 (Project v32 v58))\n(let v67 6)\n(let v68 (Project v67 v58))\n(let v69 (vec-of v62 v63 v64 v65 v66 v68))\n(let v70 (VO v69))\n(let v71 (Theta v59 v61 v70))\n(let v72 (Project v15 v71))\n(let v73 (Project v6 v71))\n(let v74 (Project v7 v71))\n(let v75 (badd v1 v73 v74))\n(let v76 (PureOp v75))\n(let v77 (Node v76))\n(let v78 (Project v10 v71))\n(let v79 (Project v32 v71))\n(let v80 (vec-of v72 v77 v50 v74 v78 v79))\n(let v81 (VO v80))\n(let v82 (vec-of v28 v81))\n(let v83 (VVO v82))\n(let v84 (Gamma v14 v21 v83))\n(let v85 (Project v7 v84))\n(let v86 (vec-of v17 v26 v50 v9 v16))\n(let v87 (VO v86))\n(let v88 (Project v15 v84))\n(let v89 (Project v6 v84))\n(let v90 (Project v18 v84))\n(let v91 (Project v10 v84))\n(let v92 (Project v32 v84))\n(let v93 (vec-of v88 v89 v90 v91 v92))\n(let v94 (VO v93))\n(let v95 (Theta v85 v87 v94))\n(let v96 (Project v6 v95))\n(let v97 (Project v15 v95))\n(let v98 (PRINT v96 v97))\n(let v99 (PureOp v98))\n(let v100 (Node v99))\n(let v101 (vec-of v100))\n(let v102 (VO v101))\n(let v103 (Func v0 v4 v5 v102))\n\n(run-schedule\n        (repeat 5 (saturate fast-analyses)\n                  (run)\n                  (saturate subst)))\n",
  "eqsat-basic": "(datatype Math\n  (Num i64)\n  (Var String)\n  (Add Math Math)\n  (Mul Math Math))\n\n;; expr1 = 2 * (x + 3)\n(let expr1 (Mul (Num 2) (Add (Var \"x\") (Num 3))))\n;; expr2 = 6 + 2 * x\n(let expr2 (Add (Num 6) (Mul (Num 2) (Var \"x\"))))\n\n\n;; (rule ((= __root (Add a b)))\n;;       ((union __root (Add b a)))\n(rewrite (Add a b)\n         (Add b a))\n(rewrite (Mul a (Add b c))\n         (Add (Mul a b) (Mul a c)))\n(rewrite (Add (Num a) (Num b))\n         (Num (+ a b)))\n(rewrite (Mul (Num a) (Num b))\n         (Num (* a b)))\n\n(run 10)\n(check (= expr1 expr2))\n",
  "eqsolve": "(datatype Expr\n  (Add Expr Expr)\n  (Neg Expr)\n  (Num i64)\n  (Mul Expr Expr)\n  (Var String)\n)\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Add x y) z) (Add x (Add y z)))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n(rule ((= (Add x y) z))\n      ((union (Add z (Neg y)) x)))\n(rewrite (Neg (Neg x)) x)\n(rewrite (Neg (Num n)) (Num (- 0 n)))\n\n(rule ((= x (Var v))) ((union (Mul (Num 1) x) x)))\n(rule ((= x (Add x1 x2))) ((union (Mul (Num 1) x) x)))\n(rewrite (Add (Mul y x) (Mul z x)) (Mul (Add y z) x))\n(rewrite (Mul x y) (Mul y x))\n(rule ((= (Mul (Num x) y) (Num z))\n       (= (% z x) 0))\n      ((union y (Num (/ z x)))))\n\n; system 1: x + 2 = 7\n(union (Add (Var \"x\") (Num 2)) (Num 7))\n; system 2: z + y = 6, 2z = y\n(union (Add (Var \"z\") (Var \"y\")) (Num 6))\n(union (Add (Var \"z\") (Var \"z\")) (Var \"y\"))\n\n(run 5)\n(query-extract (Var \"x\"))\n(query-extract (Var \"y\"))\n(query-extract (Var \"z\"))\n(check (= (Var \"z\") (Add (Num 6) (Neg (Var \"y\")))))\n(check (= (Var \"y\") (Add (Add (Num 6) (Neg (Var \"y\"))) (Add (Num 6) (Neg (Var \"y\"))))))\n(check (= (Var \"y\") (Add (Add (Num 12) (Neg (Var \"y\"))) (Neg (Var \"y\")))))\n(check (= (Add (Var \"y\") (Var \"y\")) \n          (Add (Num 12) (Neg (Var \"y\")))))\n(check (= (Add (Add (Var \"y\") (Var \"y\")) (Var \"y\"))\n          (Num 12)))\n(check (= (Add (Mul (Num 2) (Var \"y\")) (Var \"y\"))\n          (Num 12)))\n(check (= (Mul (Num 3) (Var \"y\"))\n          (Num 12)))\n",
  "f64": "(check (= (neg 1.5) -1.5))\n(check (= (+ 1.5 9.2) 10.7))\n(check (= (/ 12.5 2.0) 6.25))\n(check (< 1.5 9.2))\n(check (>= 9.2 1.5))\n(fail (check (< 9.2 1.5)))\n(fail (check (= (+ 1.5 9.2) 10.6)))\n(check (= (to-f64 1) 1.0))\n(check (= (to-i64 1.0) 1))\n(check (= (to-string 1.2) \"1.2\"))\n(check (= (to-string 1.0) \"1.0\"))\n",
  "unbound": "(datatype Math\n    (Add Math Math)\n    (Sub Math Math)\n)\n\n(rule ((= e (Add x y))) ((Add x i)))\n",
  "unstable-fn-wrong-args": ";; test that applying a function with the wrong number of args will violate the type checker\n\n\n(datatype Math\n    (Inc Math))\n\n(sort Fn (UnstableFn (Math) Math))\n(unstable-app (unstable-fn \"Inc\") 10)\n",
  "unstable-fn-wrong-return": ";; test that the value of a applied function is well typed\n\n\n(datatype Math\n    (Zero)\n    (Inc Math))\n\n(sort Fn (UnstableFn (Math) Math))\n(let x (unstable-app (unstable-fn \"Inc\") (Zero)))\n\n(+ x 10)\n",
  "fail_wrong_assertion": ";; This test ensure check test fails for wrong assertion\n(function f (i64) i64 :merge (min old new))\n\n(set (f 1) 4)\n(set (f 1) 5)\n\n(check (= (f 1) 4))\n(fail (check (= (f 1) 2)))\n\n(delete (f 1))\n(fail (check (= (f 1) 4)))\n\n(function g (i64 i64) i64 :merge (min old new))\n\n(set (g 1 2) 3)\n(set (g 2 3) 3)\n\n(check (= (g 1 2) (g 2 3)))\n(fail (check (!= (g 1 2) (g 2 3))))\n(fail (check (= (g 0 2) (g 2 3))))\n(check (= x (g 1 2)))\n(fail (check (= x (g 1 3))))\n(check (= x (g 1 2)) (= y (g 2 3)) (= x y))\n(fail (check (= x (g 0 0)) (= y (g 1 1)) (= x y)))",
  "fibonacci-demand": "(datatype Expr \n  (Num i64 :cost 1)\n  (Add Expr Expr :cost 5))\n\n(function Fib (i64) Expr :cost 10)\n\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rewrite (Fib x) (Add (Fib (- x 1)) (Fib (- x 2)))\n         :when ((> x 1)))\n(rewrite (Fib x) (Num x)\n         :when ((<= x 1)))\n\n(let f7 (Fib 7))\n(run 1000)\n(print-function Fib 10)\n(extract f7)\n(check (= f7 (Num 13)))\n       \n ",
  "fibonacci": "(function fib (i64) i64)\n(set (fib 0) 0)\n(set (fib 1) 1)\n\n(rule ((= f0 (fib x))\n       (= f1 (fib (+ x 1))))\n      ((set (fib (+ x 2)) (+ f0 f1))))\n\n(run 7)\n\n(check (= (fib 7) 13))",
  "fusion": "(datatype Var)\n(datatype Term\n    (App Term Term)\n    (Lam Var Term)\n    (TVar Var)\n    (Let Var Term Term)\n    (Add Term Term)\n    (Num i64)\n    (CaseSplit Term Term Term)\n    (Cons Term Term))\n(declare Nil Term)\n\n(function V (String) Var) \n(function From (Term) Var)\n\n;; ==== FV ====\n(sort StringSet (Set Var))\n(function freer (Term) StringSet :merge (set-intersect old new))\n(rule ((= e (App e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Lam var body))\n       (= (freer body) fv))\n      ((set (freer e) (set-remove fv var))))\n(rule ((= e (TVar v)))\n      ((set (freer e) (set-insert (set-empty) v))))\n(rule ((= e (Let var e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 (set-remove fv2 var)))))\n(rule ((= e (Add e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Num v)))\n      ((set (freer e) (set-empty))))\n(rule ((= e (CaseSplit e1 e2 e3))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2)\n       (= (freer e3) fv3))\n      ((set (freer e) (set-union (set-union fv1 fv2) fv3))))\n(rule ((= e (Cons e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e Nil))\n      ((set (freer e) (set-empty))))\n\n;; ==== eval ====\n; beta\n(rewrite (App (Lam v body) e) (Let v e body))\n; case-split-nil\n(rewrite (CaseSplit Nil e1 e2) e1)\n; case-split-cons\n(rewrite (CaseSplit (Cons x xs) e1 e2) (App (App e2 x) xs))\n\n; let-num\n(rewrite (Let v e (Num n)) (Num n))\n; let-nil\n(rewrite (Let v e Nil) Nil)\n; let-var-same\n(rewrite (Let v1 e (TVar v1)) e)\n; let-var-diff\n(rewrite (Let v1 e (TVar v2)) (TVar v2) :when ((!= v1 v2)))\n\n; let-lam-close\n(rewrite (Let v1 e expr) expr :when ((set-not-contains (freer expr) v1)))      \n; let-app\n(rewrite (Let v e expr) (App (Let v e a) (Let v e b)) :when ((= expr (App a b)) (set-contains (freer expr) v)))\n; let-add\n(rewrite (Let v e expr) (Add (Let v e a) (Let v e b)) :when ((= expr (Add a b)) (set-contains (freer expr) v)))\n; let-cons\n(rewrite (Let v e expr) (Cons (Let v e x) (Let v e xs)) :when ((= expr (Cons x xs)) (set-contains (freer expr) v)))\n; let-case-split\n(rewrite (Let v e expr) \n         (CaseSplit (Let v e e1) (Let v e e2) (Let v e e3))\n    :when ((= expr (CaseSplit e1 e2 e3))\n           (set-contains (freer expr) v)))\n; let-lam-same\n(rewrite (Let v1 e (Lam v1 body)) (Lam v1 body))\n; let-lam-diff\n(rewrite (Let v1 e (Lam v2 body)) (Lam v2 (Let v1 e body))\n      :when ((set-contains (freer body) v1)\n             (!= v1 v2)\n             (= fvs (freer e))\n             (set-not-contains fvs v2)))\n(rule ((= expr (Let v1 e (Lam v2 body)))\n       (set-contains (freer body) v1)\n       (!= v1 v2)\n       (= fvs (freer e))\n       (set-contains fvs v2))\n      ((union expr (Lam (From expr) (Let v1 e (Let v2 (TVar (From expr)) body))))))\n\n(function pushdown (Term Term) Term :cost 10000)\n(rewrite (App f (App (Lam x e) e2))\n         (App (Lam x (pushdown f e)) e2))\n\n(rewrite (pushdown f (CaseSplit e e1 (Lam x (Lam xs e2)))) \n         (CaseSplit e (App f e1) (Lam x (Lam xs (App f e2)))))\n\n(relation is-tail (Term))\n(rule ((= demand (pushdown f e)) (= e (App e1 e2))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (Lam x e))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (TVar x))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (Cons e1 e2))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e Nil)) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (Add e1 e2))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (Num n1))) ((is-tail e)))\n(rewrite (pushdown f e) (App f e) :when ((is-tail e)))\n\n;; ==== definition ====\n\n(function sum () Term :cost 1000)\n(function mapf () Term :cost 1000)\n(function sum-o-mapf () Term)\n(rewrite (App (sum) (App (mapf) x)) (App (sum-o-mapf) x))\n(union (sum) (Lam (V \"xs\")\n    (CaseSplit (TVar (V \"xs\")) \n        (Num 0)\n        (Lam (V \"x\") (Lam (V \"xs'\") \n            (Add (TVar (V \"x\")) (App (sum) (TVar (V \"xs'\")))))))))\n\n(union (mapf) (Lam (V \"xs\")\n    (CaseSplit (TVar (V \"xs\"))\n        Nil\n        (Lam (V \"x\") (Lam (V \"xs'\")\n            (Cons (Add (TVar (V \"x\")) (Num 1))\n                  (App (mapf) (TVar (V \"xs'\")))))))))\n\n(set (freer (sum)) (set-empty))\n(set (freer (mapf)) (set-empty))\n\n(let expr (App (sum) (App (mapf) (TVar (V \"expr\")))))\n\n(run 100)\n\n(query-extract (freer expr))\n\n\n(let my-output\n    (CaseSplit (TVar (V \"expr\")) (Num 0) \n           (Lam (V \"x\") (Lam (V \"xs'\") \n                (Add (Add (TVar (V \"x\")) (Num 1)) \n                     (App (sum-o-mapf) (TVar (V \"xs'\"))))))))\n\n(check (= (App (sum-o-mapf) (TVar (V \"expr\")))\n          (CaseSplit (TVar (V \"expr\")) (Num 0) \n                 (Lam (V \"x\") (Lam (V \"xs'\") \n                      (Add (Add (TVar (V \"x\")) (Num 1)) \n                           (App (sum-o-mapf) (TVar (V \"xs'\")))))))))\n",
  "herbie-tutorial": "(datatype Math\n  (Num Rational)\n  (Var String)\n  (Add Math Math)\n  (Div Math Math)\n  (Mul Math Math))\n\n(let zero (Num (rational 0 1)))\n(let one (Num (rational 1 1)))\n(let two (Num (rational 2 1)))\n\n(rewrite (Add a b) (Add b a))\n(rewrite (Add a zero) a)\n(rewrite (Add (Num r1) (Num r2))\n         (Num (+ r1 r2)))\n\n(let one-two (Add one two))\n\n(push)\n(run 1)\n;; yay, constant folding works\n(check (= one-two (Num (rational 3 1))))\n;; also, commutativity works\n(check (= (Add two one) one-two))\n(pop)\n\n(push)\n;; rule is like rewrite, but more general\n;; the following rule doesn't union (Num r) with the result:\n(rule ((Num r))\n      ((union one (Div (Num r) (Num r)))))\n;; uh oh, division by zero!\n(run 1)\n\n(pop)\n\n;; we need to detect when things are non-zero\n(function lower-bound (Math) Rational :merge (max old new))\n(function upper-bound (Math) Rational :merge (min old new))\n\n(rule ((Num r))\n      ((set (lower-bound (Num r)) r)\n       (set (upper-bound (Num r)) r)))\n(rule ((= e (Add a b)) (= x (lower-bound a)) (= y (lower-bound b)))\n      ((set (lower-bound e) (+ x y))))\n(rule ((= e (Add a b)) (= x (upper-bound a)) (= y (upper-bound b)))\n      ((set (upper-bound e) (+ x y))))\n(rule ((= e (Mul a b)))\n      ((set (lower-bound e)\n            (min (* (lower-bound a) (lower-bound b))\n                 (min (* (lower-bound a) (upper-bound b))\n                 (min (* (upper-bound a) (lower-bound b))\n                      (* (upper-bound a) (upper-bound b))))))\n       (set (upper-bound e)\n            (max (* (lower-bound a) (lower-bound b))\n                 (max (* (lower-bound a) (upper-bound b))\n                 (max (* (upper-bound a) (lower-bound b))\n                      (* (upper-bound a) (upper-bound b))))))))\n\n(rule ((= e (Add a b))\n       (> (lower-bound e) (rational 0 1)))\n      ((union one (Div (Add a b) (Add a b)))))\n\n(let x (Var \"x\"))\n(let x1 (Add x one))\n\n(push)\n(set (lower-bound x) (rational 0 1))\n(set (upper-bound x) (rational 1 1))\n\n(run 3)\n\n(query-extract (lower-bound x1))\n(query-extract (upper-bound x1))\n(check (= one (Div x1 x1)))\n\n(pop)\n\n\n;; Set the variable x to a particular input value 200/201\n(set (lower-bound x) (rational 200 201))\n(set (upper-bound x) (rational 200 201))\n\n(run 3)\n\n(query-extract (lower-bound x1))\n(query-extract (upper-bound x1))\n\n(function true-value (Math) f64)\n\n(rule ((= (to-f64 (lower-bound e))\n          (to-f64 (upper-bound e))))\n      ((set (true-value e)\n            (to-f64 (lower-bound e)))))\n\n(run 1)\n(query-extract (true-value x1))\n\n(function best-error (Math) f64 :merge new :default (to-f64 (rational 10000 1)))\n\n(rule ((Num n))\n      ((set (best-error (Num n)) (to-f64 n))))\n(rule ((Add a b)) ((best-error (Add a b))))\n\n;; finally, the mega rule for finding more accurate programs\n(rule ((= expr (Add a b))\n       (= (best-error a) va)\n       (= (best-error b) vb)\n       (= true-v (true-value (Add a b)))\n       (= computed (+ va vb))\n       (< (abs (- computed true-v))\n          (best-error (Add a b))))\n      ((set (best-error (Add a b)) computed)))\n\n\n\n(push)\n\n(let target\n  (Add \n    (Add (Num (rational 1 100)) (Num (rational 1 100)))\n    (Num (rational -2 100))))\n\n(run 1)\n\n;; set a default\n(best-error target)\n;; error is bad, constant folding hasn't fired enough\n(query-extract (best-error target))\n\n(run 1)\n\n;; error is good, constant folding has fired enough\n(query-extract (best-error target))\n\n\n(pop)",
  "herbie": ";; Implements part of the simplification layer of herbie in egglog\ud83e\udee1\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Datatypes\n\n(datatype Math\n  ; Ground terms\n  (Num Rational)\n  (Var String)\n\n  ; Custom ops\n  (Const String)\n  (Unary String Math)\n  ; unneeded for now\n  ; (Binary String Math Math)\n\n  ; Constant-folding ops\n  (Add Math Math)\n  (Sub Math Math)\n  (Mul Math Math)\n  (Div Math Math)\n  (Pow Math Math)\n  (Neg Math)\n  (Sqrt Math)\n  (Cbrt Math) ; cube root\n  (Fabs Math)\n  (Ceil Math)\n  (Floor Math)\n  (Round Math)\n  (Log Math))\n\n(let r-zero (rational 0 1))\n(let r-one  (rational 1 1))\n(let r-two  (rational 2 1))\n(let zero (Num r-zero))\n(let one  (Num r-one))\n(let two  (Num r-two))\n(let three (Num (rational 3 1)))\n(let neg-one (Neg one))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Analyses\n;; --------\n;; This example has three analyses:\n;; an interval analysis consisting of a hi and lo component\n;; and a non-zero analysis.\n;; The non-zero analysis is built off the interval analysis (in order to prove\n;; that rewrites are sound, even if some parts of an expr can't be const-evaled)\n\n; TODO: unbounded intervals?\n(function hi (Math) Rational :merge (min old new))\n(function lo (Math) Rational :merge (max old new))\n(relation non-zero (Math))\n\n;; First, constant folding!\n;; We don't need an explicit constant folding analysis, we can just union\n;; with nums when we can\n\n; Cases\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rewrite (Sub (Num a) (Num b)) (Num (- a b)))\n(rewrite (Mul (Num a) (Num b)) (Num (* a b)))\n(rewrite (Div (Num a) denom) (Num (/ a b)) :when ((= denom (Num b)) (non-zero denom)))\n(rewrite (Pow (Num a) (Num b)) (Num res) :when ((= res (pow a b))))\n(rewrite (Neg (Num a)) (Num (neg a)))\n;; TODO unimplemented\n;; (rewrite (Sqrt (Num a)) (Num res) :when ((= res (sqrt a))))\n;; (rewrite (Cbrt (Num a)) (Num res) :when ((= res (cbrt a))))\n(rewrite (Fabs (Num a)) (Num (abs a)))\n(rewrite (Ceil (Num a)) (Num (ceil a)))\n(rewrite (Floor (Num a)) (Num (floor a)))\n(rewrite (Round (Num a)) (Num (round a)))\n(rewrite (Log (Num a)) (Num res) :when ((= res (log a))))\n\n;; To check if something is zero, we check that zero is not contained in the\n;; interval. There are two possible (overlapping!) cases:\n;; - There exists a lo interval, in which case it must be larger than 0\n;; - There exists a hi interval, in which case it must be smaller than 0\n;; This assumes that intervals are well-formed: lo <= hi at all times.\n(rule ((= l (lo e))\n       (> l r-zero))\n      ((non-zero e)))\n(rule ((= h (hi e))\n       (< h r-zero))\n      ((non-zero e)))\n\n(rule ((= e (Num ve)))\n      ((set (lo e) ve)\n       (set (hi e) ve)))\n\n;; The interval analyses are similar to the constant-folding analysis,\n;; except we have to take the lower/upper bound of the results we get\n(rule ((= e (Add a b))\n       (= la (lo a))\n       (= lb (lo b)))\n      ((set (lo e) (+ la lb))))\n(rule ((= e (Add a b))\n       (= ha (hi a))\n       (= hb (hi b)))\n      ((set (hi e) (+ ha hb))))\n      \n(rule ((= e (Sub a b))\n       (= la (lo a))\n       (= ha (hi a))\n       (= lb (lo b))\n       (= hb (hi b)))\n      ((set (lo e) \n          (min (min (- la lb) (- la hb))\n               (min (- ha lb) (- ha hb))))\n       (set (hi e) \n          (max (max (- la lb) (- la hb))\n               (max (- ha lb) (- ha hb))))))\n\n(rule ((= e (Mul a b))\n       (= la (lo a))\n       (= ha (hi a))\n       (= lb (lo b))\n       (= hb (hi b)))\n      ((set (lo e) \n          (min (min (* la lb) (* la hb))\n               (min (* ha lb) (* ha hb))))\n       (set (hi e) \n          (max (max (* la lb) (* la hb))\n               (max (* ha lb) (* ha hb))))))\n\n(rule ((= e (Div a b))\n       (= la (lo a))\n       (= ha (hi a))\n       (= lb (lo b))\n       (= hb (hi b)))\n      ((set (lo e) \n          (min (min (/ la lb) (/ la hb))\n               (min (/ ha lb) (/ ha hb))))\n       (set (hi e) \n          (max (max (/ la lb) (/ la hb))\n               (max (/ ha lb) (/ ha hb))))))\n\n; TODO: Pow\n\n(rule ((= e (Neg a))\n       (= la (lo a))\n       (= ha (hi a)))\n      ((set (lo e) (neg ha))\n       (set (hi e) (neg la))))\n\n; TODO: Sqrt\n; TODO: Cbrt\n\n(rule ((= e (Fabs a))\n       (= la (lo a))\n       (= ha (hi a)))\n      ((set (lo e) (min (abs la) (abs ha)))\n       (set (hi e) (max (abs la) (abs ha)))))\n\n(rule ((= e (Ceil a))\n       (= la (lo a)))\n      ((set (lo e) (ceil la))))\n(rule ((= e (Ceil a))\n       (= ha (hi a)))\n      ((set (hi e) (ceil ha))))\n\n(rule ((= e (Floor a))\n       (= la (lo a)))\n      ((set (lo e) (floor la))))\n(rule ((= e (Floor a))\n       (= ha (hi a)))\n      ((set (hi e) (floor ha))))\n\n(rule ((= e (Round a))\n       (= la (lo a)))\n      ((set (lo e) (round la))))\n(rule ((= e (Round a))\n       (= ha (hi a)))\n      ((set (hi e) (round ha))))\n\n; TODO: Log\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Rewrites\n;; --------\n;; These rewrites were compiled from src/syntax/rules.rkt in the herbie repo,\n;; using all rewrites in the `simplify` rewrite group.\n\n;; Commutativity\n(rewrite (Add a b) (Add b a))\n(rewrite (Mul a b) (Mul b a))\n\n;; Associativity\n(rewrite (Add a (Add b c)) (Add (Add a b) c))\n(rewrite (Add (Add a b) c) (Add a (Add b c)))\n(rewrite (Add a (Sub b c)) (Sub (Add a b) c))\n(rewrite (Add (Sub a b) c) (Sub a (Sub b c)))\n(rewrite (Sub a (Add b c)) (Sub (Sub a b) c))\n(rewrite (Sub (Add a b) c) (Add a (Sub b c)))\n(rewrite (Sub (Sub a b) c) (Sub a (Add b c)))\n(rewrite (Sub a (Sub b c)) (Add (Sub a b) c))\n(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))\n(rewrite (Mul (Mul a b) c) (Mul a (Mul b c)))\n(rewrite (Mul a (Div b c)) (Div (Mul a b) c))\n(rewrite (Mul (Div a b) c) (Div (Mul a c) b))\n(rewrite (Div a (Mul b c)) (Div (Div a b) c))\n(rewrite (Div (Mul b c) a) (Div b (Div a c)) :when ((non-zero c)))\n(rewrite (Div a (Div b c)) (Mul (Div a b) c) :when ((non-zero c)))\n(rewrite (Div (Div b c) a) (Div b (Mul a c)) :when ((non-zero a)))\n\n;; Counting\n(rewrite (Add x x) (Mul two x))\n\n;; Distributivity\n(rewrite (Mul a (Add b c))         (Add (Mul a b) (Mul a c)))\n(rewrite (Mul a (Add b c))         (Add (Mul b a) (Mul c a)))\n(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))\n(rewrite (Sub (Mul a b) (Mul a c)) (Mul a (Sub b c)))\n(rewrite (Add (Mul b a) (Mul c a)) (Mul a (Add b c)))\n(rewrite (Sub (Mul b a) (Mul c a)) (Mul a (Sub b c)))\n(rewrite (Add (Mul b a) a)         (Mul (Add b one) a))\n(rewrite (Add a (Mul c a))         (Mul (Add c one) a))\n\n(rewrite (Neg (Mul a b))       (Mul (Neg a) b))\n(rewrite (Neg (Mul a b))       (Mul a (Neg b)))\n(rewrite (Mul (Neg a) b)       (Neg (Mul a b)))\n(rewrite (Mul a (Neg b))       (Neg (Mul a b)))\n(rewrite (Neg (Add a b))       (Add (Neg a) (Neg b)))\n(rewrite (Add (Neg a) (Neg b)) (Neg (Add a b)))\n(rewrite (Div (Neg a) b)       (Neg (Div a b)))\n(rewrite (Neg (Div a b))       (Div (Neg a) b))\n\n(rewrite (Sub a (Mul (Neg b) c)) (Add a (Mul b c)))\n(rewrite (Sub a (Mul b c))       (Add a (Mul (Neg b) c)))\n\n;; Difference of squares\n(rewrite (Mul (Mul a b) (Mul a b))                           (Mul (Mul a a) (Mul b b)))\n(rewrite (Mul (Mul a a) (Mul b b))                           (Mul (Mul a b) (Mul a b)))\n(rewrite (Sub (Mul a a) (Mul b b))                           (Mul (Add a b) (Sub a b)))\n(rewrite (Sub (Mul a a) one)                (Mul (Add a one) (Sub a one)))\n(rewrite (Add (Mul a a) (Neg one))          (Mul (Add a one) (Sub a one)))\n(rewrite (Pow a b) (Mul (Pow a (Div b two)) (Pow a (Div b two))))\n(rewrite (Mul (Pow a b) (Pow a b))                           (Pow a (Mul two b)))\n\n;; Identity\n;; This isn't subsumed by const folding since this can return results\n;; even if we can't evaluate a precise value for x\n(rewrite (Div one (Div one x))\n         x\n         :when ((non-zero x)))\n(rewrite (Mul x (Div one x))\n         one\n         :when ((non-zero x)))\n(rewrite (Mul (Div one x) x)\n         one\n         :when ((non-zero x)))\n\n(rewrite (Sub x x) zero)\n(rewrite (Div x x) one\n         :when ((non-zero x)))\n(rewrite (Div zero x) zero\n         :when ((non-zero x)))\n(rewrite (Mul zero x) zero)\n(rewrite (Mul x zero) zero)\n\n(rewrite (Add zero x) x)\n(rewrite (Add x zero) x)\n(rewrite (Sub zero x) (Neg x))\n(rewrite (Sub x zero) x)\n(rewrite (Neg (Neg x)) x)\n(rewrite (Mul one x) x)\n(rewrite (Mul x one) x)\n(rewrite (Div x one) x)\n(rewrite (Mul neg-one x) (Neg x))\n \n(rewrite (Sub a b) (Add a (Neg b)))\n(rewrite (Add a (Neg b)) (Sub a b))\n(rewrite (Neg x) (Sub zero x))\n(rewrite (Neg x) (Mul neg-one x))\n\n(rewrite (Div x y) (Mul x (Div one y)))\n(rewrite (Mul x (Div one y)) (Div x y))\n(rewrite (Div x y) (Div one (Div y x))\n  :when ((non-zero x)\n         (non-zero y)))\n\n; FIXME: this rule can't be expressed in its full generality;\n;        we can't express the general rule x -> 1/x since\n;        we can't quantify over Math yet\n;        for now we just apply it to vars\n;        it's also p slow lmao\n(rewrite (Var x) (Mul one (Var x)))\n\n;; Fractions\n(rewrite (Div (Sub a b) c)         (Sub (Div a c) (Div b c)))\n(rewrite (Div (Mul a b) (Mul c d)) (Mul (Div a c) (Div b d)))\n\n;; Square root\n(rewrite (Mul (Sqrt x) (Sqrt x)) x)\n(rewrite (Sqrt (Mul x x)) (Fabs x))\n\n(rewrite (Mul (Neg x) (Neg x)) (Mul x x))\n(rewrite (Mul (Fabs x) (Fabs x)) (Mul x x))\n\n;; Absolute values\n(rewrite (Fabs (Fabs x)) (Fabs x))\n(rewrite (Fabs (Sub a b)) (Fabs (Sub b a)))\n(rewrite (Fabs (Neg x)) (Fabs x))\n(rewrite (Fabs (Mul x x)) (Mul x x))\n(rewrite (Fabs (Mul a b)) (Mul (Fabs a) (Fabs b)))\n(rewrite (Fabs (Div a b)) (Div (Fabs a) (Fabs b)))\n\n;; Cube root\n(rewrite (Pow (Cbrt x) three)    x)\n(rewrite (Cbrt (Pow x three))    x)\n(rewrite (Mul (Mul (Cbrt x) (Cbrt x)) (Cbrt x)) x)\n(rewrite (Mul (Cbrt x) (Mul (Cbrt x) (Cbrt x))) x)\n(rewrite (Pow (Neg x) three)     (Neg (Pow x three)))\n\n(rewrite (Pow (Mul x y) three)\n         (Mul (Pow x three) (Pow y three)))\n(rewrite (Pow (Div x y) three)\n         (Div (Pow x three) (Pow y three)))\n \n(rewrite (Pow x three) (Mul x (Mul x x)))\n; FIXME: this rewrite is slow and has the potential to blow up the egraph\n;        this is bc this rule and the second-to-last difference of squares rule\n;        have some cyclic behavior goin on\n;        the last identity rule compounds this behavior\n(rewrite (Mul x (Mul x x)) (Pow x three))\n\n;; Exponentials\n(rewrite (Unary \"exp\" (Log x)) x)\n(rewrite (Log (Unary \"exp\" x)) x)\n\n(rewrite (Unary \"exp\" zero) one)\n(rewrite (Unary \"exp\" one) (Const \"E\"))\n;; (rewrite one               (Unary \"exp\" zero))\n(rewrite (Const \"E\")       (Unary \"exp\" one))\n\n(rewrite (Unary \"exp\" (Add a b)) (Mul (Unary \"exp\" a) (Unary \"exp\" b)))\n(rewrite (Unary \"exp\" (Sub a b)) (Div (Unary \"exp\" a) (Unary \"exp\" b)))\n(rewrite (Unary \"exp\" (Neg a))   (Div one (Unary \"exp\" a)))\n\n(rewrite (Mul (Unary \"exp\" a) (Unary \"exp\" b))      (Unary \"exp\" (Add a b)))\n(rewrite (Div one (Unary \"exp\" a)) (Unary \"exp\" (Neg a)))\n(rewrite (Div (Unary \"exp\" a) (Unary \"exp\" b))      (Unary \"exp\" (Sub a b)))\n(rewrite (Unary \"exp\" (Mul a b))                    (Pow (Unary \"exp\" a) b))\n(rewrite (Unary \"exp\" (Div a two)) (Sqrt (Unary \"exp\" a)))\n(rewrite (Unary \"exp\" (Div a three)) (Cbrt (Unary \"exp\" a)))\n(rewrite (Unary \"exp\" (Mul a two)) (Mul (Unary \"exp\" a) (Unary \"exp\" a)))\n(rewrite (Unary \"exp\" (Mul a three)) (Pow (Unary \"exp\" a) three))\n\n;; Powers\n(rewrite (Pow a neg-one) (Div one a))\n(rewrite (Pow a one) a)\n\n; 0^0 is undefined\n(rewrite (Pow a zero) one :when ((non-zero a)))\n(rewrite (Pow one a) one)\n\n(rewrite (Unary \"Exp\" (Mul (Log a) b)) (Pow a b))\n(rewrite (Mul (Pow a b) a) (Pow a (Add b one)))\n(rewrite (Pow a (Num (rational 1 2))) (Sqrt a))\n(rewrite (Pow a two) (Mul a a))\n(rewrite (Pow a (Num (rational 1 3))) (Cbrt a))\n(rewrite (Pow a three) (Mul (Mul a a) a))\n\n; 0^0 is undefined\n(rewrite (Pow zero a) zero :when ((non-zero a)))\n\n;; Logarithms\n(rewrite (Log (Mul a b)) (Add (Log a) (Log b)))\n(rewrite (Log (Div a b)) (Sub (Log a) (Log b)))\n(rewrite (Log (Div one a)) (Neg (Log a)))\n(rewrite (Log (Pow a b)) (Mul b (Log a)))\n(rewrite (Log (Const \"E\")) one)\n\n;; Trigonometry\n(rewrite (Add (Mul (Unary \"cos\" a) (Unary \"cos\" a)) (Mul (Unary \"sin\" a) (Unary \"sin\" a)))\n         one)\n(rewrite (Sub one (Mul (Unary \"cos\" a) (Unary \"cos\" a)))\n         (Mul (Unary \"sin\" a) (Unary \"sin\" a)))\n(rewrite (Sub one (Mul (Unary \"sin\" a) (Unary \"sin\" a)))\n         (Mul (Unary \"cos\" a) (Unary \"cos\" a)))\n(rewrite (Add (Mul (Unary \"cos\" a) (Unary \"cos\" a)) (Num (rational -1 1))) \n         (Neg (Mul (Unary \"sin\" a) (Unary \"sin\" a))))\n(rewrite (Add (Mul (Unary \"sin\" a) (Unary \"sin\" a)) (Num (rational -1 1))) \n         (Neg (Mul (Unary \"cos\" a) (Unary \"cos\" a))))\n(rewrite (Sub (Mul (Unary \"cos\" a) (Unary \"cos\" a)) one)  \n         (Neg (Mul (Unary \"sin\" a) (Unary \"sin\" a))))\n(rewrite (Sub (Mul (Unary \"sin\" a) (Unary \"sin\" a)) one)  \n         (Neg (Mul (Unary \"cos\" a) (Unary \"cos\" a))))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") (Num (rational 6 1))))       \n         (Num (rational 1 2)))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") (Num (rational 4 1))))       \n         (Div (Sqrt two) two))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") three))       \n         (Div (Sqrt three) two))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") two))       \n         one)\n(rewrite (Unary \"sin\" (Const \"PI\"))             \n         zero)\n(rewrite (Unary \"sin\" (Add x (Const \"PI\")))       \n         (Neg (Unary \"sin\" x)))\n(rewrite (Unary \"sin\" (Add x (Div (Const \"PI\") two))) \n         (Unary \"cos\" x))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") (Num (rational 6 1))))       \n         (Div (Sqrt three) two))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") (Num (rational 4 1))))       \n         (Div (Sqrt two) two))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") three))       \n         (Num (rational 1 2)))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") two))       \n         zero)\n(rewrite (Unary \"cos\" (Const \"PI\"))             \n         (Num (rational -1 1)))\n(rewrite (Unary \"cos\" (Add x (Const \"PI\")))       \n         (Neg (Unary \"cos\" x)))\n(rewrite (Unary \"cos\" (Add x (Div (Const \"PI\") two))) \n         (Neg (Unary \"sin\" x)))\n(rewrite (Unary \"tan\" (Div (Const \"PI\") (Num (rational 6 1))))       \n         (Div one (Sqrt three)))\n(rewrite (Unary \"tan\" (Div (Const \"PI\") (Num (rational 4 1))))       \n         one)\n(rewrite (Unary \"tan\" (Div (Const \"PI\") three))       \n         (Sqrt three))\n(rewrite (Unary \"tan\" (Const \"PI\"))             \n         zero)\n(rewrite (Unary \"tan\" (Add x (Const \"PI\")))       \n         (Unary \"tan\" x))\n(rewrite (Unary \"tan\" (Add x (Div (Const \"PI\") two))) \n         (Div neg-one (Unary \"tan\" x)))\n(rewrite (Div (Unary \"sin\" a) (Add one (Unary \"cos\" a)))    \n         (Unary \"tan\" (Div a two)))\n(rewrite (Div (Neg (Unary \"sin\" a)) (Add one (Unary \"cos\" a)))\n         (Unary \"tan\" (Div (Neg a) two)))\n(rewrite (Div (Sub one (Unary \"cos\" a)) (Unary \"sin\" a))    \n         (Unary \"tan\" (Div a two)))\n(rewrite (Div (Sub one (Unary \"cos\" a)) (Neg (Unary \"sin\" a)))\n         (Unary \"tan\" (Div (Neg a) two)))\n(rewrite (Div (Add (Unary \"sin\" a) (Unary \"sin\" b)) (Add (Unary \"cos\" a) (Unary \"cos\" b)))\n         (Unary \"tan\" (Div (Add a b) two)))\n(rewrite (Div (Sub (Unary \"sin\" a) (Unary \"sin\" b)) (Add (Unary \"cos\" a) (Unary \"cos\" b)))\n         (Unary \"tan\" (Div (Sub a b) two)))\n\n(rewrite (Unary \"sin\" zero) zero)\n(rewrite (Unary \"cos\" zero) one)\n(rewrite (Unary \"tan\" zero) zero)\n\n(rewrite (Unary \"sin\" (Neg x)) (Neg (Unary \"sin\" x)))\n(rewrite (Unary \"cos\" (Neg x)) (Unary \"cos\" x))\n(rewrite (Unary \"tan\" (Neg x)) (Neg (Unary \"cos\" x)))\n\n; Hyperbolics\n(rewrite (Unary \"sinh\" x) (Div (Sub (Unary \"exp\" x) (Unary \"exp\" (Neg x))) two))\n(rewrite (Unary \"cosh\" x) (Div (Add (Unary \"exp\" x) (Unary \"exp\" (Neg x))) two))\n(rewrite (Unary \"tanh\" x) (Div (Sub (Unary \"exp\" x) (Unary \"exp\" (Neg x))) (Add (Unary \"exp\" x) (Unary \"exp\" (Neg x)))))\n(rewrite (Unary \"tanh\" x) (Div (Sub (Unary \"exp\" (Mul two x)) one) (Add (Unary \"exp\" (Mul two x)) one)))\n(rewrite (Unary \"tanh\" x) (Div (Sub one (Unary \"exp\" (Mul (Num (rational -2 1)) x))) (Add one (Unary \"exp\" (Mul (Num (rational -2 1)) x)))))\n(rewrite (Sub (Mul (Unary \"cosh\" x) (Unary \"cosh\" x)) (Mul (Unary \"sinh\" x) (Unary \"sinh\" x))) one)\n(rewrite (Add (Unary \"cosh\" x) (Unary \"sinh\" x)) (Unary \"exp\" x))\n(rewrite (Sub (Unary \"cosh\" x) (Unary \"sinh\" x)) (Unary \"exp\" (Neg x)))\n\n;; Unimplemented: misc. rewrites (conditionals, specialized numerical fns)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Testing\n;; -------\n;; In actuality, herbie would be responsible for plugging exprs in here.\n;; For our purposes, we take some test cases from herbie\n;; (src/core/simplify.rkt)\n\n(push)\n(let e (Add one zero))\n(run 1)\n(check (= e one))\n(pop)\n\n(push)\n(let five (Num (rational 5 1)))\n(let six (Num (rational 6 1)))\n(let e2 (Add one five))\n(run 1)\n(check (= e2 six))\n(pop)\n\n(let x (Var \"x\"))\n\n(push)\n(let e3 (Add x zero))\n(run 1)\n(check (= e3 x))\n(pop)\n\n(push)\n(let e4 (Sub x zero))\n(run 1)\n(check (= e4 x))\n(pop)\n\n(push)\n\n(let e5 (Mul x one))\n(run 1)\n(check (= e5 x))\n(pop)\n\n(push)\n\n(let e6 (Div x one))\n(run 1)\n(check (= e6 x))\n(pop)\n\n(push)\n\n(let e7 (Sub (Mul one x) (Mul (Add x one) one)))\n(run 3)\n(check (= e7 (Num (rational -1 1))))\n(pop)\n\n(push)\n\n(let e8 (Sub (Add x one) x))\n(run 4)\n(check (= e8 one))\n(pop)\n\n(push)\n\n(let e9 (Sub (Add x one) one))\n(run 4)\n(check (= e9 x))\n(pop)\n\n(push)\n\n(set (lo x) r-one)\n(let e10 (Div (Mul x three) x))\n(run 3)\n(check (= e10 three))\n(pop)\n\n(push)\n\n(let e11 (Sub (Mul (Sqrt (Add x one)) (Sqrt (Add x one))) (Mul (Sqrt x) (Sqrt x))))\n(run 5)\n(check (= one e11))\n(pop)\n\n(push)\n(let e12 (Add (Num (rational 1 5)) (Num (rational 3 10))))\n(run 1)\n(check (= e12 (Num (rational 1 2))))\n(pop)\n\n(push)\n(let e13 (Unary \"cos\" (Const \"PI\")))\n(run 1)\n(check (= e13 (Num (rational -1 1))))\n(pop)\n\n(push)\n(let sqrt5 (Sqrt (Num (rational 5 1))))\n(let e14\n  (Div one (Sub (Div (Add one sqrt5) two) (Div (Sub one sqrt5) two))))\n(let tgt (Div one sqrt5))\n(run 6)\n(check (= e14 tgt))\n(pop)",
  "i64": "(check (= (to-string 20) \"20\"))\n",
  "include": "(include \"tests/path.egg\")\n(check (path 1 3))\n",
  "integer_math": "(datatype Math\n    (Diff Math Math)\n    (Integral Math Math)\n    \n    (Add Math Math)\n    (Sub Math Math)\n    (Mul Math Math)\n    (Div Math Math)\n    (Pow Math Math)\n    (RShift Math Math)\n    (LShift Math Math)\n    (Mod Math Math)\n    (Not Math)\n    \n    (Const i64)\n    (Var String))\n\n(relation MathU (Math))\n(rule ((= e (Diff x y))) ((MathU e)))\n(rule ((= e (Integral x y))) ((MathU e)))\n(rule ((= e (Add x y))) ((MathU e)))\n(rule ((= e (Sub x y))) ((MathU e)))\n(rule ((= e (Mul x y))) ((MathU e)))\n(rule ((= e (Div x y))) ((MathU e)))\n(rule ((= e (Pow x y))) ((MathU e)))\n(rule ((= e (Const x))) ((MathU e)))\n(rule ((= e (Var x))) ((MathU e)))\n(rule ((= e (RShift x y))) ((MathU e)))\n(rule ((= e (LShift x y))) ((MathU e)))\n(rule ((= e (Mod x y))) ((MathU e)))\n(rule ((= e (Not x))) ((MathU e)))\n\n(relation evals-to (Math i64))\n(rule ((evals-to x vx)) ((union x (Const vx))))\n(rule ((= e (Const c))) ((evals-to e c)))\n\n(relation is-not-zero (Math))\n(rule ((MathU a) (!= a (Const 0))) ((is-not-zero a)))\n\n;; Evaluation\n(rewrite (Add (Const a) (Const b))\n         (Const (+ a b)))\n(rewrite (Sub (Const a) (Const b))\n            (Const (- a b)))\n(rewrite (Mul (Const a) (Const b)) (Const (* a b)))\n(rewrite (Div (Const a) (Const b)) (Const (/ a b)) :when ((!= 0 b)))\n(rewrite (RShift (Const a) (Const b)) (Const (>> a b)))\n(rewrite (LShift (Const a) (Const b)) (Const (<< a b)))\n(rewrite (Not (Const a)) (Const (not-i64 a)))\n\n;; Properties\n(rewrite (Add a b) (Add b a))\n(rewrite (Mul a b) (Mul b a))\n(rewrite (Add a (Add b c)) (Add (Add a b) c))\n(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))\n\n(rewrite (Sub a b) (Add a (Mul (Const -1) b)))\n\n(rewrite (Add a (Const 0)) a)\n(rewrite (Mul a (Const 0)) (Const 0))\n(rewrite (Mul a (Const 1)) a)\n\n(rule ((MathU a) (!= a (Const 0))) ((union a (Add a (Const 0)))))\n(rule ((MathU a) (!= a (Const 1))) ((union a (Mul a (Const 1)))))\n\n(rewrite (Sub a a) (Const 0))\n(rewrite (Div a a) (Const 1) :when ((is-not-zero a)))\n\n(rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))\n(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))\n\n; This rule doesn't work when pow is negative - consider 2^-1 * 2^1, which is 0, but 2^0 = 1\n(rewrite (Mul (Pow a b) (Pow a c)) (Pow a (Add b c)) :when ((is-not-zero b) (is-not-zero c)))\n\n(rewrite (Pow x (Const 0)) (Const 1) :when ((is-not-zero x)))\n(rewrite (Pow x (Const 1 )) x)\n(rewrite (Pow x (Const 2)) (Mul x x))\n\n(rewrite (Pow x (Const -1)) (Div (Const 1) x) :when ((is-not-zero x)))\n\n(rewrite (Mul x (Pow (Const 2) y)) (LShift x y))\n(rewrite (Div x (Pow (Const 2) y)) (RShift x y))\n\n(rewrite (Not (Not x)) x)\n\n\n;; Tests\n(let start-expr (Div (\n                        Mul (Var \"a\") (Pow (Const 2) (Const 3))\n                    ) (\n                        Add (Var \"c\") (\n                            Sub (Mul (Var \"b\") (Const 2)) (Mul (Var \"b\") (Const 2))\n                        )\n                    )))\n\n(let equiv-expr (Div (\n                    LShift (Var \"a\") (Const 3)\n                ) (\n                    Mul (Var \"c\") (Not (Not (Const 1)))\n                )\n                ))\n\n(run 4)\n\n(check (= start-expr equiv-expr))\n\n",
  "intersection": ";; computes \"e-graph intersection\"\n\n(datatype Expr\n    (Var String)\n    (f Expr))\n\n(function intersect (Expr Expr) Expr)\n\n(rule (\n    (= x3 (intersect x1 x2))\n    (= f1 (f x1))\n    (= f2 (f x2))\n)(\n    (union (intersect f1 f2) (f x3))\n))\n\n(let a1 (Var \"a1\")) (let a2 (Var \"a2\")) (let a3 (Var \"a3\"))\n(let b1 (Var \"b1\")) (let b2 (Var \"b2\")) (let b3 (Var \"b3\"))\n\n;; e-graph 1: f(a) = f(b), f(f(a))\n(let t1 (f (f a1)))\n(let fb1 (f b1))\n(union (f a1) fb1)\n\n;; e-graph 2: f(f(a)) = f(f(b))\n(let t2  (f (f a2)))\n(let t2p (f (f b2)))\n(union t2 t2p)\n\n(union (intersect a1 a2) a3)\n(union (intersect b1 b2) b3)\n\n(run 100)\n\n(let t3 (f (f a3)))\n(query-extract :variants 5 t3)\n\n;; f(f(a)) = f(f(b)) is preserved\n(check (= (f (f a3)) (f (f b3))))\n;; but not f(a) = f(b), it was only in e-graph 1\n(check (!= (f a3) (f b3)))",
  "interval": "(datatype Math\n  (Num Rational)\n  (Var String)\n  (Mul Math Math))\n\n(function hi (Math) Rational :merge (min old new))\n(function lo (Math) Rational :merge (max old new))\n\n(rule ((= mul (Mul a b)))\n      ((set (lo mul) \n          (min (min (* (lo a) (lo b)) (* (lo a) (hi b)))\n               (min (* (hi a) (lo b)) (* (hi a) (hi b)))))))\n\n(let x (Var \"x\"))\n(let e (Mul x x))\n\n(set (lo x) (rational -10 1))\n(set (hi x) (rational 10 1))\n\n(run 1)\n\n(check (= (lo e) (rational -100 1)))\n\n(rule ((= mul (Mul a a)))\n      ((set (lo mul) (* (lo a) (lo a)))))\n\n(run 1)\n(check (= (lo e) (rational 100 1)))\n\n;; testing extraction of rationals\n(query-extract (lo e))\n",
  "knapsack": "(datatype expr \n    (Num i64)\n    (Add expr expr)\n    (Max expr expr))\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rewrite (Max (Num a) (Num b)) (Num (max a b)))\n\n; List of (weight, value) pairs\n(datatype objects\n    (Cons i64 i64 objects))\n(declare Nil objects)\n\n; Given a capacity and a list of objects, finds the maximum value of a\n; collection of objects whose total weight does not exceed the capacity.\n(function Knap (i64 objects) expr)\n\n(rule ((= f (Knap capacity (Cons weight val rest))) (<= weight capacity))\n      ((union (Knap capacity (Cons weight val rest))\n            (Max\n                (Add (Num val) (Knap (- capacity weight) rest))\n                (Knap capacity rest)))))\n\n(rule ((= f (Knap capacity (Cons weight val rest))) (> weight capacity))\n      ((union (Knap capacity (Cons weight val rest))\n            (Knap capacity rest))))\n\n(rule ((= f (Knap capacity Nil)))\n      ((union (Knap capacity Nil) (Num 0))))\n\n(let test1 (Knap 13 (Cons 5 5 (Cons 3 3 (Cons 12 12 (Cons 5 5 Nil))))))\n\n(let test2 (Knap 5 (Cons 6 6 Nil)))\n\n(let test3 (Knap 5 (Cons 1 1 (Cons 1 1 (Cons 1 1 Nil)))))\n\n(let test4 (Knap 15 (Cons 12 40 (Cons 2 20 (Cons 1 20 (Cons 1 10 (Cons 4 100 Nil)))))))\n\n; turn a (Num n) into n\n(function Unwrap (expr) i64)\n(rule ((= x (Num n))) ((set (Unwrap (Num n)) n)))\n\n(run 100)\n\n(check (= test1 (Num 13)))\n\n",
  "lambda": ";; NOTE: This file contains several unsafe operations\n(datatype Value (Num i64))\n(declare True Value)\n(declare False Value)\n(datatype VarType)\n(datatype Term\n    (Val Value)\n    (Var VarType)\n    (Add Term Term)\n    (Eq Term Term)\n    (App Term Term)\n    (Lam VarType Term)\n    (Let VarType Term Term)\n    (Fix VarType Term)\n    (If Term Term Term))\n(function V (String) VarType) \n(function From (Term) VarType)\n\n; All free variables are free,\n; but some free variables are more free than others\n; Freer variables will only contain variables\n; that will affect the evaluation\n; of the corresponding term\n; e.g., x is free in x - x, but not freer in x - x\n(sort StringSet (Set VarType))\n(function freer (Term) StringSet :merge (set-intersect old new))\n(rule ((= e (Val v)))\n      ((set (freer e) (set-empty))))\n(rule ((= e (Var v)))\n      ((set (freer e) (set-insert (set-empty) v))))\n(rule ((= e (Add e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Eq e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (App e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Lam var body))\n       (= (freer body) fv))\n      ((set (freer e) (set-remove fv var))))\n(rule ((= e (Let var e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 (set-remove fv2 var)))))\n(rule ((= e (Fix var body))\n       (= (freer body) fv))\n      ((set (freer e) (set-remove fv var))))\n(rule ((= e (If c e1 e2))\n       (= (freer c) fv1)\n       (= (freer e1) fv2)\n       (= (freer e2) fv3))\n      ((set (freer e) (set-union fv1 (set-union fv2 fv3)))))\n\n;; START evals-to\n(function evals-to (Term) Value)\n\n(rule ((= e (Val val)))\n      ((union (evals-to e) val)))\n(rule ((= e (Add a b))\n       (= (Num va) (evals-to a))\n       (= (Num vb) (evals-to b)))\n      ((union (evals-to e) (Num (+ va vb)))))\n(rule ((= e (Eq a b))\n       (= (evals-to b) (evals-to a)))\n      ((union (evals-to e) True)))\n(rule ((= e (Eq a b))\n       (= va (evals-to a))\n       (= vb (evals-to b))\n       (!= va vb)) ; TODO: if true and false are non-mergeable datatype, \n                   ; we should be able to do != over it\n      ((union (evals-to e) False)))\n(rule ((= v (evals-to e)))\n      ((union e (Val v))))\n;; END evals-to\n\n; if-true\n(rewrite (If (Val True) then else) then)\n; if-false\n(rewrite (If (Val False) then else) else)\n; if-elim\n(rule ((= term (If (Eq (Var x) e) then else)))\n      ((Let x e then)\n       (Let x e else)))\n(rewrite (If (Eq (Var x) e) then else) else\n    :when ((= (Let x e then) (Let x e else))))\n\n; add-comm\n(rewrite (Add a b) (Add b a))\n; add-assoc\n(rewrite (Add (Add a b) c) (Add a (Add b c)))\n; eq-comm\n(rewrite (Eq a b) (Eq b a))\n\n; fix\n(rewrite (Fix v e) (Let v (Fix v e) e))\n; beta\n(rewrite (App (Lam v body) e) (Let v e body))\n; let-app\n(rewrite (Let v e (App a b)) (App (Let v e a) (Let v e b)))\n; let-add\n(rewrite (Let v e (Add a b)) (Add (Let v e a) (Let v e b)))\n; let-eq\n(rewrite (Let v e (Eq a b)) (Eq (Let v e a) (Let v e b)))\n; let-const\n(rewrite (Let v e c) c :when ((= const (evals-to c))))\n; let-if\n(rewrite (Let v e (If cond then else)) \n         (If (Let v e cond) (Let v e then) (Let v e else)))\n; let-var-same\n(rewrite (Let v1 e (Var v1)) e)\n; let-var-diff\n(rewrite (Let v1 e (Var v2)) (Var v2) :when ((!= v1 v2)))\n; let-lam-same\n(rewrite (Let v1 e (Lam v1 body)) (Lam v1 body))\n; let-lam-diff\n(rewrite (Let v1 e (Lam v2 body)) (Lam v2 (Let v1 e body))\n      :when ((!= v1 v2)\n             (= fvs (freer e))\n             (set-not-contains fvs v2)))\n(rule ((= expr (Let v1 e (Lam v2 body)))\n       (!= v1 v2)\n       (= fvs (freer e))\n       (set-contains fvs v2))\n      ((union expr (Lam (From expr) (Let v1 e (Let v2 (Var (From expr)) body))))))\n\n;; lambda_under\n(push)\n(let e \n        (Lam (V \"x\") \n             (Add (Val (Num 4))\n                  (App (Lam (V \"y\") (Var (V \"y\"))) (Val (Num 4))))))\n(run 10)\n(check (= e (Lam (V \"x\") (Val (Num 8)))))\n(pop)\n\n;; lambda_if_elim\n(push)\n(let e2 (If (Eq (Var (V \"a\")) (Var (V \"b\")))\n              (Add (Var (V \"a\")) (Var (V \"a\")))\n              (Add (Var (V \"a\")) (Var (V \"b\")))))\n(run 10)\n(check (= e2 (Add (Var (V \"a\")) (Var (V \"b\")))))\n(pop)\n\n;; lambda_let_simple\n(push)\n(let e3 (Let (V \"x\") (Val (Num 0))\n          (Let (V \"y\") (Val (Num 1))\n          (Add (Var (V \"x\")) (Var (V \"y\"))))))\n(run 10)\n(check (= e3 (Val (Num 1))))\n(pop)\n\n;; lambda_capture\n(push)\n(let e4 (Let (V \"x\") (Val (Num 1)) \n          (Lam (V \"x\") (Var (V \"x\")))))\n(run 10)\n(fail (check (= e4 (Lam (V \"x\") (Val (Num 1))))))\n(pop)\n\n;; lambda_capture_free\n(push)\n(let e5  (Let (V \"y\") (Add (Var (V \"x\")) (Var (V \"x\"))) \n           (Lam (V \"x\") (Var (V \"y\")))))\n(run 10)\n(check (set-contains (freer (Lam (V \"x\") (Var (V \"y\")))) (V \"y\")))\n(fail (check (= e5 (Lam (V \"x\") (Add (Var (V \"x\")) (Var (V \"x\")))))))\n(pop)\n\n;; lambda_closure_not_seven\n(push)\n(let e6\n     (Let (V \"five\") (Val (Num 5))\n     (Let (V \"add-five\") (Lam (V \"x\") (Add (Var (V \"x\")) (Var (V \"five\"))))\n     (Let (V \"five\") (Val (Num 6))\n     (App (Var (V \"add-five\")) (Val (Num 1)))))))\n(run 10)\n(fail (check (= e6 (Val (Num 7)))))\n(check (= e6 (Val (Num 6))))\n(pop)\n\n\n;; lambda_compose\n(push)\n(let e7\n    (Let (V \"compose\") (Lam (V \"f\") \n                       (Lam (V \"g\") \n                       (Lam (V \"x\") (App (Var (V \"f\"))\n                                         (App (Var (V \"g\")) \n                                              (Var (V \"x\")))))))\n    (Let (V \"add1\") (Lam (V \"y\") (Add (Var (V \"y\")) (Val (Num 1))))\n    (App (App (Var (V \"compose\")) (Var (V \"add1\"))) (Var (V \"add1\"))))))\n(run 20)\n(check (= e7 (Lam x (Add (Var x) (Val (Num 2))))))\n(pop)\n\n;; lambda_if_simple\n(push)\n(let e10 (If (Eq (Val (Num 1)) (Val (Num 1))) (Val (Num 7)) (Val (Num 9))))\n(run 4)\n(check (= e10 (Val (Num 7))))\n(pop)\n\n;; lambda_compose_many\n(push)\n(let e11\n    (Let (V \"compose\") (Lam (V \"f\") (Lam (V \"g\") (Lam (V \"x\") (App (Var (V \"f\"))\n                                                              (App (Var (V \"g\")) (Var (V \"x\")))))))\n    (Let (V \"add1\") (Lam (V \"y\") (Add (Var (V \"y\")) (Val (Num 1))))\n    (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n         (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n              (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                   (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                        (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                             (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                                  (Var (V \"add1\")))))))))))\n\n(run 30)\n(check (= e11 (Lam x (Add (Var x) (Val (Num 7))))))\n(pop)\n\n;; lambda_if\n(push)\n(let e8\n    (Let (V \"zeroone\") (Lam (V \"x\")\n         (If (Eq (Var (V \"x\")) (Val (Num 0)))\n             (Val (Num 0))\n             (Val (Num 1))))\n         (Add (App (Var (V \"zeroone\")) (Val (Num 0)))\n              (App (Var (V \"zeroone\")) (Val (Num 10)))))\n)\n(run 20)\n(check (= e8 (Val (Num 1))))\n(pop)\n",
  "levenshtein-distance": "; Datatypes\n\n(datatype expr \n    (Num i64)\n    (Add expr expr)\n    (Min expr expr expr))\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rewrite (Min (Num a) (Num b) (Num c)) (Num (min (min a b) c)))\n\n; `String` supports limited operations, let's just use it as a char type\n(datatype str\n    (Cons String str))\n(declare Empty str)\n\n; Length function\n\n(function Length (str) expr)\n\n(rule ((= f (Length Empty)))\n      ((union (Length Empty) (Num 0))))\n\n(rule ((= f (Length (Cons c cs))))\n      ((union (Length (Cons c cs)) (Add (Num 1) (Length cs)))))\n\n; EditDist function\n\n(function EditDist (str str) expr)\n\n(rule ((= f (EditDist Empty s)))\n      ((union (EditDist Empty s) (Length s))))\n\n(rule ((= f (EditDist s Empty)))\n      ((union (EditDist s Empty) (Length s))))\n\n(rule ((= f (EditDist (Cons head rest1) (Cons head rest2))))\n      ((union (EditDist (Cons head rest1) (Cons head rest2))\n            (EditDist rest1 rest2))))\n\n(rule ((= f (EditDist (Cons head1 rest1) (Cons head2 rest2))) (!= head1 head2))\n      ((union (EditDist (Cons head1 rest1) (Cons head2 rest2))\n            (Add (Num 1)\n                 (Min (EditDist rest1 rest2)\n                      (EditDist (Cons head1 rest1) rest2)\n                      (EditDist rest1 (Cons head2 rest2)))))))\n\n; Unwrap function - turn a (Num n) into n\n\n(function Unwrap (expr) i64)\n(rule ((= x (Num n))) ((set (Unwrap (Num n)) n)))\n\n; Tests\n(let HorseStr (Cons \"h\" (Cons \"o\" (Cons \"r\" (Cons \"s\" (Cons \"e\" Empty))))))\n(let RosStr (Cons \"r\" (Cons \"o\" (Cons \"s\" Empty))))\n(let IntentionStr (Cons \"i\" (Cons \"n\" (Cons \"t\" (Cons \"e\" (Cons \"n\" (Cons \"t\" (Cons \"i\" (Cons \"o\" (Cons \"n\" Empty))))))))))\n(let ExecutionStr (Cons \"e\" (Cons \"x\" (Cons \"e\" (Cons \"c\" (Cons \"u\" (Cons \"t\" (Cons \"i\" (Cons \"o\" (Cons \"n\" Empty))))))))))\n\n(let Test1 (EditDist HorseStr RosStr))\n(let Test2 (EditDist IntentionStr ExecutionStr))\n(let Test3 (EditDist HorseStr Empty))\n\n(run 100)\n\n(extract (Unwrap Test1))\n(check (= Test1 (Num 3)))\n\n(extract (Unwrap Test2))\n(check (= Test2 (Num 5)))\n\n(extract (Unwrap Test3))\n(check (= Test3 (Num 5)))",
  "list": "(datatype List\n\t(Nil)\n\t(Cons i64 List))\n\n(ruleset list)\n\n(function list-length (List) i64)\n(relation list-length-demand (List))\n(rule\n\t((list-length-demand (Nil)))\n\t((set (list-length (Nil)) 0))\n\t:ruleset list)\n(rule\n\t((list-length-demand (Cons head tail)))\n\t((list-length-demand tail))\n\t:ruleset list)\n(rule\n\t(\t(list-length-demand (Cons head tail))\n\t\t(= (list-length tail) tail-length))\n\t((set (list-length (Cons head tail)) (+ tail-length 1)))\n\t:ruleset list)\n\n(function list-get (List i64) i64)\n(relation list-get-demand (List i64))\n(rule\n\t(\t(list-get-demand list 0)\n\t\t(= list (Cons head tail)))\n\t((set (list-get list 0) head))\n\t:ruleset list)\n(rule\n\t(\t(list-get-demand list n) (> n 0)\n\t\t(= list (Cons head tail)))\n\t((list-get-demand tail (- n 1)))\n\t:ruleset list)\n(rule\n\t(\t(list-get-demand list n)\n\t\t(= list (Cons head tail))\n\t\t(= item (list-get tail (- n 1))))\n\t((set (list-get list n) item))\n\t:ruleset list)\n\n(function list-append (List List) List)\n(rewrite (list-append (Nil) list) list :ruleset list)\n(rewrite (list-append (Cons head tail) list) (Cons head (list-append tail list)) :ruleset list)\n\n; list-contains Nil _ => false\n; list-contains (Cons item tail) item => true\n; list-contains (Cons head tail) item => assert(head != item); (list-contains tail item)\n; list-contains needs inequality\n\n(function list-set (List i64 i64) List)\n(rewrite (list-set (Cons head tail) 0 item) (Cons item tail) :ruleset list)\n(rewrite (list-set (Cons head tail) i item) (Cons head (list-set tail (- i 1) item)) :when ((> i 0)) :ruleset list)\n\n; Tests\n(let a (Cons 1 (Cons 2 (Nil))))\n(let b (Cons 3 (Nil)))\n(let c (Cons 1 (Cons 2 (Cons 3 (Nil)))))\n(let d (Cons 1 (Cons 4 (Nil))))\n(let e (list-append a b))\n(let f (list-set a 1 4))\n\n(list-length-demand c)\n(list-get-demand b 0)\n(list-get-demand a 1)\n\n(run-schedule (saturate (run list)))\n\n(check (= e c))\n(check (= (list-length c) 3))\n(check (= (list-get b 0) 3))\n(check (= (list-get a 1) 2))\n(check (= f d))\n",
  "map": "(sort MyMap (Map i64 String))\n\n(let my_map1 (map-insert (map-empty) 1 \"one\"))\n(let my_map2 (map-insert my_map1 2 \"two\"))\n\n(check (= \"one\" (map-get my_map1 1)))\n(query-extract my_map2)",
  "math-microbenchmark": "(datatype Math\n    (Diff Math Math)\n    (Integral Math Math)\n    \n    (Add Math Math)\n    (Sub Math Math)\n    (Mul Math Math)\n    (Div Math Math)\n    (Pow Math Math)\n    (Ln Math)\n    (Sqrt Math)\n    \n    (Sin Math)\n    (Cos Math)\n    \n    (Const Rational)\n    (Var String))\n\n(rewrite (Add a b) (Add b a))\n(rewrite (Mul a b) (Mul b a))\n(rewrite (Add a (Add b c)) (Add (Add a b) c))\n(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))\n\n(rewrite (Sub a b) (Add a (Mul (Const (rational -1 1)) b)))\n;; (rewrite (Div a b) (Mul a (Pow b (Const (rational -1 1)))) :when ((is-not-zero b)))\n\n(rewrite (Add a (Const (rational 0 1))) a)\n(rewrite (Mul a (Const (rational 0 1))) (Const (rational 0 1)))\n(rewrite (Mul a (Const (rational 1 1))) a)\n\n(rewrite (Sub a a) (Const (rational 0 1)))\n\n(rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))\n(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))\n\n(rewrite (Mul (Pow a b) (Pow a c)) (Pow a (Add b c)))\n(rewrite (Pow x (Const (rational 1 1))) x)\n(rewrite (Pow x (Const (rational 2 1))) (Mul x x))\n\n(rewrite (Diff x (Add a b)) (Add (Diff x a) (Diff x b)))\n(rewrite (Diff x (Mul a b)) (Add (Mul a (Diff x b)) (Mul b (Diff x a))))\n\n(rewrite (Diff x (Sin x)) (Cos x))\n(rewrite (Diff x (Cos x)) (Mul (Const (rational -1 1)) (Sin x)))\n\n(rewrite (Integral (Const (rational 1 1)) x) x)\n(rewrite (Integral (Cos x) x) (Sin x))\n(rewrite (Integral (Sin x) x) (Mul (Const (rational -1 1)) (Cos x)))\n(rewrite (Integral (Add f g) x) (Add (Integral f x) (Integral g x)))\n(rewrite (Integral (Sub f g) x) (Sub (Integral f x) (Integral g x)))\n(rewrite (Integral (Mul a b) x) \n(Sub (Mul a (Integral b x)) \n    (Integral (Mul (Diff x a) (Integral b x)) x)))\n(Integral (Ln (Var \"x\")) (Var \"x\"))\n(Integral (Add (Var \"x\") (Cos (Var \"x\"))) (Var \"x\"))\n(Integral (Mul (Cos (Var \"x\")) (Var \"x\")) (Var \"x\"))\n(Diff (Var \"x\") (Add (Const (rational 1 1)) (Mul (Const (rational 2 1)) (Var \"x\"))))\n(Diff (Var \"x\") (Sub (Pow (Var \"x\") (Const (rational 3 1))) (Mul (Const (rational 7 1)) (Pow (Var \"x\") (Const (rational 2 1))))))\n(Add (Mul (Var \"y\") (Add (Var \"x\") (Var \"y\"))) (Sub (Add (Var \"x\") (Const (rational 2 1))) (Add (Var \"x\") (Var \"x\"))))\n(Div (Const (rational 1 1))\n                        (Sub (Div (Add (Const (rational 1 1))\n                                    (Sqrt (Var \"five\")))\n                                (Const (rational 2 1)))\n                            (Div (Sub (Const (rational 1 1))\n                                    (Sqrt (Var \"five\")))\n                                (Const (rational 2 1)))))\n(run 11)\n(print-size Add)\n(print-size Mul)\n\n(print-size)\n\n(print-stats)",
  "math": "(datatype Math\n    (Diff Math Math)\n    (Integral Math Math)\n    \n    (Add Math Math)\n    (Sub Math Math)\n    (Mul Math Math)\n    (Div Math Math)\n    (Pow Math Math)\n    (Ln Math)\n    (Sqrt Math)\n    \n    (Sin Math)\n    (Cos Math)\n    \n    (Const Rational)\n    (Var String))\n\n(relation MathU (Math))\n(rule ((= e (Diff x y))) ((MathU e)))\n(rule ((= e (Integral x y))) ((MathU e)))\n(rule ((= e (Add x y))) ((MathU e)))\n(rule ((= e (Sub x y))) ((MathU e)))\n(rule ((= e (Mul x y))) ((MathU e)))\n(rule ((= e (Div x y))) ((MathU e)))\n(rule ((= e (Pow x y))) ((MathU e)))\n(rule ((= e (Ln x))) ((MathU e)))\n(rule ((= e (Sqrt x))) ((MathU e)))\n(rule ((= e (Sin x))) ((MathU e)))\n(rule ((= e (Cos x))) ((MathU e)))\n(rule ((= e (Const x))) ((MathU e)))\n(rule ((= e (Var x))) ((MathU e)))\n\n(relation evals-to (Math Rational))\n\n(rule ((= e (Const c))) ((evals-to e c)))\n(rule ((= e (Add a b)) (evals-to a va) (evals-to b vb))\n      ((evals-to e (+ va vb))))\n(rule ((= e (Sub a b)) (evals-to a va) (evals-to b vb))\n      ((evals-to e (- va vb))))\n(rule ((= e (Mul a b)) (evals-to a va) (evals-to b vb))\n      ((evals-to e (* va vb))))\n(rule ((= e (Div a b)) (evals-to a va) (evals-to b vb) (!= vb (rational 0 1)))\n      ((evals-to e (/ va vb))))\n(rule ((evals-to x vx)) ((union x (Const vx))))\n\n(relation is-const (Math))\n(rule ((evals-to a va)) ((is-const a)))\n\n(relation is-sym (Math))\n(rule ((= e (Var s))) ((is-sym e)))\n\n(relation is-not-zero (Math))\n(rule ((evals-to x vx)\n       (!= vx (rational 0 1)))\n      ((is-not-zero x)))\n\n(relation is-const-or-distinct-var-demand (Math Math))\n(relation is-const-or-distinct-var (Math Math))\n(rule ((is-const-or-distinct-var-demand v w)\n       (is-const v))\n      ((is-const-or-distinct-var v w)))\n(rule ((is-const-or-distinct-var-demand v w)\n       (= v (Var vv))\n       (= w (Var vw))\n       (!= vv vw))\n      ((is-const-or-distinct-var v w)))\n\n(rewrite (Add a b) (Add b a))\n(rewrite (Mul a b) (Mul b a))\n(rewrite (Add a (Add b c)) (Add (Add a b) c))\n(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))\n\n(rewrite (Sub a b) (Add a (Mul (Const (rational -1 1)) b)))\n(rewrite (Div a b) (Mul a (Pow b (Const (rational -1 1)))) :when ((is-not-zero b)))\n\n(rewrite (Add a (Const (rational 0 1))) a)\n(rewrite (Mul a (Const (rational 0 1))) (Const (rational 0 1)))\n(rewrite (Mul a (Const (rational 1 1))) a)\n\n;; NOTE: these two rules are different from math.rs, as math.rs does pruning\n(rule ((MathU a) (!= a (Const (rational 0 1)))) ((union a (Add a (Const (rational 0 1))))))\n(rule ((MathU a) (!= a (Const (rational 1 1)))) ((union a (Mul a (Const (rational 1 1))))))\n\n(rewrite (Sub a a) (Const (rational 0 1)))\n(rewrite (Div a a) (Const (rational 1 1)) :when ((is-not-zero a)))\n\n(rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))\n(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))\n\n(rewrite (Mul (Pow a b) (Pow a c)) (Pow a (Add b c)))\n(rewrite (Pow x (Const (rational 0 1))) (Const (rational 1 1)) :when ((is-not-zero x)))\n(rewrite (Pow x (Const (rational 1 1))) x)\n(rewrite (Pow x (Const (rational 2 1))) (Mul x x))\n(rewrite (Pow x (Const (rational -1 1))) (Div (Const (rational 1 1)) x) :when ((is-not-zero x)))\n(rewrite (Mul x (Div (Const (rational 1 1)) x)) (Const (rational 1 1)) :when ((is-not-zero x)))\n\n(rewrite (Diff x x) (Const (rational 1 1)) :when ((is-sym x)))\n(rule ((= e (Diff x c))\n       (is-sym x))\n      ((is-const-or-distinct-var-demand c x)))\n(rewrite (Diff x c) (Const (rational 0 1)) :when ((is-sym x) (is-const-or-distinct-var c x)))\n\n(rewrite (Diff x (Add a b)) (Add (Diff x a) (Diff x b)))\n(rewrite (Diff x (Mul a b)) (Add (Mul a (Diff x b)) (Mul b (Diff x a))))\n\n(rewrite (Diff x (Sin x)) (Cos x))\n(rewrite (Diff x (Cos x)) (Mul (Const (rational -1 1)) (Sin x)))\n\n(rewrite (Diff x (Ln x)) (Div (Const (rational 1 1)) x) :when ((is-not-zero x)))\n\n(rewrite (Diff x (Pow f g))\n         (Mul (Pow f g) \n              (Add (Mul (Diff x f) (Div g f)) \n                   (Mul (Diff x g) (Ln f)))) \n         :when ((is-not-zero f) \n                (is-not-zero g)))\n\n(rewrite (Integral (Const (rational 1 1)) x) x)\n(rewrite (Integral (Pow x c) x)\n         (Div (Pow x (Add c (Const (rational 1 1)))) (Add c (Const (rational 1 1)))) \n         :when ((is-const c)))\n(rewrite (Integral (Cos x) x) (Sin x))\n(rewrite (Integral (Sin x) x) (Mul (Const (rational -1 1)) (Cos x)))\n(rewrite (Integral (Add f g) x) (Add (Integral f x) (Integral g x)))\n(rewrite (Integral (Sub f g) x) (Sub (Integral f x) (Integral g x)))\n(rewrite (Integral (Mul a b) x) \n         (Sub (Mul a (Integral b x)) \n              (Integral (Mul (Diff x a) (Integral b x)) x)))\n\n\n(let start-expr2 (Add (Const (rational 1 1))\n                        (Sub (Var \"a\") \n                             (Mul (Sub (Const (rational 2 1)) \n                                       (Const (rational 1 1))) \n                                  (Var \"a\")))))\n\n(run 6)\n\n(let end-expr2 (Const (rational 1 1)))\n\n(check (= start-expr2 end-expr2))\n\n(query-extract start-expr2)",
  "matrix": "\n(datatype Dim (Times Dim Dim) (NamedDim String) (Lit i64))\n\n(rewrite (Times a (Times b c)) (Times (Times a b) c))\n(rewrite (Times (Times a b) c) (Times a (Times b c)) )\n(rewrite (Times (Lit i) (Lit j)) (Lit (* i j)))\n(rewrite (Times a b) (Times b a))\n\n(datatype MExpr\n    (MMul MExpr MExpr)\n    (Kron MExpr MExpr)\n    (NamedMat String)\n    (Id Dim)\n    ; DSum\n    ; HStack\n    ; VStack\n    ; Transpose\n    ; Inverse\n    ; Zero Math Math\n    ; ScalarMul\n)\n\n; alternative encoding (type A) = (Matrix n m) may be more useful for \"large story example\"\n(function nrows (MExpr) Dim)\n(function ncols (MExpr) Dim)\n\n(rewrite (nrows (Kron A B)) (Times (nrows A) (nrows B)))\n(rewrite (ncols (Kron A B)) (Times (ncols A) (ncols B)))\n\n(rewrite (nrows (MMul A B)) (nrows A))\n(rewrite (ncols (MMul A B)) (ncols B))\n\n(rewrite (nrows (Id n)) n)\n(rewrite (ncols (Id n)) n)\n\n(rewrite (MMul (Id n) A) A)\n(rewrite (MMul A (Id n)) A)\n\n(rewrite (MMul A (MMul B C)) (MMul (MMul A B) C))\n(rewrite (MMul (MMul A B) C) (MMul A (MMul B C)))\n\n(rewrite (Kron A (Kron B C)) (Kron (Kron A B) C))\n(rewrite (Kron (Kron A B) C) (Kron A (Kron B C)))\n\n(rewrite (Kron (MMul A C) (MMul B D))  (MMul (Kron A B) (Kron C D)))\n\n\n(rewrite (MMul (Kron A B) (Kron C D))\n    (Kron (MMul A C) (MMul B D))\n    :when\n        ((= (ncols A) (nrows C))\n        (= (ncols B) (nrows D)))\n)\n\n; demand\n(rule ((= e (MMul A B)))\n((ncols A)\n(nrows A)\n(ncols B)\n(nrows B))\n)\n\n(rule ((= e (Kron A B)))\n((ncols A)\n(nrows A)\n(ncols B)\n(nrows B))\n)\n\n\n(let n (NamedDim \"n\"))\n(let m (NamedDim \"m\"))\n(let p (NamedDim \"p\"))\n\n(let A (NamedMat \"A\"))\n(let B (NamedMat \"B\"))\n(let C (NamedMat \"C\"))\n\n(union (nrows A) n)\n(union (ncols A) n)\n(union (nrows B) m)\n(union (ncols B) m)\n(union (nrows C) p)\n(union (ncols C) p)\n(let ex1 (MMul (Kron (Id n) B) (Kron A (Id m))))\n(let rows1 (nrows ex1))\n(let cols1 (ncols ex1))\n\n(run 20)\n\n(check (= (nrows B) m))\n(check (= (nrows (Kron (Id n) B)) (Times n m)))\n(let simple_ex1 (Kron A B))\n(check (= ex1 simple_ex1))\n\n(let ex2 (MMul (Kron (Id p) C) (Kron A (Id m))))\n(run 10)\n(fail (check (= ex2 (Kron A C))))\n",
  "merge-during-rebuild": "; This file tests that non-union merges can be triggered during rebuilds as well\n; as \"inline\" during a set action. See issue #42\n\n(datatype N (Node i64))\n(function distance (N N) i64 :merge (min old new))\n\n(let a (Node 0))\n(let b (Node 1))\n(let x (Node 2))\n(let y (Node 3))\n(set (distance x y) 1)\n(set (distance a b) 2)\n\n(union a x)\n(union b y)\n\n(run 1)\n(check (= (distance x y) 1)) ; fails, the distance has gone up!\n",
  "merge-saturates": ";; SKIP_PROOFS\n;; doesn't work with proofs because of the side effect in\n;; the merge function\n(function foo () i64 :merge (min old new))\n\n(set (foo) 0)\n\n; This should break at iteration 0 because the merge doesn't cause any updates\n(rule ((= f (foo))) ((set (foo) 1)))\n(run 100)\n\n\n; This should run for about 50 iterations, because even though the merge doesn't\n; change the value of baz, it has a side effect of expanding the domain of bar.\n\n(function baz (i64) i64 :default 0)\n\n(function bar () i64 :merge (min (baz new) 0))\n\n(set (bar) 1)\n(set (bar) 2)\n\n(rule ((= f (baz x)) (< x 50))\n      ((set (bar) (+ x 1))))\n\n(run 100)\n(check (= 0 (baz 50)))\n",
  "name-resolution": "(datatype Math\n  (Add Math Math)\n  (Num i64))\n  \n(let zero (Num 0))\n\n\n;; zero here refers to the function/constant zero, not a free variable\n(rewrite (Add zero x) x)\n\n(let a (Add (Num 0) (Num 3)))\n(let b (Add (Num 7) (Num 9)))\n(let c (Num 16))\n(union b c)\n\n;; crash if we merge two numbers\n(rule (\n (= (Num x) (Num y))\n (!= x y)\n)(\n (panic \"ahhh\")\n))\n      \n      \n(run 10)",
  "path-union": "(datatype Node\n (mk i64))\n\n(relation edge (Node Node))\n(relation path (Node Node))\n            \n(rule ((edge x y))\n      ((path x y)))\n\n(rule ((path x y) (edge y z))\n      ((path x z)))\n\n(edge (mk 1) (mk 2))\n(edge (mk 2) (mk 3))\n(edge (mk 5) (mk 6))\n\n(union (mk 3) (mk 5))\n\n(run 10)\n(check (edge (mk 3) (mk 6)))\n(check (path (mk 1) (mk 6)))",
  "path": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n(rule ((path x y) (edge y z))\n      ((path x z)))\n        \n(edge 1 2)\n(edge 2 3)\n(edge 3 4)\n(check (edge 1 2))\n(fail (check (path 1 2)))\n(run 3)\n\n(print-function path 100)\n(check (path 1 4))\n(fail (check (path 4 1)))\n",
  "pathproof": "; proofs of connectivity are paths\n(datatype Proof\n  (Trans i64 Proof)\n  (Edge i64 i64))\n\n; We enhance the path relation to carry a proof field\n(relation path (i64 i64 Proof))\n(relation edge (i64 i64))\n\n(edge 2 1)\n(edge 3 2)\n(edge 1 3)\n\n(rule ((edge x y))  \n      ((path x y (Edge x y))))\n(rule ((edge x y) (path y z p))  \n      ((path x z (Trans x p))))\n\n; We consider equal all paths tha connect same points.\n; Smallest Extraction will extract shortest path.\n(rule ((path x y p1) (path x y p2))  \n      ((union p1 p2)))\n\n(run 3)\n(check (path 3 1 (Trans 3 (Edge 2 1))))\n; Would prefer being able to check\n;(check (path 1 2 _))\n; or extract\n;(query-extract (path 1 4 ?p))\n(print-function path 100)",
  "points-to": "; Identifiers represented as strings, keep some newtypes around to aid clarity\n(datatype ClassT (Class String))\n(datatype FieldT (Field String))\n\n(datatype Stmt\n    (New String ClassT)\n    ; Assign dst src\n    (Assign String String)\n    ; Store dst field src\n    (Store String FieldT String)\n    ; Load dst src field\n    (Load String String FieldT))\n\n(relation VarPointsTo (String ClassT))\n(relation HeapPointsTo (ClassT FieldT ClassT))\n\n; New variables point to classes they're initialized as\n(rule ((= x (New a b))) ((VarPointsTo a b)))\n\n; If I assign v1 <- v2 and v2 points to a class c2, then v1 points to class c2\n; as well\n(rule ((= x (Assign v1 v2)) (VarPointsTo v2 c2))\n      ((VarPointsTo v1 c2)))\n\n; If c1.f points to c2, and v2 points to class c1, then assigning v1 <- v2.f\n; means v1 points to c2\n(rule ((= x (Load v1 v2 f)) \n       (VarPointsTo v2 c1)\n       (HeapPointsTo c1 f c2))\n      ((VarPointsTo v1 c2)))\n\n; If v1 points to class c1, and v2 to c2, and if v1.f <- v2, then c1.f points to\n; c2\n(rule ((= x (Store v1 f v2))\n       (VarPointsTo v1 c1)\n       (VarPointsTo v2 c2))\n      ((HeapPointsTo c1 f c2)))\n\n; Example in \"From Datalog to Flix\"\n; l1: ClassA o1 = new ClassA();\n; l2: ClassB o2 = new ClassB();\n; l3: ClassB o3 = o2;\n; l4: o2.f = o1;\n; l5: Object r = o3.f;\n\n(let A (Class \"A\"))\n(let B (Class \"B\"))\n(let f (Field \"f\"))\n\n(let l1 (New \"o1\" A))\n(let l2 (New \"o2\" B))\n(let l3 (Assign \"o3\" \"o2\"))\n(let l4 (Store \"o2\" f \"o1\"))\n(let l5 (Load \"r\" \"o3\" f))\n\n(run 3)\n\n(check (VarPointsTo \"o1\" A))\n(check (VarPointsTo \"o2\" B))\n\n(check (VarPointsTo \"o3\" B))\n(check (HeapPointsTo B f A))\n(check (VarPointsTo \"r\" A))",
  "primitives": "(check (= (+ 2 2)  4))\n(check (= (- 2 1)  1))\n(check (= (- 1 2) -1))\n(check (< 1 2))\n(check (> 1 -2))",
  "prims": "; A nasty, imperative implementation of Prim's algorithm... in egglog!\n; https://en.wikipedia.org/wiki/Prim%27s_algorithm\n\n; Weighted edge (vertex 1 * vertex 2 * weight)\n(datatype edge (Edge i64 i64 i64))\n(relation edge-exists (edge))\n\n(relation mytrue ())\n(mytrue)\n(let infinity 99999999)  ; close enough\n\n; ==== PROBLEM INSTANCES ====\n\n; Graph 1\n; (1)--2--(2)\n;    \\     |\n;      1   2\n;        \\ |\n; (3)--3--(4)\n(ruleset graph1)\n(rule ((mytrue))\n      ((edge-exists (Edge 1 2 2))\n       (edge-exists (Edge 1 4 1))\n       (edge-exists (Edge 2 4 2))\n       (edge-exists (Edge 3 4 3)))\n       :ruleset graph1)\n\n; Graph 2\n; (1)-2-(2)  (3)\n;  |\\   /|   / |\n;  | 3 5 |  4  |\n;  5  X  2 /   5\n;  | / \\ |/    |\n; (4)-4-(5)-7-(6)\n(ruleset graph2)\n(rule ((mytrue))\n      ((edge-exists (Edge 1 2 1))\n       (edge-exists (Edge 1 4 5))\n       (edge-exists (Edge 1 5 3))\n       (edge-exists (Edge 2 4 5))\n       (edge-exists (Edge 2 5 2))\n       (edge-exists (Edge 3 5 4))\n       (edge-exists (Edge 3 6 5))\n       (edge-exists (Edge 4 5 4))\n       (edge-exists (Edge 5 6 7)))\n       :ruleset graph2)\n\n; ==== \"INIT\" RULESET ====\n\n(ruleset init)\n\n; Graph is undirected\n(rule ((= e (Edge x y weight)))\n      ((union e (Edge y x weight)))\n      :ruleset init)\n\n; Whether a vertex is included *so far* (this changes). Returns 0 or 1.\n(function vertex-included (i64) i64 :merge (max old new))\n\n; All vertices default to being not included (note vertex-included's :merge)\n(rule ((edge-exists (Edge x y weight)))\n      ((set (vertex-included x) 0))\n      :ruleset init)\n\n; Keep track of the current iteration\n(function current-iteration () i64 :merge (max old new))\n\n; Map iteration to best edge found so far\n(function iteration-to-best-edge (i64) edge :merge new)\n(function iteration-to-best-edge-weight (i64) i64 :merge new)\n\n(rule ((mytrue))\n      ((set (vertex-included 1) 1)  ; Initially just include vertex 1\n       (set (current-iteration) 0)\n       (set (iteration-to-best-edge-weight 0) infinity))\n      :ruleset init)\n\n; === \"CHOOSE BEST EDGE\" RULESET ===\n\n(relation edge-in-mst (edge))  ; whether an edge is in our solution\n\n(ruleset choose-best-edge)\n(rule ((= i (current-iteration))\n       (edge-exists (Edge x y weight))\n       (= 1 (vertex-included x))\n       (= 0 (vertex-included y))\n       (< weight (iteration-to-best-edge-weight i)))\n      ((set (iteration-to-best-edge-weight i) weight)\n       (set (iteration-to-best-edge i) (Edge x y weight)))\n      :ruleset choose-best-edge)\n\n; === \"FINISH ITERATION\" RULESET ===\n\n(ruleset finish-iteration)\n(rule ((= i (current-iteration))\n       (= (Edge x y weight) (iteration-to-best-edge i)))\n      ((edge-in-mst (Edge x y weight))    ; incorporate chosen best edge\n       (set (vertex-included x) 1)        ; mark its vertices as included\n       (set (vertex-included y) 1)\n       (set (current-iteration) (+ i 1))  ; advance iteration\n       (set (iteration-to-best-edge-weight (+ i 1)) infinity))\n      :ruleset finish-iteration)\n\n; === RUN VIA SCHEDULE ===\n\n(run-schedule\n    (saturate init graph1)  ; change to graph2 to see other example\n    (saturate (saturate choose-best-edge) finish-iteration)\n)\n\n; === PRINT RESULTS ===\n\n; (print-function edge-in-mst) ; this is not very helpful\n\n; Just copy canonical edges to solution\n(relation solution (i64 i64 i64))\n\n(ruleset finalize)\n(rule ((edge-in-mst (Edge x y weight)) (< x y))\n      ((solution x y weight))\n      :ruleset finalize)\n(run-schedule (saturate finalize))\n\n(print-function solution 100) ; this is better\n",
  "push-pop": "(function foo () i64 :merge (max old new))\n\n(set (foo) 1)\n(check (= (foo) 1))\n\n(push)\n(set (foo) 2)\n(check (= (foo) 2))\n(pop)\n\n(check (= (foo) 1))",
  "rational": "; Test that can run rule matching on rational\n\n(datatype Pretty\n    (pretty-str String)\n    (pretty-rational Rational))\n\n; This will fail with `Unbound variable x in primitive computation` currently:\n; (rewrite (pretty-rational (rational x y)) (pretty-str (+ (to-string x) \"/\" (to-string y))))\n\n(rewrite (pretty-rational r) (pretty-str (+ (to-string (numer r)) \"/\" (to-string (denom r)))))\n\n(let z (pretty-rational (rational 1 2)))\n(run 1)\n(check (= z (pretty-str \"1/2\")))\n",
  "resolution": "; Resolution theorem proving\n; \n; Traditional resolution theorem provers maintain a clause database\n; of formulas in Conjunction Normal Form (CNF a big And of Ors).\n; Each clause is a set of positive and negative literals\n; The prover saturates this set by taking two clauses \n; {a}\\/c1  {not a}\\/c2 and creating a new clause c1 \\/ c2.\n; Clauses also are pruned by simplications, unit propagation,\n; and subsumption.\n; These systems use sophisticated term indexing to find matching clauses\n\n; A natural question is whether egglog's saturation and term indexing gives\n; a leg up towards building one of these systems. A programmable one even,\n; with built in support for equality reasoning\n\n; Resolution is provided by a join\n; unit propagation is an equation solving process and egraph substitution\n; Clause Simplification is provided by rewrite rules\n\n; This encoding seems about right but is unsatisfying\n; Using AC to encode the set nature of clauses is inefficient\n\n; An important aspect of these provers that seems challenging to encode shallowly\n; is that the match also occurs modulo _unification_.\n; The unification variables of each clause are not globally scoped, really\n; they are scoped outside the body of each clase in an implicit \\forall\n; This encoding as it stands really only supports ground atoms modulo equality\n\n(datatype Bool)\n(declare True Bool)\n(declare False Bool)\n(function myor (Bool Bool) Bool)\n(function negate (Bool) Bool)\n\n; clauses are assumed in the normal form (or a (or b (or c False)))\n\n(union (negate False) True)\n(union (negate True) False)\n\n; \"Solving\" negation equations\n(rule ((= (negate p) True)) ((union p False)))\n(rule ((= (negate p) False)) ((union p True)))\n\n; canonicalize associtivity. \"append\" for clauses\n; terminate with false\n(rewrite (myor (myor a  b) c) (myor a (myor b c)))\n; commutativity\n(rewrite (myor a (myor b c)) (myor b (myor a c)))\n\n;absoprtion\n(rewrite (myor a (myor a b)) (myor a b))\n(rewrite (myor a (myor (negate a) b)) True)\n\n; simplification\n(rewrite (myor False a) a)\n(rewrite (myor a False) a)\n(rewrite (myor True a) True)\n(rewrite (myor a True) True)\n\n; unit propagation\n; This is kind of interesting actually.\n; Looks a bit like equation solving\n\n; The following is not valid egglog but could be?\n;(rewrite p True    \n;    :when ((= True (or p False))))\n\n(rule ((= True (myor p False))) ((union p True)))\n\n; resolution\n; This counts on commutativity to bubble everything possible up to the front of the clause.\n(rule ((= True (myor a as)) (= True (myor (negate a) bs)))\n      ((union (myor as bs) True)))\n\n; example predicate\n(function p (i64) Bool)\n(let p0 (p 0))\n(let p1 (p 1))\n(let p2 (p 2))\n;(union (or p0 (or p1 (or p2 False))) True)\n;(union (or (negate p0) (or p1 (or (negate p2) False))) True)\n(union (myor p1 (myor (negate p2) False)) True)\n(union (myor p2 (myor (negate p0) False)) True)\n(union (myor p0 (myor (negate p1) False)) True)\n(union p1 False)\n(union (myor (negate p0) (myor p1 (myor p2 False))) True)\n(run 10)\n\n\n(check (!= True False))\n(check (= p0 False))\n(check (= p2 False))\n\n; we could turn the original axioms into _patterns_  in all possible directions.\n; Which is kind of compelling\n; (rule ((or (pat x)))  )\n; or let a unification expansion happen and use thos\n\n\n",
  "rw-analysis": ";;;;;;;;;;;;;;;;\n;; Abstact Domain\n;;;;;;;;;;;;;;;;\n\n; Top means it can be an arbitrary value\n(datatype Val (I i64))\n(declare Top Val)\n(declare True Val)\n(declare False Val)\n(relation Bool (Val))\n(Bool True)\n(Bool False)\n\n(function merge-val (Val Val) Val)\n\n(rewrite (merge-val Top x) Top)\n(rewrite (merge-val x Top) Top)\n(rewrite (merge-val True  False) Top)\n(rewrite (merge-val True  (I x))   Top)\n(rewrite (merge-val False True)  Top)\n(rewrite (merge-val False (I x))   Top)\n(rewrite (merge-val (I x) (I y)) Top :when ((!= x y)))\n(rewrite (merge-val x x) x)\n\n(function add-val (Val Val) Val)\n\n(rewrite (add-val Top x) Top)\n(rewrite (add-val x Top) Top)\n(rewrite (add-val True x) Top)\n(rewrite (add-val False x) Top)\n(rewrite (add-val x True) Top)\n(rewrite (add-val x False) Top)\n(rewrite (add-val (I x) (I y)) (I (+ x y)))\n\n(function eq-val (Val Val) Val)\n\n(rewrite (eq-val Top x) Top)\n(rewrite (eq-val x Top) Top)\n(rewrite (eq-val True False) False)\n(rewrite (eq-val True (I x)) False)\n(rewrite (eq-val False True) False)\n(rewrite (eq-val False (I x)) False)\n(rewrite (eq-val (I x) True) False)\n(rewrite (eq-val (I x) False) False)\n(rewrite (eq-val x x) True)\n\n(datatype VarT (V String))\n(datatype Loc (L i64))\n(datatype Exp\n    (Add VarT VarT)\n    (Eq VarT VarT)\n    (Var VarT)\n    (Const Val))\n(datatype ProgStmt\n    (Ass VarT Exp)\n    (If VarT Loc Loc)\n    (Goto Loc)\n    (Call VarT))\n(declare End ProgStmt)\n(function Prog (Loc) ProgStmt)\n(relation RProg (Loc ProgStmt))\n\n(function const-prop (Loc VarT) Val :merge (merge-val old new))\n\n;;;;;;;;;;;;;;;;\n;; ASS Case\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n\n; propagate x = k\n(rule (\n    (RProg (L li) (Ass x (Const k)))\n)(\n    (set (const-prop (L (+ li 1)) x) k)\n))\n\n; propagate x = a + b (non-constant)\n(rule (\n    (RProg l (Ass x (Add x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n    (= l (L li))\n)(\n    (set (const-prop (L (+ li 1)) x) (add-val v1 v2))\n))\n\n; propagate x = a == b\n(rule (\n    (RProg l (Ass x (Eq x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n    (= l (L li))\n)(\n    (set (const-prop (L (+ li 1)) x) (eq-val v1 v2))\n))\n\n; propagate other vars\n(rule (\n    (RProg (L li) (Ass (V x) e))\n    (= val (const-prop (L li) (V y)))\n    (!= x y)\n)(\n    (set (const-prop (L (+ li 1)) (V y)) val)\n))\n\n;; TRANSFORMATION \n\n; generate demand for biop\n(rule (\n    (= (Prog l) (Ass x (Add x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n)(\n    (add-val v1 v2)\n))\n\n(rule (\n    (= (Prog l) (Ass x (Eq x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n)(\n    (eq-val v1 v2)\n))\n\n; replace x = a + b (constant)\n(rule (\n    (= (Prog l) (Ass x (Add x1 x2)))\n    (= (I val) (add-val (const-prop l x1)\n                        (const-prop l x2)))\n)(\n    (RProg l (Ass x (Const (I val))))\n))\n\n; replace x = a + b (non-contant)\n(rule (\n    (= (Prog l) (Ass x (Add x1 x2)))\n    (= Top (add-val (const-prop l x1)\n                      (const-prop l x2)))\n)(\n    (RProg l (Ass x (Add x1 x2)))\n))\n\n; replace x = a == b (constant)\n(rule (\n    (= (Prog l) (Ass x (Eq x1 x2)))\n    (= b (eq-val (const-prop l x1) (const-prop l x2)))\n    (Bool b)\n)(\n    (RProg l (Ass x (Const b)))\n))\n\n; replace x = a == b (non-constant)\n(rule (\n    (= (Prog l) (Ass x (Eq x1 x2)))\n    (= Top (eq-val (const-prop l x1) (const-prop l x2)))\n)(\n    (RProg l (Ass x (Eq x1 x2)))\n))\n\n; replace x = k\n(rule (\n    (= (Prog l) (Ass x (Const val)))\n)(\n    (RProg l (Ass x (Const val)))\n))\n\n;;;;;;;;;;;;;;;;\n;; CALL CASE\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n(rule (\n    (RProg l (Call f))\n    (= val (const-prop l x))\n    (= l (L li))\n)(\n    (set (const-prop (L (+ li 1)) x) val)\n))\n\n;; TRANSFORMATION\n(rule (\n    (= (Prog l) (Call f))\n)(\n    (RProg l (Call f))\n))\n\n;;;;;;;;;;;;;;;;\n;; IF CASE\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n(rule (\n    (RProg l (If b l1 l2))\n    (= val (const-prop l x))\n)(\n    (set (const-prop l1 x) val)\n    (set (const-prop l2 x) val)\n))\n\n;; TRANSFORMATION\n\n; replace if true\n(rule (\n    (= (Prog l) (If b l1 l2))\n    (= True (const-prop l b))\n)(\n    (RProg l (Goto l1))\n))\n\n; replace if false\n(rule (\n    (= (Prog l) (If b l1 l2))\n    (= False (const-prop l b))\n)(\n    (RProg l (Goto l2))\n))\n\n; replace if Top\n(rule (\n    (= (Prog l) (If b l1 l2))\n    (= Top (const-prop l b))\n)(\n    (RProg l (If b l1 l2))\n))\n\n;;;;;;;;;;;;;;;;\n;; GOTO CASE\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n(rule (\n    (RProg l1 (Goto l2))\n    (= val (const-prop l1 x))\n)(\n    (set (const-prop l2 x) val)\n))\n\n;; TRANSFORMATION\n(rule (\n    (= (Prog l1) (Goto l2))\n)(\n    (RProg l1 (Goto l2))\n))\n\n;;;;;;;;;;;;;;;;\n;; TEST\n;;;;;;;;;;;;;;;;\n\n(union (Prog (L 0)) (Ass (V \"b\") (Const Top)))\n(union (Prog (L 1)) (Ass (V \"ten\") (Const (I 10))))\n(union (Prog (L 2)) (Ass (V \"one\") (Const (I 1))))\n(union (Prog (L 3)) (Ass (V \"zero\") (Const (I 0))))\n; x := 10\n(union (Prog (L 4)) (Ass (V \"x\") (Const (I 10))))\n; while (...) {\n(union (Prog (L 5)) (If (V \"b\") (L 6) (L 13)))\n;     if (x == 10) {\n(union (Prog (L 6)) (Ass (V \"cond\") (Eq (V \"x\") (V \"ten\"))))\n(union (Prog (L 7)) (If (V \"cond\") (L 8) (L 10)))\n;         DoSomething();\n(union (Prog (L 8)) (Call (V \"DoSomething\")))\n;     }\n(union (Prog (L 9)) (Goto (L 12)))\n;     else {\n;         DoSomething();\n(union (Prog (L 10)) (Call (V \"DoSomethingElse\")))\n;         x := x + 1;\n(union (Prog (L 11)) (Ass (V \"x\") (Add (V \"x\") (V \"one\"))))\n;; (union (Prog (L 11)) (Call (V \"DoSomethingElse\")))\n;     }\n(union (Prog (L 12)) (Goto (L 5)))\n; y := x\n(union (Prog (L 13)) (Ass (V \"y\") (Add (V \"x\") (V \"zero\"))))\n(union (Prog (L 14)) End)\n\n(run 20)\n\n(check (= (const-prop (L 14) (V \"y\")) (I 10)))\n\n",
  "schedule-demo": "; Step with alternating feet, left before right\n(relation left (i64))\n(relation right (i64))\n\n(left 0)\n(right 0)\n\n(ruleset step-left)\n(rule ((left x) (right x))\n      ((left (+ x 1)))\n      :ruleset step-left)\n\n(ruleset step-right)\n(rule ((left x) (right y) (= x (+ y 1)))\n      ((right x))\n      :ruleset step-right)\n\n(run-schedule\n      (repeat 10\n            (saturate step-right)\n            (saturate step-left)))\n\n; We took 10 steps with the left, but the right couldn't go the first round,\n; so we took only 9 steps with the right.\n(check (left 10))\n(check (right 9))\n(fail (check (left 11)))\n(fail (check (right 10)))\n",
  "semi_naive_set_function": ";; From issue#93. The change happened in right-hand-side of a rule may also impact output in semi-naive cases\n(push)\n(function f (i64) i64 :merge (max old new))\n\n(set (f 0) 0)\n(set (f 3) 0)\n\n(rule ((= f0 (f 0))) ((set (f 1) f0)))\n(rule ((= f1 (f 1))) ((set (f 2) f1)))\n\n;; update f3 some iters later to make sure f(0) is inactive\n(rule ((= f2 (f 2))) ((set (f 3) 3)))\n\n(push)\n\n;; This rule should fire and set f(0) to be 3, but because f0 is inactive, \n;; it does not fire (despite that f3 is active now)\n(rule ((= f0 (f 0))) ((set (f 0) (f 3))))\n\n(run 100)\n(print-function f 100) ;; f0 is expected to have value 3, but has 0 in reality.\n\n(check (= (f 0) 3))\n(check (= (f 1) 3))\n(check (= (f 2) 3))\n(check (= (f 3) 3))\n\n(pop)\n(push)\n\n;; variants of the last rule.\n(rule ((= f0 (f 0)) (= x 3) (= y x))  ((set (f 0) (f y))))\n\n(run 100)\n(check (= (f 0) 3))\n(check (= (f 1) 3))\n(check (= (f 2) 3))\n(check (= (f 3) 3))\n\n(pop)\n(push)\n\n;; adding let binding\n(rule ((= f0 (f 0))) ((let x 3) (let y x) (set (f 0) (f y))))\n\n(run 100)\n(check (= (f 0) 3))\n(check (= (f 1) 3))\n(check (= (f 2) 3))\n(check (= (f 3) 3))\n\n(pop)\n(push)\n\n(function g (i64) i64 :merge (max old new))\n(set (g 0) 3)\n\n;; bind to another function\n(rule ((= f0 (f 0))) ((let x (g 0)) (let y x) (set (f 0) (f y))))\n\n(run 100)\n(check (= (f 0) 3))\n(check (= (f 1) 3))\n(check (= (f 2) 3))\n(check (= (f 3) 3))\n\n(pop)\n(pop)\n\n;; more complicated case, when the evaluation never finish\n;; the semi_naive and naive behavior diverage a bit\n(function f (i64) i64 :merge (max old new))\n\n(set (f 0) 0)\n(set (f 3) 0)\n\n(rule ((= f0 (f 0))) ((set (f 1) (+ 1 f0))))\n(rule ((= f1 (f 1))) ((set (f 2) (+ 1 f1))))\n\n(push)\n\n(rule ((= f2 (f 2))) ((set (f 3) 1)))\n(rule ((= f0 (f 0))) ((set (f 0) (f (f 3)))))\n\n\n(run 100)\n(print-function f 100) \n(check (!= 0 (f 0)))\n(check (!= 0 (f 1)))\n(check (!= 0 (f 2)))\n\n(pop)\n\n\n;; id function that will set all int values, but need strong induction.\n(function g (i64) i64 :merge (max old new))\n(set (g 0) 0)\n(set (g 1) 1)\n(rule ((= x (g x)) (= y (g (- x 1)))) ((set (g (+ x 1)) (+ y 2))))\n\n(run 100)\n(print-function g 100) \n\n(check (= 20 (g 20)))",
  "set": "(sort ISetBase (Set i64))\n\n; Test set-of\n(check (= (set-of 1 2) (set-insert (set-insert (set-empty) 1) 2)))\n(check (= (set-of 1 2) (set-insert (set-insert (set-empty) 2) 1)))\n\n; Test set-union\n(check (= (set-union (set-of 1 2) (set-of 3 4)) (set-of 1 2 3 4)))\n\n; Test set-length\n(check (= 0 (set-length (set-empty))))\n(check (= 1 (set-length (set-of 1 1 1))))\n(check (= 2 (set-length (set-of 1 -1 1 1))))\n\n; Test set-get\n(check (= 1 (set-get (set-of 1 -1 2 4 1) 0)))\n(check (= 2 (set-get (set-of 1 -1 2 4 1) 1)))\n(check (= 4 (set-get (set-of 1 -1 2 4 1) 2)))\n(check (= -1 (set-get (set-of 1 -1 2 4 1) 3)))\n\n; Test set-remove\n(check (= (set-remove (set-of 1 2 3) 3) (set-of 1 2)))\n\n; Reify set\n(sort ISet)\n(function IS (ISetBase) ISet)\n\n(function ISet-get (ISet i64) i64 :unextractable)\n(rule ((IS x) (> (set-length x) 0))\n    ((set (ISet-get (IS x) 0) (set-get x 0))))\n(rule ((ISet-get (IS x) j)\n     (= i (+ j 1)) (< i (set-length x)))\n    ((set (ISet-get (IS x) i) (set-get x i))))\n\n(let myset (IS (set-of 2 4 1 4 -1)))\n(run 100)\n(check (= 1 (ISet-get myset 0)))\n(check (= 2 (ISet-get myset 1)))\n(check (= 4 (ISet-get myset 2)))\n(check (= -1 (ISet-get myset 3)))\n",
  "stratified": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n(edge 1 2)\n(edge 2 3)\n(edge 3 4)\n(check (edge 1 2))\n(run 3)\n(check (path 1 2))\n\n(ruleset path-rules)\n\n(rule ((path x y) (edge y z))\n      ((path x z))\n      :ruleset path-rules)\n\n(edge 3 8)\n(run path-rules 1)\n(check (path 1 3))\n\n\n\n; Should fail\n; (check (path 1 4))\n; (check (path 3 8)) \n",
  "string": "; Tests for the string sort\n\n; Concatenation\n(check (= (+ \"a\" \"bc\" \"de\") \"abcde\"))\n; Counting the number of substring occurances\n(check (= (count-matches \"ab ab\" \"ab\") 2))\n; replacing a substring\n(check (= (replace \"ab ab\" \"ab\" \"cd\") \"cd cd\"))\n",
  "string_quotes": "(function f () String)\n(input f \"tests/string_quotes.csv\")\n(check (= (f) \"abc\"))\n",
  "subsume": ";; Let's pretend that we are optimizing mathematical expressions, but for some reason on our compiler\n;; multiplying by three is very expensive. So we want to rewrite those forms to three additions instead, and always\n;; extract that form.\n\n(datatype Math\n  (Num i64)\n  (Var String)\n  (Add Math Math)\n  (Mul Math Math))\n\n\n(rewrite (Mul (Num 3) x) (Add x (Add x x)) :subsume)\n\n(let x (Mul (Num 2) (Mul (Num 3) (Var \"x\"))))\n\n(run 10)\n\n; When X is extracted, we get the optimized form, where the * 3 is expanded out\n(check (= x (Mul (Num 2) (Add (Var \"x\") (Add (Var \"x\") (Var \"x\"))))))\n(extract x)\n; Will be (Mul (Num 2) (Add (Var \"x\") (Add (Var \"x\") (Var \"x\"))))\n\n; Even though it can't be extracted, we can still check that x equal 2 * (3 * x)\n(check (= x (Mul (Num 2) (Mul (Num 3) (Var \"x\")))))\n\n; Also if we make multiplication commutative and run that run, we won't get that result either\n; since the original expr has been subsumed when it was replaced with the addition\n(rewrite (Mul x y) (Mul y x))\n(run 10)\n(extract x)\n",
  "test-combined-steps": "; Step with alternating feet, left before right\n(relation left (i64))\n(relation right (i64))\n(relation middle (i64))\n\n(left 0)\n(right 0)\n\n(ruleset step-left)\n(rule ((left x) (right x))\n      ((left (+ x 1)))\n      :ruleset step-left)\n\n(ruleset step-right)\n(rule ((left x) (right y) (= x (+ y 1)))\n      ((right x))\n      :ruleset step-right)\n\n(ruleset step-middle)\n(rule ((left x))\n      ((middle x))\n      :ruleset step-middle)\n\n(unstable-combined-ruleset\n  my-combination \n  step-left step-right \n  step-middle)\n\n(run-schedule (repeat 1 my-combination))\n\n(check (left 1))\n(check (right 0))\n;; middle didn't observe anything except original step\n(check (middle 0))\n(fail (check (left 2)))\n(fail (check (right 1)))\n(fail (check (middle 1)))\n(fail (check (middle 2)))\n\n\n(run-schedule\n      (repeat 9\n            (saturate step-right)\n            my-combination\n            (saturate step-right)))\n\n(check (left 10))\n(check (right 10))\n;; middle didn't get a chance to observe (left 10)\n(check (middle 9))\n(fail (check (middle 10)))\n(fail (check (left 11)))\n(fail (check (right 11)))\n",
  "test-combined": "(relation edge (i64 i64))\n(relation path (i64 i64))\n\n\n(ruleset myrules1)\n(rule ((edge x y))\n      ((path x y))\n      :ruleset myrules1)\n(ruleset myrules2)\n(rule ((path x y) (edge y z))\n      ((path x z))\n      :ruleset myrules2)\n\n(unstable-combined-ruleset myrules-combined\n    myrules1 myrules2)\n\n\n(edge 0 1)\n(edge 1 2)\n(edge 2 3)\n(edge 2 4)\n\n(run-schedule\n  (repeat 3 myrules-combined))\n\n\n(check (path 0 1))\n(check (path 0 2))\n(check (path 0 3))\n(check (path 0 4))\n(check (path 1 2))\n(check (path 1 3))\n(check (path 1 4))\n",
  "towers-of-hanoi": "(datatype Stack\n          (Empty)\n          (Cons i64 Stack))\n\n(function Config (Stack Stack Stack) i64 :merge (min old new))\n\n;; move from first stack\n(rule ((= len (Config (Cons x a) b c)))\n      ((set (Config a (Cons x b) c) (+ len 1))\n       (set (Config a b (Cons x c)) (+ len 1))))\n\n;; move from second stack\n(rule ((= len (Config a (Cons x b) c)))\n      ((set (Config (Cons x a) b c) (+ len 1))\n       (set (Config a b (Cons x c)) (+ len 1))))\n\n;; move from third stack\n(rule ((= len (Config a b (Cons x c))))\n      ((set (Config (Cons x a) b c) (+ len 1))\n       (set (Config a (Cons x b) c) (+ len 1))))\n\n(let e (Empty))\n\n\n;; initial state [123 _ _] with path \"length\" 0\n(set (Config (Cons 1 (Cons 2 (Cons 3 e))) e e) 0)\n\n;; find all reachable states\n(run 1000000)\n\n;; print first 10 tuples\n(print-function Config 10)\n(print-size Config)\n\n;; how to long to move to state [_ _ 123]\n(query-extract (Config e e (Cons 1 (Cons 2 (Cons 3 e)))))\n\n;; actually do the assertion\n(check (= 5 (Config e e (Cons 1 (Cons 2 (Cons 3 e))))))",
  "tricky-type-checking": ";;;;;;;;;;;;;;;;;;\n;; From repro-constraineq\n\n;; repro-constraineq\n(push)\n(rule ((= x 1) (= y x) (= z y)) ())\n(run 1)\n(pop)\n\n;; repro-constraineq2\n(push)\n(rule ((= x 1) (= y x)) ())\n(run 1)\n(pop)\n\n;; repro-constraineq3\n(push)\n(relation f (i64))\n\n(rule ((= x 1)\n       (= x 2))\n      ((f x)))\n      \n(run 1)\n(print-function f 10)\n(pop)\n\n;;;;;;;;;;;;;;;;;;\n;; Atoms need to be order-insensitive\n\n;; Issue #196\n(push)\n(relation R (i64))\n\n(rule \n  ((= x y)\n   (= y 1)) \n  ((R x)))\n(run 1)\n(check (R 1))\n(pop)\n\n(push)\n(relation R (i64))\n\n(rule \n  ((= x (+ y 1))\n   (= y 1)) \n  ((R x)))\n(run 1)\n(check (R 2))\n(pop)\n\n;; Issue #80\n(push)\n(datatype TYPE)\n(datatype TERM)\n(function type (TERM) TYPE)\n(function Ob () TYPE)\n(function Hom (TERM TERM) TYPE)\n\n(function id (TERM) TERM)\n(rule ((type (id A)))\n      ((type A)))\n(rewrite (type (id A)) \n         (Hom A A) \n    :when ((= (type A) (Ob))))\n\n(function compose (TERM TERM) TERM)\n(rule ((type (compose f g)))  \n      ((type f) \n       (type g)))\n(rewrite (type (compose f g)) \n         (Hom A C) \n    :when ((= (type f) (Hom A B)) \n           (= (type g) (Hom B C))))\n\n(birewrite (compose (compose f g) h) \n           (compose f (compose g h)) \n    :when ((= (type A) (Ob)) \n           (= (type B) (Ob))\n           (= (type C) (Ob))\n           (= (type D) (Ob))\n           (= (type f) (Hom A B))\n           (= (type g) (Hom B C))\n           (= (type h) (Hom C D))))\n(birewrite (compose f (id B)) f \n    :when ((= (type A) (Ob)) \n           (= (type B) (Ob))\n           (= (type f) (Hom A B))))\n(birewrite (compose (id A) f) f \n    :when ((= (type A) (Ob)) \n           (= (type B) (Ob))\n           (= (type f) (Hom A B))))\n\n(declare A TERM)\n(declare B TERM)\n(declare f TERM)\n(declare g TERM)\n(let fog (compose g f))\n(union (type f) (Hom A B))\n(union (type g) (Hom B A))\n(union (type A) (Ob))\n(union (type B) (Ob))\n(type fog)\n(run 10)\n(print-function type 10)\n(check (= (type f) \n          (type (compose (id A) \n                         (compose f (id B))))))\n(check (= (type fog)\n          (Hom B B)))\n(pop)\n\n\n;;;;;;;;;;;;;;;;;;\n;; Finding the right type in case of container types and primitives\n\n;; Issue #113\n\n(push)\n(sort MyMap (Map i64 String))\n(sort MyMap1 (Map i64 i64))\n\n(let my_map1 (map-insert (map-empty) 1 \"one\"))\n(pop)\n\n(push)\n(sort MyMap1 (Map i64 i64))\n(sort MyMap (Map i64 String))\n\n(let my_map1 (map-insert (map-empty) 1 \"one\"))\n(pop)\n\n",
  "type-constraints-tests": "(datatype Operand)\n(sort VecOperandBase (Vec Operand))\n(datatype VecOperand (VO VecOperandBase))\n(sort VecVecOperandBase (Vec VecOperand))\n\n(rule\n   ((= v1 (vec-of))\n    (= v2 (VO v1))\n    (= v3 (vec-of v2)))\n   ())\n",
  "typecheck": "; type checking for simply typed lambda calculus\n\n(datatype Type \n  (TArr Type Type) ; t1 -> t2\n)\n(declare TUnit Type)\n\n(datatype Expr \n  (Lam String Type Expr) ; lam x : t . e\n  (App Expr Expr) \n  (Var String) \n)\n(declare MyUnit Expr)\n\n(datatype Ctx \n  (Cons String Type Ctx)\n)\n(declare Nil Ctx)\n\n; ctx |- expr : type\n(function typeof (Ctx Expr) Type)\n\n; ctx |- () : unit\n(rewrite (typeof ctx MyUnit) TUnit)\n\n; ctx; x: t |- x : t\n(rewrite (typeof (Cons x t ctx) (Var x)) t)\n\n; ctx |- f :- t1 -> t2\n; ctx |- e : t1\n; -----------------\n; ctx |- f e : t2\n\n(rule (\n  (= (typeof ctx (App f e)) t2)\n)(\n  (typeof ctx f)\n  (typeof ctx e)\n))\n\n(rule (\n  (= (typeof ctx (App f e)) t1)\n  (= (typeof ctx f) (TArr (typeof ctx e) t2))\n)(\n  (union t1 t2)\n))\n\n; ctx |- x : t\n; ------------------ y != x \n; ctx; y: t |- x : t\n\n(rewrite (typeof (Cons y ty ctx) (Var x))\n         (typeof ctx (Var x))\n    :when ((!= x y)))\n\n; ctx; x: t1 |- e : t2\n; ------------------------------\n; ctx |- lam x: t1. e : t1 -> t2\n\n; rhs of rewrite creates demand\n(rewrite (typeof ctx (Lam x t1 e))\n         (TArr t1 (typeof (Cons x t1 ctx) e)))\n\n; TEST\n; ----\n\n; lam x : unit, f : unit -> unit . f x\n(let e \n  (Lam \"x\" TUnit \n       (Lam \"f\" (TArr TUnit TUnit)\n            (App (Var \"f\") (Var \"x\")))))\n\n; lam x : unit . x\n(let id (Lam \"x\" TUnit (Var \"x\")))\n(let t-id (typeof Nil id))\n\n; (e () id) = ()\n(let app-unit-id (App (App e MyUnit) id))\n(let t-app (typeof Nil app-unit-id))\n\n(let free (Lam \"x\" TUnit (Var \"y\")))\n(let t-free-ill (typeof Nil free))\n(let t-free-1 (typeof (Cons \"y\" TUnit Nil) free))\n(let t-free-2 (typeof (Cons \"y\" (TArr (TArr TUnit TUnit) TUnit) Nil) free))\n\n(run 15)\n\n(query-extract t-id)\n(check (= t-id (TArr TUnit TUnit)))\n\n(query-extract t-app)\n(check (= t-app TUnit))\n\n(query-extract t-free-1)\n(check (= t-free-1 (TArr TUnit TUnit)))\n(query-extract t-free-2)\n(check (= t-free-2 (TArr TUnit (TArr (TArr TUnit TUnit) TUnit))))\n; this will err\n; (query-extract t-free-ill)\n",
  "typeinfer": ";;;;;;;;;;;;;;;;;;;;;;\n;; Exprs and Types\n;;;;;;;;;;;;;;;;;;;;;;\n\n(datatype Ident)\n(datatype Expr)\n(datatype Type)\n(datatype Scheme)\n(datatype Ctx)\n;; TODO: can't do unit right now\n(sort QuantifiedVs (Set Ident))\n\n(function Fresh (Ident i64) Ident)\n(function V (String) Ident)\n\n(function Var (Ident) Expr)\n(function App (Expr Expr) Expr)\n(function Abs (Ident Expr) Expr)\n(function Let (Ident Expr Expr) Expr)\n(function Num (i64) Expr)\n(function True () Expr)\n(function False () Expr)\n(function MyUnit () Expr)\n\n(function TVar (Ident) Type :cost 3)\n(function TArr (Type Type) Type :cost 1)\n(function TInt () Type :cost 1)\n(function TBool () Type :cost 1)\n(function TUnit () Type :cost 1)\n\n(function Forall (QuantifiedVs Type) Scheme)\n(function Nil () Ctx)\n(function Cons (Ident Scheme Ctx) Ctx)\n\n(relation ftvCtx (Ctx QuantifiedVs))\n(relation ftv (Type QuantifiedVs))\n(relation ftvScheme (Scheme QuantifiedVs))\n(relation has-qs (Ctx Type QuantifiedVs))\n(relation has-qs-demand (Ctx Type))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Expression size\n;;;;;;;;;;;;;;;;;;;;;;\n(relation expr-size (Expr i64))\n(rule ((= e (Num n)))((expr-size e 1)))\n(rule ((= e (Var x)))((expr-size e 1)))\n;; asserted facts will be cleared so we define them as rules\n(rule ((= e (True))) ((expr-size e 1)))\n(rule ((= e (False))) ((expr-size e 1)))\n(rule ((= e (MyUnit))) ((expr-size e 1)))\n(rule ((= e (App e1 e2)) \n       (expr-size e1 s1) \n       (expr-size e2 s2))\n      ((expr-size e (+ (+ s1 s2) 1))))\n(rule ((= e (Let x e1 e2)) \n       (expr-size e1 s1) \n       (expr-size e2 s2))\n      ((expr-size e (+ (+ s1 s2) 1))))\n(rule ((= e (Abs x e1)) \n       (expr-size e1 s1))\n      ((expr-size e (+ s1 1))))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Scheme and Context\n;;;;;;;;;;;;;;;;;;;;;;\n\n(rule ((= e (TBool)))((ftv e (set-empty))))\n(rule ((= e (TUnit)))((ftv e (set-empty))))\n(rule ((= e (TInt)))((ftv e (set-empty))))\n(rule ((= e (TVar x)))((ftv e (set-insert (set-empty) x))))\n(rule ((= e (TArr fr to))\n       (ftv fr s1)\n       (ftv to s2))\n      ((ftv e (set-union s1 s2))))\n(rule ((= c (Nil))) ((ftvCtx c (set-empty))))\n(rule ((= e (Forall qs t))\n       (ftv t fvs))\n      ((ftvScheme e (set-diff fvs qs)))) \n(rule ((= c (Cons x s n))\n       (ftvCtx n fvs1)\n       (ftvScheme s fvs2))\n      ((ftvCtx c (set-union fvs1 fvs2))))\n\n\n;; TODO: rewrite lookup to use native sets\n(function lookup (Ctx Ident) Scheme :cost 1000)\n(rewrite (lookup (Cons x s tl) x) s)\n(rule (\n  (= t (lookup (Cons y s tl) x))\n  (!= x y)\n)(\n  (union t (lookup tl x))\n))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Generalization and Instantiation\n;;;;;;;;;;;;;;;;;;;;;;\n\n(function generalize (Ctx Type) Scheme :cost 1000)\n(function instantiate (Scheme i64) Type :cost 1000)\n\n(rule ((has-qs-demand ctx (TInt)))\n      ((has-qs ctx (TInt) (set-empty))))\n(rule ((has-qs-demand ctx (TBool)))\n      ((has-qs ctx (TBool) (set-empty))))\n(rule ((has-qs-demand ctx (TUnit)))\n      ((has-qs ctx (TUnit) (set-empty))))\n\n(rule ((has-qs-demand ctx (TArr fr to)))\n      ((has-qs-demand ctx fr)\n       (has-qs-demand ctx to)))\n(rule ((has-qs-demand ctx (TArr fr to))\n       (has-qs ctx fr qs1)\n       (has-qs ctx to qs2))\n      ((has-qs ctx (TArr fr to) (set-union qs1 qs2))))\n\n(rule ((has-qs-demand ctx (TVar x))\n       (ftvCtx ctx key-set)\n       (set-contains key-set x))\n      ((has-qs ctx (TVar x) (set-empty))))\n(rule ((has-qs-demand ctx (TVar x))\n       (ftvCtx ctx key-set)\n       (set-not-contains key-set x))\n      ((has-qs ctx (TVar x) (set-insert (set-empty) x))))\n\n(rule ((= sc (generalize ctx t)))\n      ((has-qs-demand ctx t)))\n(rewrite (generalize ctx t)\n         (Forall qs t)\n         :when ((has-qs ctx t qs)))\n\n(function subst-fresh (QuantifiedVs Type i64) Type :cost 1000)\n(rewrite (subst-fresh vs (TInt) c) (TInt))\n(rewrite (subst-fresh vs (TBool) c) (TBool))\n(rewrite (subst-fresh vs (TUnit) c) (TUnit))\n(rewrite (subst-fresh vs (TArr fr to) c) \n         (TArr (subst-fresh vs fr c) (subst-fresh vs to c)))\n(rule ((= otype (subst-fresh vs (TVar s) c))\n       (set-contains vs s))\n      ((union otype (TVar (Fresh s c)))))\n(rule ((= otype (subst-fresh vs (TVar s) c))\n       (set-not-contains vs s))\n      ((union otype (TVar s))))\n\n(rewrite (instantiate (Forall vs t) c)\n         (subst-fresh vs t c))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Injectivity\n;;;;;;;;;;;;;;;;;;;;;;\n\n(rule ((= (TArr fr1 to1) (TArr fr2 to2)))\n      ((union fr1 fr2) \n       (union to1 to2)))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Type inference\n;;;;;;;;;;;;;;;;;;;;;;\n\n; ctx |- expr : type\n(function typeof (Ctx Expr i64) Type :cost 1000)\n\n;; Basic types (TInt, TBool, TUnit)\n(rewrite (typeof ctx (Num x) c) (TInt))\n(rewrite (typeof ctx (True) c) (TBool))\n(rewrite (typeof ctx (False) c) (TBool))\n(rewrite (typeof ctx (MyUnit) c) (TUnit))\n\n; sc = lookup(ctx, x)\n; t = instantiate(sc)\n; ---------------\n; ctx |- x : t\n(rewrite (typeof ctx (Var x)  c)\n         (instantiate (lookup ctx x) c))\n\n(rewrite \n  (typeof ctx (Abs x e) c)\n  (TArr (TVar (Fresh x c)) \n        (typeof (Cons x (Forall (set-empty) (TVar (Fresh x c)))\n                      ctx)\n                e cc))\n    :when ((= cc (+ c 1))))\n\n(rule ((= to (typeof ctx (App e1 e2) c))\n       (= c1 (+ c 1))\n       (expr-size e1 sz)\n       (= c2 (+ c (+ sz 1))))\n      ((union (typeof ctx e1 c1) \n              (TArr (typeof ctx e2 c2) to))))\n\n(rewrite (typeof ctx (Let x e1 e2) c)\n         (typeof (Cons x (generalize ctx (typeof ctx e1 c1)) \n                       ctx)\n                 e2 c2)\n    :when ((= c1 (+ c 1))\n           (expr-size e1 sz)\n           (= c2 (+ c (+ sz 1)))))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Occurs check\n;;;;;;;;;;;;;;;;;;;;;;\n(relation occurs-check (Ident Type))\n(function errors () Ident)\n(rule ((= (TVar x) (TArr fr to)))\n      ((occurs-check x fr)\n       (occurs-check x to)))\n(rule ((occurs-check x (TVar x)))\n      ;; ((set (errors) x)))\n      ((panic \"occurs check fail\")))\n(rule ((occurs-check x (TArr fr to)))\n      ((occurs-check x fr)\n       (occurs-check x to)))\n\n(relation base-types (Type))\n(base-types (TInt))\n(base-types (TBool))\n(base-types (TUnit))\n(rule ((base-types t)\n       (= t (TArr fr to)))\n      ((panic \"Unifying base types with functions\")) )\n(rule ((= (TInt) (TBool))) ((panic \"Unifying base types\")))\n(rule ((= (TInt) (TUnit))) ((panic \"Unifying base types\")))\n(rule ((= (TBool) (TUnit))) ((panic \"Unifying base types\")))\n;;;;;;;;;;;;;;;;;;;;;;\n;; TEST\n;;;;;;;;;;;;;;;;;;;;;;\n\n(push)\n(let id (Abs (V \"x\") (Var (V \"x\"))))\n(let t-id (typeof (Nil) id 0))\n(run 100)\n(check (= t-id (TArr (TVar (Fresh (V \"x\") 0)) (TVar (Fresh (V \"x\") 0)))))\n(pop)\n\n(push)\n(let let-poly (Let (V \"id\") (Abs (V \"x\") (Var (V \"x\")))\n                  (App (App (Var (V \"id\")) (Var (V \"id\")))\n                       (App (Var (V \"id\")) (True)))))\n(let t-let-poly (typeof (Nil) let-poly 0))\n(run 100)\n(check (= t-let-poly (TBool)))\n(pop)\n\n(push)\n(let id-id (App (Abs (V \"x\") (Var (V \"x\")))\n                   (Abs (V \"y\") (Var (V \"y\")))))\n(let t-id-id (typeof (Nil) id-id 0))\n(run 100)\n(check (= t-id-id (TArr (TVar (Fresh (V \"y\") 3)) (TVar (Fresh (V \"y\") 3)))))\n(pop)\n\n\n(push)\n(let let-true (Let (V \"x\") (True) (True)))\n(let t-let-true (typeof (Nil) let-true 0))\n(run 100)\n(check (= t-let-true (TBool)))\n(pop)\n\n(push)\n\n(let let-var-true (Let (V \"x\") (True) (Var (V \"x\"))))\n(let t-let-var-true (typeof (Nil) let-var-true 0))\n(run 100)\n(check (= t-let-var-true (TBool)))\n(pop)\n\n(push)\n\n(let abs-id (Abs (V \"x\") \n                    (Let (V \"y\") (Abs (V \"z\") (Var (V \"z\"))) (Var (V \"y\")))))\n(let t-abs-id (typeof (Nil) abs-id 0))\n(run 100)\n(let x (Fresh (V \"x\") 0))\n(let z (Fresh (Fresh (V \"z\") 2) 4))\n(check (= t-abs-id (TArr (TVar x) (TArr (TVar z) (TVar z)))))\n(pop)\n\n(push)\n\n(let let-env (Let (V \"x\") (True) \n                (Let (V \"f\") (Abs (V \"a\") (Var (V \"a\")))\n                (Let (V \"x\") (MyUnit)\n                (App (Var (V \"f\")) (Var (V \"x\")))\n                ))))\n(let t-let-env (typeof (Nil) let-env 0))\n(run 100)\n(check (= t-let-env (TUnit)))\n(pop)\n\n(push)\n(let let-env-2a (Let (V \"x\") (MyUnit)\n                   (Let (V \"f\") (Abs (V \"y\") (Var (V \"x\")))\n                   (Let (V \"x\") (True)\n                   (App (Var (V \"f\")) (Var (V \"x\")))))))\n(let t-let-env-2a (typeof (Nil) let-env-2a 0))\n(run 100)\n(check (= t-let-env-2a (TUnit)))\n(pop)\n\n(push)\n\n(let let-env-2b (App (Abs (V \"x\")\n                             (Let (V \"f\") (Abs (V \"y\") (Var (V \"x\")))\n                             (Let (V \"x\") (True)\n                             (App (Var (V \"f\")) (Var (V \"x\"))))))\n                        (MyUnit)))\n(let t-let-env-2b (typeof (Nil) let-env-2b 0))\n(run 100)\n(check (= t-let-env-2b (TUnit)))\n(pop)\n\n(push)\n\n;; ((lambda (x) ((lambda (f) ((lambda (x) (f x)) #t)) (lambda (y) x))) 5)\n(let let-env-hard (App (Abs (V \"x\") \n                               (App (Abs (V \"f\") \n                                         (App (Abs (V \"x\") (App (Var (V \"f\")) (Var (V \"x\")))) \n                                              (True)))\n                                    (Abs (V \"y\") (Var (V \"x\")))))\n                          (MyUnit)))\n(let t-let-env-hard (typeof (Nil) let-env-hard 0))\n(run 100)\n(check (= t-let-env-hard (TUnit)))\n(pop)\n\n(push)\n\n(let let-inst (Let (V \"id\") (Abs (V \"x\") (Var (V \"x\")))\n                 (Let (V \"iid\") (Abs (V \"y\") (Var (V \"id\")))\n                 (App (Var (V \"iid\")) \n                      (App (Var (V \"id\")) (True))))) )\n(let t-let-inst (typeof (Nil) let-inst 0))\n(run 100)\n(check (= t-let-inst  (TArr (TVar (Fresh (Fresh (Fresh (V \"x\") 1) 5) 7)) (TVar (Fresh (Fresh (Fresh (V \"x\") 1) 5) 7)))))\n(pop)\n\n",
  "unification-points-to": "(datatype FuncT (Func String))\n(datatype StmtT (Stmt String))\n(datatype ExprT (Expr String))\n(datatype FieldT (Field String))\n(datatype TypeT (Type String))\n(datatype AllocT (Alloc AllocT) (AllocVar ExprT))\n\n(relation func (FuncT ExprT TypeT TypeT))\n(relation func-stmt (FuncT StmtT))\n(relation assign (StmtT TypeT ExprT ExprT))\n(relation field-assign (StmtT ExprT FieldT ExprT))\n(relation store (StmtT ExprT ExprT))\n(relation expr (StmtT ExprT))\n(relation return (StmtT ExprT))\n(relation eq (ExprT ExprT ExprT))\n(relation call (ExprT FuncT ExprT))\n(relation add (ExprT ExprT ExprT))\n(relation field (ExprT ExprT FieldT))\n(relation struct-lit-field (ExprT FieldT ExprT))\n(relation addr (ExprT ExprT FieldT))\n(relation load (ExprT ExprT))\n(relation malloc (ExprT TypeT))\n\n;; typedef struct s {\n;;   int x;\n;;   int y;\n;; } s;\n\n;; int mul(struct s q) { ... }\n\n;; int fact(int i) {\n;;   int c = i == 0;\n;;   if (c) {\n;;     return 1;\n;;   } else {\n;;     int j = i + -1;\n;;     int r = fact(j);\n;;     int prod = mul((struct s){i, r});\n;;     return prod;\n;;   }\n;; }\n;; (func (Func \"fact\") (Expr \"i\") (Type \"int\") (Type \"int\"))\n;; (func-stmt (Func \"fact\") (Stmt \"int c = i == 0;\"))\n;; (func-stmt (Func \"fact\") (Stmt \"if ...\"))\n;; (func-stmt (Func \"fact\") (Stmt \"return 1\"))\n;; (func-stmt (Func \"fact\") (Stmt \"int j = i + -1\"))\n;; (func-stmt (Func \"fact\") (Stmt \"int r = fact(j)\"))\n;; (func-stmt (Func \"fact\") (Stmt \"int prod = mul({ x: i, y: r })\"))\n;; (func-stmt (Func \"fact\") (Stmt \"return prod\"))\n;; (assign (Stmt \"int c = i == 0\") (Type \"int\") (Expr \"c\") (Expr \"i == 0\"))\n;; (assign (Stmt \"int j = i + -1\") (Type \"int\") (Expr \"j\") (Expr \"i + -1\"))\n;; (assign (Stmt \"int r = fact(j)\") (Type \"int\") (Expr \"r\") (Expr \"fact(j)\"))\n;; (assign (Stmt \"int prod = mul({ x: i, y: r })\") (Type \"int\") (Expr \"prod\") (Expr \"mul({ x: i, y: r })\"))\n;; (eq (Expr \"i == 0\") (Expr \"i\") (Expr \"0\"))\n;; (add (Expr \"i + -1\") (Expr \"i\") (Expr \"-1\"))\n;; (call (Expr \"fact(j)\") (Func \"fact\") (Expr \"j\"))\n;; (call (Expr \"mul({ x: i, y: r })\") (Func \"mul\") (Expr \"{ x: i, y: r }\"))\n;; (return (Stmt \"return prod\") (Expr \"prod\"))\n\n;; typedef struct s {\n;;   int *x;\n;;   int *y;\n;; } s;\n\n;; void swap(struct s *r) {\n;;   int **xp = &(r->x);\n;;   int **yp = &(r->y);\n;;   int *a = *xp;\n;;   int *b = *yp;\n;;   *xp = a;\n;;   *yp = b;\n;; }\n\n;; int f(int i) {\n;;   struct s *sp = malloc(sizeof(struct s));\n;;   int *u = malloc(sizeof(int));\n;;   int *v = malloc(sizeof(int));\n;;   *u = i;\n;;   *v = i;\n;;   *sp = (struct s){u, v};\n;;   swap(sp);\n;;   int **zpp = &(sp->x);\n;;   int *zp = *zpp;\n;;   return *zp;\n;; }\n(func (Func \"swap\") (Expr \"r\") (Type \"void\") (Type \"{int *x; int *y;}*\"))\n;; statements\n(func-stmt (Func \"swap\") (Stmt \"int **xp = &(r->x)\"))\n(func-stmt (Func \"swap\") (Stmt \"int **yp = &(r->y)\"))\n(func-stmt (Func \"swap\") (Stmt \"int *z = *xp\"))\n(func-stmt (Func \"swap\") (Stmt \"int *w = *yp\"))\n(func-stmt (Func \"swap\") (Stmt \"*xp = a\"))\n(func-stmt (Func \"swap\") (Stmt \"*yp = b\"))\n(assign (Stmt \"int **xp = &(r->x)\") (Type \"int **\") (Expr \"xp\") (Expr \"&(r->x)\"))\n(assign (Stmt \"int **yp = &(r->x)\") (Type \"int **\") (Expr \"yp\") (Expr \"&(r->y)\"))\n(assign (Stmt \"int *a = *xp\") (Type \"int *\") (Expr \"a\") (Expr \"*xp\"))\n(assign (Stmt \"int *b = *yp\") (Type \"int *\") (Expr \"b\") (Expr \"*yp\"))\n(store (Stmt \"*xp = a\") (Expr \"xp\") (Expr \"a\"))\n(store (Stmt \"*yp = b\") (Expr \"yp\") (Expr \"b\"))\n;; expressions\n(addr (Expr \"&(r->x)\") (Expr \"r\") (Field \"x\"))\n(addr (Expr \"&(r->y)\") (Expr \"r\") (Field \"y\"))\n(load (Expr \"*xp\") (Expr \"xp\"))\n(load (Expr \"*yp\") (Expr \"yp\"))\n\n(func (Func \"f\") (Expr \"i\") (Type \"int\") (Type \"int\"))\n;; statements\n(func-stmt (Func \"f\") (Stmt \"struct s *sp = malloc(sizeof(struct s))\"))\n(func-stmt (Func \"f\") (Stmt \"int *u = malloc(sizeof(int))\"))\n(func-stmt (Func \"f\") (Stmt \"int *v = malloc(sizeof(int))\"))\n(func-stmt (Func \"f\") (Stmt \"*u = i\"))\n(func-stmt (Func \"f\") (Stmt \"*v = i\"))\n(func-stmt (Func \"f\") (Stmt \"*sp = (struct s){u, v}\"))\n(func-stmt (Func \"f\") (Stmt \"swap(sp)\"))\n(func-stmt (Func \"f\") (Stmt \"int **zpp = &(sp->x)\"))\n(func-stmt (Func \"f\") (Stmt \"int *zp = *zpp\"))\n(func-stmt (Func \"f\") (Stmt \"return *zp\"))\n(assign (Stmt \"struct s *sp = malloc(sizeof(struct s))\") (Type \"struct s*\") (Expr \"sp\") (Expr \"malloc(sizeof(struct s))\"))\n(assign (Stmt \"int *u = malloc(sizeof(int))\") (Type \"int *\") (Expr \"u\") (Expr \"malloc(sizeof(int))\"))\n(assign (Stmt \"int *v = malloc(sizeof(int))\") (Type \"int *\") (Expr \"v\") (Expr \"malloc(sizeof(int))\"))\n(store (Stmt \"*u = i\") (Expr \"u\") (Expr \"i\"))\n(store (Stmt \"*v = i\") (Expr \"v\") (Expr \"i\"))\n(store (Stmt \"*sp = (struct s){u, v}\") (Expr \"sp\") (Expr \"(struct s){u, v}\"))\n(expr (Stmt \"swap(sp)\") (Expr \"swap(sp)\"))\n(assign (Stmt \"int **zpp = &(sp->x)\") (Type \"int **\") (Expr \"zpp\") (Expr \"&(sp->x)\"))\n(assign (Stmt \"int *zp = *zpp\") (Type \"int *\") (Expr \"zp\") (Expr \"*zpp\"))\n(return (Stmt \"return *zp\") (Expr \"*zp\"))\n;; expressions\n(malloc (Expr \"malloc(sizeof(struct s))\") (Type \"struct s\"))\n(malloc (Expr \"malloc(sizeof(int))\") (Type \"int\"))\n(struct-lit-field (Expr \"(struct s){u, v}\") (Field \"x\") (Expr \"u\"))\n(struct-lit-field (Expr \"(struct s){u, v}\") (Field \"y\") (Expr \"v\"))\n(call (Expr \"swap(sp)\") (Func \"swap\") (Expr \"sp\"))\n(addr (Expr \"&(sp->x)\") (Expr \"sp\") (Field \"x\"))\n(load (Expr \"*zpp\") (Expr \"zpp\"))\n(load (Expr \"*zp\") (Expr \"zp\"))\n\n;; a variable points to its allocation\n(function expr-points-to (ExprT) AllocT)\n(function ptr-points-to (AllocT) AllocT)\n\n;; If `v = malloc(...)`, then `v -> alloc[v]`.\n(rule (\n    (assign s t1 v c)\n    (malloc c t2)\n)(\n    (union (expr-points-to v) (AllocVar v))\n))\n\n;; If `t v = e` and `e -> a`, then `v -> a`.\n(rule (\n    (assign s t v e)\n    (= (expr-points-to e) a)\n)(\n    (union (expr-points-to v) a)\n))\n\n;; If `*v = u`, `v -> a`, and `u -> b`, then `a -> b`.\n(rule (\n    (store s v u)\n    (= (expr-points-to v) a)\n    (= (expr-points-to u) b)\n)(\n    (union (ptr-points-to a) b)\n))\n\n;; If `e.f -> a` then `e -> a`.\n(rule (\n    (field ef e f)\n    (= (expr-points-to ef) a)\n)(\n    (union (expr-points-to e) a)\n))\n\n;; If `e -> a` then `e.f -> a`.\n(rule (\n    (= (expr-points-to e) a)\n    (field ef e f)\n)(\n    (union (expr-points-to ef) a)    \n))\n\n;; If `u -> a` and `a -> b`, then `&(u->f) -> b`.\n(rule (\n    (= (expr-points-to u) a)\n    (= (ptr-points-to a) b)\n    (addr e u f)\n)(\n    (union (expr-points-to e) b)\n))\n\n;; If `u -> a` and `&(u->f) -> b`, then `a -> b`.\n(rule (\n    (= (expr-points-to u) a)\n    (addr e u f)\n    (= (expr-points-to e) b)\n)(\n    (union (ptr-points-to a) b)\n))\n\n;; If `(struct t){..., x, ...}` and `x -> b`, then `(struct t){..., x, ...} -> b`.\n(rule (\n    (struct-lit-field l f x)\n    (= (expr-points-to x) b)\n)(\n    (union (expr-points-to l) b)    \n))\n\n;; If `f(t* x)`, `f(v)`, and `v -> a`, then `x -> a`.\n(rule (\n    (func f x in out)\n    (call e f v)\n    (= (expr-points-to v) a)\n)(\n    (union (expr-points-to x) a)  \n))\n\n;; If `return u` in `f` and `u -> a`, then `f(z) -> a`.\n(rule (\n    (call e f v)\n    (func-stmt f s)\n    (return s u)\n    (= (expr-points-to u) a)\n)(\n    (union (expr-points-to e) a)    \n))\n\n;; store rule\n(rule (\n    (load e u)\n    (= (expr-points-to u) a)\n    (= (ptr-points-to a) b)\n)(\n    (union (expr-points-to e) b)\n))\n\n(run 40)\n\n(check (= (AllocVar (Expr \"v\")) (AllocVar (Expr \"u\"))))\n(check (!= (AllocVar (Expr \"v\")) (AllocVar (Expr \"sp\"))))\n\n(query-extract :variants 100 (AllocVar (Expr \"u\")))\n(query-extract :variants 100 (AllocVar (Expr \"sp\")))\n",
  "unify": "(datatype Expr\n  (Mul Expr Expr)\n  (Var String)\n  (Lit i64)\n)\n\n; Assume injectivity of Mul for unification\n(rule ((= (Mul a b) (Mul c d)))\n      ((union a c)\n       (union b d)))\n\n;; (relation False (i64))\n; If any Literal make equal to something it can't be, false is derived\n;(rule ((= (Lit i) (Lit j)) (!= i j))\n;      ((False 0)))\n(rule ((= (Lit i) (Mul a b)))\n      ((panic \"Literal cannot be equal to a product\")))\n\n(union (Mul (Var \"a\") (Var \"a\")) \n     (Mul (Lit 1) (Lit 2)))\n\n\n(run 3)\n(check (= (Var \"a\") (Lit 1)))\n(check (= (Lit 2) (Lit 1)))\n; (check (False 0)) ;; this should fail because we don't want prove false",
  "unstable-fn": "(datatype Math\n  (Num i64)\n  (Var String)\n  (Add Math Math)\n  (Mul Math Math))\n\n(rewrite (Mul (Num x) (Num y)) (Num (* x y)))\n\n(datatype MathList\n  (Nil)\n  (Cons Math MathList))\n\n(sort MathFn (UnstableFn (Math) Math))\n\n\n(function square (Math) Math)\n(rewrite (square x) (Mul x x))\n\n(let square-fn (unstable-fn \"square\" ))\n\n;; test that we can call a function\n(let squared-3 (unstable-app square-fn (Num 3)))\n(check (= squared-3 (square (Num 3))))\n\n;; test that we can apply a function to a list\n\n(function list-map-math (MathList MathFn) MathList)\n(rewrite (list-map-math (Nil) fn) (Nil))\n(rewrite (list-map-math (Cons x xs) fn) (Cons (unstable-app fn x) (list-map-math xs fn)))\n\n(let x (Cons (Num 1) (Cons (Num 2) (Cons (Num 3) (Nil)))))\n(let squared-x (list-map-math x square-fn))\n(run 100)\n(check (= squared-x (Cons (Num 1) (Cons (Num 4) (Cons (Num 9) (Nil))))))\n\n;; Test that we can partially apply a function in a rewrite rule\n\n(function list-multiply-by (MathList Math) MathList)\n(rewrite (list-multiply-by l i) (list-map-math l (unstable-fn \"Mul\" i)))\n\n(let doubled-x (list-multiply-by x (Num 2)))\n(run 100)\n(check (= doubled-x (Cons (Num 2) (Cons (Num 4) (Cons (Num 6) (Nil))))))\n\n;; Test we can define a higher order compose function\n\n(function composed-math (MathFn MathFn Math) Math)\n(rewrite (composed-math f g v) (unstable-app f (unstable-app g v)))\n\n(let square-of-double (unstable-fn \"composed-math\" square-fn (unstable-fn \"Mul\" (Num 2))))\n\n(let squared-doubled-x (list-map-math x square-of-double))\n(run 100)\n(check (= squared-doubled-x (Cons (Num 4) (Cons (Num 16) (Cons (Num 36) (Nil))))))\n\n\n;; See that it supports primitive values as well\n(sort i64Fun (UnstableFn (i64) i64))\n\n(function composed-i64-math (MathFn i64Fun i64) Math)\n(rewrite (composed-i64-math f g v) (unstable-app f (Num (unstable-app g v))))\n\n(let res (composed-i64-math square-fn (unstable-fn \"*\" 2) 4))\n(run 100)\n(check (= res (Num 64)))\n",
  "until": "; A simple group\n(datatype G)\n(declare I G)\n(declare A G)\n(declare B G)\n\n(function g* (G G) G)\n(function inv (G) G)\n(birewrite (g* (g* a b) c) (g* a (g* b c))) ; assoc\n(rewrite (g* I a) a) ; idl\n(rewrite (g* a I) a) ; idr\n\n; A is cyclic of period 4\n(rewrite (g* A (g* A (g* A A))) I)\n\n(let A2 (g* A A))\n(let A4 (g* A2 A2))\n(let A8 (g* A4 A4))\n\n; non terminating rule\n(relation allgs (G))\n(rule ((allgs x)) ((allgs (g* B x))))\n(allgs A)\n\n; if you remove :until, this will take a very long time\n(run 10000 :until (= A8 I))\n(check (= A8 I))\n(check (!= B A))\n(check (!= I A))\n; If you need multiple stop conditions, consider using a (relation relation stop (unit))\n; With rules filling it in with different stop conditions of interest.\n",
  "vec": "(sort IVec (Vec i64))\n\n; Test vec-of\n(check (= (vec-of 1 2) (vec-push (vec-push (vec-empty) 1) 2)))\n\n; Test vec-append\n(check (= (vec-append (vec-of 1 2) (vec-of 3 4)) (vec-of 1 2 3 4)))\n\n; Test vec-pop\n(check (= (vec-pop (vec-of 1 2 3)) (vec-of 1 2)))\n\n; Test vec-not-contains\n(check (vec-not-contains (vec-of 1 2 3) 4))\n\n; Test vec-contains\n(check (vec-contains (vec-of 1 2 3) 2))\n\n; Test length\n(check (= (vec-length (vec-of 1 2 3)) 3))\n\n; Test vec-get\n(check (= (vec-get (vec-of 1 2 3) 1) 2))\n\n; Test vec-set\n(check (= (vec-set (vec-of 1 2 3) 1 4) (vec-of 1 4 3)))\n"
}